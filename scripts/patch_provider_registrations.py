#!/usr/bin/env python3
"""Patch provider.go to register hand-written resources and data sources.

After Speakeasy regenerates provider.go, this script inserts registrations for
hand-written resources/data sources that aren't generated by Speakeasy, and
wraps typed connector resources with deprecation notices.

Usage:
    python3 scripts/patch_provider_registrations.py internal/provider/provider.go
"""

from __future__ import annotations

import re
import sys
from pathlib import Path

CUSTOM_DATA_SOURCES = [
    "NewConnectorConfigurationDataSource",
]

CUSTOM_RESOURCES: list[str] = [
    "NewSourceCustomResource",
    "NewDestinationCustomResource",
]

DATA_SOURCES_MARKER = "func (p *AirbyteProvider) DataSources(ctx context.Context) []func() datasource.DataSource {"

SKIP_DEPRECATION_WRAP = {
    "NewConnectionResource",
    "NewDeclarativeSourceDefinitionResource",
    "NewDestinationResource",
    "NewDestinationDefinitionResource",
    "NewPermissionResource",
    "NewSourceResource",
    "NewSourceDefinitionResource",
    "NewWorkspaceResource",
    "NewSourceCustomResource",
    "NewDestinationCustomResource",
}
RESOURCES_MARKER = "func (p *AirbyteProvider) Resources(ctx context.Context) []func() resource.Resource {"


def patch_registrations(content: str, marker: str, registrations: list[str]) -> str:
    if not registrations:
        return content

    idx = content.find(marker)
    if idx == -1:
        print(f"WARNING: Could not find marker: {marker}", file=sys.stderr)
        return content

    return_idx = content.find("return []func()", idx)
    if return_idx == -1:
        print(f"WARNING: Could not find return statement after marker", file=sys.stderr)
        return content

    brace_idx = content.find("{", return_idx)
    if brace_idx == -1:
        print(f"WARNING: Could not find opening brace", file=sys.stderr)
        return content

    insert_point = brace_idx + 1
    new_registrations = [reg for reg in registrations if reg not in content]
    if not new_registrations:
        for reg in registrations:
            print(f"  Skipping {reg} (already registered)")
        return content
    insert_lines = "\n".join(f"\t\t{reg}," for reg in new_registrations)
    patched = content[:insert_point] + "\n" + insert_lines + content[insert_point:]

    for reg in registrations:
        if reg in content:
            print(f"  Skipping {reg} (already registered)")
        else:
            print(f"  Added {reg}")

    return patched


def wrap_typed_resources_with_deprecation(content: str) -> str:
    """Wrap typed source/destination resource constructors with deprecation wrappers.

    Finds lines like:
        NewSourcePostgresResource,
        NewDestinationBigqueryResource,
    and replaces them with:
        wrapDeprecatedSource(NewSourcePostgresResource),
        wrapDeprecatedDestination(NewDestinationBigqueryResource),

    Skips generic/non-typed resources listed in SKIP_DEPRECATION_WRAP.
    """
    resources_start = content.find(RESOURCES_MARKER)
    if resources_start == -1:
        print("WARNING: Could not find Resources() function", file=sys.stderr)
        return content

    datasources_start = content.find(DATA_SOURCES_MARKER)
    if datasources_start == -1:
        resources_end = len(content)
    else:
        resources_end = datasources_start

    resources_block = content[resources_start:resources_end]

    source_pattern = re.compile(r"(\t+)(NewSource\w+Resource),")
    dest_pattern = re.compile(r"(\t+)(NewDestination\w+Resource),")

    wrap_count = 0

    def replace_source(m: re.Match) -> str:
        nonlocal wrap_count
        indent, name = m.group(1), m.group(2)
        if name in SKIP_DEPRECATION_WRAP:
            return m.group(0)
        wrap_count += 1
        return f"{indent}wrapDeprecatedSource({name}),"

    def replace_dest(m: re.Match) -> str:
        nonlocal wrap_count
        indent, name = m.group(1), m.group(2)
        if name in SKIP_DEPRECATION_WRAP:
            return m.group(0)
        wrap_count += 1
        return f"{indent}wrapDeprecatedDestination({name}),"

    patched_block = source_pattern.sub(replace_source, resources_block)
    patched_block = dest_pattern.sub(replace_dest, patched_block)

    if wrap_count > 0:
        print(f"  Wrapped {wrap_count} typed resource(s) with deprecation notices")

    return content[:resources_start] + patched_block + content[resources_end:]


def main() -> None:
    if len(sys.argv) != 2:
        print(f"Usage: {sys.argv[0]} <provider.go>", file=sys.stderr)
        sys.exit(1)

    provider_path = Path(sys.argv[1])
    if not provider_path.exists():
        print(f"ERROR: {provider_path} does not exist", file=sys.stderr)
        sys.exit(1)

    content = provider_path.read_text()
    original = content

    missing_data_sources = [reg for reg in CUSTOM_DATA_SOURCES if reg not in content]
    missing_resources = [reg for reg in CUSTOM_RESOURCES if reg not in content]

    if missing_data_sources:
        print("Patching custom data source registrations...")
        content = patch_registrations(content, DATA_SOURCES_MARKER, missing_data_sources)

    if missing_resources:
        print("Patching custom resource registrations...")
        content = patch_registrations(content, RESOURCES_MARKER, missing_resources)

    needs_wrap = "wrapDeprecatedSource(" not in content
    if needs_wrap:
        print("Wrapping typed resources with deprecation notices...")
        content = wrap_typed_resources_with_deprecation(content)

    if content != original:
        provider_path.write_text(content)
        print(f"Patched {provider_path}")
    else:
        print("No changes needed.")


if __name__ == "__main__":
    main()
