// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"airbyte/internal/sdk/pkg/utils"
	"encoding/json"
	"errors"
	"fmt"
)

type DestinationMongodbUpdateAuthorizationTypeLoginPasswordAuthorization string

const (
	DestinationMongodbUpdateAuthorizationTypeLoginPasswordAuthorizationLoginPassword DestinationMongodbUpdateAuthorizationTypeLoginPasswordAuthorization = "login/password"
)

func (e DestinationMongodbUpdateAuthorizationTypeLoginPasswordAuthorization) ToPointer() *DestinationMongodbUpdateAuthorizationTypeLoginPasswordAuthorization {
	return &e
}

func (e *DestinationMongodbUpdateAuthorizationTypeLoginPasswordAuthorization) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "login/password":
		*e = DestinationMongodbUpdateAuthorizationTypeLoginPasswordAuthorization(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationMongodbUpdateAuthorizationTypeLoginPasswordAuthorization: %v", v)
	}
}

// DestinationMongodbUpdateAuthorizationTypeLoginPassword - Login/Password.
type DestinationMongodbUpdateAuthorizationTypeLoginPassword struct {
	authorization DestinationMongodbUpdateAuthorizationTypeLoginPasswordAuthorization `const:"login/password" json:"authorization"`
	// Password associated with the username.
	Password string `json:"password"`
	// Username to use to access the database.
	Username string `json:"username"`
}

func (d DestinationMongodbUpdateAuthorizationTypeLoginPassword) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationMongodbUpdateAuthorizationTypeLoginPassword) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationMongodbUpdateAuthorizationTypeLoginPassword) GetAuthorization() DestinationMongodbUpdateAuthorizationTypeLoginPasswordAuthorization {
	return DestinationMongodbUpdateAuthorizationTypeLoginPasswordAuthorizationLoginPassword
}

func (o *DestinationMongodbUpdateAuthorizationTypeLoginPassword) GetPassword() string {
	if o == nil {
		return ""
	}
	return o.Password
}

func (o *DestinationMongodbUpdateAuthorizationTypeLoginPassword) GetUsername() string {
	if o == nil {
		return ""
	}
	return o.Username
}

type DestinationMongodbUpdateAuthorizationTypeNoneAuthorization string

const (
	DestinationMongodbUpdateAuthorizationTypeNoneAuthorizationNone DestinationMongodbUpdateAuthorizationTypeNoneAuthorization = "none"
)

func (e DestinationMongodbUpdateAuthorizationTypeNoneAuthorization) ToPointer() *DestinationMongodbUpdateAuthorizationTypeNoneAuthorization {
	return &e
}

func (e *DestinationMongodbUpdateAuthorizationTypeNoneAuthorization) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "none":
		*e = DestinationMongodbUpdateAuthorizationTypeNoneAuthorization(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationMongodbUpdateAuthorizationTypeNoneAuthorization: %v", v)
	}
}

// DestinationMongodbUpdateAuthorizationTypeNone - None.
type DestinationMongodbUpdateAuthorizationTypeNone struct {
	authorization DestinationMongodbUpdateAuthorizationTypeNoneAuthorization `const:"none" json:"authorization"`
}

func (d DestinationMongodbUpdateAuthorizationTypeNone) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationMongodbUpdateAuthorizationTypeNone) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationMongodbUpdateAuthorizationTypeNone) GetAuthorization() DestinationMongodbUpdateAuthorizationTypeNoneAuthorization {
	return DestinationMongodbUpdateAuthorizationTypeNoneAuthorizationNone
}

type DestinationMongodbUpdateAuthorizationTypeType string

const (
	DestinationMongodbUpdateAuthorizationTypeTypeDestinationMongodbUpdateAuthorizationTypeNone          DestinationMongodbUpdateAuthorizationTypeType = "destination-mongodb-update_Authorization type_None"
	DestinationMongodbUpdateAuthorizationTypeTypeDestinationMongodbUpdateAuthorizationTypeLoginPassword DestinationMongodbUpdateAuthorizationTypeType = "destination-mongodb-update_Authorization type_Login/Password"
)

type DestinationMongodbUpdateAuthorizationType struct {
	DestinationMongodbUpdateAuthorizationTypeNone          *DestinationMongodbUpdateAuthorizationTypeNone
	DestinationMongodbUpdateAuthorizationTypeLoginPassword *DestinationMongodbUpdateAuthorizationTypeLoginPassword

	Type DestinationMongodbUpdateAuthorizationTypeType
}

func CreateDestinationMongodbUpdateAuthorizationTypeDestinationMongodbUpdateAuthorizationTypeNone(destinationMongodbUpdateAuthorizationTypeNone DestinationMongodbUpdateAuthorizationTypeNone) DestinationMongodbUpdateAuthorizationType {
	typ := DestinationMongodbUpdateAuthorizationTypeTypeDestinationMongodbUpdateAuthorizationTypeNone

	return DestinationMongodbUpdateAuthorizationType{
		DestinationMongodbUpdateAuthorizationTypeNone: &destinationMongodbUpdateAuthorizationTypeNone,
		Type: typ,
	}
}

func CreateDestinationMongodbUpdateAuthorizationTypeDestinationMongodbUpdateAuthorizationTypeLoginPassword(destinationMongodbUpdateAuthorizationTypeLoginPassword DestinationMongodbUpdateAuthorizationTypeLoginPassword) DestinationMongodbUpdateAuthorizationType {
	typ := DestinationMongodbUpdateAuthorizationTypeTypeDestinationMongodbUpdateAuthorizationTypeLoginPassword

	return DestinationMongodbUpdateAuthorizationType{
		DestinationMongodbUpdateAuthorizationTypeLoginPassword: &destinationMongodbUpdateAuthorizationTypeLoginPassword,
		Type: typ,
	}
}

func (u *DestinationMongodbUpdateAuthorizationType) UnmarshalJSON(data []byte) error {

	destinationMongodbUpdateAuthorizationTypeNone := new(DestinationMongodbUpdateAuthorizationTypeNone)
	if err := utils.UnmarshalJSON(data, &destinationMongodbUpdateAuthorizationTypeNone, "", true, true); err == nil {
		u.DestinationMongodbUpdateAuthorizationTypeNone = destinationMongodbUpdateAuthorizationTypeNone
		u.Type = DestinationMongodbUpdateAuthorizationTypeTypeDestinationMongodbUpdateAuthorizationTypeNone
		return nil
	}

	destinationMongodbUpdateAuthorizationTypeLoginPassword := new(DestinationMongodbUpdateAuthorizationTypeLoginPassword)
	if err := utils.UnmarshalJSON(data, &destinationMongodbUpdateAuthorizationTypeLoginPassword, "", true, true); err == nil {
		u.DestinationMongodbUpdateAuthorizationTypeLoginPassword = destinationMongodbUpdateAuthorizationTypeLoginPassword
		u.Type = DestinationMongodbUpdateAuthorizationTypeTypeDestinationMongodbUpdateAuthorizationTypeLoginPassword
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u DestinationMongodbUpdateAuthorizationType) MarshalJSON() ([]byte, error) {
	if u.DestinationMongodbUpdateAuthorizationTypeNone != nil {
		return utils.MarshalJSON(u.DestinationMongodbUpdateAuthorizationTypeNone, "", true)
	}

	if u.DestinationMongodbUpdateAuthorizationTypeLoginPassword != nil {
		return utils.MarshalJSON(u.DestinationMongodbUpdateAuthorizationTypeLoginPassword, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type DestinationMongodbUpdateMongoDBInstanceTypeMongoDBAtlasInstance string

const (
	DestinationMongodbUpdateMongoDBInstanceTypeMongoDBAtlasInstanceAtlas DestinationMongodbUpdateMongoDBInstanceTypeMongoDBAtlasInstance = "atlas"
)

func (e DestinationMongodbUpdateMongoDBInstanceTypeMongoDBAtlasInstance) ToPointer() *DestinationMongodbUpdateMongoDBInstanceTypeMongoDBAtlasInstance {
	return &e
}

func (e *DestinationMongodbUpdateMongoDBInstanceTypeMongoDBAtlasInstance) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "atlas":
		*e = DestinationMongodbUpdateMongoDBInstanceTypeMongoDBAtlasInstance(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationMongodbUpdateMongoDBInstanceTypeMongoDBAtlasInstance: %v", v)
	}
}

// DestinationMongodbUpdateMongoDBInstanceTypeMongoDBAtlas - MongoDb instance to connect to. For MongoDB Atlas and Replica Set TLS connection is used by default.
type DestinationMongodbUpdateMongoDBInstanceTypeMongoDBAtlas struct {
	// URL of a cluster to connect to.
	ClusterURL string                                                           `json:"cluster_url"`
	Instance   *DestinationMongodbUpdateMongoDBInstanceTypeMongoDBAtlasInstance `default:"atlas" json:"instance"`
}

func (d DestinationMongodbUpdateMongoDBInstanceTypeMongoDBAtlas) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationMongodbUpdateMongoDBInstanceTypeMongoDBAtlas) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationMongodbUpdateMongoDBInstanceTypeMongoDBAtlas) GetClusterURL() string {
	if o == nil {
		return ""
	}
	return o.ClusterURL
}

func (o *DestinationMongodbUpdateMongoDBInstanceTypeMongoDBAtlas) GetInstance() *DestinationMongodbUpdateMongoDBInstanceTypeMongoDBAtlasInstance {
	if o == nil {
		return nil
	}
	return o.Instance
}

type DestinationMongodbUpdateMongoDbInstanceTypeReplicaSetInstance string

const (
	DestinationMongodbUpdateMongoDbInstanceTypeReplicaSetInstanceReplica DestinationMongodbUpdateMongoDbInstanceTypeReplicaSetInstance = "replica"
)

func (e DestinationMongodbUpdateMongoDbInstanceTypeReplicaSetInstance) ToPointer() *DestinationMongodbUpdateMongoDbInstanceTypeReplicaSetInstance {
	return &e
}

func (e *DestinationMongodbUpdateMongoDbInstanceTypeReplicaSetInstance) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "replica":
		*e = DestinationMongodbUpdateMongoDbInstanceTypeReplicaSetInstance(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationMongodbUpdateMongoDbInstanceTypeReplicaSetInstance: %v", v)
	}
}

// DestinationMongodbUpdateMongoDbInstanceTypeReplicaSet - MongoDb instance to connect to. For MongoDB Atlas and Replica Set TLS connection is used by default.
type DestinationMongodbUpdateMongoDbInstanceTypeReplicaSet struct {
	Instance *DestinationMongodbUpdateMongoDbInstanceTypeReplicaSetInstance `default:"replica" json:"instance"`
	// A replica set name.
	ReplicaSet *string `json:"replica_set,omitempty"`
	// The members of a replica set. Please specify `host`:`port` of each member seperated by comma.
	ServerAddresses string `json:"server_addresses"`
}

func (d DestinationMongodbUpdateMongoDbInstanceTypeReplicaSet) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationMongodbUpdateMongoDbInstanceTypeReplicaSet) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationMongodbUpdateMongoDbInstanceTypeReplicaSet) GetInstance() *DestinationMongodbUpdateMongoDbInstanceTypeReplicaSetInstance {
	if o == nil {
		return nil
	}
	return o.Instance
}

func (o *DestinationMongodbUpdateMongoDbInstanceTypeReplicaSet) GetReplicaSet() *string {
	if o == nil {
		return nil
	}
	return o.ReplicaSet
}

func (o *DestinationMongodbUpdateMongoDbInstanceTypeReplicaSet) GetServerAddresses() string {
	if o == nil {
		return ""
	}
	return o.ServerAddresses
}

type DestinationMongodbUpdateMongoDbInstanceTypeStandaloneMongoDbInstanceInstance string

const (
	DestinationMongodbUpdateMongoDbInstanceTypeStandaloneMongoDbInstanceInstanceStandalone DestinationMongodbUpdateMongoDbInstanceTypeStandaloneMongoDbInstanceInstance = "standalone"
)

func (e DestinationMongodbUpdateMongoDbInstanceTypeStandaloneMongoDbInstanceInstance) ToPointer() *DestinationMongodbUpdateMongoDbInstanceTypeStandaloneMongoDbInstanceInstance {
	return &e
}

func (e *DestinationMongodbUpdateMongoDbInstanceTypeStandaloneMongoDbInstanceInstance) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "standalone":
		*e = DestinationMongodbUpdateMongoDbInstanceTypeStandaloneMongoDbInstanceInstance(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationMongodbUpdateMongoDbInstanceTypeStandaloneMongoDbInstanceInstance: %v", v)
	}
}

// DestinationMongodbUpdateMongoDbInstanceTypeStandaloneMongoDbInstance - MongoDb instance to connect to. For MongoDB Atlas and Replica Set TLS connection is used by default.
type DestinationMongodbUpdateMongoDbInstanceTypeStandaloneMongoDbInstance struct {
	// The Host of a Mongo database to be replicated.
	Host     string                                                                        `json:"host"`
	Instance *DestinationMongodbUpdateMongoDbInstanceTypeStandaloneMongoDbInstanceInstance `default:"standalone" json:"instance"`
	// The Port of a Mongo database to be replicated.
	Port *int64 `default:"27017" json:"port"`
}

func (d DestinationMongodbUpdateMongoDbInstanceTypeStandaloneMongoDbInstance) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationMongodbUpdateMongoDbInstanceTypeStandaloneMongoDbInstance) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationMongodbUpdateMongoDbInstanceTypeStandaloneMongoDbInstance) GetHost() string {
	if o == nil {
		return ""
	}
	return o.Host
}

func (o *DestinationMongodbUpdateMongoDbInstanceTypeStandaloneMongoDbInstance) GetInstance() *DestinationMongodbUpdateMongoDbInstanceTypeStandaloneMongoDbInstanceInstance {
	if o == nil {
		return nil
	}
	return o.Instance
}

func (o *DestinationMongodbUpdateMongoDbInstanceTypeStandaloneMongoDbInstance) GetPort() *int64 {
	if o == nil {
		return nil
	}
	return o.Port
}

type DestinationMongodbUpdateMongoDbInstanceTypeType string

const (
	DestinationMongodbUpdateMongoDbInstanceTypeTypeDestinationMongodbUpdateMongoDbInstanceTypeStandaloneMongoDbInstance DestinationMongodbUpdateMongoDbInstanceTypeType = "destination-mongodb-update_MongoDb Instance Type_Standalone MongoDb Instance"
	DestinationMongodbUpdateMongoDbInstanceTypeTypeDestinationMongodbUpdateMongoDbInstanceTypeReplicaSet                DestinationMongodbUpdateMongoDbInstanceTypeType = "destination-mongodb-update_MongoDb Instance Type_Replica Set"
	DestinationMongodbUpdateMongoDbInstanceTypeTypeDestinationMongodbUpdateMongoDBInstanceTypeMongoDBAtlas              DestinationMongodbUpdateMongoDbInstanceTypeType = "destination-mongodb-update_MongoDb Instance Type_MongoDB Atlas"
)

type DestinationMongodbUpdateMongoDbInstanceType struct {
	DestinationMongodbUpdateMongoDbInstanceTypeStandaloneMongoDbInstance *DestinationMongodbUpdateMongoDbInstanceTypeStandaloneMongoDbInstance
	DestinationMongodbUpdateMongoDbInstanceTypeReplicaSet                *DestinationMongodbUpdateMongoDbInstanceTypeReplicaSet
	DestinationMongodbUpdateMongoDBInstanceTypeMongoDBAtlas              *DestinationMongodbUpdateMongoDBInstanceTypeMongoDBAtlas

	Type DestinationMongodbUpdateMongoDbInstanceTypeType
}

func CreateDestinationMongodbUpdateMongoDbInstanceTypeDestinationMongodbUpdateMongoDbInstanceTypeStandaloneMongoDbInstance(destinationMongodbUpdateMongoDbInstanceTypeStandaloneMongoDbInstance DestinationMongodbUpdateMongoDbInstanceTypeStandaloneMongoDbInstance) DestinationMongodbUpdateMongoDbInstanceType {
	typ := DestinationMongodbUpdateMongoDbInstanceTypeTypeDestinationMongodbUpdateMongoDbInstanceTypeStandaloneMongoDbInstance

	return DestinationMongodbUpdateMongoDbInstanceType{
		DestinationMongodbUpdateMongoDbInstanceTypeStandaloneMongoDbInstance: &destinationMongodbUpdateMongoDbInstanceTypeStandaloneMongoDbInstance,
		Type: typ,
	}
}

func CreateDestinationMongodbUpdateMongoDbInstanceTypeDestinationMongodbUpdateMongoDbInstanceTypeReplicaSet(destinationMongodbUpdateMongoDbInstanceTypeReplicaSet DestinationMongodbUpdateMongoDbInstanceTypeReplicaSet) DestinationMongodbUpdateMongoDbInstanceType {
	typ := DestinationMongodbUpdateMongoDbInstanceTypeTypeDestinationMongodbUpdateMongoDbInstanceTypeReplicaSet

	return DestinationMongodbUpdateMongoDbInstanceType{
		DestinationMongodbUpdateMongoDbInstanceTypeReplicaSet: &destinationMongodbUpdateMongoDbInstanceTypeReplicaSet,
		Type: typ,
	}
}

func CreateDestinationMongodbUpdateMongoDbInstanceTypeDestinationMongodbUpdateMongoDBInstanceTypeMongoDBAtlas(destinationMongodbUpdateMongoDBInstanceTypeMongoDBAtlas DestinationMongodbUpdateMongoDBInstanceTypeMongoDBAtlas) DestinationMongodbUpdateMongoDbInstanceType {
	typ := DestinationMongodbUpdateMongoDbInstanceTypeTypeDestinationMongodbUpdateMongoDBInstanceTypeMongoDBAtlas

	return DestinationMongodbUpdateMongoDbInstanceType{
		DestinationMongodbUpdateMongoDBInstanceTypeMongoDBAtlas: &destinationMongodbUpdateMongoDBInstanceTypeMongoDBAtlas,
		Type: typ,
	}
}

func (u *DestinationMongodbUpdateMongoDbInstanceType) UnmarshalJSON(data []byte) error {

	destinationMongodbUpdateMongoDBInstanceTypeMongoDBAtlas := new(DestinationMongodbUpdateMongoDBInstanceTypeMongoDBAtlas)
	if err := utils.UnmarshalJSON(data, &destinationMongodbUpdateMongoDBInstanceTypeMongoDBAtlas, "", true, true); err == nil {
		u.DestinationMongodbUpdateMongoDBInstanceTypeMongoDBAtlas = destinationMongodbUpdateMongoDBInstanceTypeMongoDBAtlas
		u.Type = DestinationMongodbUpdateMongoDbInstanceTypeTypeDestinationMongodbUpdateMongoDBInstanceTypeMongoDBAtlas
		return nil
	}

	destinationMongodbUpdateMongoDbInstanceTypeStandaloneMongoDbInstance := new(DestinationMongodbUpdateMongoDbInstanceTypeStandaloneMongoDbInstance)
	if err := utils.UnmarshalJSON(data, &destinationMongodbUpdateMongoDbInstanceTypeStandaloneMongoDbInstance, "", true, true); err == nil {
		u.DestinationMongodbUpdateMongoDbInstanceTypeStandaloneMongoDbInstance = destinationMongodbUpdateMongoDbInstanceTypeStandaloneMongoDbInstance
		u.Type = DestinationMongodbUpdateMongoDbInstanceTypeTypeDestinationMongodbUpdateMongoDbInstanceTypeStandaloneMongoDbInstance
		return nil
	}

	destinationMongodbUpdateMongoDbInstanceTypeReplicaSet := new(DestinationMongodbUpdateMongoDbInstanceTypeReplicaSet)
	if err := utils.UnmarshalJSON(data, &destinationMongodbUpdateMongoDbInstanceTypeReplicaSet, "", true, true); err == nil {
		u.DestinationMongodbUpdateMongoDbInstanceTypeReplicaSet = destinationMongodbUpdateMongoDbInstanceTypeReplicaSet
		u.Type = DestinationMongodbUpdateMongoDbInstanceTypeTypeDestinationMongodbUpdateMongoDbInstanceTypeReplicaSet
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u DestinationMongodbUpdateMongoDbInstanceType) MarshalJSON() ([]byte, error) {
	if u.DestinationMongodbUpdateMongoDbInstanceTypeStandaloneMongoDbInstance != nil {
		return utils.MarshalJSON(u.DestinationMongodbUpdateMongoDbInstanceTypeStandaloneMongoDbInstance, "", true)
	}

	if u.DestinationMongodbUpdateMongoDbInstanceTypeReplicaSet != nil {
		return utils.MarshalJSON(u.DestinationMongodbUpdateMongoDbInstanceTypeReplicaSet, "", true)
	}

	if u.DestinationMongodbUpdateMongoDBInstanceTypeMongoDBAtlas != nil {
		return utils.MarshalJSON(u.DestinationMongodbUpdateMongoDBInstanceTypeMongoDBAtlas, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

// DestinationMongodbUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod - Connect through a jump server tunnel host using username and password authentication
type DestinationMongodbUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod string

const (
	DestinationMongodbUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethodSSHPasswordAuth DestinationMongodbUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod = "SSH_PASSWORD_AUTH"
)

func (e DestinationMongodbUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod) ToPointer() *DestinationMongodbUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod {
	return &e
}

func (e *DestinationMongodbUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_PASSWORD_AUTH":
		*e = DestinationMongodbUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationMongodbUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod: %v", v)
	}
}

// DestinationMongodbUpdateSSHTunnelMethodPasswordAuthentication - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type DestinationMongodbUpdateSSHTunnelMethodPasswordAuthentication struct {
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and password authentication
	tunnelMethod DestinationMongodbUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod `const:"SSH_PASSWORD_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser string `json:"tunnel_user"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword string `json:"tunnel_user_password"`
}

func (d DestinationMongodbUpdateSSHTunnelMethodPasswordAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationMongodbUpdateSSHTunnelMethodPasswordAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationMongodbUpdateSSHTunnelMethodPasswordAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *DestinationMongodbUpdateSSHTunnelMethodPasswordAuthentication) GetTunnelMethod() DestinationMongodbUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod {
	return DestinationMongodbUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethodSSHPasswordAuth
}

func (o *DestinationMongodbUpdateSSHTunnelMethodPasswordAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *DestinationMongodbUpdateSSHTunnelMethodPasswordAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

func (o *DestinationMongodbUpdateSSHTunnelMethodPasswordAuthentication) GetTunnelUserPassword() string {
	if o == nil {
		return ""
	}
	return o.TunnelUserPassword
}

// DestinationMongodbUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod - Connect through a jump server tunnel host using username and ssh key
type DestinationMongodbUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod string

const (
	DestinationMongodbUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethodSSHKeyAuth DestinationMongodbUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod = "SSH_KEY_AUTH"
)

func (e DestinationMongodbUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod) ToPointer() *DestinationMongodbUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod {
	return &e
}

func (e *DestinationMongodbUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_KEY_AUTH":
		*e = DestinationMongodbUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationMongodbUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod: %v", v)
	}
}

// DestinationMongodbUpdateSSHTunnelMethodSSHKeyAuthentication - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type DestinationMongodbUpdateSSHTunnelMethodSSHKeyAuthentication struct {
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey string `json:"ssh_key"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and ssh key
	tunnelMethod DestinationMongodbUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod `const:"SSH_KEY_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host.
	TunnelUser string `json:"tunnel_user"`
}

func (d DestinationMongodbUpdateSSHTunnelMethodSSHKeyAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationMongodbUpdateSSHTunnelMethodSSHKeyAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationMongodbUpdateSSHTunnelMethodSSHKeyAuthentication) GetSSHKey() string {
	if o == nil {
		return ""
	}
	return o.SSHKey
}

func (o *DestinationMongodbUpdateSSHTunnelMethodSSHKeyAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *DestinationMongodbUpdateSSHTunnelMethodSSHKeyAuthentication) GetTunnelMethod() DestinationMongodbUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod {
	return DestinationMongodbUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethodSSHKeyAuth
}

func (o *DestinationMongodbUpdateSSHTunnelMethodSSHKeyAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *DestinationMongodbUpdateSSHTunnelMethodSSHKeyAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

// DestinationMongodbUpdateSSHTunnelMethodNoTunnelTunnelMethod - No ssh tunnel needed to connect to database
type DestinationMongodbUpdateSSHTunnelMethodNoTunnelTunnelMethod string

const (
	DestinationMongodbUpdateSSHTunnelMethodNoTunnelTunnelMethodNoTunnel DestinationMongodbUpdateSSHTunnelMethodNoTunnelTunnelMethod = "NO_TUNNEL"
)

func (e DestinationMongodbUpdateSSHTunnelMethodNoTunnelTunnelMethod) ToPointer() *DestinationMongodbUpdateSSHTunnelMethodNoTunnelTunnelMethod {
	return &e
}

func (e *DestinationMongodbUpdateSSHTunnelMethodNoTunnelTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NO_TUNNEL":
		*e = DestinationMongodbUpdateSSHTunnelMethodNoTunnelTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationMongodbUpdateSSHTunnelMethodNoTunnelTunnelMethod: %v", v)
	}
}

// DestinationMongodbUpdateSSHTunnelMethodNoTunnel - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type DestinationMongodbUpdateSSHTunnelMethodNoTunnel struct {
	// No ssh tunnel needed to connect to database
	tunnelMethod DestinationMongodbUpdateSSHTunnelMethodNoTunnelTunnelMethod `const:"NO_TUNNEL" json:"tunnel_method"`
}

func (d DestinationMongodbUpdateSSHTunnelMethodNoTunnel) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationMongodbUpdateSSHTunnelMethodNoTunnel) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationMongodbUpdateSSHTunnelMethodNoTunnel) GetTunnelMethod() DestinationMongodbUpdateSSHTunnelMethodNoTunnelTunnelMethod {
	return DestinationMongodbUpdateSSHTunnelMethodNoTunnelTunnelMethodNoTunnel
}

type DestinationMongodbUpdateSSHTunnelMethodType string

const (
	DestinationMongodbUpdateSSHTunnelMethodTypeDestinationMongodbUpdateSSHTunnelMethodNoTunnel               DestinationMongodbUpdateSSHTunnelMethodType = "destination-mongodb-update_SSH Tunnel Method_No Tunnel"
	DestinationMongodbUpdateSSHTunnelMethodTypeDestinationMongodbUpdateSSHTunnelMethodSSHKeyAuthentication   DestinationMongodbUpdateSSHTunnelMethodType = "destination-mongodb-update_SSH Tunnel Method_SSH Key Authentication"
	DestinationMongodbUpdateSSHTunnelMethodTypeDestinationMongodbUpdateSSHTunnelMethodPasswordAuthentication DestinationMongodbUpdateSSHTunnelMethodType = "destination-mongodb-update_SSH Tunnel Method_Password Authentication"
)

type DestinationMongodbUpdateSSHTunnelMethod struct {
	DestinationMongodbUpdateSSHTunnelMethodNoTunnel               *DestinationMongodbUpdateSSHTunnelMethodNoTunnel
	DestinationMongodbUpdateSSHTunnelMethodSSHKeyAuthentication   *DestinationMongodbUpdateSSHTunnelMethodSSHKeyAuthentication
	DestinationMongodbUpdateSSHTunnelMethodPasswordAuthentication *DestinationMongodbUpdateSSHTunnelMethodPasswordAuthentication

	Type DestinationMongodbUpdateSSHTunnelMethodType
}

func CreateDestinationMongodbUpdateSSHTunnelMethodDestinationMongodbUpdateSSHTunnelMethodNoTunnel(destinationMongodbUpdateSSHTunnelMethodNoTunnel DestinationMongodbUpdateSSHTunnelMethodNoTunnel) DestinationMongodbUpdateSSHTunnelMethod {
	typ := DestinationMongodbUpdateSSHTunnelMethodTypeDestinationMongodbUpdateSSHTunnelMethodNoTunnel

	return DestinationMongodbUpdateSSHTunnelMethod{
		DestinationMongodbUpdateSSHTunnelMethodNoTunnel: &destinationMongodbUpdateSSHTunnelMethodNoTunnel,
		Type: typ,
	}
}

func CreateDestinationMongodbUpdateSSHTunnelMethodDestinationMongodbUpdateSSHTunnelMethodSSHKeyAuthentication(destinationMongodbUpdateSSHTunnelMethodSSHKeyAuthentication DestinationMongodbUpdateSSHTunnelMethodSSHKeyAuthentication) DestinationMongodbUpdateSSHTunnelMethod {
	typ := DestinationMongodbUpdateSSHTunnelMethodTypeDestinationMongodbUpdateSSHTunnelMethodSSHKeyAuthentication

	return DestinationMongodbUpdateSSHTunnelMethod{
		DestinationMongodbUpdateSSHTunnelMethodSSHKeyAuthentication: &destinationMongodbUpdateSSHTunnelMethodSSHKeyAuthentication,
		Type: typ,
	}
}

func CreateDestinationMongodbUpdateSSHTunnelMethodDestinationMongodbUpdateSSHTunnelMethodPasswordAuthentication(destinationMongodbUpdateSSHTunnelMethodPasswordAuthentication DestinationMongodbUpdateSSHTunnelMethodPasswordAuthentication) DestinationMongodbUpdateSSHTunnelMethod {
	typ := DestinationMongodbUpdateSSHTunnelMethodTypeDestinationMongodbUpdateSSHTunnelMethodPasswordAuthentication

	return DestinationMongodbUpdateSSHTunnelMethod{
		DestinationMongodbUpdateSSHTunnelMethodPasswordAuthentication: &destinationMongodbUpdateSSHTunnelMethodPasswordAuthentication,
		Type: typ,
	}
}

func (u *DestinationMongodbUpdateSSHTunnelMethod) UnmarshalJSON(data []byte) error {

	destinationMongodbUpdateSSHTunnelMethodNoTunnel := new(DestinationMongodbUpdateSSHTunnelMethodNoTunnel)
	if err := utils.UnmarshalJSON(data, &destinationMongodbUpdateSSHTunnelMethodNoTunnel, "", true, true); err == nil {
		u.DestinationMongodbUpdateSSHTunnelMethodNoTunnel = destinationMongodbUpdateSSHTunnelMethodNoTunnel
		u.Type = DestinationMongodbUpdateSSHTunnelMethodTypeDestinationMongodbUpdateSSHTunnelMethodNoTunnel
		return nil
	}

	destinationMongodbUpdateSSHTunnelMethodSSHKeyAuthentication := new(DestinationMongodbUpdateSSHTunnelMethodSSHKeyAuthentication)
	if err := utils.UnmarshalJSON(data, &destinationMongodbUpdateSSHTunnelMethodSSHKeyAuthentication, "", true, true); err == nil {
		u.DestinationMongodbUpdateSSHTunnelMethodSSHKeyAuthentication = destinationMongodbUpdateSSHTunnelMethodSSHKeyAuthentication
		u.Type = DestinationMongodbUpdateSSHTunnelMethodTypeDestinationMongodbUpdateSSHTunnelMethodSSHKeyAuthentication
		return nil
	}

	destinationMongodbUpdateSSHTunnelMethodPasswordAuthentication := new(DestinationMongodbUpdateSSHTunnelMethodPasswordAuthentication)
	if err := utils.UnmarshalJSON(data, &destinationMongodbUpdateSSHTunnelMethodPasswordAuthentication, "", true, true); err == nil {
		u.DestinationMongodbUpdateSSHTunnelMethodPasswordAuthentication = destinationMongodbUpdateSSHTunnelMethodPasswordAuthentication
		u.Type = DestinationMongodbUpdateSSHTunnelMethodTypeDestinationMongodbUpdateSSHTunnelMethodPasswordAuthentication
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u DestinationMongodbUpdateSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.DestinationMongodbUpdateSSHTunnelMethodNoTunnel != nil {
		return utils.MarshalJSON(u.DestinationMongodbUpdateSSHTunnelMethodNoTunnel, "", true)
	}

	if u.DestinationMongodbUpdateSSHTunnelMethodSSHKeyAuthentication != nil {
		return utils.MarshalJSON(u.DestinationMongodbUpdateSSHTunnelMethodSSHKeyAuthentication, "", true)
	}

	if u.DestinationMongodbUpdateSSHTunnelMethodPasswordAuthentication != nil {
		return utils.MarshalJSON(u.DestinationMongodbUpdateSSHTunnelMethodPasswordAuthentication, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type DestinationMongodbUpdate struct {
	// Authorization type.
	AuthType DestinationMongodbUpdateAuthorizationType `json:"auth_type"`
	// Name of the database.
	Database string `json:"database"`
	// MongoDb instance to connect to. For MongoDB Atlas and Replica Set TLS connection is used by default.
	InstanceType *DestinationMongodbUpdateMongoDbInstanceType `json:"instance_type,omitempty"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod *DestinationMongodbUpdateSSHTunnelMethod `json:"tunnel_method,omitempty"`
}

func (o *DestinationMongodbUpdate) GetAuthType() DestinationMongodbUpdateAuthorizationType {
	if o == nil {
		return DestinationMongodbUpdateAuthorizationType{}
	}
	return o.AuthType
}

func (o *DestinationMongodbUpdate) GetDatabase() string {
	if o == nil {
		return ""
	}
	return o.Database
}

func (o *DestinationMongodbUpdate) GetInstanceType() *DestinationMongodbUpdateMongoDbInstanceType {
	if o == nil {
		return nil
	}
	return o.InstanceType
}

func (o *DestinationMongodbUpdate) GetTunnelMethod() *DestinationMongodbUpdateSSHTunnelMethod {
	if o == nil {
		return nil
	}
	return o.TunnelMethod
}
