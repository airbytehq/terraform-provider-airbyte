// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"airbyte/internal/sdk/pkg/utils"
	"encoding/json"
	"errors"
	"fmt"
)

type SourceAlloydbReplicationMethodStandardMethod string

const (
	SourceAlloydbReplicationMethodStandardMethodStandard SourceAlloydbReplicationMethodStandardMethod = "Standard"
)

func (e SourceAlloydbReplicationMethodStandardMethod) ToPointer() *SourceAlloydbReplicationMethodStandardMethod {
	return &e
}

func (e *SourceAlloydbReplicationMethodStandardMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Standard":
		*e = SourceAlloydbReplicationMethodStandardMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceAlloydbReplicationMethodStandardMethod: %v", v)
	}
}

// SourceAlloydbReplicationMethodStandard - Standard replication requires no setup on the DB side but will not be able to represent deletions incrementally.
type SourceAlloydbReplicationMethodStandard struct {
	method SourceAlloydbReplicationMethodStandardMethod `const:"Standard" json:"method"`
}

func (s SourceAlloydbReplicationMethodStandard) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceAlloydbReplicationMethodStandard) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceAlloydbReplicationMethodStandard) GetMethod() SourceAlloydbReplicationMethodStandardMethod {
	return SourceAlloydbReplicationMethodStandardMethodStandard
}

// SourceAlloydbReplicationMethodLogicalReplicationCDCLSNCommitBehaviour - Determines when Airbtye should flush the LSN of processed WAL logs in the source database. `After loading Data in the destination` is default. If `While reading Data` is selected, in case of a downstream failure (while loading data into the destination), next sync would result in a full sync.
type SourceAlloydbReplicationMethodLogicalReplicationCDCLSNCommitBehaviour string

const (
	SourceAlloydbReplicationMethodLogicalReplicationCDCLSNCommitBehaviourWhileReadingData                 SourceAlloydbReplicationMethodLogicalReplicationCDCLSNCommitBehaviour = "While reading Data"
	SourceAlloydbReplicationMethodLogicalReplicationCDCLSNCommitBehaviourAfterLoadingDataInTheDestination SourceAlloydbReplicationMethodLogicalReplicationCDCLSNCommitBehaviour = "After loading Data in the destination"
)

func (e SourceAlloydbReplicationMethodLogicalReplicationCDCLSNCommitBehaviour) ToPointer() *SourceAlloydbReplicationMethodLogicalReplicationCDCLSNCommitBehaviour {
	return &e
}

func (e *SourceAlloydbReplicationMethodLogicalReplicationCDCLSNCommitBehaviour) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "While reading Data":
		fallthrough
	case "After loading Data in the destination":
		*e = SourceAlloydbReplicationMethodLogicalReplicationCDCLSNCommitBehaviour(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceAlloydbReplicationMethodLogicalReplicationCDCLSNCommitBehaviour: %v", v)
	}
}

type SourceAlloydbReplicationMethodLogicalReplicationCDCMethod string

const (
	SourceAlloydbReplicationMethodLogicalReplicationCDCMethodCdc SourceAlloydbReplicationMethodLogicalReplicationCDCMethod = "CDC"
)

func (e SourceAlloydbReplicationMethodLogicalReplicationCDCMethod) ToPointer() *SourceAlloydbReplicationMethodLogicalReplicationCDCMethod {
	return &e
}

func (e *SourceAlloydbReplicationMethodLogicalReplicationCDCMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CDC":
		*e = SourceAlloydbReplicationMethodLogicalReplicationCDCMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceAlloydbReplicationMethodLogicalReplicationCDCMethod: %v", v)
	}
}

// SourceAlloydbReplicationMethodLogicalReplicationCDCPlugin - A logical decoding plugin installed on the PostgreSQL server.
type SourceAlloydbReplicationMethodLogicalReplicationCDCPlugin string

const (
	SourceAlloydbReplicationMethodLogicalReplicationCDCPluginPgoutput SourceAlloydbReplicationMethodLogicalReplicationCDCPlugin = "pgoutput"
)

func (e SourceAlloydbReplicationMethodLogicalReplicationCDCPlugin) ToPointer() *SourceAlloydbReplicationMethodLogicalReplicationCDCPlugin {
	return &e
}

func (e *SourceAlloydbReplicationMethodLogicalReplicationCDCPlugin) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "pgoutput":
		*e = SourceAlloydbReplicationMethodLogicalReplicationCDCPlugin(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceAlloydbReplicationMethodLogicalReplicationCDCPlugin: %v", v)
	}
}

// SourceAlloydbReplicationMethodLogicalReplicationCDC - Logical replication uses the Postgres write-ahead log (WAL) to detect inserts, updates, and deletes. This needs to be configured on the source database itself. Only available on Postgres 10 and above. Read the <a href="https://docs.airbyte.com/integrations/sources/postgres">docs</a>.
type SourceAlloydbReplicationMethodLogicalReplicationCDC struct {
	AdditionalProperties interface{} `additionalProperties:"true" json:"-"`
	// The amount of time the connector will wait when it launches to determine if there is new data to sync or not. Defaults to 300 seconds. Valid range: 120 seconds to 1200 seconds. Read about <a href="https://docs.airbyte.com/integrations/sources/postgres#step-5-optional-set-up-initial-waiting-time">initial waiting time</a>.
	InitialWaitingSeconds *int64 `default:"300" json:"initial_waiting_seconds"`
	// Determines when Airbtye should flush the LSN of processed WAL logs in the source database. `After loading Data in the destination` is default. If `While reading Data` is selected, in case of a downstream failure (while loading data into the destination), next sync would result in a full sync.
	LsnCommitBehaviour *SourceAlloydbReplicationMethodLogicalReplicationCDCLSNCommitBehaviour `default:"After loading Data in the destination" json:"lsn_commit_behaviour"`
	method             SourceAlloydbReplicationMethodLogicalReplicationCDCMethod              `const:"CDC" json:"method"`
	// A logical decoding plugin installed on the PostgreSQL server.
	Plugin *SourceAlloydbReplicationMethodLogicalReplicationCDCPlugin `default:"pgoutput" json:"plugin"`
	// A Postgres publication used for consuming changes. Read about <a href="https://docs.airbyte.com/integrations/sources/postgres#step-4-create-publications-and-replication-identities-for-tables">publications and replication identities</a>.
	Publication string `json:"publication"`
	// The size of the internal queue. This may interfere with memory consumption and efficiency of the connector, please be careful.
	QueueSize *int64 `default:"10000" json:"queue_size"`
	// A plugin logical replication slot. Read about <a href="https://docs.airbyte.com/integrations/sources/postgres#step-3-create-replication-slot">replication slots</a>.
	ReplicationSlot string `json:"replication_slot"`
}

func (s SourceAlloydbReplicationMethodLogicalReplicationCDC) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceAlloydbReplicationMethodLogicalReplicationCDC) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceAlloydbReplicationMethodLogicalReplicationCDC) GetAdditionalProperties() interface{} {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *SourceAlloydbReplicationMethodLogicalReplicationCDC) GetInitialWaitingSeconds() *int64 {
	if o == nil {
		return nil
	}
	return o.InitialWaitingSeconds
}

func (o *SourceAlloydbReplicationMethodLogicalReplicationCDC) GetLsnCommitBehaviour() *SourceAlloydbReplicationMethodLogicalReplicationCDCLSNCommitBehaviour {
	if o == nil {
		return nil
	}
	return o.LsnCommitBehaviour
}

func (o *SourceAlloydbReplicationMethodLogicalReplicationCDC) GetMethod() SourceAlloydbReplicationMethodLogicalReplicationCDCMethod {
	return SourceAlloydbReplicationMethodLogicalReplicationCDCMethodCdc
}

func (o *SourceAlloydbReplicationMethodLogicalReplicationCDC) GetPlugin() *SourceAlloydbReplicationMethodLogicalReplicationCDCPlugin {
	if o == nil {
		return nil
	}
	return o.Plugin
}

func (o *SourceAlloydbReplicationMethodLogicalReplicationCDC) GetPublication() string {
	if o == nil {
		return ""
	}
	return o.Publication
}

func (o *SourceAlloydbReplicationMethodLogicalReplicationCDC) GetQueueSize() *int64 {
	if o == nil {
		return nil
	}
	return o.QueueSize
}

func (o *SourceAlloydbReplicationMethodLogicalReplicationCDC) GetReplicationSlot() string {
	if o == nil {
		return ""
	}
	return o.ReplicationSlot
}

type SourceAlloydbReplicationMethodStandardXminMethod string

const (
	SourceAlloydbReplicationMethodStandardXminMethodXmin SourceAlloydbReplicationMethodStandardXminMethod = "Xmin"
)

func (e SourceAlloydbReplicationMethodStandardXminMethod) ToPointer() *SourceAlloydbReplicationMethodStandardXminMethod {
	return &e
}

func (e *SourceAlloydbReplicationMethodStandardXminMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Xmin":
		*e = SourceAlloydbReplicationMethodStandardXminMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceAlloydbReplicationMethodStandardXminMethod: %v", v)
	}
}

// SourceAlloydbReplicationMethodStandardXmin - Xmin replication requires no setup on the DB side but will not be able to represent deletions incrementally.
type SourceAlloydbReplicationMethodStandardXmin struct {
	method SourceAlloydbReplicationMethodStandardXminMethod `const:"Xmin" json:"method"`
}

func (s SourceAlloydbReplicationMethodStandardXmin) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceAlloydbReplicationMethodStandardXmin) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceAlloydbReplicationMethodStandardXmin) GetMethod() SourceAlloydbReplicationMethodStandardXminMethod {
	return SourceAlloydbReplicationMethodStandardXminMethodXmin
}

type SourceAlloydbReplicationMethodType string

const (
	SourceAlloydbReplicationMethodTypeSourceAlloydbReplicationMethodStandardXmin          SourceAlloydbReplicationMethodType = "source-alloydb_Replication Method_Standard (Xmin)"
	SourceAlloydbReplicationMethodTypeSourceAlloydbReplicationMethodLogicalReplicationCDC SourceAlloydbReplicationMethodType = "source-alloydb_Replication Method_Logical Replication (CDC)"
	SourceAlloydbReplicationMethodTypeSourceAlloydbReplicationMethodStandard              SourceAlloydbReplicationMethodType = "source-alloydb_Replication Method_Standard"
)

type SourceAlloydbReplicationMethod struct {
	SourceAlloydbReplicationMethodStandardXmin          *SourceAlloydbReplicationMethodStandardXmin
	SourceAlloydbReplicationMethodLogicalReplicationCDC *SourceAlloydbReplicationMethodLogicalReplicationCDC
	SourceAlloydbReplicationMethodStandard              *SourceAlloydbReplicationMethodStandard

	Type SourceAlloydbReplicationMethodType
}

func CreateSourceAlloydbReplicationMethodSourceAlloydbReplicationMethodStandardXmin(sourceAlloydbReplicationMethodStandardXmin SourceAlloydbReplicationMethodStandardXmin) SourceAlloydbReplicationMethod {
	typ := SourceAlloydbReplicationMethodTypeSourceAlloydbReplicationMethodStandardXmin

	return SourceAlloydbReplicationMethod{
		SourceAlloydbReplicationMethodStandardXmin: &sourceAlloydbReplicationMethodStandardXmin,
		Type: typ,
	}
}

func CreateSourceAlloydbReplicationMethodSourceAlloydbReplicationMethodLogicalReplicationCDC(sourceAlloydbReplicationMethodLogicalReplicationCDC SourceAlloydbReplicationMethodLogicalReplicationCDC) SourceAlloydbReplicationMethod {
	typ := SourceAlloydbReplicationMethodTypeSourceAlloydbReplicationMethodLogicalReplicationCDC

	return SourceAlloydbReplicationMethod{
		SourceAlloydbReplicationMethodLogicalReplicationCDC: &sourceAlloydbReplicationMethodLogicalReplicationCDC,
		Type: typ,
	}
}

func CreateSourceAlloydbReplicationMethodSourceAlloydbReplicationMethodStandard(sourceAlloydbReplicationMethodStandard SourceAlloydbReplicationMethodStandard) SourceAlloydbReplicationMethod {
	typ := SourceAlloydbReplicationMethodTypeSourceAlloydbReplicationMethodStandard

	return SourceAlloydbReplicationMethod{
		SourceAlloydbReplicationMethodStandard: &sourceAlloydbReplicationMethodStandard,
		Type:                                   typ,
	}
}

func (u *SourceAlloydbReplicationMethod) UnmarshalJSON(data []byte) error {

	sourceAlloydbReplicationMethodStandardXmin := new(SourceAlloydbReplicationMethodStandardXmin)
	if err := utils.UnmarshalJSON(data, &sourceAlloydbReplicationMethodStandardXmin, "", true, true); err == nil {
		u.SourceAlloydbReplicationMethodStandardXmin = sourceAlloydbReplicationMethodStandardXmin
		u.Type = SourceAlloydbReplicationMethodTypeSourceAlloydbReplicationMethodStandardXmin
		return nil
	}

	sourceAlloydbReplicationMethodStandard := new(SourceAlloydbReplicationMethodStandard)
	if err := utils.UnmarshalJSON(data, &sourceAlloydbReplicationMethodStandard, "", true, true); err == nil {
		u.SourceAlloydbReplicationMethodStandard = sourceAlloydbReplicationMethodStandard
		u.Type = SourceAlloydbReplicationMethodTypeSourceAlloydbReplicationMethodStandard
		return nil
	}

	sourceAlloydbReplicationMethodLogicalReplicationCDC := new(SourceAlloydbReplicationMethodLogicalReplicationCDC)
	if err := utils.UnmarshalJSON(data, &sourceAlloydbReplicationMethodLogicalReplicationCDC, "", true, true); err == nil {
		u.SourceAlloydbReplicationMethodLogicalReplicationCDC = sourceAlloydbReplicationMethodLogicalReplicationCDC
		u.Type = SourceAlloydbReplicationMethodTypeSourceAlloydbReplicationMethodLogicalReplicationCDC
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SourceAlloydbReplicationMethod) MarshalJSON() ([]byte, error) {
	if u.SourceAlloydbReplicationMethodStandardXmin != nil {
		return utils.MarshalJSON(u.SourceAlloydbReplicationMethodStandardXmin, "", true)
	}

	if u.SourceAlloydbReplicationMethodLogicalReplicationCDC != nil {
		return utils.MarshalJSON(u.SourceAlloydbReplicationMethodLogicalReplicationCDC, "", true)
	}

	if u.SourceAlloydbReplicationMethodStandard != nil {
		return utils.MarshalJSON(u.SourceAlloydbReplicationMethodStandard, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type SourceAlloydbAlloydb string

const (
	SourceAlloydbAlloydbAlloydb SourceAlloydbAlloydb = "alloydb"
)

func (e SourceAlloydbAlloydb) ToPointer() *SourceAlloydbAlloydb {
	return &e
}

func (e *SourceAlloydbAlloydb) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "alloydb":
		*e = SourceAlloydbAlloydb(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceAlloydbAlloydb: %v", v)
	}
}

type SourceAlloydbSSLModesVerifyFullMode string

const (
	SourceAlloydbSSLModesVerifyFullModeVerifyFull SourceAlloydbSSLModesVerifyFullMode = "verify-full"
)

func (e SourceAlloydbSSLModesVerifyFullMode) ToPointer() *SourceAlloydbSSLModesVerifyFullMode {
	return &e
}

func (e *SourceAlloydbSSLModesVerifyFullMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "verify-full":
		*e = SourceAlloydbSSLModesVerifyFullMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceAlloydbSSLModesVerifyFullMode: %v", v)
	}
}

// SourceAlloydbSSLModesVerifyFull - This is the most secure mode. Always require encryption and verifies the identity of the source database server.
type SourceAlloydbSSLModesVerifyFull struct {
	AdditionalProperties interface{} `additionalProperties:"true" json:"-"`
	// CA certificate
	CaCertificate string `json:"ca_certificate"`
	// Client certificate
	ClientCertificate *string `json:"client_certificate,omitempty"`
	// Client key
	ClientKey *string `json:"client_key,omitempty"`
	// Password for keystorage. If you do not add it - the password will be generated automatically.
	ClientKeyPassword *string                             `json:"client_key_password,omitempty"`
	mode              SourceAlloydbSSLModesVerifyFullMode `const:"verify-full" json:"mode"`
}

func (s SourceAlloydbSSLModesVerifyFull) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceAlloydbSSLModesVerifyFull) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceAlloydbSSLModesVerifyFull) GetAdditionalProperties() interface{} {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *SourceAlloydbSSLModesVerifyFull) GetCaCertificate() string {
	if o == nil {
		return ""
	}
	return o.CaCertificate
}

func (o *SourceAlloydbSSLModesVerifyFull) GetClientCertificate() *string {
	if o == nil {
		return nil
	}
	return o.ClientCertificate
}

func (o *SourceAlloydbSSLModesVerifyFull) GetClientKey() *string {
	if o == nil {
		return nil
	}
	return o.ClientKey
}

func (o *SourceAlloydbSSLModesVerifyFull) GetClientKeyPassword() *string {
	if o == nil {
		return nil
	}
	return o.ClientKeyPassword
}

func (o *SourceAlloydbSSLModesVerifyFull) GetMode() SourceAlloydbSSLModesVerifyFullMode {
	return SourceAlloydbSSLModesVerifyFullModeVerifyFull
}

type SourceAlloydbSSLModesVerifyCaMode string

const (
	SourceAlloydbSSLModesVerifyCaModeVerifyCa SourceAlloydbSSLModesVerifyCaMode = "verify-ca"
)

func (e SourceAlloydbSSLModesVerifyCaMode) ToPointer() *SourceAlloydbSSLModesVerifyCaMode {
	return &e
}

func (e *SourceAlloydbSSLModesVerifyCaMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "verify-ca":
		*e = SourceAlloydbSSLModesVerifyCaMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceAlloydbSSLModesVerifyCaMode: %v", v)
	}
}

// SourceAlloydbSSLModesVerifyCa - Always require encryption and verifies that the source database server has a valid SSL certificate.
type SourceAlloydbSSLModesVerifyCa struct {
	AdditionalProperties interface{} `additionalProperties:"true" json:"-"`
	// CA certificate
	CaCertificate string `json:"ca_certificate"`
	// Client certificate
	ClientCertificate *string `json:"client_certificate,omitempty"`
	// Client key
	ClientKey *string `json:"client_key,omitempty"`
	// Password for keystorage. If you do not add it - the password will be generated automatically.
	ClientKeyPassword *string                           `json:"client_key_password,omitempty"`
	mode              SourceAlloydbSSLModesVerifyCaMode `const:"verify-ca" json:"mode"`
}

func (s SourceAlloydbSSLModesVerifyCa) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceAlloydbSSLModesVerifyCa) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceAlloydbSSLModesVerifyCa) GetAdditionalProperties() interface{} {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *SourceAlloydbSSLModesVerifyCa) GetCaCertificate() string {
	if o == nil {
		return ""
	}
	return o.CaCertificate
}

func (o *SourceAlloydbSSLModesVerifyCa) GetClientCertificate() *string {
	if o == nil {
		return nil
	}
	return o.ClientCertificate
}

func (o *SourceAlloydbSSLModesVerifyCa) GetClientKey() *string {
	if o == nil {
		return nil
	}
	return o.ClientKey
}

func (o *SourceAlloydbSSLModesVerifyCa) GetClientKeyPassword() *string {
	if o == nil {
		return nil
	}
	return o.ClientKeyPassword
}

func (o *SourceAlloydbSSLModesVerifyCa) GetMode() SourceAlloydbSSLModesVerifyCaMode {
	return SourceAlloydbSSLModesVerifyCaModeVerifyCa
}

type SourceAlloydbSSLModesRequireMode string

const (
	SourceAlloydbSSLModesRequireModeRequire SourceAlloydbSSLModesRequireMode = "require"
)

func (e SourceAlloydbSSLModesRequireMode) ToPointer() *SourceAlloydbSSLModesRequireMode {
	return &e
}

func (e *SourceAlloydbSSLModesRequireMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "require":
		*e = SourceAlloydbSSLModesRequireMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceAlloydbSSLModesRequireMode: %v", v)
	}
}

// SourceAlloydbSSLModesRequire - Always require encryption. If the source database server does not support encryption, connection will fail.
type SourceAlloydbSSLModesRequire struct {
	AdditionalProperties interface{}                      `additionalProperties:"true" json:"-"`
	mode                 SourceAlloydbSSLModesRequireMode `const:"require" json:"mode"`
}

func (s SourceAlloydbSSLModesRequire) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceAlloydbSSLModesRequire) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceAlloydbSSLModesRequire) GetAdditionalProperties() interface{} {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *SourceAlloydbSSLModesRequire) GetMode() SourceAlloydbSSLModesRequireMode {
	return SourceAlloydbSSLModesRequireModeRequire
}

type SourceAlloydbSSLModesPreferMode string

const (
	SourceAlloydbSSLModesPreferModePrefer SourceAlloydbSSLModesPreferMode = "prefer"
)

func (e SourceAlloydbSSLModesPreferMode) ToPointer() *SourceAlloydbSSLModesPreferMode {
	return &e
}

func (e *SourceAlloydbSSLModesPreferMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "prefer":
		*e = SourceAlloydbSSLModesPreferMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceAlloydbSSLModesPreferMode: %v", v)
	}
}

// SourceAlloydbSSLModesPrefer - Allows unencrypted connection only if the source database does not support encryption.
type SourceAlloydbSSLModesPrefer struct {
	AdditionalProperties interface{}                     `additionalProperties:"true" json:"-"`
	mode                 SourceAlloydbSSLModesPreferMode `const:"prefer" json:"mode"`
}

func (s SourceAlloydbSSLModesPrefer) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceAlloydbSSLModesPrefer) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceAlloydbSSLModesPrefer) GetAdditionalProperties() interface{} {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *SourceAlloydbSSLModesPrefer) GetMode() SourceAlloydbSSLModesPreferMode {
	return SourceAlloydbSSLModesPreferModePrefer
}

type SourceAlloydbSSLModesAllowMode string

const (
	SourceAlloydbSSLModesAllowModeAllow SourceAlloydbSSLModesAllowMode = "allow"
)

func (e SourceAlloydbSSLModesAllowMode) ToPointer() *SourceAlloydbSSLModesAllowMode {
	return &e
}

func (e *SourceAlloydbSSLModesAllowMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "allow":
		*e = SourceAlloydbSSLModesAllowMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceAlloydbSSLModesAllowMode: %v", v)
	}
}

// SourceAlloydbSSLModesAllow - Enables encryption only when required by the source database.
type SourceAlloydbSSLModesAllow struct {
	AdditionalProperties interface{}                    `additionalProperties:"true" json:"-"`
	mode                 SourceAlloydbSSLModesAllowMode `const:"allow" json:"mode"`
}

func (s SourceAlloydbSSLModesAllow) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceAlloydbSSLModesAllow) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceAlloydbSSLModesAllow) GetAdditionalProperties() interface{} {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *SourceAlloydbSSLModesAllow) GetMode() SourceAlloydbSSLModesAllowMode {
	return SourceAlloydbSSLModesAllowModeAllow
}

type SourceAlloydbSSLModesDisableMode string

const (
	SourceAlloydbSSLModesDisableModeDisable SourceAlloydbSSLModesDisableMode = "disable"
)

func (e SourceAlloydbSSLModesDisableMode) ToPointer() *SourceAlloydbSSLModesDisableMode {
	return &e
}

func (e *SourceAlloydbSSLModesDisableMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "disable":
		*e = SourceAlloydbSSLModesDisableMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceAlloydbSSLModesDisableMode: %v", v)
	}
}

// SourceAlloydbSSLModesDisable - Disables encryption of communication between Airbyte and source database.
type SourceAlloydbSSLModesDisable struct {
	AdditionalProperties interface{}                      `additionalProperties:"true" json:"-"`
	mode                 SourceAlloydbSSLModesDisableMode `const:"disable" json:"mode"`
}

func (s SourceAlloydbSSLModesDisable) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceAlloydbSSLModesDisable) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceAlloydbSSLModesDisable) GetAdditionalProperties() interface{} {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *SourceAlloydbSSLModesDisable) GetMode() SourceAlloydbSSLModesDisableMode {
	return SourceAlloydbSSLModesDisableModeDisable
}

type SourceAlloydbSSLModesType string

const (
	SourceAlloydbSSLModesTypeSourceAlloydbSSLModesDisable    SourceAlloydbSSLModesType = "source-alloydb_SSL Modes_disable"
	SourceAlloydbSSLModesTypeSourceAlloydbSSLModesAllow      SourceAlloydbSSLModesType = "source-alloydb_SSL Modes_allow"
	SourceAlloydbSSLModesTypeSourceAlloydbSSLModesPrefer     SourceAlloydbSSLModesType = "source-alloydb_SSL Modes_prefer"
	SourceAlloydbSSLModesTypeSourceAlloydbSSLModesRequire    SourceAlloydbSSLModesType = "source-alloydb_SSL Modes_require"
	SourceAlloydbSSLModesTypeSourceAlloydbSSLModesVerifyCa   SourceAlloydbSSLModesType = "source-alloydb_SSL Modes_verify-ca"
	SourceAlloydbSSLModesTypeSourceAlloydbSSLModesVerifyFull SourceAlloydbSSLModesType = "source-alloydb_SSL Modes_verify-full"
)

type SourceAlloydbSSLModes struct {
	SourceAlloydbSSLModesDisable    *SourceAlloydbSSLModesDisable
	SourceAlloydbSSLModesAllow      *SourceAlloydbSSLModesAllow
	SourceAlloydbSSLModesPrefer     *SourceAlloydbSSLModesPrefer
	SourceAlloydbSSLModesRequire    *SourceAlloydbSSLModesRequire
	SourceAlloydbSSLModesVerifyCa   *SourceAlloydbSSLModesVerifyCa
	SourceAlloydbSSLModesVerifyFull *SourceAlloydbSSLModesVerifyFull

	Type SourceAlloydbSSLModesType
}

func CreateSourceAlloydbSSLModesSourceAlloydbSSLModesDisable(sourceAlloydbSSLModesDisable SourceAlloydbSSLModesDisable) SourceAlloydbSSLModes {
	typ := SourceAlloydbSSLModesTypeSourceAlloydbSSLModesDisable

	return SourceAlloydbSSLModes{
		SourceAlloydbSSLModesDisable: &sourceAlloydbSSLModesDisable,
		Type:                         typ,
	}
}

func CreateSourceAlloydbSSLModesSourceAlloydbSSLModesAllow(sourceAlloydbSSLModesAllow SourceAlloydbSSLModesAllow) SourceAlloydbSSLModes {
	typ := SourceAlloydbSSLModesTypeSourceAlloydbSSLModesAllow

	return SourceAlloydbSSLModes{
		SourceAlloydbSSLModesAllow: &sourceAlloydbSSLModesAllow,
		Type:                       typ,
	}
}

func CreateSourceAlloydbSSLModesSourceAlloydbSSLModesPrefer(sourceAlloydbSSLModesPrefer SourceAlloydbSSLModesPrefer) SourceAlloydbSSLModes {
	typ := SourceAlloydbSSLModesTypeSourceAlloydbSSLModesPrefer

	return SourceAlloydbSSLModes{
		SourceAlloydbSSLModesPrefer: &sourceAlloydbSSLModesPrefer,
		Type:                        typ,
	}
}

func CreateSourceAlloydbSSLModesSourceAlloydbSSLModesRequire(sourceAlloydbSSLModesRequire SourceAlloydbSSLModesRequire) SourceAlloydbSSLModes {
	typ := SourceAlloydbSSLModesTypeSourceAlloydbSSLModesRequire

	return SourceAlloydbSSLModes{
		SourceAlloydbSSLModesRequire: &sourceAlloydbSSLModesRequire,
		Type:                         typ,
	}
}

func CreateSourceAlloydbSSLModesSourceAlloydbSSLModesVerifyCa(sourceAlloydbSSLModesVerifyCa SourceAlloydbSSLModesVerifyCa) SourceAlloydbSSLModes {
	typ := SourceAlloydbSSLModesTypeSourceAlloydbSSLModesVerifyCa

	return SourceAlloydbSSLModes{
		SourceAlloydbSSLModesVerifyCa: &sourceAlloydbSSLModesVerifyCa,
		Type:                          typ,
	}
}

func CreateSourceAlloydbSSLModesSourceAlloydbSSLModesVerifyFull(sourceAlloydbSSLModesVerifyFull SourceAlloydbSSLModesVerifyFull) SourceAlloydbSSLModes {
	typ := SourceAlloydbSSLModesTypeSourceAlloydbSSLModesVerifyFull

	return SourceAlloydbSSLModes{
		SourceAlloydbSSLModesVerifyFull: &sourceAlloydbSSLModesVerifyFull,
		Type:                            typ,
	}
}

func (u *SourceAlloydbSSLModes) UnmarshalJSON(data []byte) error {

	sourceAlloydbSSLModesDisable := new(SourceAlloydbSSLModesDisable)
	if err := utils.UnmarshalJSON(data, &sourceAlloydbSSLModesDisable, "", true, true); err == nil {
		u.SourceAlloydbSSLModesDisable = sourceAlloydbSSLModesDisable
		u.Type = SourceAlloydbSSLModesTypeSourceAlloydbSSLModesDisable
		return nil
	}

	sourceAlloydbSSLModesAllow := new(SourceAlloydbSSLModesAllow)
	if err := utils.UnmarshalJSON(data, &sourceAlloydbSSLModesAllow, "", true, true); err == nil {
		u.SourceAlloydbSSLModesAllow = sourceAlloydbSSLModesAllow
		u.Type = SourceAlloydbSSLModesTypeSourceAlloydbSSLModesAllow
		return nil
	}

	sourceAlloydbSSLModesPrefer := new(SourceAlloydbSSLModesPrefer)
	if err := utils.UnmarshalJSON(data, &sourceAlloydbSSLModesPrefer, "", true, true); err == nil {
		u.SourceAlloydbSSLModesPrefer = sourceAlloydbSSLModesPrefer
		u.Type = SourceAlloydbSSLModesTypeSourceAlloydbSSLModesPrefer
		return nil
	}

	sourceAlloydbSSLModesRequire := new(SourceAlloydbSSLModesRequire)
	if err := utils.UnmarshalJSON(data, &sourceAlloydbSSLModesRequire, "", true, true); err == nil {
		u.SourceAlloydbSSLModesRequire = sourceAlloydbSSLModesRequire
		u.Type = SourceAlloydbSSLModesTypeSourceAlloydbSSLModesRequire
		return nil
	}

	sourceAlloydbSSLModesVerifyCa := new(SourceAlloydbSSLModesVerifyCa)
	if err := utils.UnmarshalJSON(data, &sourceAlloydbSSLModesVerifyCa, "", true, true); err == nil {
		u.SourceAlloydbSSLModesVerifyCa = sourceAlloydbSSLModesVerifyCa
		u.Type = SourceAlloydbSSLModesTypeSourceAlloydbSSLModesVerifyCa
		return nil
	}

	sourceAlloydbSSLModesVerifyFull := new(SourceAlloydbSSLModesVerifyFull)
	if err := utils.UnmarshalJSON(data, &sourceAlloydbSSLModesVerifyFull, "", true, true); err == nil {
		u.SourceAlloydbSSLModesVerifyFull = sourceAlloydbSSLModesVerifyFull
		u.Type = SourceAlloydbSSLModesTypeSourceAlloydbSSLModesVerifyFull
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SourceAlloydbSSLModes) MarshalJSON() ([]byte, error) {
	if u.SourceAlloydbSSLModesDisable != nil {
		return utils.MarshalJSON(u.SourceAlloydbSSLModesDisable, "", true)
	}

	if u.SourceAlloydbSSLModesAllow != nil {
		return utils.MarshalJSON(u.SourceAlloydbSSLModesAllow, "", true)
	}

	if u.SourceAlloydbSSLModesPrefer != nil {
		return utils.MarshalJSON(u.SourceAlloydbSSLModesPrefer, "", true)
	}

	if u.SourceAlloydbSSLModesRequire != nil {
		return utils.MarshalJSON(u.SourceAlloydbSSLModesRequire, "", true)
	}

	if u.SourceAlloydbSSLModesVerifyCa != nil {
		return utils.MarshalJSON(u.SourceAlloydbSSLModesVerifyCa, "", true)
	}

	if u.SourceAlloydbSSLModesVerifyFull != nil {
		return utils.MarshalJSON(u.SourceAlloydbSSLModesVerifyFull, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

// SourceAlloydbSSHTunnelMethodPasswordAuthenticationTunnelMethod - Connect through a jump server tunnel host using username and password authentication
type SourceAlloydbSSHTunnelMethodPasswordAuthenticationTunnelMethod string

const (
	SourceAlloydbSSHTunnelMethodPasswordAuthenticationTunnelMethodSSHPasswordAuth SourceAlloydbSSHTunnelMethodPasswordAuthenticationTunnelMethod = "SSH_PASSWORD_AUTH"
)

func (e SourceAlloydbSSHTunnelMethodPasswordAuthenticationTunnelMethod) ToPointer() *SourceAlloydbSSHTunnelMethodPasswordAuthenticationTunnelMethod {
	return &e
}

func (e *SourceAlloydbSSHTunnelMethodPasswordAuthenticationTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_PASSWORD_AUTH":
		*e = SourceAlloydbSSHTunnelMethodPasswordAuthenticationTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceAlloydbSSHTunnelMethodPasswordAuthenticationTunnelMethod: %v", v)
	}
}

// SourceAlloydbSSHTunnelMethodPasswordAuthentication - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceAlloydbSSHTunnelMethodPasswordAuthentication struct {
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and password authentication
	tunnelMethod SourceAlloydbSSHTunnelMethodPasswordAuthenticationTunnelMethod `const:"SSH_PASSWORD_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser string `json:"tunnel_user"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword string `json:"tunnel_user_password"`
}

func (s SourceAlloydbSSHTunnelMethodPasswordAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceAlloydbSSHTunnelMethodPasswordAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceAlloydbSSHTunnelMethodPasswordAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *SourceAlloydbSSHTunnelMethodPasswordAuthentication) GetTunnelMethod() SourceAlloydbSSHTunnelMethodPasswordAuthenticationTunnelMethod {
	return SourceAlloydbSSHTunnelMethodPasswordAuthenticationTunnelMethodSSHPasswordAuth
}

func (o *SourceAlloydbSSHTunnelMethodPasswordAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *SourceAlloydbSSHTunnelMethodPasswordAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

func (o *SourceAlloydbSSHTunnelMethodPasswordAuthentication) GetTunnelUserPassword() string {
	if o == nil {
		return ""
	}
	return o.TunnelUserPassword
}

// SourceAlloydbSSHTunnelMethodSSHKeyAuthenticationTunnelMethod - Connect through a jump server tunnel host using username and ssh key
type SourceAlloydbSSHTunnelMethodSSHKeyAuthenticationTunnelMethod string

const (
	SourceAlloydbSSHTunnelMethodSSHKeyAuthenticationTunnelMethodSSHKeyAuth SourceAlloydbSSHTunnelMethodSSHKeyAuthenticationTunnelMethod = "SSH_KEY_AUTH"
)

func (e SourceAlloydbSSHTunnelMethodSSHKeyAuthenticationTunnelMethod) ToPointer() *SourceAlloydbSSHTunnelMethodSSHKeyAuthenticationTunnelMethod {
	return &e
}

func (e *SourceAlloydbSSHTunnelMethodSSHKeyAuthenticationTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_KEY_AUTH":
		*e = SourceAlloydbSSHTunnelMethodSSHKeyAuthenticationTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceAlloydbSSHTunnelMethodSSHKeyAuthenticationTunnelMethod: %v", v)
	}
}

// SourceAlloydbSSHTunnelMethodSSHKeyAuthentication - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceAlloydbSSHTunnelMethodSSHKeyAuthentication struct {
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey string `json:"ssh_key"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and ssh key
	tunnelMethod SourceAlloydbSSHTunnelMethodSSHKeyAuthenticationTunnelMethod `const:"SSH_KEY_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host.
	TunnelUser string `json:"tunnel_user"`
}

func (s SourceAlloydbSSHTunnelMethodSSHKeyAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceAlloydbSSHTunnelMethodSSHKeyAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceAlloydbSSHTunnelMethodSSHKeyAuthentication) GetSSHKey() string {
	if o == nil {
		return ""
	}
	return o.SSHKey
}

func (o *SourceAlloydbSSHTunnelMethodSSHKeyAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *SourceAlloydbSSHTunnelMethodSSHKeyAuthentication) GetTunnelMethod() SourceAlloydbSSHTunnelMethodSSHKeyAuthenticationTunnelMethod {
	return SourceAlloydbSSHTunnelMethodSSHKeyAuthenticationTunnelMethodSSHKeyAuth
}

func (o *SourceAlloydbSSHTunnelMethodSSHKeyAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *SourceAlloydbSSHTunnelMethodSSHKeyAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

// SourceAlloydbSSHTunnelMethodNoTunnelTunnelMethod - No ssh tunnel needed to connect to database
type SourceAlloydbSSHTunnelMethodNoTunnelTunnelMethod string

const (
	SourceAlloydbSSHTunnelMethodNoTunnelTunnelMethodNoTunnel SourceAlloydbSSHTunnelMethodNoTunnelTunnelMethod = "NO_TUNNEL"
)

func (e SourceAlloydbSSHTunnelMethodNoTunnelTunnelMethod) ToPointer() *SourceAlloydbSSHTunnelMethodNoTunnelTunnelMethod {
	return &e
}

func (e *SourceAlloydbSSHTunnelMethodNoTunnelTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NO_TUNNEL":
		*e = SourceAlloydbSSHTunnelMethodNoTunnelTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceAlloydbSSHTunnelMethodNoTunnelTunnelMethod: %v", v)
	}
}

// SourceAlloydbSSHTunnelMethodNoTunnel - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceAlloydbSSHTunnelMethodNoTunnel struct {
	// No ssh tunnel needed to connect to database
	tunnelMethod SourceAlloydbSSHTunnelMethodNoTunnelTunnelMethod `const:"NO_TUNNEL" json:"tunnel_method"`
}

func (s SourceAlloydbSSHTunnelMethodNoTunnel) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceAlloydbSSHTunnelMethodNoTunnel) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceAlloydbSSHTunnelMethodNoTunnel) GetTunnelMethod() SourceAlloydbSSHTunnelMethodNoTunnelTunnelMethod {
	return SourceAlloydbSSHTunnelMethodNoTunnelTunnelMethodNoTunnel
}

type SourceAlloydbSSHTunnelMethodType string

const (
	SourceAlloydbSSHTunnelMethodTypeSourceAlloydbSSHTunnelMethodNoTunnel               SourceAlloydbSSHTunnelMethodType = "source-alloydb_SSH Tunnel Method_No Tunnel"
	SourceAlloydbSSHTunnelMethodTypeSourceAlloydbSSHTunnelMethodSSHKeyAuthentication   SourceAlloydbSSHTunnelMethodType = "source-alloydb_SSH Tunnel Method_SSH Key Authentication"
	SourceAlloydbSSHTunnelMethodTypeSourceAlloydbSSHTunnelMethodPasswordAuthentication SourceAlloydbSSHTunnelMethodType = "source-alloydb_SSH Tunnel Method_Password Authentication"
)

type SourceAlloydbSSHTunnelMethod struct {
	SourceAlloydbSSHTunnelMethodNoTunnel               *SourceAlloydbSSHTunnelMethodNoTunnel
	SourceAlloydbSSHTunnelMethodSSHKeyAuthentication   *SourceAlloydbSSHTunnelMethodSSHKeyAuthentication
	SourceAlloydbSSHTunnelMethodPasswordAuthentication *SourceAlloydbSSHTunnelMethodPasswordAuthentication

	Type SourceAlloydbSSHTunnelMethodType
}

func CreateSourceAlloydbSSHTunnelMethodSourceAlloydbSSHTunnelMethodNoTunnel(sourceAlloydbSSHTunnelMethodNoTunnel SourceAlloydbSSHTunnelMethodNoTunnel) SourceAlloydbSSHTunnelMethod {
	typ := SourceAlloydbSSHTunnelMethodTypeSourceAlloydbSSHTunnelMethodNoTunnel

	return SourceAlloydbSSHTunnelMethod{
		SourceAlloydbSSHTunnelMethodNoTunnel: &sourceAlloydbSSHTunnelMethodNoTunnel,
		Type:                                 typ,
	}
}

func CreateSourceAlloydbSSHTunnelMethodSourceAlloydbSSHTunnelMethodSSHKeyAuthentication(sourceAlloydbSSHTunnelMethodSSHKeyAuthentication SourceAlloydbSSHTunnelMethodSSHKeyAuthentication) SourceAlloydbSSHTunnelMethod {
	typ := SourceAlloydbSSHTunnelMethodTypeSourceAlloydbSSHTunnelMethodSSHKeyAuthentication

	return SourceAlloydbSSHTunnelMethod{
		SourceAlloydbSSHTunnelMethodSSHKeyAuthentication: &sourceAlloydbSSHTunnelMethodSSHKeyAuthentication,
		Type: typ,
	}
}

func CreateSourceAlloydbSSHTunnelMethodSourceAlloydbSSHTunnelMethodPasswordAuthentication(sourceAlloydbSSHTunnelMethodPasswordAuthentication SourceAlloydbSSHTunnelMethodPasswordAuthentication) SourceAlloydbSSHTunnelMethod {
	typ := SourceAlloydbSSHTunnelMethodTypeSourceAlloydbSSHTunnelMethodPasswordAuthentication

	return SourceAlloydbSSHTunnelMethod{
		SourceAlloydbSSHTunnelMethodPasswordAuthentication: &sourceAlloydbSSHTunnelMethodPasswordAuthentication,
		Type: typ,
	}
}

func (u *SourceAlloydbSSHTunnelMethod) UnmarshalJSON(data []byte) error {

	sourceAlloydbSSHTunnelMethodNoTunnel := new(SourceAlloydbSSHTunnelMethodNoTunnel)
	if err := utils.UnmarshalJSON(data, &sourceAlloydbSSHTunnelMethodNoTunnel, "", true, true); err == nil {
		u.SourceAlloydbSSHTunnelMethodNoTunnel = sourceAlloydbSSHTunnelMethodNoTunnel
		u.Type = SourceAlloydbSSHTunnelMethodTypeSourceAlloydbSSHTunnelMethodNoTunnel
		return nil
	}

	sourceAlloydbSSHTunnelMethodSSHKeyAuthentication := new(SourceAlloydbSSHTunnelMethodSSHKeyAuthentication)
	if err := utils.UnmarshalJSON(data, &sourceAlloydbSSHTunnelMethodSSHKeyAuthentication, "", true, true); err == nil {
		u.SourceAlloydbSSHTunnelMethodSSHKeyAuthentication = sourceAlloydbSSHTunnelMethodSSHKeyAuthentication
		u.Type = SourceAlloydbSSHTunnelMethodTypeSourceAlloydbSSHTunnelMethodSSHKeyAuthentication
		return nil
	}

	sourceAlloydbSSHTunnelMethodPasswordAuthentication := new(SourceAlloydbSSHTunnelMethodPasswordAuthentication)
	if err := utils.UnmarshalJSON(data, &sourceAlloydbSSHTunnelMethodPasswordAuthentication, "", true, true); err == nil {
		u.SourceAlloydbSSHTunnelMethodPasswordAuthentication = sourceAlloydbSSHTunnelMethodPasswordAuthentication
		u.Type = SourceAlloydbSSHTunnelMethodTypeSourceAlloydbSSHTunnelMethodPasswordAuthentication
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SourceAlloydbSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.SourceAlloydbSSHTunnelMethodNoTunnel != nil {
		return utils.MarshalJSON(u.SourceAlloydbSSHTunnelMethodNoTunnel, "", true)
	}

	if u.SourceAlloydbSSHTunnelMethodSSHKeyAuthentication != nil {
		return utils.MarshalJSON(u.SourceAlloydbSSHTunnelMethodSSHKeyAuthentication, "", true)
	}

	if u.SourceAlloydbSSHTunnelMethodPasswordAuthentication != nil {
		return utils.MarshalJSON(u.SourceAlloydbSSHTunnelMethodPasswordAuthentication, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type SourceAlloydb struct {
	// Name of the database.
	Database string `json:"database"`
	// Hostname of the database.
	Host string `json:"host"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (Eg. key1=value1&key2=value2&key3=value3). For more information read about <a href="https://jdbc.postgresql.org/documentation/head/connect.html">JDBC URL parameters</a>.
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// Password associated with the username.
	Password *string `json:"password,omitempty"`
	// Port of the database.
	Port *int64 `default:"5432" json:"port"`
	// Replication method for extracting data from the database.
	ReplicationMethod *SourceAlloydbReplicationMethod `json:"replication_method,omitempty"`
	// The list of schemas (case sensitive) to sync from. Defaults to public.
	Schemas    []string             `json:"schemas,omitempty"`
	sourceType SourceAlloydbAlloydb `const:"alloydb" json:"sourceType"`
	// SSL connection modes.
	//   Read more <a href="https://jdbc.postgresql.org/documentation/head/ssl-client.html"> in the docs</a>.
	SslMode *SourceAlloydbSSLModes `json:"ssl_mode,omitempty"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod *SourceAlloydbSSHTunnelMethod `json:"tunnel_method,omitempty"`
	// Username to access the database.
	Username string `json:"username"`
}

func (s SourceAlloydb) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceAlloydb) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *SourceAlloydb) GetDatabase() string {
	if o == nil {
		return ""
	}
	return o.Database
}

func (o *SourceAlloydb) GetHost() string {
	if o == nil {
		return ""
	}
	return o.Host
}

func (o *SourceAlloydb) GetJdbcURLParams() *string {
	if o == nil {
		return nil
	}
	return o.JdbcURLParams
}

func (o *SourceAlloydb) GetPassword() *string {
	if o == nil {
		return nil
	}
	return o.Password
}

func (o *SourceAlloydb) GetPort() *int64 {
	if o == nil {
		return nil
	}
	return o.Port
}

func (o *SourceAlloydb) GetReplicationMethod() *SourceAlloydbReplicationMethod {
	if o == nil {
		return nil
	}
	return o.ReplicationMethod
}

func (o *SourceAlloydb) GetSchemas() []string {
	if o == nil {
		return nil
	}
	return o.Schemas
}

func (o *SourceAlloydb) GetSourceType() SourceAlloydbAlloydb {
	return SourceAlloydbAlloydbAlloydb
}

func (o *SourceAlloydb) GetSslMode() *SourceAlloydbSSLModes {
	if o == nil {
		return nil
	}
	return o.SslMode
}

func (o *SourceAlloydb) GetTunnelMethod() *SourceAlloydbSSHTunnelMethod {
	if o == nil {
		return nil
	}
	return o.TunnelMethod
}

func (o *SourceAlloydb) GetUsername() string {
	if o == nil {
		return ""
	}
	return o.Username
}
