// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/pkg/utils"
)

type SourceAlloydbSchemasReplicationMethodMethod string

const (
	SourceAlloydbSchemasReplicationMethodMethodStandard SourceAlloydbSchemasReplicationMethodMethod = "Standard"
)

func (e SourceAlloydbSchemasReplicationMethodMethod) ToPointer() *SourceAlloydbSchemasReplicationMethodMethod {
	return &e
}

func (e *SourceAlloydbSchemasReplicationMethodMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Standard":
		*e = SourceAlloydbSchemasReplicationMethodMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceAlloydbSchemasReplicationMethodMethod: %v", v)
	}
}

// SourceAlloydbStandard - Standard replication requires no setup on the DB side but will not be able to represent deletions incrementally.
type SourceAlloydbStandard struct {
	method SourceAlloydbSchemasReplicationMethodMethod `const:"Standard" json:"method"`
}

func (s SourceAlloydbStandard) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceAlloydbStandard) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceAlloydbStandard) GetMethod() SourceAlloydbSchemasReplicationMethodMethod {
	return SourceAlloydbSchemasReplicationMethodMethodStandard
}

// SourceAlloydbLSNCommitBehaviour - Determines when Airbtye should flush the LSN of processed WAL logs in the source database. `After loading Data in the destination` is default. If `While reading Data` is selected, in case of a downstream failure (while loading data into the destination), next sync would result in a full sync.
type SourceAlloydbLSNCommitBehaviour string

const (
	SourceAlloydbLSNCommitBehaviourWhileReadingData                 SourceAlloydbLSNCommitBehaviour = "While reading Data"
	SourceAlloydbLSNCommitBehaviourAfterLoadingDataInTheDestination SourceAlloydbLSNCommitBehaviour = "After loading Data in the destination"
)

func (e SourceAlloydbLSNCommitBehaviour) ToPointer() *SourceAlloydbLSNCommitBehaviour {
	return &e
}

func (e *SourceAlloydbLSNCommitBehaviour) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "While reading Data":
		fallthrough
	case "After loading Data in the destination":
		*e = SourceAlloydbLSNCommitBehaviour(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceAlloydbLSNCommitBehaviour: %v", v)
	}
}

type SourceAlloydbSchemasMethod string

const (
	SourceAlloydbSchemasMethodCdc SourceAlloydbSchemasMethod = "CDC"
)

func (e SourceAlloydbSchemasMethod) ToPointer() *SourceAlloydbSchemasMethod {
	return &e
}

func (e *SourceAlloydbSchemasMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CDC":
		*e = SourceAlloydbSchemasMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceAlloydbSchemasMethod: %v", v)
	}
}

// SourceAlloydbPlugin - A logical decoding plugin installed on the PostgreSQL server.
type SourceAlloydbPlugin string

const (
	SourceAlloydbPluginPgoutput SourceAlloydbPlugin = "pgoutput"
)

func (e SourceAlloydbPlugin) ToPointer() *SourceAlloydbPlugin {
	return &e
}

func (e *SourceAlloydbPlugin) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "pgoutput":
		*e = SourceAlloydbPlugin(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceAlloydbPlugin: %v", v)
	}
}

// SourceAlloydbLogicalReplicationCDC - Logical replication uses the Postgres write-ahead log (WAL) to detect inserts, updates, and deletes. This needs to be configured on the source database itself. Only available on Postgres 10 and above. Read the <a href="https://docs.airbyte.com/integrations/sources/postgres">docs</a>.
type SourceAlloydbLogicalReplicationCDC struct {
	AdditionalProperties interface{} `additionalProperties:"true" json:"-"`
	// The amount of time the connector will wait when it launches to determine if there is new data to sync or not. Defaults to 300 seconds. Valid range: 120 seconds to 1200 seconds. Read about <a href="https://docs.airbyte.com/integrations/sources/postgres#step-5-optional-set-up-initial-waiting-time">initial waiting time</a>.
	InitialWaitingSeconds *int64 `default:"300" json:"initial_waiting_seconds"`
	// Determines when Airbtye should flush the LSN of processed WAL logs in the source database. `After loading Data in the destination` is default. If `While reading Data` is selected, in case of a downstream failure (while loading data into the destination), next sync would result in a full sync.
	LsnCommitBehaviour *SourceAlloydbLSNCommitBehaviour `default:"After loading Data in the destination" json:"lsn_commit_behaviour"`
	method             SourceAlloydbSchemasMethod       `const:"CDC" json:"method"`
	// A logical decoding plugin installed on the PostgreSQL server.
	Plugin *SourceAlloydbPlugin `default:"pgoutput" json:"plugin"`
	// A Postgres publication used for consuming changes. Read about <a href="https://docs.airbyte.com/integrations/sources/postgres#step-4-create-publications-and-replication-identities-for-tables">publications and replication identities</a>.
	Publication string `json:"publication"`
	// The size of the internal queue. This may interfere with memory consumption and efficiency of the connector, please be careful.
	QueueSize *int64 `default:"10000" json:"queue_size"`
	// A plugin logical replication slot. Read about <a href="https://docs.airbyte.com/integrations/sources/postgres#step-3-create-replication-slot">replication slots</a>.
	ReplicationSlot string `json:"replication_slot"`
}

func (s SourceAlloydbLogicalReplicationCDC) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceAlloydbLogicalReplicationCDC) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceAlloydbLogicalReplicationCDC) GetAdditionalProperties() interface{} {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *SourceAlloydbLogicalReplicationCDC) GetInitialWaitingSeconds() *int64 {
	if o == nil {
		return nil
	}
	return o.InitialWaitingSeconds
}

func (o *SourceAlloydbLogicalReplicationCDC) GetLsnCommitBehaviour() *SourceAlloydbLSNCommitBehaviour {
	if o == nil {
		return nil
	}
	return o.LsnCommitBehaviour
}

func (o *SourceAlloydbLogicalReplicationCDC) GetMethod() SourceAlloydbSchemasMethod {
	return SourceAlloydbSchemasMethodCdc
}

func (o *SourceAlloydbLogicalReplicationCDC) GetPlugin() *SourceAlloydbPlugin {
	if o == nil {
		return nil
	}
	return o.Plugin
}

func (o *SourceAlloydbLogicalReplicationCDC) GetPublication() string {
	if o == nil {
		return ""
	}
	return o.Publication
}

func (o *SourceAlloydbLogicalReplicationCDC) GetQueueSize() *int64 {
	if o == nil {
		return nil
	}
	return o.QueueSize
}

func (o *SourceAlloydbLogicalReplicationCDC) GetReplicationSlot() string {
	if o == nil {
		return ""
	}
	return o.ReplicationSlot
}

type SourceAlloydbMethod string

const (
	SourceAlloydbMethodXmin SourceAlloydbMethod = "Xmin"
)

func (e SourceAlloydbMethod) ToPointer() *SourceAlloydbMethod {
	return &e
}

func (e *SourceAlloydbMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Xmin":
		*e = SourceAlloydbMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceAlloydbMethod: %v", v)
	}
}

// SourceAlloydbStandardXmin - Xmin replication requires no setup on the DB side but will not be able to represent deletions incrementally.
type SourceAlloydbStandardXmin struct {
	method SourceAlloydbMethod `const:"Xmin" json:"method"`
}

func (s SourceAlloydbStandardXmin) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceAlloydbStandardXmin) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceAlloydbStandardXmin) GetMethod() SourceAlloydbMethod {
	return SourceAlloydbMethodXmin
}

type SourceAlloydbReplicationMethodType string

const (
	SourceAlloydbReplicationMethodTypeSourceAlloydbStandardXmin          SourceAlloydbReplicationMethodType = "source-alloydb_Standard (Xmin)"
	SourceAlloydbReplicationMethodTypeSourceAlloydbLogicalReplicationCDC SourceAlloydbReplicationMethodType = "source-alloydb_Logical Replication (CDC)"
	SourceAlloydbReplicationMethodTypeSourceAlloydbStandard              SourceAlloydbReplicationMethodType = "source-alloydb_Standard"
)

type SourceAlloydbReplicationMethod struct {
	SourceAlloydbStandardXmin          *SourceAlloydbStandardXmin
	SourceAlloydbLogicalReplicationCDC *SourceAlloydbLogicalReplicationCDC
	SourceAlloydbStandard              *SourceAlloydbStandard

	Type SourceAlloydbReplicationMethodType
}

func CreateSourceAlloydbReplicationMethodSourceAlloydbStandardXmin(sourceAlloydbStandardXmin SourceAlloydbStandardXmin) SourceAlloydbReplicationMethod {
	typ := SourceAlloydbReplicationMethodTypeSourceAlloydbStandardXmin

	return SourceAlloydbReplicationMethod{
		SourceAlloydbStandardXmin: &sourceAlloydbStandardXmin,
		Type:                      typ,
	}
}

func CreateSourceAlloydbReplicationMethodSourceAlloydbLogicalReplicationCDC(sourceAlloydbLogicalReplicationCDC SourceAlloydbLogicalReplicationCDC) SourceAlloydbReplicationMethod {
	typ := SourceAlloydbReplicationMethodTypeSourceAlloydbLogicalReplicationCDC

	return SourceAlloydbReplicationMethod{
		SourceAlloydbLogicalReplicationCDC: &sourceAlloydbLogicalReplicationCDC,
		Type:                               typ,
	}
}

func CreateSourceAlloydbReplicationMethodSourceAlloydbStandard(sourceAlloydbStandard SourceAlloydbStandard) SourceAlloydbReplicationMethod {
	typ := SourceAlloydbReplicationMethodTypeSourceAlloydbStandard

	return SourceAlloydbReplicationMethod{
		SourceAlloydbStandard: &sourceAlloydbStandard,
		Type:                  typ,
	}
}

func (u *SourceAlloydbReplicationMethod) UnmarshalJSON(data []byte) error {

	sourceAlloydbStandardXmin := new(SourceAlloydbStandardXmin)
	if err := utils.UnmarshalJSON(data, &sourceAlloydbStandardXmin, "", true, true); err == nil {
		u.SourceAlloydbStandardXmin = sourceAlloydbStandardXmin
		u.Type = SourceAlloydbReplicationMethodTypeSourceAlloydbStandardXmin
		return nil
	}

	sourceAlloydbStandard := new(SourceAlloydbStandard)
	if err := utils.UnmarshalJSON(data, &sourceAlloydbStandard, "", true, true); err == nil {
		u.SourceAlloydbStandard = sourceAlloydbStandard
		u.Type = SourceAlloydbReplicationMethodTypeSourceAlloydbStandard
		return nil
	}

	sourceAlloydbLogicalReplicationCDC := new(SourceAlloydbLogicalReplicationCDC)
	if err := utils.UnmarshalJSON(data, &sourceAlloydbLogicalReplicationCDC, "", true, true); err == nil {
		u.SourceAlloydbLogicalReplicationCDC = sourceAlloydbLogicalReplicationCDC
		u.Type = SourceAlloydbReplicationMethodTypeSourceAlloydbLogicalReplicationCDC
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SourceAlloydbReplicationMethod) MarshalJSON() ([]byte, error) {
	if u.SourceAlloydbStandardXmin != nil {
		return utils.MarshalJSON(u.SourceAlloydbStandardXmin, "", true)
	}

	if u.SourceAlloydbLogicalReplicationCDC != nil {
		return utils.MarshalJSON(u.SourceAlloydbLogicalReplicationCDC, "", true)
	}

	if u.SourceAlloydbStandard != nil {
		return utils.MarshalJSON(u.SourceAlloydbStandard, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type Alloydb string

const (
	AlloydbAlloydb Alloydb = "alloydb"
)

func (e Alloydb) ToPointer() *Alloydb {
	return &e
}

func (e *Alloydb) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "alloydb":
		*e = Alloydb(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Alloydb: %v", v)
	}
}

type SourceAlloydbSchemasSSLModeSSLModes6Mode string

const (
	SourceAlloydbSchemasSSLModeSSLModes6ModeVerifyFull SourceAlloydbSchemasSSLModeSSLModes6Mode = "verify-full"
)

func (e SourceAlloydbSchemasSSLModeSSLModes6Mode) ToPointer() *SourceAlloydbSchemasSSLModeSSLModes6Mode {
	return &e
}

func (e *SourceAlloydbSchemasSSLModeSSLModes6Mode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "verify-full":
		*e = SourceAlloydbSchemasSSLModeSSLModes6Mode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceAlloydbSchemasSSLModeSSLModes6Mode: %v", v)
	}
}

// SourceAlloydbVerifyFull - This is the most secure mode. Always require encryption and verifies the identity of the source database server.
type SourceAlloydbVerifyFull struct {
	AdditionalProperties interface{} `additionalProperties:"true" json:"-"`
	// CA certificate
	CaCertificate string `json:"ca_certificate"`
	// Client certificate
	ClientCertificate *string `json:"client_certificate,omitempty"`
	// Client key
	ClientKey *string `json:"client_key,omitempty"`
	// Password for keystorage. If you do not add it - the password will be generated automatically.
	ClientKeyPassword *string                                  `json:"client_key_password,omitempty"`
	mode              SourceAlloydbSchemasSSLModeSSLModes6Mode `const:"verify-full" json:"mode"`
}

func (s SourceAlloydbVerifyFull) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceAlloydbVerifyFull) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceAlloydbVerifyFull) GetAdditionalProperties() interface{} {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *SourceAlloydbVerifyFull) GetCaCertificate() string {
	if o == nil {
		return ""
	}
	return o.CaCertificate
}

func (o *SourceAlloydbVerifyFull) GetClientCertificate() *string {
	if o == nil {
		return nil
	}
	return o.ClientCertificate
}

func (o *SourceAlloydbVerifyFull) GetClientKey() *string {
	if o == nil {
		return nil
	}
	return o.ClientKey
}

func (o *SourceAlloydbVerifyFull) GetClientKeyPassword() *string {
	if o == nil {
		return nil
	}
	return o.ClientKeyPassword
}

func (o *SourceAlloydbVerifyFull) GetMode() SourceAlloydbSchemasSSLModeSSLModes6Mode {
	return SourceAlloydbSchemasSSLModeSSLModes6ModeVerifyFull
}

type SourceAlloydbSchemasSSLModeSSLModes5Mode string

const (
	SourceAlloydbSchemasSSLModeSSLModes5ModeVerifyCa SourceAlloydbSchemasSSLModeSSLModes5Mode = "verify-ca"
)

func (e SourceAlloydbSchemasSSLModeSSLModes5Mode) ToPointer() *SourceAlloydbSchemasSSLModeSSLModes5Mode {
	return &e
}

func (e *SourceAlloydbSchemasSSLModeSSLModes5Mode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "verify-ca":
		*e = SourceAlloydbSchemasSSLModeSSLModes5Mode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceAlloydbSchemasSSLModeSSLModes5Mode: %v", v)
	}
}

// SourceAlloydbVerifyCa - Always require encryption and verifies that the source database server has a valid SSL certificate.
type SourceAlloydbVerifyCa struct {
	AdditionalProperties interface{} `additionalProperties:"true" json:"-"`
	// CA certificate
	CaCertificate string `json:"ca_certificate"`
	// Client certificate
	ClientCertificate *string `json:"client_certificate,omitempty"`
	// Client key
	ClientKey *string `json:"client_key,omitempty"`
	// Password for keystorage. If you do not add it - the password will be generated automatically.
	ClientKeyPassword *string                                  `json:"client_key_password,omitempty"`
	mode              SourceAlloydbSchemasSSLModeSSLModes5Mode `const:"verify-ca" json:"mode"`
}

func (s SourceAlloydbVerifyCa) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceAlloydbVerifyCa) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceAlloydbVerifyCa) GetAdditionalProperties() interface{} {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *SourceAlloydbVerifyCa) GetCaCertificate() string {
	if o == nil {
		return ""
	}
	return o.CaCertificate
}

func (o *SourceAlloydbVerifyCa) GetClientCertificate() *string {
	if o == nil {
		return nil
	}
	return o.ClientCertificate
}

func (o *SourceAlloydbVerifyCa) GetClientKey() *string {
	if o == nil {
		return nil
	}
	return o.ClientKey
}

func (o *SourceAlloydbVerifyCa) GetClientKeyPassword() *string {
	if o == nil {
		return nil
	}
	return o.ClientKeyPassword
}

func (o *SourceAlloydbVerifyCa) GetMode() SourceAlloydbSchemasSSLModeSSLModes5Mode {
	return SourceAlloydbSchemasSSLModeSSLModes5ModeVerifyCa
}

type SourceAlloydbSchemasSSLModeSSLModesMode string

const (
	SourceAlloydbSchemasSSLModeSSLModesModeRequire SourceAlloydbSchemasSSLModeSSLModesMode = "require"
)

func (e SourceAlloydbSchemasSSLModeSSLModesMode) ToPointer() *SourceAlloydbSchemasSSLModeSSLModesMode {
	return &e
}

func (e *SourceAlloydbSchemasSSLModeSSLModesMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "require":
		*e = SourceAlloydbSchemasSSLModeSSLModesMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceAlloydbSchemasSSLModeSSLModesMode: %v", v)
	}
}

// SourceAlloydbRequire - Always require encryption. If the source database server does not support encryption, connection will fail.
type SourceAlloydbRequire struct {
	AdditionalProperties interface{}                             `additionalProperties:"true" json:"-"`
	mode                 SourceAlloydbSchemasSSLModeSSLModesMode `const:"require" json:"mode"`
}

func (s SourceAlloydbRequire) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceAlloydbRequire) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceAlloydbRequire) GetAdditionalProperties() interface{} {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *SourceAlloydbRequire) GetMode() SourceAlloydbSchemasSSLModeSSLModesMode {
	return SourceAlloydbSchemasSSLModeSSLModesModeRequire
}

type SourceAlloydbSchemasSslModeMode string

const (
	SourceAlloydbSchemasSslModeModePrefer SourceAlloydbSchemasSslModeMode = "prefer"
)

func (e SourceAlloydbSchemasSslModeMode) ToPointer() *SourceAlloydbSchemasSslModeMode {
	return &e
}

func (e *SourceAlloydbSchemasSslModeMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "prefer":
		*e = SourceAlloydbSchemasSslModeMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceAlloydbSchemasSslModeMode: %v", v)
	}
}

// SourceAlloydbPrefer - Allows unencrypted connection only if the source database does not support encryption.
type SourceAlloydbPrefer struct {
	AdditionalProperties interface{}                     `additionalProperties:"true" json:"-"`
	mode                 SourceAlloydbSchemasSslModeMode `const:"prefer" json:"mode"`
}

func (s SourceAlloydbPrefer) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceAlloydbPrefer) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceAlloydbPrefer) GetAdditionalProperties() interface{} {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *SourceAlloydbPrefer) GetMode() SourceAlloydbSchemasSslModeMode {
	return SourceAlloydbSchemasSslModeModePrefer
}

type SourceAlloydbSchemasMode string

const (
	SourceAlloydbSchemasModeAllow SourceAlloydbSchemasMode = "allow"
)

func (e SourceAlloydbSchemasMode) ToPointer() *SourceAlloydbSchemasMode {
	return &e
}

func (e *SourceAlloydbSchemasMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "allow":
		*e = SourceAlloydbSchemasMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceAlloydbSchemasMode: %v", v)
	}
}

// SourceAlloydbAllow - Enables encryption only when required by the source database.
type SourceAlloydbAllow struct {
	AdditionalProperties interface{}              `additionalProperties:"true" json:"-"`
	mode                 SourceAlloydbSchemasMode `const:"allow" json:"mode"`
}

func (s SourceAlloydbAllow) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceAlloydbAllow) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceAlloydbAllow) GetAdditionalProperties() interface{} {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *SourceAlloydbAllow) GetMode() SourceAlloydbSchemasMode {
	return SourceAlloydbSchemasModeAllow
}

type SourceAlloydbMode string

const (
	SourceAlloydbModeDisable SourceAlloydbMode = "disable"
)

func (e SourceAlloydbMode) ToPointer() *SourceAlloydbMode {
	return &e
}

func (e *SourceAlloydbMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "disable":
		*e = SourceAlloydbMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceAlloydbMode: %v", v)
	}
}

// SourceAlloydbDisable - Disables encryption of communication between Airbyte and source database.
type SourceAlloydbDisable struct {
	AdditionalProperties interface{}       `additionalProperties:"true" json:"-"`
	mode                 SourceAlloydbMode `const:"disable" json:"mode"`
}

func (s SourceAlloydbDisable) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceAlloydbDisable) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceAlloydbDisable) GetAdditionalProperties() interface{} {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *SourceAlloydbDisable) GetMode() SourceAlloydbMode {
	return SourceAlloydbModeDisable
}

type SourceAlloydbSSLModesType string

const (
	SourceAlloydbSSLModesTypeSourceAlloydbDisable    SourceAlloydbSSLModesType = "source-alloydb_disable"
	SourceAlloydbSSLModesTypeSourceAlloydbAllow      SourceAlloydbSSLModesType = "source-alloydb_allow"
	SourceAlloydbSSLModesTypeSourceAlloydbPrefer     SourceAlloydbSSLModesType = "source-alloydb_prefer"
	SourceAlloydbSSLModesTypeSourceAlloydbRequire    SourceAlloydbSSLModesType = "source-alloydb_require"
	SourceAlloydbSSLModesTypeSourceAlloydbVerifyCa   SourceAlloydbSSLModesType = "source-alloydb_verify-ca"
	SourceAlloydbSSLModesTypeSourceAlloydbVerifyFull SourceAlloydbSSLModesType = "source-alloydb_verify-full"
)

type SourceAlloydbSSLModes struct {
	SourceAlloydbDisable    *SourceAlloydbDisable
	SourceAlloydbAllow      *SourceAlloydbAllow
	SourceAlloydbPrefer     *SourceAlloydbPrefer
	SourceAlloydbRequire    *SourceAlloydbRequire
	SourceAlloydbVerifyCa   *SourceAlloydbVerifyCa
	SourceAlloydbVerifyFull *SourceAlloydbVerifyFull

	Type SourceAlloydbSSLModesType
}

func CreateSourceAlloydbSSLModesSourceAlloydbDisable(sourceAlloydbDisable SourceAlloydbDisable) SourceAlloydbSSLModes {
	typ := SourceAlloydbSSLModesTypeSourceAlloydbDisable

	return SourceAlloydbSSLModes{
		SourceAlloydbDisable: &sourceAlloydbDisable,
		Type:                 typ,
	}
}

func CreateSourceAlloydbSSLModesSourceAlloydbAllow(sourceAlloydbAllow SourceAlloydbAllow) SourceAlloydbSSLModes {
	typ := SourceAlloydbSSLModesTypeSourceAlloydbAllow

	return SourceAlloydbSSLModes{
		SourceAlloydbAllow: &sourceAlloydbAllow,
		Type:               typ,
	}
}

func CreateSourceAlloydbSSLModesSourceAlloydbPrefer(sourceAlloydbPrefer SourceAlloydbPrefer) SourceAlloydbSSLModes {
	typ := SourceAlloydbSSLModesTypeSourceAlloydbPrefer

	return SourceAlloydbSSLModes{
		SourceAlloydbPrefer: &sourceAlloydbPrefer,
		Type:                typ,
	}
}

func CreateSourceAlloydbSSLModesSourceAlloydbRequire(sourceAlloydbRequire SourceAlloydbRequire) SourceAlloydbSSLModes {
	typ := SourceAlloydbSSLModesTypeSourceAlloydbRequire

	return SourceAlloydbSSLModes{
		SourceAlloydbRequire: &sourceAlloydbRequire,
		Type:                 typ,
	}
}

func CreateSourceAlloydbSSLModesSourceAlloydbVerifyCa(sourceAlloydbVerifyCa SourceAlloydbVerifyCa) SourceAlloydbSSLModes {
	typ := SourceAlloydbSSLModesTypeSourceAlloydbVerifyCa

	return SourceAlloydbSSLModes{
		SourceAlloydbVerifyCa: &sourceAlloydbVerifyCa,
		Type:                  typ,
	}
}

func CreateSourceAlloydbSSLModesSourceAlloydbVerifyFull(sourceAlloydbVerifyFull SourceAlloydbVerifyFull) SourceAlloydbSSLModes {
	typ := SourceAlloydbSSLModesTypeSourceAlloydbVerifyFull

	return SourceAlloydbSSLModes{
		SourceAlloydbVerifyFull: &sourceAlloydbVerifyFull,
		Type:                    typ,
	}
}

func (u *SourceAlloydbSSLModes) UnmarshalJSON(data []byte) error {

	sourceAlloydbDisable := new(SourceAlloydbDisable)
	if err := utils.UnmarshalJSON(data, &sourceAlloydbDisable, "", true, true); err == nil {
		u.SourceAlloydbDisable = sourceAlloydbDisable
		u.Type = SourceAlloydbSSLModesTypeSourceAlloydbDisable
		return nil
	}

	sourceAlloydbAllow := new(SourceAlloydbAllow)
	if err := utils.UnmarshalJSON(data, &sourceAlloydbAllow, "", true, true); err == nil {
		u.SourceAlloydbAllow = sourceAlloydbAllow
		u.Type = SourceAlloydbSSLModesTypeSourceAlloydbAllow
		return nil
	}

	sourceAlloydbPrefer := new(SourceAlloydbPrefer)
	if err := utils.UnmarshalJSON(data, &sourceAlloydbPrefer, "", true, true); err == nil {
		u.SourceAlloydbPrefer = sourceAlloydbPrefer
		u.Type = SourceAlloydbSSLModesTypeSourceAlloydbPrefer
		return nil
	}

	sourceAlloydbRequire := new(SourceAlloydbRequire)
	if err := utils.UnmarshalJSON(data, &sourceAlloydbRequire, "", true, true); err == nil {
		u.SourceAlloydbRequire = sourceAlloydbRequire
		u.Type = SourceAlloydbSSLModesTypeSourceAlloydbRequire
		return nil
	}

	sourceAlloydbVerifyCa := new(SourceAlloydbVerifyCa)
	if err := utils.UnmarshalJSON(data, &sourceAlloydbVerifyCa, "", true, true); err == nil {
		u.SourceAlloydbVerifyCa = sourceAlloydbVerifyCa
		u.Type = SourceAlloydbSSLModesTypeSourceAlloydbVerifyCa
		return nil
	}

	sourceAlloydbVerifyFull := new(SourceAlloydbVerifyFull)
	if err := utils.UnmarshalJSON(data, &sourceAlloydbVerifyFull, "", true, true); err == nil {
		u.SourceAlloydbVerifyFull = sourceAlloydbVerifyFull
		u.Type = SourceAlloydbSSLModesTypeSourceAlloydbVerifyFull
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SourceAlloydbSSLModes) MarshalJSON() ([]byte, error) {
	if u.SourceAlloydbDisable != nil {
		return utils.MarshalJSON(u.SourceAlloydbDisable, "", true)
	}

	if u.SourceAlloydbAllow != nil {
		return utils.MarshalJSON(u.SourceAlloydbAllow, "", true)
	}

	if u.SourceAlloydbPrefer != nil {
		return utils.MarshalJSON(u.SourceAlloydbPrefer, "", true)
	}

	if u.SourceAlloydbRequire != nil {
		return utils.MarshalJSON(u.SourceAlloydbRequire, "", true)
	}

	if u.SourceAlloydbVerifyCa != nil {
		return utils.MarshalJSON(u.SourceAlloydbVerifyCa, "", true)
	}

	if u.SourceAlloydbVerifyFull != nil {
		return utils.MarshalJSON(u.SourceAlloydbVerifyFull, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

// SourceAlloydbSchemasTunnelMethodTunnelMethod - Connect through a jump server tunnel host using username and password authentication
type SourceAlloydbSchemasTunnelMethodTunnelMethod string

const (
	SourceAlloydbSchemasTunnelMethodTunnelMethodSSHPasswordAuth SourceAlloydbSchemasTunnelMethodTunnelMethod = "SSH_PASSWORD_AUTH"
)

func (e SourceAlloydbSchemasTunnelMethodTunnelMethod) ToPointer() *SourceAlloydbSchemasTunnelMethodTunnelMethod {
	return &e
}

func (e *SourceAlloydbSchemasTunnelMethodTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_PASSWORD_AUTH":
		*e = SourceAlloydbSchemasTunnelMethodTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceAlloydbSchemasTunnelMethodTunnelMethod: %v", v)
	}
}

// SourceAlloydbPasswordAuthentication - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceAlloydbPasswordAuthentication struct {
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and password authentication
	tunnelMethod SourceAlloydbSchemasTunnelMethodTunnelMethod `const:"SSH_PASSWORD_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser string `json:"tunnel_user"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword string `json:"tunnel_user_password"`
}

func (s SourceAlloydbPasswordAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceAlloydbPasswordAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceAlloydbPasswordAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *SourceAlloydbPasswordAuthentication) GetTunnelMethod() SourceAlloydbSchemasTunnelMethodTunnelMethod {
	return SourceAlloydbSchemasTunnelMethodTunnelMethodSSHPasswordAuth
}

func (o *SourceAlloydbPasswordAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *SourceAlloydbPasswordAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

func (o *SourceAlloydbPasswordAuthentication) GetTunnelUserPassword() string {
	if o == nil {
		return ""
	}
	return o.TunnelUserPassword
}

// SourceAlloydbSchemasTunnelMethod - Connect through a jump server tunnel host using username and ssh key
type SourceAlloydbSchemasTunnelMethod string

const (
	SourceAlloydbSchemasTunnelMethodSSHKeyAuth SourceAlloydbSchemasTunnelMethod = "SSH_KEY_AUTH"
)

func (e SourceAlloydbSchemasTunnelMethod) ToPointer() *SourceAlloydbSchemasTunnelMethod {
	return &e
}

func (e *SourceAlloydbSchemasTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_KEY_AUTH":
		*e = SourceAlloydbSchemasTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceAlloydbSchemasTunnelMethod: %v", v)
	}
}

// SourceAlloydbSSHKeyAuthentication - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceAlloydbSSHKeyAuthentication struct {
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey string `json:"ssh_key"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and ssh key
	tunnelMethod SourceAlloydbSchemasTunnelMethod `const:"SSH_KEY_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host.
	TunnelUser string `json:"tunnel_user"`
}

func (s SourceAlloydbSSHKeyAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceAlloydbSSHKeyAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceAlloydbSSHKeyAuthentication) GetSSHKey() string {
	if o == nil {
		return ""
	}
	return o.SSHKey
}

func (o *SourceAlloydbSSHKeyAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *SourceAlloydbSSHKeyAuthentication) GetTunnelMethod() SourceAlloydbSchemasTunnelMethod {
	return SourceAlloydbSchemasTunnelMethodSSHKeyAuth
}

func (o *SourceAlloydbSSHKeyAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *SourceAlloydbSSHKeyAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

// SourceAlloydbTunnelMethod - No ssh tunnel needed to connect to database
type SourceAlloydbTunnelMethod string

const (
	SourceAlloydbTunnelMethodNoTunnel SourceAlloydbTunnelMethod = "NO_TUNNEL"
)

func (e SourceAlloydbTunnelMethod) ToPointer() *SourceAlloydbTunnelMethod {
	return &e
}

func (e *SourceAlloydbTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NO_TUNNEL":
		*e = SourceAlloydbTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceAlloydbTunnelMethod: %v", v)
	}
}

// SourceAlloydbNoTunnel - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceAlloydbNoTunnel struct {
	// No ssh tunnel needed to connect to database
	tunnelMethod SourceAlloydbTunnelMethod `const:"NO_TUNNEL" json:"tunnel_method"`
}

func (s SourceAlloydbNoTunnel) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceAlloydbNoTunnel) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceAlloydbNoTunnel) GetTunnelMethod() SourceAlloydbTunnelMethod {
	return SourceAlloydbTunnelMethodNoTunnel
}

type SourceAlloydbSSHTunnelMethodType string

const (
	SourceAlloydbSSHTunnelMethodTypeSourceAlloydbNoTunnel               SourceAlloydbSSHTunnelMethodType = "source-alloydb_No Tunnel"
	SourceAlloydbSSHTunnelMethodTypeSourceAlloydbSSHKeyAuthentication   SourceAlloydbSSHTunnelMethodType = "source-alloydb_SSH Key Authentication"
	SourceAlloydbSSHTunnelMethodTypeSourceAlloydbPasswordAuthentication SourceAlloydbSSHTunnelMethodType = "source-alloydb_Password Authentication"
)

type SourceAlloydbSSHTunnelMethod struct {
	SourceAlloydbNoTunnel               *SourceAlloydbNoTunnel
	SourceAlloydbSSHKeyAuthentication   *SourceAlloydbSSHKeyAuthentication
	SourceAlloydbPasswordAuthentication *SourceAlloydbPasswordAuthentication

	Type SourceAlloydbSSHTunnelMethodType
}

func CreateSourceAlloydbSSHTunnelMethodSourceAlloydbNoTunnel(sourceAlloydbNoTunnel SourceAlloydbNoTunnel) SourceAlloydbSSHTunnelMethod {
	typ := SourceAlloydbSSHTunnelMethodTypeSourceAlloydbNoTunnel

	return SourceAlloydbSSHTunnelMethod{
		SourceAlloydbNoTunnel: &sourceAlloydbNoTunnel,
		Type:                  typ,
	}
}

func CreateSourceAlloydbSSHTunnelMethodSourceAlloydbSSHKeyAuthentication(sourceAlloydbSSHKeyAuthentication SourceAlloydbSSHKeyAuthentication) SourceAlloydbSSHTunnelMethod {
	typ := SourceAlloydbSSHTunnelMethodTypeSourceAlloydbSSHKeyAuthentication

	return SourceAlloydbSSHTunnelMethod{
		SourceAlloydbSSHKeyAuthentication: &sourceAlloydbSSHKeyAuthentication,
		Type:                              typ,
	}
}

func CreateSourceAlloydbSSHTunnelMethodSourceAlloydbPasswordAuthentication(sourceAlloydbPasswordAuthentication SourceAlloydbPasswordAuthentication) SourceAlloydbSSHTunnelMethod {
	typ := SourceAlloydbSSHTunnelMethodTypeSourceAlloydbPasswordAuthentication

	return SourceAlloydbSSHTunnelMethod{
		SourceAlloydbPasswordAuthentication: &sourceAlloydbPasswordAuthentication,
		Type:                                typ,
	}
}

func (u *SourceAlloydbSSHTunnelMethod) UnmarshalJSON(data []byte) error {

	sourceAlloydbNoTunnel := new(SourceAlloydbNoTunnel)
	if err := utils.UnmarshalJSON(data, &sourceAlloydbNoTunnel, "", true, true); err == nil {
		u.SourceAlloydbNoTunnel = sourceAlloydbNoTunnel
		u.Type = SourceAlloydbSSHTunnelMethodTypeSourceAlloydbNoTunnel
		return nil
	}

	sourceAlloydbSSHKeyAuthentication := new(SourceAlloydbSSHKeyAuthentication)
	if err := utils.UnmarshalJSON(data, &sourceAlloydbSSHKeyAuthentication, "", true, true); err == nil {
		u.SourceAlloydbSSHKeyAuthentication = sourceAlloydbSSHKeyAuthentication
		u.Type = SourceAlloydbSSHTunnelMethodTypeSourceAlloydbSSHKeyAuthentication
		return nil
	}

	sourceAlloydbPasswordAuthentication := new(SourceAlloydbPasswordAuthentication)
	if err := utils.UnmarshalJSON(data, &sourceAlloydbPasswordAuthentication, "", true, true); err == nil {
		u.SourceAlloydbPasswordAuthentication = sourceAlloydbPasswordAuthentication
		u.Type = SourceAlloydbSSHTunnelMethodTypeSourceAlloydbPasswordAuthentication
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SourceAlloydbSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.SourceAlloydbNoTunnel != nil {
		return utils.MarshalJSON(u.SourceAlloydbNoTunnel, "", true)
	}

	if u.SourceAlloydbSSHKeyAuthentication != nil {
		return utils.MarshalJSON(u.SourceAlloydbSSHKeyAuthentication, "", true)
	}

	if u.SourceAlloydbPasswordAuthentication != nil {
		return utils.MarshalJSON(u.SourceAlloydbPasswordAuthentication, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type SourceAlloydb struct {
	// Name of the database.
	Database string `json:"database"`
	// Hostname of the database.
	Host string `json:"host"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (Eg. key1=value1&key2=value2&key3=value3). For more information read about <a href="https://jdbc.postgresql.org/documentation/head/connect.html">JDBC URL parameters</a>.
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// Password associated with the username.
	Password *string `json:"password,omitempty"`
	// Port of the database.
	Port *int64 `default:"5432" json:"port"`
	// Replication method for extracting data from the database.
	ReplicationMethod *SourceAlloydbReplicationMethod `json:"replication_method,omitempty"`
	// The list of schemas (case sensitive) to sync from. Defaults to public.
	Schemas    []string `json:"schemas,omitempty"`
	sourceType Alloydb  `const:"alloydb" json:"sourceType"`
	// SSL connection modes.
	//   Read more <a href="https://jdbc.postgresql.org/documentation/head/ssl-client.html"> in the docs</a>.
	SslMode *SourceAlloydbSSLModes `json:"ssl_mode,omitempty"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod *SourceAlloydbSSHTunnelMethod `json:"tunnel_method,omitempty"`
	// Username to access the database.
	Username string `json:"username"`
}

func (s SourceAlloydb) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceAlloydb) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *SourceAlloydb) GetDatabase() string {
	if o == nil {
		return ""
	}
	return o.Database
}

func (o *SourceAlloydb) GetHost() string {
	if o == nil {
		return ""
	}
	return o.Host
}

func (o *SourceAlloydb) GetJdbcURLParams() *string {
	if o == nil {
		return nil
	}
	return o.JdbcURLParams
}

func (o *SourceAlloydb) GetPassword() *string {
	if o == nil {
		return nil
	}
	return o.Password
}

func (o *SourceAlloydb) GetPort() *int64 {
	if o == nil {
		return nil
	}
	return o.Port
}

func (o *SourceAlloydb) GetReplicationMethod() *SourceAlloydbReplicationMethod {
	if o == nil {
		return nil
	}
	return o.ReplicationMethod
}

func (o *SourceAlloydb) GetSchemas() []string {
	if o == nil {
		return nil
	}
	return o.Schemas
}

func (o *SourceAlloydb) GetSourceType() Alloydb {
	return AlloydbAlloydb
}

func (o *SourceAlloydb) GetSslMode() *SourceAlloydbSSLModes {
	if o == nil {
		return nil
	}
	return o.SslMode
}

func (o *SourceAlloydb) GetTunnelMethod() *SourceAlloydbSSHTunnelMethod {
	if o == nil {
		return nil
	}
	return o.TunnelMethod
}

func (o *SourceAlloydb) GetUsername() string {
	if o == nil {
		return ""
	}
	return o.Username
}
