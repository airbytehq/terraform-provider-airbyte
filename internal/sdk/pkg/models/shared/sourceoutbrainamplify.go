// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
)

type SourceOutbrainAmplifyAuthenticationMethodUsernamePasswordBothUsernameAndPasswordIsRequiredForAuthenticationRequest string

const (
	SourceOutbrainAmplifyAuthenticationMethodUsernamePasswordBothUsernameAndPasswordIsRequiredForAuthenticationRequestUsernamePassword SourceOutbrainAmplifyAuthenticationMethodUsernamePasswordBothUsernameAndPasswordIsRequiredForAuthenticationRequest = "username_password"
)

func (e SourceOutbrainAmplifyAuthenticationMethodUsernamePasswordBothUsernameAndPasswordIsRequiredForAuthenticationRequest) ToPointer() *SourceOutbrainAmplifyAuthenticationMethodUsernamePasswordBothUsernameAndPasswordIsRequiredForAuthenticationRequest {
	return &e
}

func (e *SourceOutbrainAmplifyAuthenticationMethodUsernamePasswordBothUsernameAndPasswordIsRequiredForAuthenticationRequest) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "username_password":
		*e = SourceOutbrainAmplifyAuthenticationMethodUsernamePasswordBothUsernameAndPasswordIsRequiredForAuthenticationRequest(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceOutbrainAmplifyAuthenticationMethodUsernamePasswordBothUsernameAndPasswordIsRequiredForAuthenticationRequest: %v", v)
	}
}

// SourceOutbrainAmplifyAuthenticationMethodUsernamePassword - Credentials for making authenticated requests requires either username/password or access_token.
type SourceOutbrainAmplifyAuthenticationMethodUsernamePassword struct {
	// Add Password for authentication.
	Password string                                                                                                             `json:"password"`
	Type     SourceOutbrainAmplifyAuthenticationMethodUsernamePasswordBothUsernameAndPasswordIsRequiredForAuthenticationRequest `json:"type"`
	// Add Username for authentication.
	Username string `json:"username"`
}

type SourceOutbrainAmplifyAuthenticationMethodAccessTokenAccessTokenIsRequiredForAuthenticationRequests string

const (
	SourceOutbrainAmplifyAuthenticationMethodAccessTokenAccessTokenIsRequiredForAuthenticationRequestsAccessToken SourceOutbrainAmplifyAuthenticationMethodAccessTokenAccessTokenIsRequiredForAuthenticationRequests = "access_token"
)

func (e SourceOutbrainAmplifyAuthenticationMethodAccessTokenAccessTokenIsRequiredForAuthenticationRequests) ToPointer() *SourceOutbrainAmplifyAuthenticationMethodAccessTokenAccessTokenIsRequiredForAuthenticationRequests {
	return &e
}

func (e *SourceOutbrainAmplifyAuthenticationMethodAccessTokenAccessTokenIsRequiredForAuthenticationRequests) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "access_token":
		*e = SourceOutbrainAmplifyAuthenticationMethodAccessTokenAccessTokenIsRequiredForAuthenticationRequests(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceOutbrainAmplifyAuthenticationMethodAccessTokenAccessTokenIsRequiredForAuthenticationRequests: %v", v)
	}
}

// SourceOutbrainAmplifyAuthenticationMethodAccessToken - Credentials for making authenticated requests requires either username/password or access_token.
type SourceOutbrainAmplifyAuthenticationMethodAccessToken struct {
	// Access Token for making authenticated requests.
	AccessToken string                                                                                             `json:"access_token"`
	Type        SourceOutbrainAmplifyAuthenticationMethodAccessTokenAccessTokenIsRequiredForAuthenticationRequests `json:"type"`
}

type SourceOutbrainAmplifyAuthenticationMethodType string

const (
	SourceOutbrainAmplifyAuthenticationMethodTypeSourceOutbrainAmplifyAuthenticationMethodAccessToken      SourceOutbrainAmplifyAuthenticationMethodType = "source-outbrain-amplify_Authentication Method_Access token"
	SourceOutbrainAmplifyAuthenticationMethodTypeSourceOutbrainAmplifyAuthenticationMethodUsernamePassword SourceOutbrainAmplifyAuthenticationMethodType = "source-outbrain-amplify_Authentication Method_Username Password"
)

type SourceOutbrainAmplifyAuthenticationMethod struct {
	SourceOutbrainAmplifyAuthenticationMethodAccessToken      *SourceOutbrainAmplifyAuthenticationMethodAccessToken
	SourceOutbrainAmplifyAuthenticationMethodUsernamePassword *SourceOutbrainAmplifyAuthenticationMethodUsernamePassword

	Type SourceOutbrainAmplifyAuthenticationMethodType
}

func CreateSourceOutbrainAmplifyAuthenticationMethodSourceOutbrainAmplifyAuthenticationMethodAccessToken(sourceOutbrainAmplifyAuthenticationMethodAccessToken SourceOutbrainAmplifyAuthenticationMethodAccessToken) SourceOutbrainAmplifyAuthenticationMethod {
	typ := SourceOutbrainAmplifyAuthenticationMethodTypeSourceOutbrainAmplifyAuthenticationMethodAccessToken

	return SourceOutbrainAmplifyAuthenticationMethod{
		SourceOutbrainAmplifyAuthenticationMethodAccessToken: &sourceOutbrainAmplifyAuthenticationMethodAccessToken,
		Type: typ,
	}
}

func CreateSourceOutbrainAmplifyAuthenticationMethodSourceOutbrainAmplifyAuthenticationMethodUsernamePassword(sourceOutbrainAmplifyAuthenticationMethodUsernamePassword SourceOutbrainAmplifyAuthenticationMethodUsernamePassword) SourceOutbrainAmplifyAuthenticationMethod {
	typ := SourceOutbrainAmplifyAuthenticationMethodTypeSourceOutbrainAmplifyAuthenticationMethodUsernamePassword

	return SourceOutbrainAmplifyAuthenticationMethod{
		SourceOutbrainAmplifyAuthenticationMethodUsernamePassword: &sourceOutbrainAmplifyAuthenticationMethodUsernamePassword,
		Type: typ,
	}
}

func (u *SourceOutbrainAmplifyAuthenticationMethod) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	sourceOutbrainAmplifyAuthenticationMethodAccessToken := new(SourceOutbrainAmplifyAuthenticationMethodAccessToken)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sourceOutbrainAmplifyAuthenticationMethodAccessToken); err == nil {
		u.SourceOutbrainAmplifyAuthenticationMethodAccessToken = sourceOutbrainAmplifyAuthenticationMethodAccessToken
		u.Type = SourceOutbrainAmplifyAuthenticationMethodTypeSourceOutbrainAmplifyAuthenticationMethodAccessToken
		return nil
	}

	sourceOutbrainAmplifyAuthenticationMethodUsernamePassword := new(SourceOutbrainAmplifyAuthenticationMethodUsernamePassword)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sourceOutbrainAmplifyAuthenticationMethodUsernamePassword); err == nil {
		u.SourceOutbrainAmplifyAuthenticationMethodUsernamePassword = sourceOutbrainAmplifyAuthenticationMethodUsernamePassword
		u.Type = SourceOutbrainAmplifyAuthenticationMethodTypeSourceOutbrainAmplifyAuthenticationMethodUsernamePassword
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SourceOutbrainAmplifyAuthenticationMethod) MarshalJSON() ([]byte, error) {
	if u.SourceOutbrainAmplifyAuthenticationMethodAccessToken != nil {
		return json.Marshal(u.SourceOutbrainAmplifyAuthenticationMethodAccessToken)
	}

	if u.SourceOutbrainAmplifyAuthenticationMethodUsernamePassword != nil {
		return json.Marshal(u.SourceOutbrainAmplifyAuthenticationMethodUsernamePassword)
	}

	return nil, nil
}

// SourceOutbrainAmplifyGranularityForGeoLocationRegion - The granularity used for geo location data in reports.
type SourceOutbrainAmplifyGranularityForGeoLocationRegion string

const (
	SourceOutbrainAmplifyGranularityForGeoLocationRegionCountry   SourceOutbrainAmplifyGranularityForGeoLocationRegion = "country"
	SourceOutbrainAmplifyGranularityForGeoLocationRegionRegion    SourceOutbrainAmplifyGranularityForGeoLocationRegion = "region"
	SourceOutbrainAmplifyGranularityForGeoLocationRegionSubregion SourceOutbrainAmplifyGranularityForGeoLocationRegion = "subregion"
)

func (e SourceOutbrainAmplifyGranularityForGeoLocationRegion) ToPointer() *SourceOutbrainAmplifyGranularityForGeoLocationRegion {
	return &e
}

func (e *SourceOutbrainAmplifyGranularityForGeoLocationRegion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "country":
		fallthrough
	case "region":
		fallthrough
	case "subregion":
		*e = SourceOutbrainAmplifyGranularityForGeoLocationRegion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceOutbrainAmplifyGranularityForGeoLocationRegion: %v", v)
	}
}

// SourceOutbrainAmplifyGranularityForPeriodicReports - The granularity used for periodic data in reports. See <a href="https://amplifyv01.docs.apiary.io/#reference/performance-reporting/periodic/retrieve-performance-statistics-for-all-marketer-campaigns-by-periodic-breakdown">the docs</a>.
type SourceOutbrainAmplifyGranularityForPeriodicReports string

const (
	SourceOutbrainAmplifyGranularityForPeriodicReportsDaily   SourceOutbrainAmplifyGranularityForPeriodicReports = "daily"
	SourceOutbrainAmplifyGranularityForPeriodicReportsWeekly  SourceOutbrainAmplifyGranularityForPeriodicReports = "weekly"
	SourceOutbrainAmplifyGranularityForPeriodicReportsMonthly SourceOutbrainAmplifyGranularityForPeriodicReports = "monthly"
)

func (e SourceOutbrainAmplifyGranularityForPeriodicReports) ToPointer() *SourceOutbrainAmplifyGranularityForPeriodicReports {
	return &e
}

func (e *SourceOutbrainAmplifyGranularityForPeriodicReports) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "daily":
		fallthrough
	case "weekly":
		fallthrough
	case "monthly":
		*e = SourceOutbrainAmplifyGranularityForPeriodicReports(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceOutbrainAmplifyGranularityForPeriodicReports: %v", v)
	}
}

type SourceOutbrainAmplifyOutbrainAmplify string

const (
	SourceOutbrainAmplifyOutbrainAmplifyOutbrainAmplify SourceOutbrainAmplifyOutbrainAmplify = "outbrain-amplify"
)

func (e SourceOutbrainAmplifyOutbrainAmplify) ToPointer() *SourceOutbrainAmplifyOutbrainAmplify {
	return &e
}

func (e *SourceOutbrainAmplifyOutbrainAmplify) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "outbrain-amplify":
		*e = SourceOutbrainAmplifyOutbrainAmplify(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceOutbrainAmplifyOutbrainAmplify: %v", v)
	}
}

type SourceOutbrainAmplify struct {
	// Credentials for making authenticated requests requires either username/password or access_token.
	Credentials SourceOutbrainAmplifyAuthenticationMethod `json:"credentials"`
	// Date in the format YYYY-MM-DD.
	EndDate *string `json:"end_date,omitempty"`
	// The granularity used for geo location data in reports.
	GeoLocationBreakdown *SourceOutbrainAmplifyGranularityForGeoLocationRegion `json:"geo_location_breakdown,omitempty"`
	// The granularity used for periodic data in reports. See <a href="https://amplifyv01.docs.apiary.io/#reference/performance-reporting/periodic/retrieve-performance-statistics-for-all-marketer-campaigns-by-periodic-breakdown">the docs</a>.
	ReportGranularity *SourceOutbrainAmplifyGranularityForPeriodicReports `json:"report_granularity,omitempty"`
	SourceType        SourceOutbrainAmplifyOutbrainAmplify                `json:"sourceType"`
	// Date in the format YYYY-MM-DD eg. 2017-01-25. Any data before this date will not be replicated.
	StartDate string `json:"start_date"`
}
