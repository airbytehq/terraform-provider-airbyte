// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"airbyte/internal/sdk/pkg/utils"
	"encoding/json"
	"errors"
	"fmt"
)

// DestinationRedisUpdateCacheType - Redis cache type to store data in.
type DestinationRedisUpdateCacheType string

const (
	DestinationRedisUpdateCacheTypeHash DestinationRedisUpdateCacheType = "hash"
)

func (e DestinationRedisUpdateCacheType) ToPointer() *DestinationRedisUpdateCacheType {
	return &e
}

func (e *DestinationRedisUpdateCacheType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "hash":
		*e = DestinationRedisUpdateCacheType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationRedisUpdateCacheType: %v", v)
	}
}

type DestinationRedisUpdateSSLModesVerifyFullMode string

const (
	DestinationRedisUpdateSSLModesVerifyFullModeVerifyFull DestinationRedisUpdateSSLModesVerifyFullMode = "verify-full"
)

func (e DestinationRedisUpdateSSLModesVerifyFullMode) ToPointer() *DestinationRedisUpdateSSLModesVerifyFullMode {
	return &e
}

func (e *DestinationRedisUpdateSSLModesVerifyFullMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "verify-full":
		*e = DestinationRedisUpdateSSLModesVerifyFullMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationRedisUpdateSSLModesVerifyFullMode: %v", v)
	}
}

// DestinationRedisUpdateSSLModesVerifyFull - Verify-full SSL mode.
type DestinationRedisUpdateSSLModesVerifyFull struct {
	// CA certificate
	CaCertificate string `json:"ca_certificate"`
	// Client certificate
	ClientCertificate string `json:"client_certificate"`
	// Client key
	ClientKey string `json:"client_key"`
	// Password for keystorage. If you do not add it - the password will be generated automatically.
	ClientKeyPassword *string                                       `json:"client_key_password,omitempty"`
	mode              *DestinationRedisUpdateSSLModesVerifyFullMode `const:"verify-full" json:"mode"`
}

func (d DestinationRedisUpdateSSLModesVerifyFull) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationRedisUpdateSSLModesVerifyFull) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationRedisUpdateSSLModesVerifyFull) GetCaCertificate() string {
	if o == nil {
		return ""
	}
	return o.CaCertificate
}

func (o *DestinationRedisUpdateSSLModesVerifyFull) GetClientCertificate() string {
	if o == nil {
		return ""
	}
	return o.ClientCertificate
}

func (o *DestinationRedisUpdateSSLModesVerifyFull) GetClientKey() string {
	if o == nil {
		return ""
	}
	return o.ClientKey
}

func (o *DestinationRedisUpdateSSLModesVerifyFull) GetClientKeyPassword() *string {
	if o == nil {
		return nil
	}
	return o.ClientKeyPassword
}

func (o *DestinationRedisUpdateSSLModesVerifyFull) GetMode() *DestinationRedisUpdateSSLModesVerifyFullMode {
	return DestinationRedisUpdateSSLModesVerifyFullModeVerifyFull.ToPointer()
}

type DestinationRedisUpdateSSLModesDisableMode string

const (
	DestinationRedisUpdateSSLModesDisableModeDisable DestinationRedisUpdateSSLModesDisableMode = "disable"
)

func (e DestinationRedisUpdateSSLModesDisableMode) ToPointer() *DestinationRedisUpdateSSLModesDisableMode {
	return &e
}

func (e *DestinationRedisUpdateSSLModesDisableMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "disable":
		*e = DestinationRedisUpdateSSLModesDisableMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationRedisUpdateSSLModesDisableMode: %v", v)
	}
}

// DestinationRedisUpdateSSLModesDisable - Disable SSL.
type DestinationRedisUpdateSSLModesDisable struct {
	mode *DestinationRedisUpdateSSLModesDisableMode `const:"disable" json:"mode"`
}

func (d DestinationRedisUpdateSSLModesDisable) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationRedisUpdateSSLModesDisable) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationRedisUpdateSSLModesDisable) GetMode() *DestinationRedisUpdateSSLModesDisableMode {
	return DestinationRedisUpdateSSLModesDisableModeDisable.ToPointer()
}

type DestinationRedisUpdateSSLModesType string

const (
	DestinationRedisUpdateSSLModesTypeDestinationRedisUpdateSSLModesDisable    DestinationRedisUpdateSSLModesType = "destination-redis-update_SSL Modes_disable"
	DestinationRedisUpdateSSLModesTypeDestinationRedisUpdateSSLModesVerifyFull DestinationRedisUpdateSSLModesType = "destination-redis-update_SSL Modes_verify-full"
)

type DestinationRedisUpdateSSLModes struct {
	DestinationRedisUpdateSSLModesDisable    *DestinationRedisUpdateSSLModesDisable
	DestinationRedisUpdateSSLModesVerifyFull *DestinationRedisUpdateSSLModesVerifyFull

	Type DestinationRedisUpdateSSLModesType
}

func CreateDestinationRedisUpdateSSLModesDestinationRedisUpdateSSLModesDisable(destinationRedisUpdateSSLModesDisable DestinationRedisUpdateSSLModesDisable) DestinationRedisUpdateSSLModes {
	typ := DestinationRedisUpdateSSLModesTypeDestinationRedisUpdateSSLModesDisable

	return DestinationRedisUpdateSSLModes{
		DestinationRedisUpdateSSLModesDisable: &destinationRedisUpdateSSLModesDisable,
		Type:                                  typ,
	}
}

func CreateDestinationRedisUpdateSSLModesDestinationRedisUpdateSSLModesVerifyFull(destinationRedisUpdateSSLModesVerifyFull DestinationRedisUpdateSSLModesVerifyFull) DestinationRedisUpdateSSLModes {
	typ := DestinationRedisUpdateSSLModesTypeDestinationRedisUpdateSSLModesVerifyFull

	return DestinationRedisUpdateSSLModes{
		DestinationRedisUpdateSSLModesVerifyFull: &destinationRedisUpdateSSLModesVerifyFull,
		Type:                                     typ,
	}
}

func (u *DestinationRedisUpdateSSLModes) UnmarshalJSON(data []byte) error {

	destinationRedisUpdateSSLModesDisable := new(DestinationRedisUpdateSSLModesDisable)
	if err := utils.UnmarshalJSON(data, &destinationRedisUpdateSSLModesDisable, "", true, true); err == nil {
		u.DestinationRedisUpdateSSLModesDisable = destinationRedisUpdateSSLModesDisable
		u.Type = DestinationRedisUpdateSSLModesTypeDestinationRedisUpdateSSLModesDisable
		return nil
	}

	destinationRedisUpdateSSLModesVerifyFull := new(DestinationRedisUpdateSSLModesVerifyFull)
	if err := utils.UnmarshalJSON(data, &destinationRedisUpdateSSLModesVerifyFull, "", true, true); err == nil {
		u.DestinationRedisUpdateSSLModesVerifyFull = destinationRedisUpdateSSLModesVerifyFull
		u.Type = DestinationRedisUpdateSSLModesTypeDestinationRedisUpdateSSLModesVerifyFull
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u DestinationRedisUpdateSSLModes) MarshalJSON() ([]byte, error) {
	if u.DestinationRedisUpdateSSLModesDisable != nil {
		return utils.MarshalJSON(u.DestinationRedisUpdateSSLModesDisable, "", true)
	}

	if u.DestinationRedisUpdateSSLModesVerifyFull != nil {
		return utils.MarshalJSON(u.DestinationRedisUpdateSSLModesVerifyFull, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

// DestinationRedisUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod - Connect through a jump server tunnel host using username and password authentication
type DestinationRedisUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod string

const (
	DestinationRedisUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethodSSHPasswordAuth DestinationRedisUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod = "SSH_PASSWORD_AUTH"
)

func (e DestinationRedisUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod) ToPointer() *DestinationRedisUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod {
	return &e
}

func (e *DestinationRedisUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_PASSWORD_AUTH":
		*e = DestinationRedisUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationRedisUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod: %v", v)
	}
}

// DestinationRedisUpdateSSHTunnelMethodPasswordAuthentication - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type DestinationRedisUpdateSSHTunnelMethodPasswordAuthentication struct {
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and password authentication
	tunnelMethod DestinationRedisUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod `const:"SSH_PASSWORD_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser string `json:"tunnel_user"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword string `json:"tunnel_user_password"`
}

func (d DestinationRedisUpdateSSHTunnelMethodPasswordAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationRedisUpdateSSHTunnelMethodPasswordAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationRedisUpdateSSHTunnelMethodPasswordAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *DestinationRedisUpdateSSHTunnelMethodPasswordAuthentication) GetTunnelMethod() DestinationRedisUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod {
	return DestinationRedisUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethodSSHPasswordAuth
}

func (o *DestinationRedisUpdateSSHTunnelMethodPasswordAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *DestinationRedisUpdateSSHTunnelMethodPasswordAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

func (o *DestinationRedisUpdateSSHTunnelMethodPasswordAuthentication) GetTunnelUserPassword() string {
	if o == nil {
		return ""
	}
	return o.TunnelUserPassword
}

// DestinationRedisUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod - Connect through a jump server tunnel host using username and ssh key
type DestinationRedisUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod string

const (
	DestinationRedisUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethodSSHKeyAuth DestinationRedisUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod = "SSH_KEY_AUTH"
)

func (e DestinationRedisUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod) ToPointer() *DestinationRedisUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod {
	return &e
}

func (e *DestinationRedisUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_KEY_AUTH":
		*e = DestinationRedisUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationRedisUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod: %v", v)
	}
}

// DestinationRedisUpdateSSHTunnelMethodSSHKeyAuthentication - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type DestinationRedisUpdateSSHTunnelMethodSSHKeyAuthentication struct {
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey string `json:"ssh_key"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and ssh key
	tunnelMethod DestinationRedisUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod `const:"SSH_KEY_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host.
	TunnelUser string `json:"tunnel_user"`
}

func (d DestinationRedisUpdateSSHTunnelMethodSSHKeyAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationRedisUpdateSSHTunnelMethodSSHKeyAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationRedisUpdateSSHTunnelMethodSSHKeyAuthentication) GetSSHKey() string {
	if o == nil {
		return ""
	}
	return o.SSHKey
}

func (o *DestinationRedisUpdateSSHTunnelMethodSSHKeyAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *DestinationRedisUpdateSSHTunnelMethodSSHKeyAuthentication) GetTunnelMethod() DestinationRedisUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod {
	return DestinationRedisUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethodSSHKeyAuth
}

func (o *DestinationRedisUpdateSSHTunnelMethodSSHKeyAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *DestinationRedisUpdateSSHTunnelMethodSSHKeyAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

// DestinationRedisUpdateSSHTunnelMethodNoTunnelTunnelMethod - No ssh tunnel needed to connect to database
type DestinationRedisUpdateSSHTunnelMethodNoTunnelTunnelMethod string

const (
	DestinationRedisUpdateSSHTunnelMethodNoTunnelTunnelMethodNoTunnel DestinationRedisUpdateSSHTunnelMethodNoTunnelTunnelMethod = "NO_TUNNEL"
)

func (e DestinationRedisUpdateSSHTunnelMethodNoTunnelTunnelMethod) ToPointer() *DestinationRedisUpdateSSHTunnelMethodNoTunnelTunnelMethod {
	return &e
}

func (e *DestinationRedisUpdateSSHTunnelMethodNoTunnelTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NO_TUNNEL":
		*e = DestinationRedisUpdateSSHTunnelMethodNoTunnelTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationRedisUpdateSSHTunnelMethodNoTunnelTunnelMethod: %v", v)
	}
}

// DestinationRedisUpdateSSHTunnelMethodNoTunnel - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type DestinationRedisUpdateSSHTunnelMethodNoTunnel struct {
	// No ssh tunnel needed to connect to database
	tunnelMethod DestinationRedisUpdateSSHTunnelMethodNoTunnelTunnelMethod `const:"NO_TUNNEL" json:"tunnel_method"`
}

func (d DestinationRedisUpdateSSHTunnelMethodNoTunnel) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationRedisUpdateSSHTunnelMethodNoTunnel) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationRedisUpdateSSHTunnelMethodNoTunnel) GetTunnelMethod() DestinationRedisUpdateSSHTunnelMethodNoTunnelTunnelMethod {
	return DestinationRedisUpdateSSHTunnelMethodNoTunnelTunnelMethodNoTunnel
}

type DestinationRedisUpdateSSHTunnelMethodType string

const (
	DestinationRedisUpdateSSHTunnelMethodTypeDestinationRedisUpdateSSHTunnelMethodNoTunnel               DestinationRedisUpdateSSHTunnelMethodType = "destination-redis-update_SSH Tunnel Method_No Tunnel"
	DestinationRedisUpdateSSHTunnelMethodTypeDestinationRedisUpdateSSHTunnelMethodSSHKeyAuthentication   DestinationRedisUpdateSSHTunnelMethodType = "destination-redis-update_SSH Tunnel Method_SSH Key Authentication"
	DestinationRedisUpdateSSHTunnelMethodTypeDestinationRedisUpdateSSHTunnelMethodPasswordAuthentication DestinationRedisUpdateSSHTunnelMethodType = "destination-redis-update_SSH Tunnel Method_Password Authentication"
)

type DestinationRedisUpdateSSHTunnelMethod struct {
	DestinationRedisUpdateSSHTunnelMethodNoTunnel               *DestinationRedisUpdateSSHTunnelMethodNoTunnel
	DestinationRedisUpdateSSHTunnelMethodSSHKeyAuthentication   *DestinationRedisUpdateSSHTunnelMethodSSHKeyAuthentication
	DestinationRedisUpdateSSHTunnelMethodPasswordAuthentication *DestinationRedisUpdateSSHTunnelMethodPasswordAuthentication

	Type DestinationRedisUpdateSSHTunnelMethodType
}

func CreateDestinationRedisUpdateSSHTunnelMethodDestinationRedisUpdateSSHTunnelMethodNoTunnel(destinationRedisUpdateSSHTunnelMethodNoTunnel DestinationRedisUpdateSSHTunnelMethodNoTunnel) DestinationRedisUpdateSSHTunnelMethod {
	typ := DestinationRedisUpdateSSHTunnelMethodTypeDestinationRedisUpdateSSHTunnelMethodNoTunnel

	return DestinationRedisUpdateSSHTunnelMethod{
		DestinationRedisUpdateSSHTunnelMethodNoTunnel: &destinationRedisUpdateSSHTunnelMethodNoTunnel,
		Type: typ,
	}
}

func CreateDestinationRedisUpdateSSHTunnelMethodDestinationRedisUpdateSSHTunnelMethodSSHKeyAuthentication(destinationRedisUpdateSSHTunnelMethodSSHKeyAuthentication DestinationRedisUpdateSSHTunnelMethodSSHKeyAuthentication) DestinationRedisUpdateSSHTunnelMethod {
	typ := DestinationRedisUpdateSSHTunnelMethodTypeDestinationRedisUpdateSSHTunnelMethodSSHKeyAuthentication

	return DestinationRedisUpdateSSHTunnelMethod{
		DestinationRedisUpdateSSHTunnelMethodSSHKeyAuthentication: &destinationRedisUpdateSSHTunnelMethodSSHKeyAuthentication,
		Type: typ,
	}
}

func CreateDestinationRedisUpdateSSHTunnelMethodDestinationRedisUpdateSSHTunnelMethodPasswordAuthentication(destinationRedisUpdateSSHTunnelMethodPasswordAuthentication DestinationRedisUpdateSSHTunnelMethodPasswordAuthentication) DestinationRedisUpdateSSHTunnelMethod {
	typ := DestinationRedisUpdateSSHTunnelMethodTypeDestinationRedisUpdateSSHTunnelMethodPasswordAuthentication

	return DestinationRedisUpdateSSHTunnelMethod{
		DestinationRedisUpdateSSHTunnelMethodPasswordAuthentication: &destinationRedisUpdateSSHTunnelMethodPasswordAuthentication,
		Type: typ,
	}
}

func (u *DestinationRedisUpdateSSHTunnelMethod) UnmarshalJSON(data []byte) error {

	destinationRedisUpdateSSHTunnelMethodNoTunnel := new(DestinationRedisUpdateSSHTunnelMethodNoTunnel)
	if err := utils.UnmarshalJSON(data, &destinationRedisUpdateSSHTunnelMethodNoTunnel, "", true, true); err == nil {
		u.DestinationRedisUpdateSSHTunnelMethodNoTunnel = destinationRedisUpdateSSHTunnelMethodNoTunnel
		u.Type = DestinationRedisUpdateSSHTunnelMethodTypeDestinationRedisUpdateSSHTunnelMethodNoTunnel
		return nil
	}

	destinationRedisUpdateSSHTunnelMethodSSHKeyAuthentication := new(DestinationRedisUpdateSSHTunnelMethodSSHKeyAuthentication)
	if err := utils.UnmarshalJSON(data, &destinationRedisUpdateSSHTunnelMethodSSHKeyAuthentication, "", true, true); err == nil {
		u.DestinationRedisUpdateSSHTunnelMethodSSHKeyAuthentication = destinationRedisUpdateSSHTunnelMethodSSHKeyAuthentication
		u.Type = DestinationRedisUpdateSSHTunnelMethodTypeDestinationRedisUpdateSSHTunnelMethodSSHKeyAuthentication
		return nil
	}

	destinationRedisUpdateSSHTunnelMethodPasswordAuthentication := new(DestinationRedisUpdateSSHTunnelMethodPasswordAuthentication)
	if err := utils.UnmarshalJSON(data, &destinationRedisUpdateSSHTunnelMethodPasswordAuthentication, "", true, true); err == nil {
		u.DestinationRedisUpdateSSHTunnelMethodPasswordAuthentication = destinationRedisUpdateSSHTunnelMethodPasswordAuthentication
		u.Type = DestinationRedisUpdateSSHTunnelMethodTypeDestinationRedisUpdateSSHTunnelMethodPasswordAuthentication
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u DestinationRedisUpdateSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.DestinationRedisUpdateSSHTunnelMethodNoTunnel != nil {
		return utils.MarshalJSON(u.DestinationRedisUpdateSSHTunnelMethodNoTunnel, "", true)
	}

	if u.DestinationRedisUpdateSSHTunnelMethodSSHKeyAuthentication != nil {
		return utils.MarshalJSON(u.DestinationRedisUpdateSSHTunnelMethodSSHKeyAuthentication, "", true)
	}

	if u.DestinationRedisUpdateSSHTunnelMethodPasswordAuthentication != nil {
		return utils.MarshalJSON(u.DestinationRedisUpdateSSHTunnelMethodPasswordAuthentication, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type DestinationRedisUpdate struct {
	// Redis cache type to store data in.
	CacheType *DestinationRedisUpdateCacheType `default:"hash" json:"cache_type"`
	// Redis host to connect to.
	Host string `json:"host"`
	// Password associated with Redis.
	Password *string `json:"password,omitempty"`
	// Port of Redis.
	Port *int64 `default:"6379" json:"port"`
	// Indicates whether SSL encryption protocol will be used to connect to Redis. It is recommended to use SSL connection if possible.
	Ssl *bool `default:"false" json:"ssl"`
	// SSL connection modes.
	//   <li><b>verify-full</b> - This is the most secure mode. Always require encryption and verifies the identity of the source database server
	SslMode *DestinationRedisUpdateSSLModes `json:"ssl_mode,omitempty"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod *DestinationRedisUpdateSSHTunnelMethod `json:"tunnel_method,omitempty"`
	// Username associated with Redis.
	Username string `json:"username"`
}

func (d DestinationRedisUpdate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationRedisUpdate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *DestinationRedisUpdate) GetCacheType() *DestinationRedisUpdateCacheType {
	if o == nil {
		return nil
	}
	return o.CacheType
}

func (o *DestinationRedisUpdate) GetHost() string {
	if o == nil {
		return ""
	}
	return o.Host
}

func (o *DestinationRedisUpdate) GetPassword() *string {
	if o == nil {
		return nil
	}
	return o.Password
}

func (o *DestinationRedisUpdate) GetPort() *int64 {
	if o == nil {
		return nil
	}
	return o.Port
}

func (o *DestinationRedisUpdate) GetSsl() *bool {
	if o == nil {
		return nil
	}
	return o.Ssl
}

func (o *DestinationRedisUpdate) GetSslMode() *DestinationRedisUpdateSSLModes {
	if o == nil {
		return nil
	}
	return o.SslMode
}

func (o *DestinationRedisUpdate) GetTunnelMethod() *DestinationRedisUpdateSSHTunnelMethod {
	if o == nil {
		return nil
	}
	return o.TunnelMethod
}

func (o *DestinationRedisUpdate) GetUsername() string {
	if o == nil {
		return ""
	}
	return o.Username
}
