// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"airbyte/internal/sdk/pkg/utils"
	"encoding/json"
	"errors"
	"fmt"
)

type SourceOracleUpdateConnectBySystemIDSIDConnectionType string

const (
	SourceOracleUpdateConnectBySystemIDSIDConnectionTypeSid SourceOracleUpdateConnectBySystemIDSIDConnectionType = "sid"
)

func (e SourceOracleUpdateConnectBySystemIDSIDConnectionType) ToPointer() *SourceOracleUpdateConnectBySystemIDSIDConnectionType {
	return &e
}

func (e *SourceOracleUpdateConnectBySystemIDSIDConnectionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "sid":
		*e = SourceOracleUpdateConnectBySystemIDSIDConnectionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceOracleUpdateConnectBySystemIDSIDConnectionType: %v", v)
	}
}

// SourceOracleUpdateConnectBySystemIDSID - Use SID (Oracle System Identifier)
type SourceOracleUpdateConnectBySystemIDSID struct {
	connectionType *SourceOracleUpdateConnectBySystemIDSIDConnectionType `const:"sid" json:"connection_type"`
	Sid            string                                                `json:"sid"`
}

func (s SourceOracleUpdateConnectBySystemIDSID) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceOracleUpdateConnectBySystemIDSID) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceOracleUpdateConnectBySystemIDSID) GetConnectionType() *SourceOracleUpdateConnectBySystemIDSIDConnectionType {
	return SourceOracleUpdateConnectBySystemIDSIDConnectionTypeSid.ToPointer()
}

func (o *SourceOracleUpdateConnectBySystemIDSID) GetSid() string {
	if o == nil {
		return ""
	}
	return o.Sid
}

type SourceOracleUpdateConnectByServiceNameConnectionType string

const (
	SourceOracleUpdateConnectByServiceNameConnectionTypeServiceName SourceOracleUpdateConnectByServiceNameConnectionType = "service_name"
)

func (e SourceOracleUpdateConnectByServiceNameConnectionType) ToPointer() *SourceOracleUpdateConnectByServiceNameConnectionType {
	return &e
}

func (e *SourceOracleUpdateConnectByServiceNameConnectionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "service_name":
		*e = SourceOracleUpdateConnectByServiceNameConnectionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceOracleUpdateConnectByServiceNameConnectionType: %v", v)
	}
}

// SourceOracleUpdateConnectByServiceName - Use service name
type SourceOracleUpdateConnectByServiceName struct {
	connectionType *SourceOracleUpdateConnectByServiceNameConnectionType `const:"service_name" json:"connection_type"`
	ServiceName    string                                                `json:"service_name"`
}

func (s SourceOracleUpdateConnectByServiceName) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceOracleUpdateConnectByServiceName) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceOracleUpdateConnectByServiceName) GetConnectionType() *SourceOracleUpdateConnectByServiceNameConnectionType {
	return SourceOracleUpdateConnectByServiceNameConnectionTypeServiceName.ToPointer()
}

func (o *SourceOracleUpdateConnectByServiceName) GetServiceName() string {
	if o == nil {
		return ""
	}
	return o.ServiceName
}

type SourceOracleUpdateConnectByType string

const (
	SourceOracleUpdateConnectByTypeSourceOracleUpdateConnectByServiceName SourceOracleUpdateConnectByType = "source-oracle-update_Connect by_Service name"
	SourceOracleUpdateConnectByTypeSourceOracleUpdateConnectBySystemIDSID SourceOracleUpdateConnectByType = "source-oracle-update_Connect by_System ID (SID)"
)

type SourceOracleUpdateConnectBy struct {
	SourceOracleUpdateConnectByServiceName *SourceOracleUpdateConnectByServiceName
	SourceOracleUpdateConnectBySystemIDSID *SourceOracleUpdateConnectBySystemIDSID

	Type SourceOracleUpdateConnectByType
}

func CreateSourceOracleUpdateConnectBySourceOracleUpdateConnectByServiceName(sourceOracleUpdateConnectByServiceName SourceOracleUpdateConnectByServiceName) SourceOracleUpdateConnectBy {
	typ := SourceOracleUpdateConnectByTypeSourceOracleUpdateConnectByServiceName

	return SourceOracleUpdateConnectBy{
		SourceOracleUpdateConnectByServiceName: &sourceOracleUpdateConnectByServiceName,
		Type:                                   typ,
	}
}

func CreateSourceOracleUpdateConnectBySourceOracleUpdateConnectBySystemIDSID(sourceOracleUpdateConnectBySystemIDSID SourceOracleUpdateConnectBySystemIDSID) SourceOracleUpdateConnectBy {
	typ := SourceOracleUpdateConnectByTypeSourceOracleUpdateConnectBySystemIDSID

	return SourceOracleUpdateConnectBy{
		SourceOracleUpdateConnectBySystemIDSID: &sourceOracleUpdateConnectBySystemIDSID,
		Type:                                   typ,
	}
}

func (u *SourceOracleUpdateConnectBy) UnmarshalJSON(data []byte) error {

	sourceOracleUpdateConnectByServiceName := new(SourceOracleUpdateConnectByServiceName)
	if err := utils.UnmarshalJSON(data, &sourceOracleUpdateConnectByServiceName, "", true, true); err == nil {
		u.SourceOracleUpdateConnectByServiceName = sourceOracleUpdateConnectByServiceName
		u.Type = SourceOracleUpdateConnectByTypeSourceOracleUpdateConnectByServiceName
		return nil
	}

	sourceOracleUpdateConnectBySystemIDSID := new(SourceOracleUpdateConnectBySystemIDSID)
	if err := utils.UnmarshalJSON(data, &sourceOracleUpdateConnectBySystemIDSID, "", true, true); err == nil {
		u.SourceOracleUpdateConnectBySystemIDSID = sourceOracleUpdateConnectBySystemIDSID
		u.Type = SourceOracleUpdateConnectByTypeSourceOracleUpdateConnectBySystemIDSID
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SourceOracleUpdateConnectBy) MarshalJSON() ([]byte, error) {
	if u.SourceOracleUpdateConnectByServiceName != nil {
		return utils.MarshalJSON(u.SourceOracleUpdateConnectByServiceName, "", true)
	}

	if u.SourceOracleUpdateConnectBySystemIDSID != nil {
		return utils.MarshalJSON(u.SourceOracleUpdateConnectBySystemIDSID, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type SourceOracleUpdateEncryptionTLSEncryptedVerifyCertificateEncryptionMethod string

const (
	SourceOracleUpdateEncryptionTLSEncryptedVerifyCertificateEncryptionMethodEncryptedVerifyCertificate SourceOracleUpdateEncryptionTLSEncryptedVerifyCertificateEncryptionMethod = "encrypted_verify_certificate"
)

func (e SourceOracleUpdateEncryptionTLSEncryptedVerifyCertificateEncryptionMethod) ToPointer() *SourceOracleUpdateEncryptionTLSEncryptedVerifyCertificateEncryptionMethod {
	return &e
}

func (e *SourceOracleUpdateEncryptionTLSEncryptedVerifyCertificateEncryptionMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "encrypted_verify_certificate":
		*e = SourceOracleUpdateEncryptionTLSEncryptedVerifyCertificateEncryptionMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceOracleUpdateEncryptionTLSEncryptedVerifyCertificateEncryptionMethod: %v", v)
	}
}

// SourceOracleUpdateEncryptionTLSEncryptedVerifyCertificate - Verify and use the certificate provided by the server.
type SourceOracleUpdateEncryptionTLSEncryptedVerifyCertificate struct {
	encryptionMethod *SourceOracleUpdateEncryptionTLSEncryptedVerifyCertificateEncryptionMethod `const:"encrypted_verify_certificate" json:"encryption_method"`
	// Privacy Enhanced Mail (PEM) files are concatenated certificate containers frequently used in certificate installations.
	SslCertificate string `json:"ssl_certificate"`
}

func (s SourceOracleUpdateEncryptionTLSEncryptedVerifyCertificate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceOracleUpdateEncryptionTLSEncryptedVerifyCertificate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceOracleUpdateEncryptionTLSEncryptedVerifyCertificate) GetEncryptionMethod() *SourceOracleUpdateEncryptionTLSEncryptedVerifyCertificateEncryptionMethod {
	return SourceOracleUpdateEncryptionTLSEncryptedVerifyCertificateEncryptionMethodEncryptedVerifyCertificate.ToPointer()
}

func (o *SourceOracleUpdateEncryptionTLSEncryptedVerifyCertificate) GetSslCertificate() string {
	if o == nil {
		return ""
	}
	return o.SslCertificate
}

// SourceOracleUpdateEncryptionNativeNetworkEncryptionNNEEncryptionAlgorithm - This parameter defines what encryption algorithm is used.
type SourceOracleUpdateEncryptionNativeNetworkEncryptionNNEEncryptionAlgorithm string

const (
	SourceOracleUpdateEncryptionNativeNetworkEncryptionNNEEncryptionAlgorithmAes256      SourceOracleUpdateEncryptionNativeNetworkEncryptionNNEEncryptionAlgorithm = "AES256"
	SourceOracleUpdateEncryptionNativeNetworkEncryptionNNEEncryptionAlgorithmRc456       SourceOracleUpdateEncryptionNativeNetworkEncryptionNNEEncryptionAlgorithm = "RC4_56"
	SourceOracleUpdateEncryptionNativeNetworkEncryptionNNEEncryptionAlgorithmThreeDes168 SourceOracleUpdateEncryptionNativeNetworkEncryptionNNEEncryptionAlgorithm = "3DES168"
)

func (e SourceOracleUpdateEncryptionNativeNetworkEncryptionNNEEncryptionAlgorithm) ToPointer() *SourceOracleUpdateEncryptionNativeNetworkEncryptionNNEEncryptionAlgorithm {
	return &e
}

func (e *SourceOracleUpdateEncryptionNativeNetworkEncryptionNNEEncryptionAlgorithm) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "AES256":
		fallthrough
	case "RC4_56":
		fallthrough
	case "3DES168":
		*e = SourceOracleUpdateEncryptionNativeNetworkEncryptionNNEEncryptionAlgorithm(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceOracleUpdateEncryptionNativeNetworkEncryptionNNEEncryptionAlgorithm: %v", v)
	}
}

type SourceOracleUpdateEncryptionNativeNetworkEncryptionNNEEncryptionMethod string

const (
	SourceOracleUpdateEncryptionNativeNetworkEncryptionNNEEncryptionMethodClientNne SourceOracleUpdateEncryptionNativeNetworkEncryptionNNEEncryptionMethod = "client_nne"
)

func (e SourceOracleUpdateEncryptionNativeNetworkEncryptionNNEEncryptionMethod) ToPointer() *SourceOracleUpdateEncryptionNativeNetworkEncryptionNNEEncryptionMethod {
	return &e
}

func (e *SourceOracleUpdateEncryptionNativeNetworkEncryptionNNEEncryptionMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "client_nne":
		*e = SourceOracleUpdateEncryptionNativeNetworkEncryptionNNEEncryptionMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceOracleUpdateEncryptionNativeNetworkEncryptionNNEEncryptionMethod: %v", v)
	}
}

// SourceOracleUpdateEncryptionNativeNetworkEncryptionNNE - The native network encryption gives you the ability to encrypt database connections, without the configuration overhead of TCP/IP and SSL/TLS and without the need to open and listen on different ports.
type SourceOracleUpdateEncryptionNativeNetworkEncryptionNNE struct {
	// This parameter defines what encryption algorithm is used.
	EncryptionAlgorithm *SourceOracleUpdateEncryptionNativeNetworkEncryptionNNEEncryptionAlgorithm `default:"AES256" json:"encryption_algorithm"`
	encryptionMethod    *SourceOracleUpdateEncryptionNativeNetworkEncryptionNNEEncryptionMethod    `const:"client_nne" json:"encryption_method"`
}

func (s SourceOracleUpdateEncryptionNativeNetworkEncryptionNNE) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceOracleUpdateEncryptionNativeNetworkEncryptionNNE) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceOracleUpdateEncryptionNativeNetworkEncryptionNNE) GetEncryptionAlgorithm() *SourceOracleUpdateEncryptionNativeNetworkEncryptionNNEEncryptionAlgorithm {
	if o == nil {
		return nil
	}
	return o.EncryptionAlgorithm
}

func (o *SourceOracleUpdateEncryptionNativeNetworkEncryptionNNE) GetEncryptionMethod() *SourceOracleUpdateEncryptionNativeNetworkEncryptionNNEEncryptionMethod {
	return SourceOracleUpdateEncryptionNativeNetworkEncryptionNNEEncryptionMethodClientNne.ToPointer()
}

type SourceOracleUpdateEncryptionType string

const (
	SourceOracleUpdateEncryptionTypeSourceOracleUpdateEncryptionNativeNetworkEncryptionNNE    SourceOracleUpdateEncryptionType = "source-oracle-update_Encryption_Native Network Encryption (NNE)"
	SourceOracleUpdateEncryptionTypeSourceOracleUpdateEncryptionTLSEncryptedVerifyCertificate SourceOracleUpdateEncryptionType = "source-oracle-update_Encryption_TLS Encrypted (verify certificate)"
)

type SourceOracleUpdateEncryption struct {
	SourceOracleUpdateEncryptionNativeNetworkEncryptionNNE    *SourceOracleUpdateEncryptionNativeNetworkEncryptionNNE
	SourceOracleUpdateEncryptionTLSEncryptedVerifyCertificate *SourceOracleUpdateEncryptionTLSEncryptedVerifyCertificate

	Type SourceOracleUpdateEncryptionType
}

func CreateSourceOracleUpdateEncryptionSourceOracleUpdateEncryptionNativeNetworkEncryptionNNE(sourceOracleUpdateEncryptionNativeNetworkEncryptionNNE SourceOracleUpdateEncryptionNativeNetworkEncryptionNNE) SourceOracleUpdateEncryption {
	typ := SourceOracleUpdateEncryptionTypeSourceOracleUpdateEncryptionNativeNetworkEncryptionNNE

	return SourceOracleUpdateEncryption{
		SourceOracleUpdateEncryptionNativeNetworkEncryptionNNE: &sourceOracleUpdateEncryptionNativeNetworkEncryptionNNE,
		Type: typ,
	}
}

func CreateSourceOracleUpdateEncryptionSourceOracleUpdateEncryptionTLSEncryptedVerifyCertificate(sourceOracleUpdateEncryptionTLSEncryptedVerifyCertificate SourceOracleUpdateEncryptionTLSEncryptedVerifyCertificate) SourceOracleUpdateEncryption {
	typ := SourceOracleUpdateEncryptionTypeSourceOracleUpdateEncryptionTLSEncryptedVerifyCertificate

	return SourceOracleUpdateEncryption{
		SourceOracleUpdateEncryptionTLSEncryptedVerifyCertificate: &sourceOracleUpdateEncryptionTLSEncryptedVerifyCertificate,
		Type: typ,
	}
}

func (u *SourceOracleUpdateEncryption) UnmarshalJSON(data []byte) error {

	sourceOracleUpdateEncryptionNativeNetworkEncryptionNNE := new(SourceOracleUpdateEncryptionNativeNetworkEncryptionNNE)
	if err := utils.UnmarshalJSON(data, &sourceOracleUpdateEncryptionNativeNetworkEncryptionNNE, "", true, true); err == nil {
		u.SourceOracleUpdateEncryptionNativeNetworkEncryptionNNE = sourceOracleUpdateEncryptionNativeNetworkEncryptionNNE
		u.Type = SourceOracleUpdateEncryptionTypeSourceOracleUpdateEncryptionNativeNetworkEncryptionNNE
		return nil
	}

	sourceOracleUpdateEncryptionTLSEncryptedVerifyCertificate := new(SourceOracleUpdateEncryptionTLSEncryptedVerifyCertificate)
	if err := utils.UnmarshalJSON(data, &sourceOracleUpdateEncryptionTLSEncryptedVerifyCertificate, "", true, true); err == nil {
		u.SourceOracleUpdateEncryptionTLSEncryptedVerifyCertificate = sourceOracleUpdateEncryptionTLSEncryptedVerifyCertificate
		u.Type = SourceOracleUpdateEncryptionTypeSourceOracleUpdateEncryptionTLSEncryptedVerifyCertificate
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SourceOracleUpdateEncryption) MarshalJSON() ([]byte, error) {
	if u.SourceOracleUpdateEncryptionNativeNetworkEncryptionNNE != nil {
		return utils.MarshalJSON(u.SourceOracleUpdateEncryptionNativeNetworkEncryptionNNE, "", true)
	}

	if u.SourceOracleUpdateEncryptionTLSEncryptedVerifyCertificate != nil {
		return utils.MarshalJSON(u.SourceOracleUpdateEncryptionTLSEncryptedVerifyCertificate, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

// SourceOracleUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod - Connect through a jump server tunnel host using username and password authentication
type SourceOracleUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod string

const (
	SourceOracleUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethodSSHPasswordAuth SourceOracleUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod = "SSH_PASSWORD_AUTH"
)

func (e SourceOracleUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod) ToPointer() *SourceOracleUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod {
	return &e
}

func (e *SourceOracleUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_PASSWORD_AUTH":
		*e = SourceOracleUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceOracleUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod: %v", v)
	}
}

// SourceOracleUpdateSSHTunnelMethodPasswordAuthentication - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceOracleUpdateSSHTunnelMethodPasswordAuthentication struct {
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and password authentication
	tunnelMethod SourceOracleUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod `const:"SSH_PASSWORD_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser string `json:"tunnel_user"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword string `json:"tunnel_user_password"`
}

func (s SourceOracleUpdateSSHTunnelMethodPasswordAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceOracleUpdateSSHTunnelMethodPasswordAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceOracleUpdateSSHTunnelMethodPasswordAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *SourceOracleUpdateSSHTunnelMethodPasswordAuthentication) GetTunnelMethod() SourceOracleUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod {
	return SourceOracleUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethodSSHPasswordAuth
}

func (o *SourceOracleUpdateSSHTunnelMethodPasswordAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *SourceOracleUpdateSSHTunnelMethodPasswordAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

func (o *SourceOracleUpdateSSHTunnelMethodPasswordAuthentication) GetTunnelUserPassword() string {
	if o == nil {
		return ""
	}
	return o.TunnelUserPassword
}

// SourceOracleUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod - Connect through a jump server tunnel host using username and ssh key
type SourceOracleUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod string

const (
	SourceOracleUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethodSSHKeyAuth SourceOracleUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod = "SSH_KEY_AUTH"
)

func (e SourceOracleUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod) ToPointer() *SourceOracleUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod {
	return &e
}

func (e *SourceOracleUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_KEY_AUTH":
		*e = SourceOracleUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceOracleUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod: %v", v)
	}
}

// SourceOracleUpdateSSHTunnelMethodSSHKeyAuthentication - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceOracleUpdateSSHTunnelMethodSSHKeyAuthentication struct {
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey string `json:"ssh_key"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and ssh key
	tunnelMethod SourceOracleUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod `const:"SSH_KEY_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host.
	TunnelUser string `json:"tunnel_user"`
}

func (s SourceOracleUpdateSSHTunnelMethodSSHKeyAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceOracleUpdateSSHTunnelMethodSSHKeyAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceOracleUpdateSSHTunnelMethodSSHKeyAuthentication) GetSSHKey() string {
	if o == nil {
		return ""
	}
	return o.SSHKey
}

func (o *SourceOracleUpdateSSHTunnelMethodSSHKeyAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *SourceOracleUpdateSSHTunnelMethodSSHKeyAuthentication) GetTunnelMethod() SourceOracleUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod {
	return SourceOracleUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethodSSHKeyAuth
}

func (o *SourceOracleUpdateSSHTunnelMethodSSHKeyAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *SourceOracleUpdateSSHTunnelMethodSSHKeyAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

// SourceOracleUpdateSSHTunnelMethodNoTunnelTunnelMethod - No ssh tunnel needed to connect to database
type SourceOracleUpdateSSHTunnelMethodNoTunnelTunnelMethod string

const (
	SourceOracleUpdateSSHTunnelMethodNoTunnelTunnelMethodNoTunnel SourceOracleUpdateSSHTunnelMethodNoTunnelTunnelMethod = "NO_TUNNEL"
)

func (e SourceOracleUpdateSSHTunnelMethodNoTunnelTunnelMethod) ToPointer() *SourceOracleUpdateSSHTunnelMethodNoTunnelTunnelMethod {
	return &e
}

func (e *SourceOracleUpdateSSHTunnelMethodNoTunnelTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NO_TUNNEL":
		*e = SourceOracleUpdateSSHTunnelMethodNoTunnelTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceOracleUpdateSSHTunnelMethodNoTunnelTunnelMethod: %v", v)
	}
}

// SourceOracleUpdateSSHTunnelMethodNoTunnel - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceOracleUpdateSSHTunnelMethodNoTunnel struct {
	// No ssh tunnel needed to connect to database
	tunnelMethod SourceOracleUpdateSSHTunnelMethodNoTunnelTunnelMethod `const:"NO_TUNNEL" json:"tunnel_method"`
}

func (s SourceOracleUpdateSSHTunnelMethodNoTunnel) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceOracleUpdateSSHTunnelMethodNoTunnel) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceOracleUpdateSSHTunnelMethodNoTunnel) GetTunnelMethod() SourceOracleUpdateSSHTunnelMethodNoTunnelTunnelMethod {
	return SourceOracleUpdateSSHTunnelMethodNoTunnelTunnelMethodNoTunnel
}

type SourceOracleUpdateSSHTunnelMethodType string

const (
	SourceOracleUpdateSSHTunnelMethodTypeSourceOracleUpdateSSHTunnelMethodNoTunnel               SourceOracleUpdateSSHTunnelMethodType = "source-oracle-update_SSH Tunnel Method_No Tunnel"
	SourceOracleUpdateSSHTunnelMethodTypeSourceOracleUpdateSSHTunnelMethodSSHKeyAuthentication   SourceOracleUpdateSSHTunnelMethodType = "source-oracle-update_SSH Tunnel Method_SSH Key Authentication"
	SourceOracleUpdateSSHTunnelMethodTypeSourceOracleUpdateSSHTunnelMethodPasswordAuthentication SourceOracleUpdateSSHTunnelMethodType = "source-oracle-update_SSH Tunnel Method_Password Authentication"
)

type SourceOracleUpdateSSHTunnelMethod struct {
	SourceOracleUpdateSSHTunnelMethodNoTunnel               *SourceOracleUpdateSSHTunnelMethodNoTunnel
	SourceOracleUpdateSSHTunnelMethodSSHKeyAuthentication   *SourceOracleUpdateSSHTunnelMethodSSHKeyAuthentication
	SourceOracleUpdateSSHTunnelMethodPasswordAuthentication *SourceOracleUpdateSSHTunnelMethodPasswordAuthentication

	Type SourceOracleUpdateSSHTunnelMethodType
}

func CreateSourceOracleUpdateSSHTunnelMethodSourceOracleUpdateSSHTunnelMethodNoTunnel(sourceOracleUpdateSSHTunnelMethodNoTunnel SourceOracleUpdateSSHTunnelMethodNoTunnel) SourceOracleUpdateSSHTunnelMethod {
	typ := SourceOracleUpdateSSHTunnelMethodTypeSourceOracleUpdateSSHTunnelMethodNoTunnel

	return SourceOracleUpdateSSHTunnelMethod{
		SourceOracleUpdateSSHTunnelMethodNoTunnel: &sourceOracleUpdateSSHTunnelMethodNoTunnel,
		Type: typ,
	}
}

func CreateSourceOracleUpdateSSHTunnelMethodSourceOracleUpdateSSHTunnelMethodSSHKeyAuthentication(sourceOracleUpdateSSHTunnelMethodSSHKeyAuthentication SourceOracleUpdateSSHTunnelMethodSSHKeyAuthentication) SourceOracleUpdateSSHTunnelMethod {
	typ := SourceOracleUpdateSSHTunnelMethodTypeSourceOracleUpdateSSHTunnelMethodSSHKeyAuthentication

	return SourceOracleUpdateSSHTunnelMethod{
		SourceOracleUpdateSSHTunnelMethodSSHKeyAuthentication: &sourceOracleUpdateSSHTunnelMethodSSHKeyAuthentication,
		Type: typ,
	}
}

func CreateSourceOracleUpdateSSHTunnelMethodSourceOracleUpdateSSHTunnelMethodPasswordAuthentication(sourceOracleUpdateSSHTunnelMethodPasswordAuthentication SourceOracleUpdateSSHTunnelMethodPasswordAuthentication) SourceOracleUpdateSSHTunnelMethod {
	typ := SourceOracleUpdateSSHTunnelMethodTypeSourceOracleUpdateSSHTunnelMethodPasswordAuthentication

	return SourceOracleUpdateSSHTunnelMethod{
		SourceOracleUpdateSSHTunnelMethodPasswordAuthentication: &sourceOracleUpdateSSHTunnelMethodPasswordAuthentication,
		Type: typ,
	}
}

func (u *SourceOracleUpdateSSHTunnelMethod) UnmarshalJSON(data []byte) error {

	sourceOracleUpdateSSHTunnelMethodNoTunnel := new(SourceOracleUpdateSSHTunnelMethodNoTunnel)
	if err := utils.UnmarshalJSON(data, &sourceOracleUpdateSSHTunnelMethodNoTunnel, "", true, true); err == nil {
		u.SourceOracleUpdateSSHTunnelMethodNoTunnel = sourceOracleUpdateSSHTunnelMethodNoTunnel
		u.Type = SourceOracleUpdateSSHTunnelMethodTypeSourceOracleUpdateSSHTunnelMethodNoTunnel
		return nil
	}

	sourceOracleUpdateSSHTunnelMethodSSHKeyAuthentication := new(SourceOracleUpdateSSHTunnelMethodSSHKeyAuthentication)
	if err := utils.UnmarshalJSON(data, &sourceOracleUpdateSSHTunnelMethodSSHKeyAuthentication, "", true, true); err == nil {
		u.SourceOracleUpdateSSHTunnelMethodSSHKeyAuthentication = sourceOracleUpdateSSHTunnelMethodSSHKeyAuthentication
		u.Type = SourceOracleUpdateSSHTunnelMethodTypeSourceOracleUpdateSSHTunnelMethodSSHKeyAuthentication
		return nil
	}

	sourceOracleUpdateSSHTunnelMethodPasswordAuthentication := new(SourceOracleUpdateSSHTunnelMethodPasswordAuthentication)
	if err := utils.UnmarshalJSON(data, &sourceOracleUpdateSSHTunnelMethodPasswordAuthentication, "", true, true); err == nil {
		u.SourceOracleUpdateSSHTunnelMethodPasswordAuthentication = sourceOracleUpdateSSHTunnelMethodPasswordAuthentication
		u.Type = SourceOracleUpdateSSHTunnelMethodTypeSourceOracleUpdateSSHTunnelMethodPasswordAuthentication
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SourceOracleUpdateSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.SourceOracleUpdateSSHTunnelMethodNoTunnel != nil {
		return utils.MarshalJSON(u.SourceOracleUpdateSSHTunnelMethodNoTunnel, "", true)
	}

	if u.SourceOracleUpdateSSHTunnelMethodSSHKeyAuthentication != nil {
		return utils.MarshalJSON(u.SourceOracleUpdateSSHTunnelMethodSSHKeyAuthentication, "", true)
	}

	if u.SourceOracleUpdateSSHTunnelMethodPasswordAuthentication != nil {
		return utils.MarshalJSON(u.SourceOracleUpdateSSHTunnelMethodPasswordAuthentication, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type SourceOracleUpdate struct {
	// Connect data that will be used for DB connection
	ConnectionData *SourceOracleUpdateConnectBy `json:"connection_data,omitempty"`
	// The encryption method with is used when communicating with the database.
	Encryption SourceOracleUpdateEncryption `json:"encryption"`
	// Hostname of the database.
	Host string `json:"host"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// The password associated with the username.
	Password *string `json:"password,omitempty"`
	// Port of the database.
	// Oracle Corporations recommends the following port numbers:
	// 1521 - Default listening port for client connections to the listener.
	// 2484 - Recommended and officially registered listening port for client connections to the listener using TCP/IP with SSL
	Port *int64 `default:"1521" json:"port"`
	// The list of schemas to sync from. Defaults to user. Case sensitive.
	Schemas []string `json:"schemas,omitempty"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod *SourceOracleUpdateSSHTunnelMethod `json:"tunnel_method,omitempty"`
	// The username which is used to access the database.
	Username string `json:"username"`
}

func (s SourceOracleUpdate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceOracleUpdate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *SourceOracleUpdate) GetConnectionData() *SourceOracleUpdateConnectBy {
	if o == nil {
		return nil
	}
	return o.ConnectionData
}

func (o *SourceOracleUpdate) GetEncryption() SourceOracleUpdateEncryption {
	if o == nil {
		return SourceOracleUpdateEncryption{}
	}
	return o.Encryption
}

func (o *SourceOracleUpdate) GetHost() string {
	if o == nil {
		return ""
	}
	return o.Host
}

func (o *SourceOracleUpdate) GetJdbcURLParams() *string {
	if o == nil {
		return nil
	}
	return o.JdbcURLParams
}

func (o *SourceOracleUpdate) GetPassword() *string {
	if o == nil {
		return nil
	}
	return o.Password
}

func (o *SourceOracleUpdate) GetPort() *int64 {
	if o == nil {
		return nil
	}
	return o.Port
}

func (o *SourceOracleUpdate) GetSchemas() []string {
	if o == nil {
		return nil
	}
	return o.Schemas
}

func (o *SourceOracleUpdate) GetTunnelMethod() *SourceOracleUpdateSSHTunnelMethod {
	if o == nil {
		return nil
	}
	return o.TunnelMethod
}

func (o *SourceOracleUpdate) GetUsername() string {
	if o == nil {
		return ""
	}
	return o.Username
}
