// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"airbyte/internal/sdk/pkg/utils"
	"encoding/json"
	"errors"
	"fmt"
)

type DestinationGcsAuthenticationHMACKeyCredentialType string

const (
	DestinationGcsAuthenticationHMACKeyCredentialTypeHmacKey DestinationGcsAuthenticationHMACKeyCredentialType = "HMAC_KEY"
)

func (e DestinationGcsAuthenticationHMACKeyCredentialType) ToPointer() *DestinationGcsAuthenticationHMACKeyCredentialType {
	return &e
}

func (e *DestinationGcsAuthenticationHMACKeyCredentialType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "HMAC_KEY":
		*e = DestinationGcsAuthenticationHMACKeyCredentialType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsAuthenticationHMACKeyCredentialType: %v", v)
	}
}

// DestinationGcsAuthenticationHMACKey - An HMAC key is a type of credential and can be associated with a service account or a user account in Cloud Storage. Read more <a href="https://cloud.google.com/storage/docs/authentication/hmackeys">here</a>.
type DestinationGcsAuthenticationHMACKey struct {
	CredentialType *DestinationGcsAuthenticationHMACKeyCredentialType `default:"HMAC_KEY" json:"credential_type"`
	// When linked to a service account, this ID is 61 characters long; when linked to a user account, it is 24 characters long. Read more <a href="https://cloud.google.com/storage/docs/authentication/hmackeys#overview">here</a>.
	HmacKeyAccessID string `json:"hmac_key_access_id"`
	// The corresponding secret for the access ID. It is a 40-character base-64 encoded string.  Read more <a href="https://cloud.google.com/storage/docs/authentication/hmackeys#secrets">here</a>.
	HmacKeySecret string `json:"hmac_key_secret"`
}

func (d DestinationGcsAuthenticationHMACKey) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsAuthenticationHMACKey) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationGcsAuthenticationHMACKey) GetCredentialType() *DestinationGcsAuthenticationHMACKeyCredentialType {
	if o == nil {
		return nil
	}
	return o.CredentialType
}

func (o *DestinationGcsAuthenticationHMACKey) GetHmacKeyAccessID() string {
	if o == nil {
		return ""
	}
	return o.HmacKeyAccessID
}

func (o *DestinationGcsAuthenticationHMACKey) GetHmacKeySecret() string {
	if o == nil {
		return ""
	}
	return o.HmacKeySecret
}

type DestinationGcsAuthenticationType string

const (
	DestinationGcsAuthenticationTypeDestinationGcsAuthenticationHMACKey DestinationGcsAuthenticationType = "destination-gcs_Authentication_HMAC Key"
)

type DestinationGcsAuthentication struct {
	DestinationGcsAuthenticationHMACKey *DestinationGcsAuthenticationHMACKey

	Type DestinationGcsAuthenticationType
}

func CreateDestinationGcsAuthenticationDestinationGcsAuthenticationHMACKey(destinationGcsAuthenticationHMACKey DestinationGcsAuthenticationHMACKey) DestinationGcsAuthentication {
	typ := DestinationGcsAuthenticationTypeDestinationGcsAuthenticationHMACKey

	return DestinationGcsAuthentication{
		DestinationGcsAuthenticationHMACKey: &destinationGcsAuthenticationHMACKey,
		Type:                                typ,
	}
}

func (u *DestinationGcsAuthentication) UnmarshalJSON(data []byte) error {

	destinationGcsAuthenticationHMACKey := new(DestinationGcsAuthenticationHMACKey)
	if err := utils.UnmarshalJSON(data, &destinationGcsAuthenticationHMACKey, "", true, true); err == nil {
		u.DestinationGcsAuthenticationHMACKey = destinationGcsAuthenticationHMACKey
		u.Type = DestinationGcsAuthenticationTypeDestinationGcsAuthenticationHMACKey
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u DestinationGcsAuthentication) MarshalJSON() ([]byte, error) {
	if u.DestinationGcsAuthenticationHMACKey != nil {
		return utils.MarshalJSON(u.DestinationGcsAuthenticationHMACKey, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type DestinationGcsGcs string

const (
	DestinationGcsGcsGcs DestinationGcsGcs = "gcs"
)

func (e DestinationGcsGcs) ToPointer() *DestinationGcsGcs {
	return &e
}

func (e *DestinationGcsGcs) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "gcs":
		*e = DestinationGcsGcs(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsGcs: %v", v)
	}
}

// DestinationGcsOutputFormatParquetColumnarStorageCompressionCodec - The compression algorithm used to compress data pages.
type DestinationGcsOutputFormatParquetColumnarStorageCompressionCodec string

const (
	DestinationGcsOutputFormatParquetColumnarStorageCompressionCodecUncompressed DestinationGcsOutputFormatParquetColumnarStorageCompressionCodec = "UNCOMPRESSED"
	DestinationGcsOutputFormatParquetColumnarStorageCompressionCodecSnappy       DestinationGcsOutputFormatParquetColumnarStorageCompressionCodec = "SNAPPY"
	DestinationGcsOutputFormatParquetColumnarStorageCompressionCodecGzip         DestinationGcsOutputFormatParquetColumnarStorageCompressionCodec = "GZIP"
	DestinationGcsOutputFormatParquetColumnarStorageCompressionCodecLzo          DestinationGcsOutputFormatParquetColumnarStorageCompressionCodec = "LZO"
	DestinationGcsOutputFormatParquetColumnarStorageCompressionCodecBrotli       DestinationGcsOutputFormatParquetColumnarStorageCompressionCodec = "BROTLI"
	DestinationGcsOutputFormatParquetColumnarStorageCompressionCodecLz4          DestinationGcsOutputFormatParquetColumnarStorageCompressionCodec = "LZ4"
	DestinationGcsOutputFormatParquetColumnarStorageCompressionCodecZstd         DestinationGcsOutputFormatParquetColumnarStorageCompressionCodec = "ZSTD"
)

func (e DestinationGcsOutputFormatParquetColumnarStorageCompressionCodec) ToPointer() *DestinationGcsOutputFormatParquetColumnarStorageCompressionCodec {
	return &e
}

func (e *DestinationGcsOutputFormatParquetColumnarStorageCompressionCodec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "UNCOMPRESSED":
		fallthrough
	case "SNAPPY":
		fallthrough
	case "GZIP":
		fallthrough
	case "LZO":
		fallthrough
	case "BROTLI":
		fallthrough
	case "LZ4":
		fallthrough
	case "ZSTD":
		*e = DestinationGcsOutputFormatParquetColumnarStorageCompressionCodec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsOutputFormatParquetColumnarStorageCompressionCodec: %v", v)
	}
}

type DestinationGcsOutputFormatParquetColumnarStorageFormatType string

const (
	DestinationGcsOutputFormatParquetColumnarStorageFormatTypeParquet DestinationGcsOutputFormatParquetColumnarStorageFormatType = "Parquet"
)

func (e DestinationGcsOutputFormatParquetColumnarStorageFormatType) ToPointer() *DestinationGcsOutputFormatParquetColumnarStorageFormatType {
	return &e
}

func (e *DestinationGcsOutputFormatParquetColumnarStorageFormatType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Parquet":
		*e = DestinationGcsOutputFormatParquetColumnarStorageFormatType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsOutputFormatParquetColumnarStorageFormatType: %v", v)
	}
}

// DestinationGcsOutputFormatParquetColumnarStorage - Output data format. One of the following formats must be selected - <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-avro#advantages_of_avro">AVRO</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-parquet#parquet_schemas">PARQUET</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-csv#loading_csv_data_into_a_table">CSV</a> format, or <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-json#loading_json_data_into_a_new_table">JSONL</a> format.
type DestinationGcsOutputFormatParquetColumnarStorage struct {
	// This is the size of a row group being buffered in memory. It limits the memory usage when writing. Larger values will improve the IO when reading, but consume more memory when writing. Default: 128 MB.
	BlockSizeMb *int64 `default:"128" json:"block_size_mb"`
	// The compression algorithm used to compress data pages.
	CompressionCodec *DestinationGcsOutputFormatParquetColumnarStorageCompressionCodec `default:"UNCOMPRESSED" json:"compression_codec"`
	// Default: true.
	DictionaryEncoding *bool `default:"true" json:"dictionary_encoding"`
	// There is one dictionary page per column per row group when dictionary encoding is used. The dictionary page size works like the page size but for dictionary. Default: 1024 KB.
	DictionaryPageSizeKb *int64                                                      `default:"1024" json:"dictionary_page_size_kb"`
	FormatType           *DestinationGcsOutputFormatParquetColumnarStorageFormatType `default:"Parquet" json:"format_type"`
	// Maximum size allowed as padding to align row groups. This is also the minimum size of a row group. Default: 8 MB.
	MaxPaddingSizeMb *int64 `default:"8" json:"max_padding_size_mb"`
	// The page size is for compression. A block is composed of pages. A page is the smallest unit that must be read fully to access a single record. If this value is too small, the compression will deteriorate. Default: 1024 KB.
	PageSizeKb *int64 `default:"1024" json:"page_size_kb"`
}

func (d DestinationGcsOutputFormatParquetColumnarStorage) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsOutputFormatParquetColumnarStorage) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationGcsOutputFormatParquetColumnarStorage) GetBlockSizeMb() *int64 {
	if o == nil {
		return nil
	}
	return o.BlockSizeMb
}

func (o *DestinationGcsOutputFormatParquetColumnarStorage) GetCompressionCodec() *DestinationGcsOutputFormatParquetColumnarStorageCompressionCodec {
	if o == nil {
		return nil
	}
	return o.CompressionCodec
}

func (o *DestinationGcsOutputFormatParquetColumnarStorage) GetDictionaryEncoding() *bool {
	if o == nil {
		return nil
	}
	return o.DictionaryEncoding
}

func (o *DestinationGcsOutputFormatParquetColumnarStorage) GetDictionaryPageSizeKb() *int64 {
	if o == nil {
		return nil
	}
	return o.DictionaryPageSizeKb
}

func (o *DestinationGcsOutputFormatParquetColumnarStorage) GetFormatType() *DestinationGcsOutputFormatParquetColumnarStorageFormatType {
	if o == nil {
		return nil
	}
	return o.FormatType
}

func (o *DestinationGcsOutputFormatParquetColumnarStorage) GetMaxPaddingSizeMb() *int64 {
	if o == nil {
		return nil
	}
	return o.MaxPaddingSizeMb
}

func (o *DestinationGcsOutputFormatParquetColumnarStorage) GetPageSizeKb() *int64 {
	if o == nil {
		return nil
	}
	return o.PageSizeKb
}

type DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIPCompressionType string

const (
	DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIPCompressionTypeGzip DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIPCompressionType = "GZIP"
)

func (e DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIPCompressionType) ToPointer() *DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIPCompressionType {
	return &e
}

func (e *DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIPCompressionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "GZIP":
		*e = DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIPCompressionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIPCompressionType: %v", v)
	}
}

// DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP - Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").
type DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP struct {
	CompressionType *DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIPCompressionType `default:"GZIP" json:"compression_type"`
}

func (d DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP) GetCompressionType() *DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIPCompressionType {
	if o == nil {
		return nil
	}
	return o.CompressionType
}

type DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompressionCompressionType string

const (
	DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompressionCompressionTypeNoCompression DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompressionCompressionType = "No Compression"
)

func (e DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompressionCompressionType) ToPointer() *DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompressionCompressionType {
	return &e
}

func (e *DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompressionCompressionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "No Compression":
		*e = DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompressionCompressionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompressionCompressionType: %v", v)
	}
}

// DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression - Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").
type DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression struct {
	CompressionType *DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompressionCompressionType `default:"No Compression" json:"compression_type"`
}

func (d DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression) GetCompressionType() *DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompressionCompressionType {
	if o == nil {
		return nil
	}
	return o.CompressionType
}

type DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionType string

const (
	DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionTypeDestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionType = "destination-gcs_Output Format_JSON Lines: newline-delimited JSON_Compression_No Compression"
	DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionTypeDestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP          DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionType = "destination-gcs_Output Format_JSON Lines: newline-delimited JSON_Compression_GZIP"
)

type DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompression struct {
	DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression *DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression
	DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP          *DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP

	Type DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionType
}

func CreateDestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionDestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression(destinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression) DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompression {
	typ := DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionTypeDestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression

	return DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompression{
		DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression: &destinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression,
		Type: typ,
	}
}

func CreateDestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionDestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP(destinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP) DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompression {
	typ := DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionTypeDestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP

	return DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompression{
		DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP: &destinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP,
		Type: typ,
	}
}

func (u *DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompression) UnmarshalJSON(data []byte) error {

	destinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression := new(DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression)
	if err := utils.UnmarshalJSON(data, &destinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression, "", true, true); err == nil {
		u.DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression = destinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression
		u.Type = DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionTypeDestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression
		return nil
	}

	destinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP := new(DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP)
	if err := utils.UnmarshalJSON(data, &destinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP, "", true, true); err == nil {
		u.DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP = destinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP
		u.Type = DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionTypeDestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompression) MarshalJSON() ([]byte, error) {
	if u.DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression != nil {
		return utils.MarshalJSON(u.DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression, "", true)
	}

	if u.DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP != nil {
		return utils.MarshalJSON(u.DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONFormatType string

const (
	DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONFormatTypeJsonl DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONFormatType = "JSONL"
)

func (e DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONFormatType) ToPointer() *DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONFormatType {
	return &e
}

func (e *DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONFormatType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "JSONL":
		*e = DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONFormatType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONFormatType: %v", v)
	}
}

// DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSON - Output data format. One of the following formats must be selected - <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-avro#advantages_of_avro">AVRO</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-parquet#parquet_schemas">PARQUET</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-csv#loading_csv_data_into_a_table">CSV</a> format, or <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-json#loading_json_data_into_a_new_table">JSONL</a> format.
type DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSON struct {
	// Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").
	Compression *DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompression `json:"compression,omitempty"`
	FormatType  *DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONFormatType  `default:"JSONL" json:"format_type"`
}

func (d DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSON) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSON) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSON) GetCompression() *DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompression {
	if o == nil {
		return nil
	}
	return o.Compression
}

func (o *DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSON) GetFormatType() *DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONFormatType {
	if o == nil {
		return nil
	}
	return o.FormatType
}

type DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIPCompressionType string

const (
	DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIPCompressionTypeGzip DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIPCompressionType = "GZIP"
)

func (e DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIPCompressionType) ToPointer() *DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIPCompressionType {
	return &e
}

func (e *DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIPCompressionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "GZIP":
		*e = DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIPCompressionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIPCompressionType: %v", v)
	}
}

// DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIP - Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".csv.gz").
type DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIP struct {
	CompressionType *DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIPCompressionType `default:"GZIP" json:"compression_type"`
}

func (d DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIP) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIP) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIP) GetCompressionType() *DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIPCompressionType {
	if o == nil {
		return nil
	}
	return o.CompressionType
}

type DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompressionCompressionType string

const (
	DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompressionCompressionTypeNoCompression DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompressionCompressionType = "No Compression"
)

func (e DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompressionCompressionType) ToPointer() *DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompressionCompressionType {
	return &e
}

func (e *DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompressionCompressionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "No Compression":
		*e = DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompressionCompressionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompressionCompressionType: %v", v)
	}
}

// DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompression - Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".csv.gz").
type DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompression struct {
	CompressionType *DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompressionCompressionType `default:"No Compression" json:"compression_type"`
}

func (d DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompression) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompression) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompression) GetCompressionType() *DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompressionCompressionType {
	if o == nil {
		return nil
	}
	return o.CompressionType
}

type DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionType string

const (
	DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionTypeDestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompression DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionType = "destination-gcs_Output Format_CSV: Comma-Separated Values_Compression_No Compression"
	DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionTypeDestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIP          DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionType = "destination-gcs_Output Format_CSV: Comma-Separated Values_Compression_GZIP"
)

type DestinationGcsOutputFormatCSVCommaSeparatedValuesCompression struct {
	DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompression *DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompression
	DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIP          *DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIP

	Type DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionType
}

func CreateDestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionDestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompression(destinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompression DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompression) DestinationGcsOutputFormatCSVCommaSeparatedValuesCompression {
	typ := DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionTypeDestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompression

	return DestinationGcsOutputFormatCSVCommaSeparatedValuesCompression{
		DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompression: &destinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompression,
		Type: typ,
	}
}

func CreateDestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionDestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIP(destinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIP DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIP) DestinationGcsOutputFormatCSVCommaSeparatedValuesCompression {
	typ := DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionTypeDestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIP

	return DestinationGcsOutputFormatCSVCommaSeparatedValuesCompression{
		DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIP: &destinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIP,
		Type: typ,
	}
}

func (u *DestinationGcsOutputFormatCSVCommaSeparatedValuesCompression) UnmarshalJSON(data []byte) error {

	destinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompression := new(DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompression)
	if err := utils.UnmarshalJSON(data, &destinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompression, "", true, true); err == nil {
		u.DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompression = destinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompression
		u.Type = DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionTypeDestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompression
		return nil
	}

	destinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIP := new(DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIP)
	if err := utils.UnmarshalJSON(data, &destinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIP, "", true, true); err == nil {
		u.DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIP = destinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIP
		u.Type = DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionTypeDestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIP
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u DestinationGcsOutputFormatCSVCommaSeparatedValuesCompression) MarshalJSON() ([]byte, error) {
	if u.DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompression != nil {
		return utils.MarshalJSON(u.DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompression, "", true)
	}

	if u.DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIP != nil {
		return utils.MarshalJSON(u.DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIP, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

// DestinationGcsOutputFormatCSVCommaSeparatedValuesNormalization - Whether the input JSON data should be normalized (flattened) in the output CSV. Please refer to docs for details.
type DestinationGcsOutputFormatCSVCommaSeparatedValuesNormalization string

const (
	DestinationGcsOutputFormatCSVCommaSeparatedValuesNormalizationNoFlattening        DestinationGcsOutputFormatCSVCommaSeparatedValuesNormalization = "No flattening"
	DestinationGcsOutputFormatCSVCommaSeparatedValuesNormalizationRootLevelFlattening DestinationGcsOutputFormatCSVCommaSeparatedValuesNormalization = "Root level flattening"
)

func (e DestinationGcsOutputFormatCSVCommaSeparatedValuesNormalization) ToPointer() *DestinationGcsOutputFormatCSVCommaSeparatedValuesNormalization {
	return &e
}

func (e *DestinationGcsOutputFormatCSVCommaSeparatedValuesNormalization) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "No flattening":
		fallthrough
	case "Root level flattening":
		*e = DestinationGcsOutputFormatCSVCommaSeparatedValuesNormalization(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsOutputFormatCSVCommaSeparatedValuesNormalization: %v", v)
	}
}

type DestinationGcsOutputFormatCSVCommaSeparatedValuesFormatType string

const (
	DestinationGcsOutputFormatCSVCommaSeparatedValuesFormatTypeCsv DestinationGcsOutputFormatCSVCommaSeparatedValuesFormatType = "CSV"
)

func (e DestinationGcsOutputFormatCSVCommaSeparatedValuesFormatType) ToPointer() *DestinationGcsOutputFormatCSVCommaSeparatedValuesFormatType {
	return &e
}

func (e *DestinationGcsOutputFormatCSVCommaSeparatedValuesFormatType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CSV":
		*e = DestinationGcsOutputFormatCSVCommaSeparatedValuesFormatType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsOutputFormatCSVCommaSeparatedValuesFormatType: %v", v)
	}
}

// DestinationGcsOutputFormatCSVCommaSeparatedValues - Output data format. One of the following formats must be selected - <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-avro#advantages_of_avro">AVRO</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-parquet#parquet_schemas">PARQUET</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-csv#loading_csv_data_into_a_table">CSV</a> format, or <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-json#loading_json_data_into_a_new_table">JSONL</a> format.
type DestinationGcsOutputFormatCSVCommaSeparatedValues struct {
	// Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".csv.gz").
	Compression *DestinationGcsOutputFormatCSVCommaSeparatedValuesCompression `json:"compression,omitempty"`
	// Whether the input JSON data should be normalized (flattened) in the output CSV. Please refer to docs for details.
	Flattening *DestinationGcsOutputFormatCSVCommaSeparatedValuesNormalization `default:"No flattening" json:"flattening"`
	FormatType *DestinationGcsOutputFormatCSVCommaSeparatedValuesFormatType    `default:"CSV" json:"format_type"`
}

func (d DestinationGcsOutputFormatCSVCommaSeparatedValues) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsOutputFormatCSVCommaSeparatedValues) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationGcsOutputFormatCSVCommaSeparatedValues) GetCompression() *DestinationGcsOutputFormatCSVCommaSeparatedValuesCompression {
	if o == nil {
		return nil
	}
	return o.Compression
}

func (o *DestinationGcsOutputFormatCSVCommaSeparatedValues) GetFlattening() *DestinationGcsOutputFormatCSVCommaSeparatedValuesNormalization {
	if o == nil {
		return nil
	}
	return o.Flattening
}

func (o *DestinationGcsOutputFormatCSVCommaSeparatedValues) GetFormatType() *DestinationGcsOutputFormatCSVCommaSeparatedValuesFormatType {
	if o == nil {
		return nil
	}
	return o.FormatType
}

type DestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappyCodec string

const (
	DestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappyCodecSnappy DestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappyCodec = "snappy"
)

func (e DestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappyCodec) ToPointer() *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappyCodec {
	return &e
}

func (e *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappyCodec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "snappy":
		*e = DestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappyCodec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappyCodec: %v", v)
	}
}

// DestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy - The compression algorithm used to compress data. Default to no compression.
type DestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy struct {
	Codec *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappyCodec `default:"snappy" json:"codec"`
}

func (d DestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy) GetCodec() *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappyCodec {
	if o == nil {
		return nil
	}
	return o.Codec
}

type DestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandardCodec string

const (
	DestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandardCodecZstandard DestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandardCodec = "zstandard"
)

func (e DestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandardCodec) ToPointer() *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandardCodec {
	return &e
}

func (e *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandardCodec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "zstandard":
		*e = DestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandardCodec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandardCodec: %v", v)
	}
}

// DestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard - The compression algorithm used to compress data. Default to no compression.
type DestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard struct {
	Codec *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandardCodec `default:"zstandard" json:"codec"`
	// Negative levels are 'fast' modes akin to lz4 or snappy, levels above 9 are generally for archival purposes, and levels above 18 use a lot of memory.
	CompressionLevel *int64 `default:"3" json:"compression_level"`
	// If true, include a checksum with each data block.
	IncludeChecksum *bool `default:"false" json:"include_checksum"`
}

func (d DestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard) GetCodec() *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandardCodec {
	if o == nil {
		return nil
	}
	return o.Codec
}

func (o *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard) GetCompressionLevel() *int64 {
	if o == nil {
		return nil
	}
	return o.CompressionLevel
}

func (o *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard) GetIncludeChecksum() *bool {
	if o == nil {
		return nil
	}
	return o.IncludeChecksum
}

type DestinationGcsOutputFormatAvroApacheAvroCompressionCodecXzCodec string

const (
	DestinationGcsOutputFormatAvroApacheAvroCompressionCodecXzCodecXz DestinationGcsOutputFormatAvroApacheAvroCompressionCodecXzCodec = "xz"
)

func (e DestinationGcsOutputFormatAvroApacheAvroCompressionCodecXzCodec) ToPointer() *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecXzCodec {
	return &e
}

func (e *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecXzCodec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "xz":
		*e = DestinationGcsOutputFormatAvroApacheAvroCompressionCodecXzCodec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsOutputFormatAvroApacheAvroCompressionCodecXzCodec: %v", v)
	}
}

// DestinationGcsOutputFormatAvroApacheAvroCompressionCodecXz - The compression algorithm used to compress data. Default to no compression.
type DestinationGcsOutputFormatAvroApacheAvroCompressionCodecXz struct {
	Codec *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecXzCodec `default:"xz" json:"codec"`
	// The presets 0-3 are fast presets with medium compression. The presets 4-6 are fairly slow presets with high compression. The default preset is 6. The presets 7-9 are like the preset 6 but use bigger dictionaries and have higher compressor and decompressor memory requirements. Unless the uncompressed size of the file exceeds 8 MiB, 16 MiB, or 32 MiB, it is waste of memory to use the presets 7, 8, or 9, respectively. Read more <a href="https://commons.apache.org/proper/commons-compress/apidocs/org/apache/commons/compress/compressors/xz/XZCompressorOutputStream.html#XZCompressorOutputStream-java.io.OutputStream-int-">here</a> for details.
	CompressionLevel *int64 `default:"6" json:"compression_level"`
}

func (d DestinationGcsOutputFormatAvroApacheAvroCompressionCodecXz) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecXz) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecXz) GetCodec() *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecXzCodec {
	if o == nil {
		return nil
	}
	return o.Codec
}

func (o *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecXz) GetCompressionLevel() *int64 {
	if o == nil {
		return nil
	}
	return o.CompressionLevel
}

type DestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2Codec string

const (
	DestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2CodecBzip2 DestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2Codec = "bzip2"
)

func (e DestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2Codec) ToPointer() *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2Codec {
	return &e
}

func (e *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2Codec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "bzip2":
		*e = DestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2Codec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2Codec: %v", v)
	}
}

// DestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2 - The compression algorithm used to compress data. Default to no compression.
type DestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2 struct {
	Codec *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2Codec `default:"bzip2" json:"codec"`
}

func (d DestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2) GetCodec() *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2Codec {
	if o == nil {
		return nil
	}
	return o.Codec
}

type DestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflateCodec string

const (
	DestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflateCodecDeflate DestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflateCodec = "Deflate"
)

func (e DestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflateCodec) ToPointer() *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflateCodec {
	return &e
}

func (e *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflateCodec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Deflate":
		*e = DestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflateCodec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflateCodec: %v", v)
	}
}

// DestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate - The compression algorithm used to compress data. Default to no compression.
type DestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate struct {
	Codec *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflateCodec `default:"Deflate" json:"codec"`
	// 0: no compression & fastest, 9: best compression & slowest.
	CompressionLevel *int64 `default:"0" json:"compression_level"`
}

func (d DestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate) GetCodec() *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflateCodec {
	if o == nil {
		return nil
	}
	return o.Codec
}

func (o *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate) GetCompressionLevel() *int64 {
	if o == nil {
		return nil
	}
	return o.CompressionLevel
}

type DestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompressionCodec string

const (
	DestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompressionCodecNoCompression DestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompressionCodec = "no compression"
)

func (e DestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompressionCodec) ToPointer() *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompressionCodec {
	return &e
}

func (e *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompressionCodec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "no compression":
		*e = DestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompressionCodec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompressionCodec: %v", v)
	}
}

// DestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression - The compression algorithm used to compress data. Default to no compression.
type DestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression struct {
	Codec *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompressionCodec `default:"no compression" json:"codec"`
}

func (d DestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression) GetCodec() *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompressionCodec {
	if o == nil {
		return nil
	}
	return o.Codec
}

type DestinationGcsOutputFormatAvroApacheAvroCompressionCodecType string

const (
	DestinationGcsOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression DestinationGcsOutputFormatAvroApacheAvroCompressionCodecType = "destination-gcs_Output Format_Avro: Apache Avro_Compression Codec_No Compression"
	DestinationGcsOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate       DestinationGcsOutputFormatAvroApacheAvroCompressionCodecType = "destination-gcs_Output Format_Avro: Apache Avro_Compression Codec_Deflate"
	DestinationGcsOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2         DestinationGcsOutputFormatAvroApacheAvroCompressionCodecType = "destination-gcs_Output Format_Avro: Apache Avro_Compression Codec_bzip2"
	DestinationGcsOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsOutputFormatAvroApacheAvroCompressionCodecXz            DestinationGcsOutputFormatAvroApacheAvroCompressionCodecType = "destination-gcs_Output Format_Avro: Apache Avro_Compression Codec_xz"
	DestinationGcsOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard     DestinationGcsOutputFormatAvroApacheAvroCompressionCodecType = "destination-gcs_Output Format_Avro: Apache Avro_Compression Codec_zstandard"
	DestinationGcsOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy        DestinationGcsOutputFormatAvroApacheAvroCompressionCodecType = "destination-gcs_Output Format_Avro: Apache Avro_Compression Codec_snappy"
)

type DestinationGcsOutputFormatAvroApacheAvroCompressionCodec struct {
	DestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression
	DestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate       *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate
	DestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2         *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2
	DestinationGcsOutputFormatAvroApacheAvroCompressionCodecXz            *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecXz
	DestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard     *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard
	DestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy        *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy

	Type DestinationGcsOutputFormatAvroApacheAvroCompressionCodecType
}

func CreateDestinationGcsOutputFormatAvroApacheAvroCompressionCodecDestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression(destinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression DestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression) DestinationGcsOutputFormatAvroApacheAvroCompressionCodec {
	typ := DestinationGcsOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression

	return DestinationGcsOutputFormatAvroApacheAvroCompressionCodec{
		DestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression: &destinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression,
		Type: typ,
	}
}

func CreateDestinationGcsOutputFormatAvroApacheAvroCompressionCodecDestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate(destinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate DestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate) DestinationGcsOutputFormatAvroApacheAvroCompressionCodec {
	typ := DestinationGcsOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate

	return DestinationGcsOutputFormatAvroApacheAvroCompressionCodec{
		DestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate: &destinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate,
		Type: typ,
	}
}

func CreateDestinationGcsOutputFormatAvroApacheAvroCompressionCodecDestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2(destinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2 DestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2) DestinationGcsOutputFormatAvroApacheAvroCompressionCodec {
	typ := DestinationGcsOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2

	return DestinationGcsOutputFormatAvroApacheAvroCompressionCodec{
		DestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2: &destinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2,
		Type: typ,
	}
}

func CreateDestinationGcsOutputFormatAvroApacheAvroCompressionCodecDestinationGcsOutputFormatAvroApacheAvroCompressionCodecXz(destinationGcsOutputFormatAvroApacheAvroCompressionCodecXz DestinationGcsOutputFormatAvroApacheAvroCompressionCodecXz) DestinationGcsOutputFormatAvroApacheAvroCompressionCodec {
	typ := DestinationGcsOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsOutputFormatAvroApacheAvroCompressionCodecXz

	return DestinationGcsOutputFormatAvroApacheAvroCompressionCodec{
		DestinationGcsOutputFormatAvroApacheAvroCompressionCodecXz: &destinationGcsOutputFormatAvroApacheAvroCompressionCodecXz,
		Type: typ,
	}
}

func CreateDestinationGcsOutputFormatAvroApacheAvroCompressionCodecDestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard(destinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard DestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard) DestinationGcsOutputFormatAvroApacheAvroCompressionCodec {
	typ := DestinationGcsOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard

	return DestinationGcsOutputFormatAvroApacheAvroCompressionCodec{
		DestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard: &destinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard,
		Type: typ,
	}
}

func CreateDestinationGcsOutputFormatAvroApacheAvroCompressionCodecDestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy(destinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy DestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy) DestinationGcsOutputFormatAvroApacheAvroCompressionCodec {
	typ := DestinationGcsOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy

	return DestinationGcsOutputFormatAvroApacheAvroCompressionCodec{
		DestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy: &destinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy,
		Type: typ,
	}
}

func (u *DestinationGcsOutputFormatAvroApacheAvroCompressionCodec) UnmarshalJSON(data []byte) error {

	destinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression := new(DestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression)
	if err := utils.UnmarshalJSON(data, &destinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression, "", true, true); err == nil {
		u.DestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression = destinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression
		u.Type = DestinationGcsOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression
		return nil
	}

	destinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2 := new(DestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2)
	if err := utils.UnmarshalJSON(data, &destinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2, "", true, true); err == nil {
		u.DestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2 = destinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2
		u.Type = DestinationGcsOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2
		return nil
	}

	destinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy := new(DestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy)
	if err := utils.UnmarshalJSON(data, &destinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy, "", true, true); err == nil {
		u.DestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy = destinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy
		u.Type = DestinationGcsOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy
		return nil
	}

	destinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate := new(DestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate)
	if err := utils.UnmarshalJSON(data, &destinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate, "", true, true); err == nil {
		u.DestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate = destinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate
		u.Type = DestinationGcsOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate
		return nil
	}

	destinationGcsOutputFormatAvroApacheAvroCompressionCodecXz := new(DestinationGcsOutputFormatAvroApacheAvroCompressionCodecXz)
	if err := utils.UnmarshalJSON(data, &destinationGcsOutputFormatAvroApacheAvroCompressionCodecXz, "", true, true); err == nil {
		u.DestinationGcsOutputFormatAvroApacheAvroCompressionCodecXz = destinationGcsOutputFormatAvroApacheAvroCompressionCodecXz
		u.Type = DestinationGcsOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsOutputFormatAvroApacheAvroCompressionCodecXz
		return nil
	}

	destinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard := new(DestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard)
	if err := utils.UnmarshalJSON(data, &destinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard, "", true, true); err == nil {
		u.DestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard = destinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard
		u.Type = DestinationGcsOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u DestinationGcsOutputFormatAvroApacheAvroCompressionCodec) MarshalJSON() ([]byte, error) {
	if u.DestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression != nil {
		return utils.MarshalJSON(u.DestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression, "", true)
	}

	if u.DestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate != nil {
		return utils.MarshalJSON(u.DestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate, "", true)
	}

	if u.DestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2 != nil {
		return utils.MarshalJSON(u.DestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2, "", true)
	}

	if u.DestinationGcsOutputFormatAvroApacheAvroCompressionCodecXz != nil {
		return utils.MarshalJSON(u.DestinationGcsOutputFormatAvroApacheAvroCompressionCodecXz, "", true)
	}

	if u.DestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard != nil {
		return utils.MarshalJSON(u.DestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard, "", true)
	}

	if u.DestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy != nil {
		return utils.MarshalJSON(u.DestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type DestinationGcsOutputFormatAvroApacheAvroFormatType string

const (
	DestinationGcsOutputFormatAvroApacheAvroFormatTypeAvro DestinationGcsOutputFormatAvroApacheAvroFormatType = "Avro"
)

func (e DestinationGcsOutputFormatAvroApacheAvroFormatType) ToPointer() *DestinationGcsOutputFormatAvroApacheAvroFormatType {
	return &e
}

func (e *DestinationGcsOutputFormatAvroApacheAvroFormatType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Avro":
		*e = DestinationGcsOutputFormatAvroApacheAvroFormatType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsOutputFormatAvroApacheAvroFormatType: %v", v)
	}
}

// DestinationGcsOutputFormatAvroApacheAvro - Output data format. One of the following formats must be selected - <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-avro#advantages_of_avro">AVRO</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-parquet#parquet_schemas">PARQUET</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-csv#loading_csv_data_into_a_table">CSV</a> format, or <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-json#loading_json_data_into_a_new_table">JSONL</a> format.
type DestinationGcsOutputFormatAvroApacheAvro struct {
	// The compression algorithm used to compress data. Default to no compression.
	CompressionCodec DestinationGcsOutputFormatAvroApacheAvroCompressionCodec `json:"compression_codec"`
	FormatType       *DestinationGcsOutputFormatAvroApacheAvroFormatType      `default:"Avro" json:"format_type"`
}

func (d DestinationGcsOutputFormatAvroApacheAvro) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsOutputFormatAvroApacheAvro) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationGcsOutputFormatAvroApacheAvro) GetCompressionCodec() DestinationGcsOutputFormatAvroApacheAvroCompressionCodec {
	if o == nil {
		return DestinationGcsOutputFormatAvroApacheAvroCompressionCodec{}
	}
	return o.CompressionCodec
}

func (o *DestinationGcsOutputFormatAvroApacheAvro) GetFormatType() *DestinationGcsOutputFormatAvroApacheAvroFormatType {
	if o == nil {
		return nil
	}
	return o.FormatType
}

type DestinationGcsOutputFormatType string

const (
	DestinationGcsOutputFormatTypeDestinationGcsOutputFormatAvroApacheAvro                DestinationGcsOutputFormatType = "destination-gcs_Output Format_Avro: Apache Avro"
	DestinationGcsOutputFormatTypeDestinationGcsOutputFormatCSVCommaSeparatedValues       DestinationGcsOutputFormatType = "destination-gcs_Output Format_CSV: Comma-Separated Values"
	DestinationGcsOutputFormatTypeDestinationGcsOutputFormatJSONLinesNewlineDelimitedJSON DestinationGcsOutputFormatType = "destination-gcs_Output Format_JSON Lines: newline-delimited JSON"
	DestinationGcsOutputFormatTypeDestinationGcsOutputFormatParquetColumnarStorage        DestinationGcsOutputFormatType = "destination-gcs_Output Format_Parquet: Columnar Storage"
)

type DestinationGcsOutputFormat struct {
	DestinationGcsOutputFormatAvroApacheAvro                *DestinationGcsOutputFormatAvroApacheAvro
	DestinationGcsOutputFormatCSVCommaSeparatedValues       *DestinationGcsOutputFormatCSVCommaSeparatedValues
	DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSON *DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSON
	DestinationGcsOutputFormatParquetColumnarStorage        *DestinationGcsOutputFormatParquetColumnarStorage

	Type DestinationGcsOutputFormatType
}

func CreateDestinationGcsOutputFormatDestinationGcsOutputFormatAvroApacheAvro(destinationGcsOutputFormatAvroApacheAvro DestinationGcsOutputFormatAvroApacheAvro) DestinationGcsOutputFormat {
	typ := DestinationGcsOutputFormatTypeDestinationGcsOutputFormatAvroApacheAvro

	return DestinationGcsOutputFormat{
		DestinationGcsOutputFormatAvroApacheAvro: &destinationGcsOutputFormatAvroApacheAvro,
		Type:                                     typ,
	}
}

func CreateDestinationGcsOutputFormatDestinationGcsOutputFormatCSVCommaSeparatedValues(destinationGcsOutputFormatCSVCommaSeparatedValues DestinationGcsOutputFormatCSVCommaSeparatedValues) DestinationGcsOutputFormat {
	typ := DestinationGcsOutputFormatTypeDestinationGcsOutputFormatCSVCommaSeparatedValues

	return DestinationGcsOutputFormat{
		DestinationGcsOutputFormatCSVCommaSeparatedValues: &destinationGcsOutputFormatCSVCommaSeparatedValues,
		Type: typ,
	}
}

func CreateDestinationGcsOutputFormatDestinationGcsOutputFormatJSONLinesNewlineDelimitedJSON(destinationGcsOutputFormatJSONLinesNewlineDelimitedJSON DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSON) DestinationGcsOutputFormat {
	typ := DestinationGcsOutputFormatTypeDestinationGcsOutputFormatJSONLinesNewlineDelimitedJSON

	return DestinationGcsOutputFormat{
		DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSON: &destinationGcsOutputFormatJSONLinesNewlineDelimitedJSON,
		Type: typ,
	}
}

func CreateDestinationGcsOutputFormatDestinationGcsOutputFormatParquetColumnarStorage(destinationGcsOutputFormatParquetColumnarStorage DestinationGcsOutputFormatParquetColumnarStorage) DestinationGcsOutputFormat {
	typ := DestinationGcsOutputFormatTypeDestinationGcsOutputFormatParquetColumnarStorage

	return DestinationGcsOutputFormat{
		DestinationGcsOutputFormatParquetColumnarStorage: &destinationGcsOutputFormatParquetColumnarStorage,
		Type: typ,
	}
}

func (u *DestinationGcsOutputFormat) UnmarshalJSON(data []byte) error {

	destinationGcsOutputFormatAvroApacheAvro := new(DestinationGcsOutputFormatAvroApacheAvro)
	if err := utils.UnmarshalJSON(data, &destinationGcsOutputFormatAvroApacheAvro, "", true, true); err == nil {
		u.DestinationGcsOutputFormatAvroApacheAvro = destinationGcsOutputFormatAvroApacheAvro
		u.Type = DestinationGcsOutputFormatTypeDestinationGcsOutputFormatAvroApacheAvro
		return nil
	}

	destinationGcsOutputFormatJSONLinesNewlineDelimitedJSON := new(DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSON)
	if err := utils.UnmarshalJSON(data, &destinationGcsOutputFormatJSONLinesNewlineDelimitedJSON, "", true, true); err == nil {
		u.DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSON = destinationGcsOutputFormatJSONLinesNewlineDelimitedJSON
		u.Type = DestinationGcsOutputFormatTypeDestinationGcsOutputFormatJSONLinesNewlineDelimitedJSON
		return nil
	}

	destinationGcsOutputFormatCSVCommaSeparatedValues := new(DestinationGcsOutputFormatCSVCommaSeparatedValues)
	if err := utils.UnmarshalJSON(data, &destinationGcsOutputFormatCSVCommaSeparatedValues, "", true, true); err == nil {
		u.DestinationGcsOutputFormatCSVCommaSeparatedValues = destinationGcsOutputFormatCSVCommaSeparatedValues
		u.Type = DestinationGcsOutputFormatTypeDestinationGcsOutputFormatCSVCommaSeparatedValues
		return nil
	}

	destinationGcsOutputFormatParquetColumnarStorage := new(DestinationGcsOutputFormatParquetColumnarStorage)
	if err := utils.UnmarshalJSON(data, &destinationGcsOutputFormatParquetColumnarStorage, "", true, true); err == nil {
		u.DestinationGcsOutputFormatParquetColumnarStorage = destinationGcsOutputFormatParquetColumnarStorage
		u.Type = DestinationGcsOutputFormatTypeDestinationGcsOutputFormatParquetColumnarStorage
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u DestinationGcsOutputFormat) MarshalJSON() ([]byte, error) {
	if u.DestinationGcsOutputFormatAvroApacheAvro != nil {
		return utils.MarshalJSON(u.DestinationGcsOutputFormatAvroApacheAvro, "", true)
	}

	if u.DestinationGcsOutputFormatCSVCommaSeparatedValues != nil {
		return utils.MarshalJSON(u.DestinationGcsOutputFormatCSVCommaSeparatedValues, "", true)
	}

	if u.DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSON != nil {
		return utils.MarshalJSON(u.DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSON, "", true)
	}

	if u.DestinationGcsOutputFormatParquetColumnarStorage != nil {
		return utils.MarshalJSON(u.DestinationGcsOutputFormatParquetColumnarStorage, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

// DestinationGCSGCSBucketRegion - Select a Region of the GCS Bucket. Read more <a href="https://cloud.google.com/storage/docs/locations">here</a>.
type DestinationGCSGCSBucketRegion string

const (
	DestinationGCSGCSBucketRegionNorthamericaNortheast1 DestinationGCSGCSBucketRegion = "northamerica-northeast1"
	DestinationGCSGCSBucketRegionNorthamericaNortheast2 DestinationGCSGCSBucketRegion = "northamerica-northeast2"
	DestinationGCSGCSBucketRegionUsCentral1             DestinationGCSGCSBucketRegion = "us-central1"
	DestinationGCSGCSBucketRegionUsEast1                DestinationGCSGCSBucketRegion = "us-east1"
	DestinationGCSGCSBucketRegionUsEast4                DestinationGCSGCSBucketRegion = "us-east4"
	DestinationGCSGCSBucketRegionUsWest1                DestinationGCSGCSBucketRegion = "us-west1"
	DestinationGCSGCSBucketRegionUsWest2                DestinationGCSGCSBucketRegion = "us-west2"
	DestinationGCSGCSBucketRegionUsWest3                DestinationGCSGCSBucketRegion = "us-west3"
	DestinationGCSGCSBucketRegionUsWest4                DestinationGCSGCSBucketRegion = "us-west4"
	DestinationGCSGCSBucketRegionSouthamericaEast1      DestinationGCSGCSBucketRegion = "southamerica-east1"
	DestinationGCSGCSBucketRegionSouthamericaWest1      DestinationGCSGCSBucketRegion = "southamerica-west1"
	DestinationGCSGCSBucketRegionEuropeCentral2         DestinationGCSGCSBucketRegion = "europe-central2"
	DestinationGCSGCSBucketRegionEuropeNorth1           DestinationGCSGCSBucketRegion = "europe-north1"
	DestinationGCSGCSBucketRegionEuropeWest1            DestinationGCSGCSBucketRegion = "europe-west1"
	DestinationGCSGCSBucketRegionEuropeWest2            DestinationGCSGCSBucketRegion = "europe-west2"
	DestinationGCSGCSBucketRegionEuropeWest3            DestinationGCSGCSBucketRegion = "europe-west3"
	DestinationGCSGCSBucketRegionEuropeWest4            DestinationGCSGCSBucketRegion = "europe-west4"
	DestinationGCSGCSBucketRegionEuropeWest6            DestinationGCSGCSBucketRegion = "europe-west6"
	DestinationGCSGCSBucketRegionAsiaEast1              DestinationGCSGCSBucketRegion = "asia-east1"
	DestinationGCSGCSBucketRegionAsiaEast2              DestinationGCSGCSBucketRegion = "asia-east2"
	DestinationGCSGCSBucketRegionAsiaNortheast1         DestinationGCSGCSBucketRegion = "asia-northeast1"
	DestinationGCSGCSBucketRegionAsiaNortheast2         DestinationGCSGCSBucketRegion = "asia-northeast2"
	DestinationGCSGCSBucketRegionAsiaNortheast3         DestinationGCSGCSBucketRegion = "asia-northeast3"
	DestinationGCSGCSBucketRegionAsiaSouth1             DestinationGCSGCSBucketRegion = "asia-south1"
	DestinationGCSGCSBucketRegionAsiaSouth2             DestinationGCSGCSBucketRegion = "asia-south2"
	DestinationGCSGCSBucketRegionAsiaSoutheast1         DestinationGCSGCSBucketRegion = "asia-southeast1"
	DestinationGCSGCSBucketRegionAsiaSoutheast2         DestinationGCSGCSBucketRegion = "asia-southeast2"
	DestinationGCSGCSBucketRegionAustraliaSoutheast1    DestinationGCSGCSBucketRegion = "australia-southeast1"
	DestinationGCSGCSBucketRegionAustraliaSoutheast2    DestinationGCSGCSBucketRegion = "australia-southeast2"
	DestinationGCSGCSBucketRegionAsia                   DestinationGCSGCSBucketRegion = "asia"
	DestinationGCSGCSBucketRegionEu                     DestinationGCSGCSBucketRegion = "eu"
	DestinationGCSGCSBucketRegionUs                     DestinationGCSGCSBucketRegion = "us"
	DestinationGCSGCSBucketRegionAsia1                  DestinationGCSGCSBucketRegion = "asia1"
	DestinationGCSGCSBucketRegionEur4                   DestinationGCSGCSBucketRegion = "eur4"
	DestinationGCSGCSBucketRegionNam4                   DestinationGCSGCSBucketRegion = "nam4"
)

func (e DestinationGCSGCSBucketRegion) ToPointer() *DestinationGCSGCSBucketRegion {
	return &e
}

func (e *DestinationGCSGCSBucketRegion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "northamerica-northeast1":
		fallthrough
	case "northamerica-northeast2":
		fallthrough
	case "us-central1":
		fallthrough
	case "us-east1":
		fallthrough
	case "us-east4":
		fallthrough
	case "us-west1":
		fallthrough
	case "us-west2":
		fallthrough
	case "us-west3":
		fallthrough
	case "us-west4":
		fallthrough
	case "southamerica-east1":
		fallthrough
	case "southamerica-west1":
		fallthrough
	case "europe-central2":
		fallthrough
	case "europe-north1":
		fallthrough
	case "europe-west1":
		fallthrough
	case "europe-west2":
		fallthrough
	case "europe-west3":
		fallthrough
	case "europe-west4":
		fallthrough
	case "europe-west6":
		fallthrough
	case "asia-east1":
		fallthrough
	case "asia-east2":
		fallthrough
	case "asia-northeast1":
		fallthrough
	case "asia-northeast2":
		fallthrough
	case "asia-northeast3":
		fallthrough
	case "asia-south1":
		fallthrough
	case "asia-south2":
		fallthrough
	case "asia-southeast1":
		fallthrough
	case "asia-southeast2":
		fallthrough
	case "australia-southeast1":
		fallthrough
	case "australia-southeast2":
		fallthrough
	case "asia":
		fallthrough
	case "eu":
		fallthrough
	case "us":
		fallthrough
	case "asia1":
		fallthrough
	case "eur4":
		fallthrough
	case "nam4":
		*e = DestinationGCSGCSBucketRegion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGCSGCSBucketRegion: %v", v)
	}
}

type DestinationGcs struct {
	// An HMAC key is a type of credential and can be associated with a service account or a user account in Cloud Storage. Read more <a href="https://cloud.google.com/storage/docs/authentication/hmackeys">here</a>.
	Credential      DestinationGcsAuthentication `json:"credential"`
	destinationType DestinationGcsGcs            `const:"gcs" json:"destinationType"`
	// Output data format. One of the following formats must be selected - <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-avro#advantages_of_avro">AVRO</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-parquet#parquet_schemas">PARQUET</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-csv#loading_csv_data_into_a_table">CSV</a> format, or <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-json#loading_json_data_into_a_new_table">JSONL</a> format.
	Format DestinationGcsOutputFormat `json:"format"`
	// You can find the bucket name in the App Engine Admin console Application Settings page, under the label Google Cloud Storage Bucket. Read more <a href="https://cloud.google.com/storage/docs/naming-buckets">here</a>.
	GcsBucketName string `json:"gcs_bucket_name"`
	// GCS Bucket Path string Subdirectory under the above bucket to sync the data into.
	GcsBucketPath string `json:"gcs_bucket_path"`
	// Select a Region of the GCS Bucket. Read more <a href="https://cloud.google.com/storage/docs/locations">here</a>.
	GcsBucketRegion *DestinationGCSGCSBucketRegion `default:"us" json:"gcs_bucket_region"`
}

func (d DestinationGcs) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcs) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *DestinationGcs) GetCredential() DestinationGcsAuthentication {
	if o == nil {
		return DestinationGcsAuthentication{}
	}
	return o.Credential
}

func (o *DestinationGcs) GetDestinationType() DestinationGcsGcs {
	return DestinationGcsGcsGcs
}

func (o *DestinationGcs) GetFormat() DestinationGcsOutputFormat {
	if o == nil {
		return DestinationGcsOutputFormat{}
	}
	return o.Format
}

func (o *DestinationGcs) GetGcsBucketName() string {
	if o == nil {
		return ""
	}
	return o.GcsBucketName
}

func (o *DestinationGcs) GetGcsBucketPath() string {
	if o == nil {
		return ""
	}
	return o.GcsBucketPath
}

func (o *DestinationGcs) GetGcsBucketRegion() *DestinationGCSGCSBucketRegion {
	if o == nil {
		return nil
	}
	return o.GcsBucketRegion
}
