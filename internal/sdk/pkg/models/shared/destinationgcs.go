// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
)

type DestinationGcsAuthenticationHMACKeyCredentialType string

const (
	DestinationGcsAuthenticationHMACKeyCredentialTypeHmacKey DestinationGcsAuthenticationHMACKeyCredentialType = "HMAC_KEY"
)

func (e DestinationGcsAuthenticationHMACKeyCredentialType) ToPointer() *DestinationGcsAuthenticationHMACKeyCredentialType {
	return &e
}

func (e *DestinationGcsAuthenticationHMACKeyCredentialType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "HMAC_KEY":
		*e = DestinationGcsAuthenticationHMACKeyCredentialType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsAuthenticationHMACKeyCredentialType: %v", v)
	}
}

// DestinationGcsAuthenticationHMACKey - An HMAC key is a type of credential and can be associated with a service account or a user account in Cloud Storage. Read more <a href="https://cloud.google.com/storage/docs/authentication/hmackeys">here</a>.
type DestinationGcsAuthenticationHMACKey struct {
	CredentialType DestinationGcsAuthenticationHMACKeyCredentialType `json:"credential_type"`
	// When linked to a service account, this ID is 61 characters long; when linked to a user account, it is 24 characters long. Read more <a href="https://cloud.google.com/storage/docs/authentication/hmackeys#overview">here</a>.
	HmacKeyAccessID string `json:"hmac_key_access_id"`
	// The corresponding secret for the access ID. It is a 40-character base-64 encoded string.  Read more <a href="https://cloud.google.com/storage/docs/authentication/hmackeys#secrets">here</a>.
	HmacKeySecret string `json:"hmac_key_secret"`
}

type DestinationGcsAuthenticationType string

const (
	DestinationGcsAuthenticationTypeDestinationGcsAuthenticationHMACKey DestinationGcsAuthenticationType = "destination-gcs_Authentication_HMAC Key"
)

type DestinationGcsAuthentication struct {
	DestinationGcsAuthenticationHMACKey *DestinationGcsAuthenticationHMACKey

	Type DestinationGcsAuthenticationType
}

func CreateDestinationGcsAuthenticationDestinationGcsAuthenticationHMACKey(destinationGcsAuthenticationHMACKey DestinationGcsAuthenticationHMACKey) DestinationGcsAuthentication {
	typ := DestinationGcsAuthenticationTypeDestinationGcsAuthenticationHMACKey

	return DestinationGcsAuthentication{
		DestinationGcsAuthenticationHMACKey: &destinationGcsAuthenticationHMACKey,
		Type:                                typ,
	}
}

func (u *DestinationGcsAuthentication) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	destinationGcsAuthenticationHMACKey := new(DestinationGcsAuthenticationHMACKey)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationGcsAuthenticationHMACKey); err == nil {
		u.DestinationGcsAuthenticationHMACKey = destinationGcsAuthenticationHMACKey
		u.Type = DestinationGcsAuthenticationTypeDestinationGcsAuthenticationHMACKey
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u DestinationGcsAuthentication) MarshalJSON() ([]byte, error) {
	if u.DestinationGcsAuthenticationHMACKey != nil {
		return json.Marshal(u.DestinationGcsAuthenticationHMACKey)
	}

	return nil, nil
}

type DestinationGcsGcs string

const (
	DestinationGcsGcsGcs DestinationGcsGcs = "gcs"
)

func (e DestinationGcsGcs) ToPointer() *DestinationGcsGcs {
	return &e
}

func (e *DestinationGcsGcs) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "gcs":
		*e = DestinationGcsGcs(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsGcs: %v", v)
	}
}

// DestinationGcsOutputFormatParquetColumnarStorageCompressionCodec - The compression algorithm used to compress data pages.
type DestinationGcsOutputFormatParquetColumnarStorageCompressionCodec string

const (
	DestinationGcsOutputFormatParquetColumnarStorageCompressionCodecUncompressed DestinationGcsOutputFormatParquetColumnarStorageCompressionCodec = "UNCOMPRESSED"
	DestinationGcsOutputFormatParquetColumnarStorageCompressionCodecSnappy       DestinationGcsOutputFormatParquetColumnarStorageCompressionCodec = "SNAPPY"
	DestinationGcsOutputFormatParquetColumnarStorageCompressionCodecGzip         DestinationGcsOutputFormatParquetColumnarStorageCompressionCodec = "GZIP"
	DestinationGcsOutputFormatParquetColumnarStorageCompressionCodecLzo          DestinationGcsOutputFormatParquetColumnarStorageCompressionCodec = "LZO"
	DestinationGcsOutputFormatParquetColumnarStorageCompressionCodecBrotli       DestinationGcsOutputFormatParquetColumnarStorageCompressionCodec = "BROTLI"
	DestinationGcsOutputFormatParquetColumnarStorageCompressionCodecLz4          DestinationGcsOutputFormatParquetColumnarStorageCompressionCodec = "LZ4"
	DestinationGcsOutputFormatParquetColumnarStorageCompressionCodecZstd         DestinationGcsOutputFormatParquetColumnarStorageCompressionCodec = "ZSTD"
)

func (e DestinationGcsOutputFormatParquetColumnarStorageCompressionCodec) ToPointer() *DestinationGcsOutputFormatParquetColumnarStorageCompressionCodec {
	return &e
}

func (e *DestinationGcsOutputFormatParquetColumnarStorageCompressionCodec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "UNCOMPRESSED":
		fallthrough
	case "SNAPPY":
		fallthrough
	case "GZIP":
		fallthrough
	case "LZO":
		fallthrough
	case "BROTLI":
		fallthrough
	case "LZ4":
		fallthrough
	case "ZSTD":
		*e = DestinationGcsOutputFormatParquetColumnarStorageCompressionCodec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsOutputFormatParquetColumnarStorageCompressionCodec: %v", v)
	}
}

type DestinationGcsOutputFormatParquetColumnarStorageFormatType string

const (
	DestinationGcsOutputFormatParquetColumnarStorageFormatTypeParquet DestinationGcsOutputFormatParquetColumnarStorageFormatType = "Parquet"
)

func (e DestinationGcsOutputFormatParquetColumnarStorageFormatType) ToPointer() *DestinationGcsOutputFormatParquetColumnarStorageFormatType {
	return &e
}

func (e *DestinationGcsOutputFormatParquetColumnarStorageFormatType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Parquet":
		*e = DestinationGcsOutputFormatParquetColumnarStorageFormatType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsOutputFormatParquetColumnarStorageFormatType: %v", v)
	}
}

// DestinationGcsOutputFormatParquetColumnarStorage - Output data format. One of the following formats must be selected - <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-avro#advantages_of_avro">AVRO</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-parquet#parquet_schemas">PARQUET</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-csv#loading_csv_data_into_a_table">CSV</a> format, or <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-json#loading_json_data_into_a_new_table">JSONL</a> format.
type DestinationGcsOutputFormatParquetColumnarStorage struct {
	// This is the size of a row group being buffered in memory. It limits the memory usage when writing. Larger values will improve the IO when reading, but consume more memory when writing. Default: 128 MB.
	BlockSizeMb *int64 `json:"block_size_mb,omitempty"`
	// The compression algorithm used to compress data pages.
	CompressionCodec *DestinationGcsOutputFormatParquetColumnarStorageCompressionCodec `json:"compression_codec,omitempty"`
	// Default: true.
	DictionaryEncoding *bool `json:"dictionary_encoding,omitempty"`
	// There is one dictionary page per column per row group when dictionary encoding is used. The dictionary page size works like the page size but for dictionary. Default: 1024 KB.
	DictionaryPageSizeKb *int64                                                     `json:"dictionary_page_size_kb,omitempty"`
	FormatType           DestinationGcsOutputFormatParquetColumnarStorageFormatType `json:"format_type"`
	// Maximum size allowed as padding to align row groups. This is also the minimum size of a row group. Default: 8 MB.
	MaxPaddingSizeMb *int64 `json:"max_padding_size_mb,omitempty"`
	// The page size is for compression. A block is composed of pages. A page is the smallest unit that must be read fully to access a single record. If this value is too small, the compression will deteriorate. Default: 1024 KB.
	PageSizeKb *int64 `json:"page_size_kb,omitempty"`
}

type DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIPCompressionType string

const (
	DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIPCompressionTypeGzip DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIPCompressionType = "GZIP"
)

func (e DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIPCompressionType) ToPointer() *DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIPCompressionType {
	return &e
}

func (e *DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIPCompressionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "GZIP":
		*e = DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIPCompressionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIPCompressionType: %v", v)
	}
}

// DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP - Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").
type DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP struct {
	CompressionType *DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIPCompressionType `json:"compression_type,omitempty"`
}

type DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompressionCompressionType string

const (
	DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompressionCompressionTypeNoCompression DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompressionCompressionType = "No Compression"
)

func (e DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompressionCompressionType) ToPointer() *DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompressionCompressionType {
	return &e
}

func (e *DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompressionCompressionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "No Compression":
		*e = DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompressionCompressionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompressionCompressionType: %v", v)
	}
}

// DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression - Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").
type DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression struct {
	CompressionType *DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompressionCompressionType `json:"compression_type,omitempty"`
}

type DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionType string

const (
	DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionTypeDestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionType = "destination-gcs_Output Format_JSON Lines: newline-delimited JSON_Compression_No Compression"
	DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionTypeDestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP          DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionType = "destination-gcs_Output Format_JSON Lines: newline-delimited JSON_Compression_GZIP"
)

type DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompression struct {
	DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression *DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression
	DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP          *DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP

	Type DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionType
}

func CreateDestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionDestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression(destinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression) DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompression {
	typ := DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionTypeDestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression

	return DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompression{
		DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression: &destinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression,
		Type: typ,
	}
}

func CreateDestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionDestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP(destinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP) DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompression {
	typ := DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionTypeDestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP

	return DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompression{
		DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP: &destinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP,
		Type: typ,
	}
}

func (u *DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompression) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	destinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression := new(DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression); err == nil {
		u.DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression = destinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression
		u.Type = DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionTypeDestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression
		return nil
	}

	destinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP := new(DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP); err == nil {
		u.DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP = destinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP
		u.Type = DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionTypeDestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompression) MarshalJSON() ([]byte, error) {
	if u.DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression != nil {
		return json.Marshal(u.DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression)
	}

	if u.DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP != nil {
		return json.Marshal(u.DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP)
	}

	return nil, nil
}

type DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONFormatType string

const (
	DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONFormatTypeJsonl DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONFormatType = "JSONL"
)

func (e DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONFormatType) ToPointer() *DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONFormatType {
	return &e
}

func (e *DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONFormatType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "JSONL":
		*e = DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONFormatType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONFormatType: %v", v)
	}
}

// DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSON - Output data format. One of the following formats must be selected - <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-avro#advantages_of_avro">AVRO</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-parquet#parquet_schemas">PARQUET</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-csv#loading_csv_data_into_a_table">CSV</a> format, or <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-json#loading_json_data_into_a_new_table">JSONL</a> format.
type DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSON struct {
	// Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").
	Compression *DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONCompression `json:"compression,omitempty"`
	FormatType  DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSONFormatType   `json:"format_type"`
}

type DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIPCompressionType string

const (
	DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIPCompressionTypeGzip DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIPCompressionType = "GZIP"
)

func (e DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIPCompressionType) ToPointer() *DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIPCompressionType {
	return &e
}

func (e *DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIPCompressionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "GZIP":
		*e = DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIPCompressionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIPCompressionType: %v", v)
	}
}

// DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIP - Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".csv.gz").
type DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIP struct {
	CompressionType *DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIPCompressionType `json:"compression_type,omitempty"`
}

type DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompressionCompressionType string

const (
	DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompressionCompressionTypeNoCompression DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompressionCompressionType = "No Compression"
)

func (e DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompressionCompressionType) ToPointer() *DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompressionCompressionType {
	return &e
}

func (e *DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompressionCompressionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "No Compression":
		*e = DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompressionCompressionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompressionCompressionType: %v", v)
	}
}

// DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompression - Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".csv.gz").
type DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompression struct {
	CompressionType *DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompressionCompressionType `json:"compression_type,omitempty"`
}

type DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionType string

const (
	DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionTypeDestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompression DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionType = "destination-gcs_Output Format_CSV: Comma-Separated Values_Compression_No Compression"
	DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionTypeDestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIP          DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionType = "destination-gcs_Output Format_CSV: Comma-Separated Values_Compression_GZIP"
)

type DestinationGcsOutputFormatCSVCommaSeparatedValuesCompression struct {
	DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompression *DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompression
	DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIP          *DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIP

	Type DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionType
}

func CreateDestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionDestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompression(destinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompression DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompression) DestinationGcsOutputFormatCSVCommaSeparatedValuesCompression {
	typ := DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionTypeDestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompression

	return DestinationGcsOutputFormatCSVCommaSeparatedValuesCompression{
		DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompression: &destinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompression,
		Type: typ,
	}
}

func CreateDestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionDestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIP(destinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIP DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIP) DestinationGcsOutputFormatCSVCommaSeparatedValuesCompression {
	typ := DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionTypeDestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIP

	return DestinationGcsOutputFormatCSVCommaSeparatedValuesCompression{
		DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIP: &destinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIP,
		Type: typ,
	}
}

func (u *DestinationGcsOutputFormatCSVCommaSeparatedValuesCompression) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	destinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompression := new(DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompression)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompression); err == nil {
		u.DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompression = destinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompression
		u.Type = DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionTypeDestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompression
		return nil
	}

	destinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIP := new(DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIP)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIP); err == nil {
		u.DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIP = destinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIP
		u.Type = DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionTypeDestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIP
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u DestinationGcsOutputFormatCSVCommaSeparatedValuesCompression) MarshalJSON() ([]byte, error) {
	if u.DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompression != nil {
		return json.Marshal(u.DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionNoCompression)
	}

	if u.DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIP != nil {
		return json.Marshal(u.DestinationGcsOutputFormatCSVCommaSeparatedValuesCompressionGZIP)
	}

	return nil, nil
}

// DestinationGcsOutputFormatCSVCommaSeparatedValuesNormalization - Whether the input JSON data should be normalized (flattened) in the output CSV. Please refer to docs for details.
type DestinationGcsOutputFormatCSVCommaSeparatedValuesNormalization string

const (
	DestinationGcsOutputFormatCSVCommaSeparatedValuesNormalizationNoFlattening        DestinationGcsOutputFormatCSVCommaSeparatedValuesNormalization = "No flattening"
	DestinationGcsOutputFormatCSVCommaSeparatedValuesNormalizationRootLevelFlattening DestinationGcsOutputFormatCSVCommaSeparatedValuesNormalization = "Root level flattening"
)

func (e DestinationGcsOutputFormatCSVCommaSeparatedValuesNormalization) ToPointer() *DestinationGcsOutputFormatCSVCommaSeparatedValuesNormalization {
	return &e
}

func (e *DestinationGcsOutputFormatCSVCommaSeparatedValuesNormalization) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "No flattening":
		fallthrough
	case "Root level flattening":
		*e = DestinationGcsOutputFormatCSVCommaSeparatedValuesNormalization(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsOutputFormatCSVCommaSeparatedValuesNormalization: %v", v)
	}
}

type DestinationGcsOutputFormatCSVCommaSeparatedValuesFormatType string

const (
	DestinationGcsOutputFormatCSVCommaSeparatedValuesFormatTypeCsv DestinationGcsOutputFormatCSVCommaSeparatedValuesFormatType = "CSV"
)

func (e DestinationGcsOutputFormatCSVCommaSeparatedValuesFormatType) ToPointer() *DestinationGcsOutputFormatCSVCommaSeparatedValuesFormatType {
	return &e
}

func (e *DestinationGcsOutputFormatCSVCommaSeparatedValuesFormatType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CSV":
		*e = DestinationGcsOutputFormatCSVCommaSeparatedValuesFormatType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsOutputFormatCSVCommaSeparatedValuesFormatType: %v", v)
	}
}

// DestinationGcsOutputFormatCSVCommaSeparatedValues - Output data format. One of the following formats must be selected - <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-avro#advantages_of_avro">AVRO</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-parquet#parquet_schemas">PARQUET</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-csv#loading_csv_data_into_a_table">CSV</a> format, or <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-json#loading_json_data_into_a_new_table">JSONL</a> format.
type DestinationGcsOutputFormatCSVCommaSeparatedValues struct {
	// Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".csv.gz").
	Compression *DestinationGcsOutputFormatCSVCommaSeparatedValuesCompression `json:"compression,omitempty"`
	// Whether the input JSON data should be normalized (flattened) in the output CSV. Please refer to docs for details.
	Flattening *DestinationGcsOutputFormatCSVCommaSeparatedValuesNormalization `json:"flattening,omitempty"`
	FormatType DestinationGcsOutputFormatCSVCommaSeparatedValuesFormatType     `json:"format_type"`
}

type DestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappyCodec string

const (
	DestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappyCodecSnappy DestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappyCodec = "snappy"
)

func (e DestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappyCodec) ToPointer() *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappyCodec {
	return &e
}

func (e *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappyCodec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "snappy":
		*e = DestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappyCodec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappyCodec: %v", v)
	}
}

// DestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy - The compression algorithm used to compress data. Default to no compression.
type DestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy struct {
	Codec DestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappyCodec `json:"codec"`
}

type DestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandardCodec string

const (
	DestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandardCodecZstandard DestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandardCodec = "zstandard"
)

func (e DestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandardCodec) ToPointer() *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandardCodec {
	return &e
}

func (e *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandardCodec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "zstandard":
		*e = DestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandardCodec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandardCodec: %v", v)
	}
}

// DestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard - The compression algorithm used to compress data. Default to no compression.
type DestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard struct {
	Codec DestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandardCodec `json:"codec"`
	// Negative levels are 'fast' modes akin to lz4 or snappy, levels above 9 are generally for archival purposes, and levels above 18 use a lot of memory.
	CompressionLevel *int64 `json:"compression_level,omitempty"`
	// If true, include a checksum with each data block.
	IncludeChecksum *bool `json:"include_checksum,omitempty"`
}

type DestinationGcsOutputFormatAvroApacheAvroCompressionCodecXzCodec string

const (
	DestinationGcsOutputFormatAvroApacheAvroCompressionCodecXzCodecXz DestinationGcsOutputFormatAvroApacheAvroCompressionCodecXzCodec = "xz"
)

func (e DestinationGcsOutputFormatAvroApacheAvroCompressionCodecXzCodec) ToPointer() *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecXzCodec {
	return &e
}

func (e *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecXzCodec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "xz":
		*e = DestinationGcsOutputFormatAvroApacheAvroCompressionCodecXzCodec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsOutputFormatAvroApacheAvroCompressionCodecXzCodec: %v", v)
	}
}

// DestinationGcsOutputFormatAvroApacheAvroCompressionCodecXz - The compression algorithm used to compress data. Default to no compression.
type DestinationGcsOutputFormatAvroApacheAvroCompressionCodecXz struct {
	Codec DestinationGcsOutputFormatAvroApacheAvroCompressionCodecXzCodec `json:"codec"`
	// The presets 0-3 are fast presets with medium compression. The presets 4-6 are fairly slow presets with high compression. The default preset is 6. The presets 7-9 are like the preset 6 but use bigger dictionaries and have higher compressor and decompressor memory requirements. Unless the uncompressed size of the file exceeds 8 MiB, 16 MiB, or 32 MiB, it is waste of memory to use the presets 7, 8, or 9, respectively. Read more <a href="https://commons.apache.org/proper/commons-compress/apidocs/org/apache/commons/compress/compressors/xz/XZCompressorOutputStream.html#XZCompressorOutputStream-java.io.OutputStream-int-">here</a> for details.
	CompressionLevel *int64 `json:"compression_level,omitempty"`
}

type DestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2Codec string

const (
	DestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2CodecBzip2 DestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2Codec = "bzip2"
)

func (e DestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2Codec) ToPointer() *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2Codec {
	return &e
}

func (e *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2Codec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "bzip2":
		*e = DestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2Codec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2Codec: %v", v)
	}
}

// DestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2 - The compression algorithm used to compress data. Default to no compression.
type DestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2 struct {
	Codec DestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2Codec `json:"codec"`
}

type DestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflateCodec string

const (
	DestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflateCodecDeflate DestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflateCodec = "Deflate"
)

func (e DestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflateCodec) ToPointer() *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflateCodec {
	return &e
}

func (e *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflateCodec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Deflate":
		*e = DestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflateCodec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflateCodec: %v", v)
	}
}

// DestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate - The compression algorithm used to compress data. Default to no compression.
type DestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate struct {
	Codec DestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflateCodec `json:"codec"`
	// 0: no compression & fastest, 9: best compression & slowest.
	CompressionLevel *int64 `json:"compression_level,omitempty"`
}

type DestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompressionCodec string

const (
	DestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompressionCodecNoCompression DestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompressionCodec = "no compression"
)

func (e DestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompressionCodec) ToPointer() *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompressionCodec {
	return &e
}

func (e *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompressionCodec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "no compression":
		*e = DestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompressionCodec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompressionCodec: %v", v)
	}
}

// DestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression - The compression algorithm used to compress data. Default to no compression.
type DestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression struct {
	Codec DestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompressionCodec `json:"codec"`
}

type DestinationGcsOutputFormatAvroApacheAvroCompressionCodecType string

const (
	DestinationGcsOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression DestinationGcsOutputFormatAvroApacheAvroCompressionCodecType = "destination-gcs_Output Format_Avro: Apache Avro_Compression Codec_No Compression"
	DestinationGcsOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate       DestinationGcsOutputFormatAvroApacheAvroCompressionCodecType = "destination-gcs_Output Format_Avro: Apache Avro_Compression Codec_Deflate"
	DestinationGcsOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2         DestinationGcsOutputFormatAvroApacheAvroCompressionCodecType = "destination-gcs_Output Format_Avro: Apache Avro_Compression Codec_bzip2"
	DestinationGcsOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsOutputFormatAvroApacheAvroCompressionCodecXz            DestinationGcsOutputFormatAvroApacheAvroCompressionCodecType = "destination-gcs_Output Format_Avro: Apache Avro_Compression Codec_xz"
	DestinationGcsOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard     DestinationGcsOutputFormatAvroApacheAvroCompressionCodecType = "destination-gcs_Output Format_Avro: Apache Avro_Compression Codec_zstandard"
	DestinationGcsOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy        DestinationGcsOutputFormatAvroApacheAvroCompressionCodecType = "destination-gcs_Output Format_Avro: Apache Avro_Compression Codec_snappy"
)

type DestinationGcsOutputFormatAvroApacheAvroCompressionCodec struct {
	DestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression
	DestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate       *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate
	DestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2         *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2
	DestinationGcsOutputFormatAvroApacheAvroCompressionCodecXz            *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecXz
	DestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard     *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard
	DestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy        *DestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy

	Type DestinationGcsOutputFormatAvroApacheAvroCompressionCodecType
}

func CreateDestinationGcsOutputFormatAvroApacheAvroCompressionCodecDestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression(destinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression DestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression) DestinationGcsOutputFormatAvroApacheAvroCompressionCodec {
	typ := DestinationGcsOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression

	return DestinationGcsOutputFormatAvroApacheAvroCompressionCodec{
		DestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression: &destinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression,
		Type: typ,
	}
}

func CreateDestinationGcsOutputFormatAvroApacheAvroCompressionCodecDestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate(destinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate DestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate) DestinationGcsOutputFormatAvroApacheAvroCompressionCodec {
	typ := DestinationGcsOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate

	return DestinationGcsOutputFormatAvroApacheAvroCompressionCodec{
		DestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate: &destinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate,
		Type: typ,
	}
}

func CreateDestinationGcsOutputFormatAvroApacheAvroCompressionCodecDestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2(destinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2 DestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2) DestinationGcsOutputFormatAvroApacheAvroCompressionCodec {
	typ := DestinationGcsOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2

	return DestinationGcsOutputFormatAvroApacheAvroCompressionCodec{
		DestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2: &destinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2,
		Type: typ,
	}
}

func CreateDestinationGcsOutputFormatAvroApacheAvroCompressionCodecDestinationGcsOutputFormatAvroApacheAvroCompressionCodecXz(destinationGcsOutputFormatAvroApacheAvroCompressionCodecXz DestinationGcsOutputFormatAvroApacheAvroCompressionCodecXz) DestinationGcsOutputFormatAvroApacheAvroCompressionCodec {
	typ := DestinationGcsOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsOutputFormatAvroApacheAvroCompressionCodecXz

	return DestinationGcsOutputFormatAvroApacheAvroCompressionCodec{
		DestinationGcsOutputFormatAvroApacheAvroCompressionCodecXz: &destinationGcsOutputFormatAvroApacheAvroCompressionCodecXz,
		Type: typ,
	}
}

func CreateDestinationGcsOutputFormatAvroApacheAvroCompressionCodecDestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard(destinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard DestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard) DestinationGcsOutputFormatAvroApacheAvroCompressionCodec {
	typ := DestinationGcsOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard

	return DestinationGcsOutputFormatAvroApacheAvroCompressionCodec{
		DestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard: &destinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard,
		Type: typ,
	}
}

func CreateDestinationGcsOutputFormatAvroApacheAvroCompressionCodecDestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy(destinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy DestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy) DestinationGcsOutputFormatAvroApacheAvroCompressionCodec {
	typ := DestinationGcsOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy

	return DestinationGcsOutputFormatAvroApacheAvroCompressionCodec{
		DestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy: &destinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy,
		Type: typ,
	}
}

func (u *DestinationGcsOutputFormatAvroApacheAvroCompressionCodec) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	destinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression := new(DestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression); err == nil {
		u.DestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression = destinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression
		u.Type = DestinationGcsOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression
		return nil
	}

	destinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2 := new(DestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2); err == nil {
		u.DestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2 = destinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2
		u.Type = DestinationGcsOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2
		return nil
	}

	destinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy := new(DestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy); err == nil {
		u.DestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy = destinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy
		u.Type = DestinationGcsOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy
		return nil
	}

	destinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate := new(DestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate); err == nil {
		u.DestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate = destinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate
		u.Type = DestinationGcsOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate
		return nil
	}

	destinationGcsOutputFormatAvroApacheAvroCompressionCodecXz := new(DestinationGcsOutputFormatAvroApacheAvroCompressionCodecXz)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationGcsOutputFormatAvroApacheAvroCompressionCodecXz); err == nil {
		u.DestinationGcsOutputFormatAvroApacheAvroCompressionCodecXz = destinationGcsOutputFormatAvroApacheAvroCompressionCodecXz
		u.Type = DestinationGcsOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsOutputFormatAvroApacheAvroCompressionCodecXz
		return nil
	}

	destinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard := new(DestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard); err == nil {
		u.DestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard = destinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard
		u.Type = DestinationGcsOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u DestinationGcsOutputFormatAvroApacheAvroCompressionCodec) MarshalJSON() ([]byte, error) {
	if u.DestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression != nil {
		return json.Marshal(u.DestinationGcsOutputFormatAvroApacheAvroCompressionCodecNoCompression)
	}

	if u.DestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2 != nil {
		return json.Marshal(u.DestinationGcsOutputFormatAvroApacheAvroCompressionCodecBzip2)
	}

	if u.DestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy != nil {
		return json.Marshal(u.DestinationGcsOutputFormatAvroApacheAvroCompressionCodecSnappy)
	}

	if u.DestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate != nil {
		return json.Marshal(u.DestinationGcsOutputFormatAvroApacheAvroCompressionCodecDeflate)
	}

	if u.DestinationGcsOutputFormatAvroApacheAvroCompressionCodecXz != nil {
		return json.Marshal(u.DestinationGcsOutputFormatAvroApacheAvroCompressionCodecXz)
	}

	if u.DestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard != nil {
		return json.Marshal(u.DestinationGcsOutputFormatAvroApacheAvroCompressionCodecZstandard)
	}

	return nil, nil
}

type DestinationGcsOutputFormatAvroApacheAvroFormatType string

const (
	DestinationGcsOutputFormatAvroApacheAvroFormatTypeAvro DestinationGcsOutputFormatAvroApacheAvroFormatType = "Avro"
)

func (e DestinationGcsOutputFormatAvroApacheAvroFormatType) ToPointer() *DestinationGcsOutputFormatAvroApacheAvroFormatType {
	return &e
}

func (e *DestinationGcsOutputFormatAvroApacheAvroFormatType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Avro":
		*e = DestinationGcsOutputFormatAvroApacheAvroFormatType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsOutputFormatAvroApacheAvroFormatType: %v", v)
	}
}

// DestinationGcsOutputFormatAvroApacheAvro - Output data format. One of the following formats must be selected - <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-avro#advantages_of_avro">AVRO</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-parquet#parquet_schemas">PARQUET</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-csv#loading_csv_data_into_a_table">CSV</a> format, or <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-json#loading_json_data_into_a_new_table">JSONL</a> format.
type DestinationGcsOutputFormatAvroApacheAvro struct {
	// The compression algorithm used to compress data. Default to no compression.
	CompressionCodec DestinationGcsOutputFormatAvroApacheAvroCompressionCodec `json:"compression_codec"`
	FormatType       DestinationGcsOutputFormatAvroApacheAvroFormatType       `json:"format_type"`
}

type DestinationGcsOutputFormatType string

const (
	DestinationGcsOutputFormatTypeDestinationGcsOutputFormatAvroApacheAvro                DestinationGcsOutputFormatType = "destination-gcs_Output Format_Avro: Apache Avro"
	DestinationGcsOutputFormatTypeDestinationGcsOutputFormatCSVCommaSeparatedValues       DestinationGcsOutputFormatType = "destination-gcs_Output Format_CSV: Comma-Separated Values"
	DestinationGcsOutputFormatTypeDestinationGcsOutputFormatJSONLinesNewlineDelimitedJSON DestinationGcsOutputFormatType = "destination-gcs_Output Format_JSON Lines: newline-delimited JSON"
	DestinationGcsOutputFormatTypeDestinationGcsOutputFormatParquetColumnarStorage        DestinationGcsOutputFormatType = "destination-gcs_Output Format_Parquet: Columnar Storage"
)

type DestinationGcsOutputFormat struct {
	DestinationGcsOutputFormatAvroApacheAvro                *DestinationGcsOutputFormatAvroApacheAvro
	DestinationGcsOutputFormatCSVCommaSeparatedValues       *DestinationGcsOutputFormatCSVCommaSeparatedValues
	DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSON *DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSON
	DestinationGcsOutputFormatParquetColumnarStorage        *DestinationGcsOutputFormatParquetColumnarStorage

	Type DestinationGcsOutputFormatType
}

func CreateDestinationGcsOutputFormatDestinationGcsOutputFormatAvroApacheAvro(destinationGcsOutputFormatAvroApacheAvro DestinationGcsOutputFormatAvroApacheAvro) DestinationGcsOutputFormat {
	typ := DestinationGcsOutputFormatTypeDestinationGcsOutputFormatAvroApacheAvro

	return DestinationGcsOutputFormat{
		DestinationGcsOutputFormatAvroApacheAvro: &destinationGcsOutputFormatAvroApacheAvro,
		Type:                                     typ,
	}
}

func CreateDestinationGcsOutputFormatDestinationGcsOutputFormatCSVCommaSeparatedValues(destinationGcsOutputFormatCSVCommaSeparatedValues DestinationGcsOutputFormatCSVCommaSeparatedValues) DestinationGcsOutputFormat {
	typ := DestinationGcsOutputFormatTypeDestinationGcsOutputFormatCSVCommaSeparatedValues

	return DestinationGcsOutputFormat{
		DestinationGcsOutputFormatCSVCommaSeparatedValues: &destinationGcsOutputFormatCSVCommaSeparatedValues,
		Type: typ,
	}
}

func CreateDestinationGcsOutputFormatDestinationGcsOutputFormatJSONLinesNewlineDelimitedJSON(destinationGcsOutputFormatJSONLinesNewlineDelimitedJSON DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSON) DestinationGcsOutputFormat {
	typ := DestinationGcsOutputFormatTypeDestinationGcsOutputFormatJSONLinesNewlineDelimitedJSON

	return DestinationGcsOutputFormat{
		DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSON: &destinationGcsOutputFormatJSONLinesNewlineDelimitedJSON,
		Type: typ,
	}
}

func CreateDestinationGcsOutputFormatDestinationGcsOutputFormatParquetColumnarStorage(destinationGcsOutputFormatParquetColumnarStorage DestinationGcsOutputFormatParquetColumnarStorage) DestinationGcsOutputFormat {
	typ := DestinationGcsOutputFormatTypeDestinationGcsOutputFormatParquetColumnarStorage

	return DestinationGcsOutputFormat{
		DestinationGcsOutputFormatParquetColumnarStorage: &destinationGcsOutputFormatParquetColumnarStorage,
		Type: typ,
	}
}

func (u *DestinationGcsOutputFormat) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	destinationGcsOutputFormatAvroApacheAvro := new(DestinationGcsOutputFormatAvroApacheAvro)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationGcsOutputFormatAvroApacheAvro); err == nil {
		u.DestinationGcsOutputFormatAvroApacheAvro = destinationGcsOutputFormatAvroApacheAvro
		u.Type = DestinationGcsOutputFormatTypeDestinationGcsOutputFormatAvroApacheAvro
		return nil
	}

	destinationGcsOutputFormatJSONLinesNewlineDelimitedJSON := new(DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSON)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationGcsOutputFormatJSONLinesNewlineDelimitedJSON); err == nil {
		u.DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSON = destinationGcsOutputFormatJSONLinesNewlineDelimitedJSON
		u.Type = DestinationGcsOutputFormatTypeDestinationGcsOutputFormatJSONLinesNewlineDelimitedJSON
		return nil
	}

	destinationGcsOutputFormatCSVCommaSeparatedValues := new(DestinationGcsOutputFormatCSVCommaSeparatedValues)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationGcsOutputFormatCSVCommaSeparatedValues); err == nil {
		u.DestinationGcsOutputFormatCSVCommaSeparatedValues = destinationGcsOutputFormatCSVCommaSeparatedValues
		u.Type = DestinationGcsOutputFormatTypeDestinationGcsOutputFormatCSVCommaSeparatedValues
		return nil
	}

	destinationGcsOutputFormatParquetColumnarStorage := new(DestinationGcsOutputFormatParquetColumnarStorage)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationGcsOutputFormatParquetColumnarStorage); err == nil {
		u.DestinationGcsOutputFormatParquetColumnarStorage = destinationGcsOutputFormatParquetColumnarStorage
		u.Type = DestinationGcsOutputFormatTypeDestinationGcsOutputFormatParquetColumnarStorage
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u DestinationGcsOutputFormat) MarshalJSON() ([]byte, error) {
	if u.DestinationGcsOutputFormatAvroApacheAvro != nil {
		return json.Marshal(u.DestinationGcsOutputFormatAvroApacheAvro)
	}

	if u.DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSON != nil {
		return json.Marshal(u.DestinationGcsOutputFormatJSONLinesNewlineDelimitedJSON)
	}

	if u.DestinationGcsOutputFormatCSVCommaSeparatedValues != nil {
		return json.Marshal(u.DestinationGcsOutputFormatCSVCommaSeparatedValues)
	}

	if u.DestinationGcsOutputFormatParquetColumnarStorage != nil {
		return json.Marshal(u.DestinationGcsOutputFormatParquetColumnarStorage)
	}

	return nil, nil
}

// DestinationGCSGCSBucketRegion - Select a Region of the GCS Bucket. Read more <a href="https://cloud.google.com/storage/docs/locations">here</a>.
type DestinationGCSGCSBucketRegion string

const (
	DestinationGCSGCSBucketRegionNorthamericaNortheast1 DestinationGCSGCSBucketRegion = "northamerica-northeast1"
	DestinationGCSGCSBucketRegionNorthamericaNortheast2 DestinationGCSGCSBucketRegion = "northamerica-northeast2"
	DestinationGCSGCSBucketRegionUsCentral1             DestinationGCSGCSBucketRegion = "us-central1"
	DestinationGCSGCSBucketRegionUsEast1                DestinationGCSGCSBucketRegion = "us-east1"
	DestinationGCSGCSBucketRegionUsEast4                DestinationGCSGCSBucketRegion = "us-east4"
	DestinationGCSGCSBucketRegionUsWest1                DestinationGCSGCSBucketRegion = "us-west1"
	DestinationGCSGCSBucketRegionUsWest2                DestinationGCSGCSBucketRegion = "us-west2"
	DestinationGCSGCSBucketRegionUsWest3                DestinationGCSGCSBucketRegion = "us-west3"
	DestinationGCSGCSBucketRegionUsWest4                DestinationGCSGCSBucketRegion = "us-west4"
	DestinationGCSGCSBucketRegionSouthamericaEast1      DestinationGCSGCSBucketRegion = "southamerica-east1"
	DestinationGCSGCSBucketRegionSouthamericaWest1      DestinationGCSGCSBucketRegion = "southamerica-west1"
	DestinationGCSGCSBucketRegionEuropeCentral2         DestinationGCSGCSBucketRegion = "europe-central2"
	DestinationGCSGCSBucketRegionEuropeNorth1           DestinationGCSGCSBucketRegion = "europe-north1"
	DestinationGCSGCSBucketRegionEuropeWest1            DestinationGCSGCSBucketRegion = "europe-west1"
	DestinationGCSGCSBucketRegionEuropeWest2            DestinationGCSGCSBucketRegion = "europe-west2"
	DestinationGCSGCSBucketRegionEuropeWest3            DestinationGCSGCSBucketRegion = "europe-west3"
	DestinationGCSGCSBucketRegionEuropeWest4            DestinationGCSGCSBucketRegion = "europe-west4"
	DestinationGCSGCSBucketRegionEuropeWest6            DestinationGCSGCSBucketRegion = "europe-west6"
	DestinationGCSGCSBucketRegionAsiaEast1              DestinationGCSGCSBucketRegion = "asia-east1"
	DestinationGCSGCSBucketRegionAsiaEast2              DestinationGCSGCSBucketRegion = "asia-east2"
	DestinationGCSGCSBucketRegionAsiaNortheast1         DestinationGCSGCSBucketRegion = "asia-northeast1"
	DestinationGCSGCSBucketRegionAsiaNortheast2         DestinationGCSGCSBucketRegion = "asia-northeast2"
	DestinationGCSGCSBucketRegionAsiaNortheast3         DestinationGCSGCSBucketRegion = "asia-northeast3"
	DestinationGCSGCSBucketRegionAsiaSouth1             DestinationGCSGCSBucketRegion = "asia-south1"
	DestinationGCSGCSBucketRegionAsiaSouth2             DestinationGCSGCSBucketRegion = "asia-south2"
	DestinationGCSGCSBucketRegionAsiaSoutheast1         DestinationGCSGCSBucketRegion = "asia-southeast1"
	DestinationGCSGCSBucketRegionAsiaSoutheast2         DestinationGCSGCSBucketRegion = "asia-southeast2"
	DestinationGCSGCSBucketRegionAustraliaSoutheast1    DestinationGCSGCSBucketRegion = "australia-southeast1"
	DestinationGCSGCSBucketRegionAustraliaSoutheast2    DestinationGCSGCSBucketRegion = "australia-southeast2"
	DestinationGCSGCSBucketRegionAsia                   DestinationGCSGCSBucketRegion = "asia"
	DestinationGCSGCSBucketRegionEu                     DestinationGCSGCSBucketRegion = "eu"
	DestinationGCSGCSBucketRegionUs                     DestinationGCSGCSBucketRegion = "us"
	DestinationGCSGCSBucketRegionAsia1                  DestinationGCSGCSBucketRegion = "asia1"
	DestinationGCSGCSBucketRegionEur4                   DestinationGCSGCSBucketRegion = "eur4"
	DestinationGCSGCSBucketRegionNam4                   DestinationGCSGCSBucketRegion = "nam4"
)

func (e DestinationGCSGCSBucketRegion) ToPointer() *DestinationGCSGCSBucketRegion {
	return &e
}

func (e *DestinationGCSGCSBucketRegion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "northamerica-northeast1":
		fallthrough
	case "northamerica-northeast2":
		fallthrough
	case "us-central1":
		fallthrough
	case "us-east1":
		fallthrough
	case "us-east4":
		fallthrough
	case "us-west1":
		fallthrough
	case "us-west2":
		fallthrough
	case "us-west3":
		fallthrough
	case "us-west4":
		fallthrough
	case "southamerica-east1":
		fallthrough
	case "southamerica-west1":
		fallthrough
	case "europe-central2":
		fallthrough
	case "europe-north1":
		fallthrough
	case "europe-west1":
		fallthrough
	case "europe-west2":
		fallthrough
	case "europe-west3":
		fallthrough
	case "europe-west4":
		fallthrough
	case "europe-west6":
		fallthrough
	case "asia-east1":
		fallthrough
	case "asia-east2":
		fallthrough
	case "asia-northeast1":
		fallthrough
	case "asia-northeast2":
		fallthrough
	case "asia-northeast3":
		fallthrough
	case "asia-south1":
		fallthrough
	case "asia-south2":
		fallthrough
	case "asia-southeast1":
		fallthrough
	case "asia-southeast2":
		fallthrough
	case "australia-southeast1":
		fallthrough
	case "australia-southeast2":
		fallthrough
	case "asia":
		fallthrough
	case "eu":
		fallthrough
	case "us":
		fallthrough
	case "asia1":
		fallthrough
	case "eur4":
		fallthrough
	case "nam4":
		*e = DestinationGCSGCSBucketRegion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGCSGCSBucketRegion: %v", v)
	}
}

type DestinationGcs struct {
	// An HMAC key is a type of credential and can be associated with a service account or a user account in Cloud Storage. Read more <a href="https://cloud.google.com/storage/docs/authentication/hmackeys">here</a>.
	Credential      DestinationGcsAuthentication `json:"credential"`
	DestinationType DestinationGcsGcs            `json:"destinationType"`
	// Output data format. One of the following formats must be selected - <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-avro#advantages_of_avro">AVRO</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-parquet#parquet_schemas">PARQUET</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-csv#loading_csv_data_into_a_table">CSV</a> format, or <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-json#loading_json_data_into_a_new_table">JSONL</a> format.
	Format DestinationGcsOutputFormat `json:"format"`
	// You can find the bucket name in the App Engine Admin console Application Settings page, under the label Google Cloud Storage Bucket. Read more <a href="https://cloud.google.com/storage/docs/naming-buckets">here</a>.
	GcsBucketName string `json:"gcs_bucket_name"`
	// GCS Bucket Path string Subdirectory under the above bucket to sync the data into.
	GcsBucketPath string `json:"gcs_bucket_path"`
	// Select a Region of the GCS Bucket. Read more <a href="https://cloud.google.com/storage/docs/locations">here</a>.
	GcsBucketRegion *DestinationGCSGCSBucketRegion `json:"gcs_bucket_region,omitempty"`
}
