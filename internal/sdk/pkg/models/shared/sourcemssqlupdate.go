// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/pkg/utils"
)

type SourceMssqlUpdateSchemasMethod string

const (
	SourceMssqlUpdateSchemasMethodStandard SourceMssqlUpdateSchemasMethod = "STANDARD"
)

func (e SourceMssqlUpdateSchemasMethod) ToPointer() *SourceMssqlUpdateSchemasMethod {
	return &e
}

func (e *SourceMssqlUpdateSchemasMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "STANDARD":
		*e = SourceMssqlUpdateSchemasMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMssqlUpdateSchemasMethod: %v", v)
	}
}

// ScanChangesWithUserDefinedCursor - Incrementally detects new inserts and updates using the <a href="https://docs.airbyte.com/understanding-airbyte/connections/incremental-append/#user-defined-cursor">cursor column</a> chosen when configuring a connection (e.g. created_at, updated_at).
type ScanChangesWithUserDefinedCursor struct {
	method SourceMssqlUpdateSchemasMethod `const:"STANDARD" json:"method"`
}

func (s ScanChangesWithUserDefinedCursor) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *ScanChangesWithUserDefinedCursor) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *ScanChangesWithUserDefinedCursor) GetMethod() SourceMssqlUpdateSchemasMethod {
	return SourceMssqlUpdateSchemasMethodStandard
}

// DataToSync - What data should be synced under the CDC. "Existing and New" will read existing data as a snapshot, and sync new changes through CDC. "New Changes Only" will skip the initial snapshot, and only sync new changes through CDC.
type DataToSync string

const (
	DataToSyncExistingAndNew DataToSync = "Existing and New"
	DataToSyncNewChangesOnly DataToSync = "New Changes Only"
)

func (e DataToSync) ToPointer() *DataToSync {
	return &e
}

func (e *DataToSync) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Existing and New":
		fallthrough
	case "New Changes Only":
		*e = DataToSync(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DataToSync: %v", v)
	}
}

type SourceMssqlUpdateSchemasReplicationMethodMethod string

const (
	SourceMssqlUpdateSchemasReplicationMethodMethodCdc SourceMssqlUpdateSchemasReplicationMethodMethod = "CDC"
)

func (e SourceMssqlUpdateSchemasReplicationMethodMethod) ToPointer() *SourceMssqlUpdateSchemasReplicationMethodMethod {
	return &e
}

func (e *SourceMssqlUpdateSchemasReplicationMethodMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CDC":
		*e = SourceMssqlUpdateSchemasReplicationMethodMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMssqlUpdateSchemasReplicationMethodMethod: %v", v)
	}
}

// InitialSnapshotIsolationLevel - Existing data in the database are synced through an initial snapshot. This parameter controls the isolation level that will be used during the initial snapshotting. If you choose the "Snapshot" level, you must enable the <a href="https://docs.microsoft.com/en-us/dotnet/framework/data/adonet/sql/snapshot-isolation-in-sql-server">snapshot isolation mode</a> on the database.
type InitialSnapshotIsolationLevel string

const (
	InitialSnapshotIsolationLevelSnapshot      InitialSnapshotIsolationLevel = "Snapshot"
	InitialSnapshotIsolationLevelReadCommitted InitialSnapshotIsolationLevel = "Read Committed"
)

func (e InitialSnapshotIsolationLevel) ToPointer() *InitialSnapshotIsolationLevel {
	return &e
}

func (e *InitialSnapshotIsolationLevel) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Snapshot":
		fallthrough
	case "Read Committed":
		*e = InitialSnapshotIsolationLevel(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InitialSnapshotIsolationLevel: %v", v)
	}
}

// ReadChangesUsingChangeDataCaptureCDC - <i>Recommended</i> - Incrementally reads new inserts, updates, and deletes using the SQL Server's <a href="https://docs.airbyte.com/integrations/sources/mssql/#change-data-capture-cdc">change data capture feature</a>. This must be enabled on your database.
type ReadChangesUsingChangeDataCaptureCDC struct {
	// What data should be synced under the CDC. "Existing and New" will read existing data as a snapshot, and sync new changes through CDC. "New Changes Only" will skip the initial snapshot, and only sync new changes through CDC.
	DataToSync *DataToSync `default:"Existing and New" json:"data_to_sync"`
	// The amount of time the connector will wait when it launches to determine if there is new data to sync or not. Defaults to 300 seconds. Valid range: 120 seconds to 1200 seconds. Read about <a href="https://docs.airbyte.com/integrations/sources/mysql/#change-data-capture-cdc">initial waiting time</a>.
	InitialWaitingSeconds *int64                                          `default:"300" json:"initial_waiting_seconds"`
	method                SourceMssqlUpdateSchemasReplicationMethodMethod `const:"CDC" json:"method"`
	// Existing data in the database are synced through an initial snapshot. This parameter controls the isolation level that will be used during the initial snapshotting. If you choose the "Snapshot" level, you must enable the <a href="https://docs.microsoft.com/en-us/dotnet/framework/data/adonet/sql/snapshot-isolation-in-sql-server">snapshot isolation mode</a> on the database.
	SnapshotIsolation *InitialSnapshotIsolationLevel `default:"Snapshot" json:"snapshot_isolation"`
}

func (r ReadChangesUsingChangeDataCaptureCDC) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(r, "", false)
}

func (r *ReadChangesUsingChangeDataCaptureCDC) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &r, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *ReadChangesUsingChangeDataCaptureCDC) GetDataToSync() *DataToSync {
	if o == nil {
		return nil
	}
	return o.DataToSync
}

func (o *ReadChangesUsingChangeDataCaptureCDC) GetInitialWaitingSeconds() *int64 {
	if o == nil {
		return nil
	}
	return o.InitialWaitingSeconds
}

func (o *ReadChangesUsingChangeDataCaptureCDC) GetMethod() SourceMssqlUpdateSchemasReplicationMethodMethod {
	return SourceMssqlUpdateSchemasReplicationMethodMethodCdc
}

func (o *ReadChangesUsingChangeDataCaptureCDC) GetSnapshotIsolation() *InitialSnapshotIsolationLevel {
	if o == nil {
		return nil
	}
	return o.SnapshotIsolation
}

type UpdateMethodType string

const (
	UpdateMethodTypeReadChangesUsingChangeDataCaptureCDC UpdateMethodType = "Read Changes using Change Data Capture (CDC)"
	UpdateMethodTypeScanChangesWithUserDefinedCursor     UpdateMethodType = "Scan Changes with User Defined Cursor"
)

type UpdateMethod struct {
	ReadChangesUsingChangeDataCaptureCDC *ReadChangesUsingChangeDataCaptureCDC
	ScanChangesWithUserDefinedCursor     *ScanChangesWithUserDefinedCursor

	Type UpdateMethodType
}

func CreateUpdateMethodReadChangesUsingChangeDataCaptureCDC(readChangesUsingChangeDataCaptureCDC ReadChangesUsingChangeDataCaptureCDC) UpdateMethod {
	typ := UpdateMethodTypeReadChangesUsingChangeDataCaptureCDC

	return UpdateMethod{
		ReadChangesUsingChangeDataCaptureCDC: &readChangesUsingChangeDataCaptureCDC,
		Type:                                 typ,
	}
}

func CreateUpdateMethodScanChangesWithUserDefinedCursor(scanChangesWithUserDefinedCursor ScanChangesWithUserDefinedCursor) UpdateMethod {
	typ := UpdateMethodTypeScanChangesWithUserDefinedCursor

	return UpdateMethod{
		ScanChangesWithUserDefinedCursor: &scanChangesWithUserDefinedCursor,
		Type:                             typ,
	}
}

func (u *UpdateMethod) UnmarshalJSON(data []byte) error {

	scanChangesWithUserDefinedCursor := new(ScanChangesWithUserDefinedCursor)
	if err := utils.UnmarshalJSON(data, &scanChangesWithUserDefinedCursor, "", true, true); err == nil {
		u.ScanChangesWithUserDefinedCursor = scanChangesWithUserDefinedCursor
		u.Type = UpdateMethodTypeScanChangesWithUserDefinedCursor
		return nil
	}

	readChangesUsingChangeDataCaptureCDC := new(ReadChangesUsingChangeDataCaptureCDC)
	if err := utils.UnmarshalJSON(data, &readChangesUsingChangeDataCaptureCDC, "", true, true); err == nil {
		u.ReadChangesUsingChangeDataCaptureCDC = readChangesUsingChangeDataCaptureCDC
		u.Type = UpdateMethodTypeReadChangesUsingChangeDataCaptureCDC
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u UpdateMethod) MarshalJSON() ([]byte, error) {
	if u.ReadChangesUsingChangeDataCaptureCDC != nil {
		return utils.MarshalJSON(u.ReadChangesUsingChangeDataCaptureCDC, "", true)
	}

	if u.ScanChangesWithUserDefinedCursor != nil {
		return utils.MarshalJSON(u.ScanChangesWithUserDefinedCursor, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type SourceMssqlUpdateSchemasSslMethodSslMethod string

const (
	SourceMssqlUpdateSchemasSslMethodSslMethodEncryptedVerifyCertificate SourceMssqlUpdateSchemasSslMethodSslMethod = "encrypted_verify_certificate"
)

func (e SourceMssqlUpdateSchemasSslMethodSslMethod) ToPointer() *SourceMssqlUpdateSchemasSslMethodSslMethod {
	return &e
}

func (e *SourceMssqlUpdateSchemasSslMethodSslMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "encrypted_verify_certificate":
		*e = SourceMssqlUpdateSchemasSslMethodSslMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMssqlUpdateSchemasSslMethodSslMethod: %v", v)
	}
}

// SourceMssqlUpdateEncryptedVerifyCertificate - Verify and use the certificate provided by the server.
type SourceMssqlUpdateEncryptedVerifyCertificate struct {
	// Specifies the host name of the server. The value of this property must match the subject property of the certificate.
	HostNameInCertificate *string                                    `json:"hostNameInCertificate,omitempty"`
	sslMethod             SourceMssqlUpdateSchemasSslMethodSslMethod `const:"encrypted_verify_certificate" json:"ssl_method"`
}

func (s SourceMssqlUpdateEncryptedVerifyCertificate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMssqlUpdateEncryptedVerifyCertificate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceMssqlUpdateEncryptedVerifyCertificate) GetHostNameInCertificate() *string {
	if o == nil {
		return nil
	}
	return o.HostNameInCertificate
}

func (o *SourceMssqlUpdateEncryptedVerifyCertificate) GetSslMethod() SourceMssqlUpdateSchemasSslMethodSslMethod {
	return SourceMssqlUpdateSchemasSslMethodSslMethodEncryptedVerifyCertificate
}

type SourceMssqlUpdateSchemasSslMethod string

const (
	SourceMssqlUpdateSchemasSslMethodEncryptedTrustServerCertificate SourceMssqlUpdateSchemasSslMethod = "encrypted_trust_server_certificate"
)

func (e SourceMssqlUpdateSchemasSslMethod) ToPointer() *SourceMssqlUpdateSchemasSslMethod {
	return &e
}

func (e *SourceMssqlUpdateSchemasSslMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "encrypted_trust_server_certificate":
		*e = SourceMssqlUpdateSchemasSslMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMssqlUpdateSchemasSslMethod: %v", v)
	}
}

// SourceMssqlUpdateEncryptedTrustServerCertificate - Use the certificate provided by the server without verification. (For testing purposes only!)
type SourceMssqlUpdateEncryptedTrustServerCertificate struct {
	sslMethod SourceMssqlUpdateSchemasSslMethod `const:"encrypted_trust_server_certificate" json:"ssl_method"`
}

func (s SourceMssqlUpdateEncryptedTrustServerCertificate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMssqlUpdateEncryptedTrustServerCertificate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceMssqlUpdateEncryptedTrustServerCertificate) GetSslMethod() SourceMssqlUpdateSchemasSslMethod {
	return SourceMssqlUpdateSchemasSslMethodEncryptedTrustServerCertificate
}

type SourceMssqlUpdateSSLMethodType string

const (
	SourceMssqlUpdateSSLMethodTypeSourceMssqlUpdateEncryptedTrustServerCertificate SourceMssqlUpdateSSLMethodType = "source-mssql-update_Encrypted (trust server certificate)"
	SourceMssqlUpdateSSLMethodTypeSourceMssqlUpdateEncryptedVerifyCertificate      SourceMssqlUpdateSSLMethodType = "source-mssql-update_Encrypted (verify certificate)"
)

type SourceMssqlUpdateSSLMethod struct {
	SourceMssqlUpdateEncryptedTrustServerCertificate *SourceMssqlUpdateEncryptedTrustServerCertificate
	SourceMssqlUpdateEncryptedVerifyCertificate      *SourceMssqlUpdateEncryptedVerifyCertificate

	Type SourceMssqlUpdateSSLMethodType
}

func CreateSourceMssqlUpdateSSLMethodSourceMssqlUpdateEncryptedTrustServerCertificate(sourceMssqlUpdateEncryptedTrustServerCertificate SourceMssqlUpdateEncryptedTrustServerCertificate) SourceMssqlUpdateSSLMethod {
	typ := SourceMssqlUpdateSSLMethodTypeSourceMssqlUpdateEncryptedTrustServerCertificate

	return SourceMssqlUpdateSSLMethod{
		SourceMssqlUpdateEncryptedTrustServerCertificate: &sourceMssqlUpdateEncryptedTrustServerCertificate,
		Type: typ,
	}
}

func CreateSourceMssqlUpdateSSLMethodSourceMssqlUpdateEncryptedVerifyCertificate(sourceMssqlUpdateEncryptedVerifyCertificate SourceMssqlUpdateEncryptedVerifyCertificate) SourceMssqlUpdateSSLMethod {
	typ := SourceMssqlUpdateSSLMethodTypeSourceMssqlUpdateEncryptedVerifyCertificate

	return SourceMssqlUpdateSSLMethod{
		SourceMssqlUpdateEncryptedVerifyCertificate: &sourceMssqlUpdateEncryptedVerifyCertificate,
		Type: typ,
	}
}

func (u *SourceMssqlUpdateSSLMethod) UnmarshalJSON(data []byte) error {

	sourceMssqlUpdateEncryptedTrustServerCertificate := new(SourceMssqlUpdateEncryptedTrustServerCertificate)
	if err := utils.UnmarshalJSON(data, &sourceMssqlUpdateEncryptedTrustServerCertificate, "", true, true); err == nil {
		u.SourceMssqlUpdateEncryptedTrustServerCertificate = sourceMssqlUpdateEncryptedTrustServerCertificate
		u.Type = SourceMssqlUpdateSSLMethodTypeSourceMssqlUpdateEncryptedTrustServerCertificate
		return nil
	}

	sourceMssqlUpdateEncryptedVerifyCertificate := new(SourceMssqlUpdateEncryptedVerifyCertificate)
	if err := utils.UnmarshalJSON(data, &sourceMssqlUpdateEncryptedVerifyCertificate, "", true, true); err == nil {
		u.SourceMssqlUpdateEncryptedVerifyCertificate = sourceMssqlUpdateEncryptedVerifyCertificate
		u.Type = SourceMssqlUpdateSSLMethodTypeSourceMssqlUpdateEncryptedVerifyCertificate
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SourceMssqlUpdateSSLMethod) MarshalJSON() ([]byte, error) {
	if u.SourceMssqlUpdateEncryptedTrustServerCertificate != nil {
		return utils.MarshalJSON(u.SourceMssqlUpdateEncryptedTrustServerCertificate, "", true)
	}

	if u.SourceMssqlUpdateEncryptedVerifyCertificate != nil {
		return utils.MarshalJSON(u.SourceMssqlUpdateEncryptedVerifyCertificate, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

// SourceMssqlUpdateSchemasTunnelMethodTunnelMethod - Connect through a jump server tunnel host using username and password authentication
type SourceMssqlUpdateSchemasTunnelMethodTunnelMethod string

const (
	SourceMssqlUpdateSchemasTunnelMethodTunnelMethodSSHPasswordAuth SourceMssqlUpdateSchemasTunnelMethodTunnelMethod = "SSH_PASSWORD_AUTH"
)

func (e SourceMssqlUpdateSchemasTunnelMethodTunnelMethod) ToPointer() *SourceMssqlUpdateSchemasTunnelMethodTunnelMethod {
	return &e
}

func (e *SourceMssqlUpdateSchemasTunnelMethodTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_PASSWORD_AUTH":
		*e = SourceMssqlUpdateSchemasTunnelMethodTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMssqlUpdateSchemasTunnelMethodTunnelMethod: %v", v)
	}
}

// SourceMssqlUpdatePasswordAuthentication - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceMssqlUpdatePasswordAuthentication struct {
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and password authentication
	tunnelMethod SourceMssqlUpdateSchemasTunnelMethodTunnelMethod `const:"SSH_PASSWORD_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser string `json:"tunnel_user"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword string `json:"tunnel_user_password"`
}

func (s SourceMssqlUpdatePasswordAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMssqlUpdatePasswordAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceMssqlUpdatePasswordAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *SourceMssqlUpdatePasswordAuthentication) GetTunnelMethod() SourceMssqlUpdateSchemasTunnelMethodTunnelMethod {
	return SourceMssqlUpdateSchemasTunnelMethodTunnelMethodSSHPasswordAuth
}

func (o *SourceMssqlUpdatePasswordAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *SourceMssqlUpdatePasswordAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

func (o *SourceMssqlUpdatePasswordAuthentication) GetTunnelUserPassword() string {
	if o == nil {
		return ""
	}
	return o.TunnelUserPassword
}

// SourceMssqlUpdateSchemasTunnelMethod - Connect through a jump server tunnel host using username and ssh key
type SourceMssqlUpdateSchemasTunnelMethod string

const (
	SourceMssqlUpdateSchemasTunnelMethodSSHKeyAuth SourceMssqlUpdateSchemasTunnelMethod = "SSH_KEY_AUTH"
)

func (e SourceMssqlUpdateSchemasTunnelMethod) ToPointer() *SourceMssqlUpdateSchemasTunnelMethod {
	return &e
}

func (e *SourceMssqlUpdateSchemasTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_KEY_AUTH":
		*e = SourceMssqlUpdateSchemasTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMssqlUpdateSchemasTunnelMethod: %v", v)
	}
}

// SourceMssqlUpdateSSHKeyAuthentication - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceMssqlUpdateSSHKeyAuthentication struct {
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey string `json:"ssh_key"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and ssh key
	tunnelMethod SourceMssqlUpdateSchemasTunnelMethod `const:"SSH_KEY_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host.
	TunnelUser string `json:"tunnel_user"`
}

func (s SourceMssqlUpdateSSHKeyAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMssqlUpdateSSHKeyAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceMssqlUpdateSSHKeyAuthentication) GetSSHKey() string {
	if o == nil {
		return ""
	}
	return o.SSHKey
}

func (o *SourceMssqlUpdateSSHKeyAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *SourceMssqlUpdateSSHKeyAuthentication) GetTunnelMethod() SourceMssqlUpdateSchemasTunnelMethod {
	return SourceMssqlUpdateSchemasTunnelMethodSSHKeyAuth
}

func (o *SourceMssqlUpdateSSHKeyAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *SourceMssqlUpdateSSHKeyAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

// SourceMssqlUpdateTunnelMethod - No ssh tunnel needed to connect to database
type SourceMssqlUpdateTunnelMethod string

const (
	SourceMssqlUpdateTunnelMethodNoTunnel SourceMssqlUpdateTunnelMethod = "NO_TUNNEL"
)

func (e SourceMssqlUpdateTunnelMethod) ToPointer() *SourceMssqlUpdateTunnelMethod {
	return &e
}

func (e *SourceMssqlUpdateTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NO_TUNNEL":
		*e = SourceMssqlUpdateTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMssqlUpdateTunnelMethod: %v", v)
	}
}

// SourceMssqlUpdateNoTunnel - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceMssqlUpdateNoTunnel struct {
	// No ssh tunnel needed to connect to database
	tunnelMethod SourceMssqlUpdateTunnelMethod `const:"NO_TUNNEL" json:"tunnel_method"`
}

func (s SourceMssqlUpdateNoTunnel) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMssqlUpdateNoTunnel) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceMssqlUpdateNoTunnel) GetTunnelMethod() SourceMssqlUpdateTunnelMethod {
	return SourceMssqlUpdateTunnelMethodNoTunnel
}

type SourceMssqlUpdateSSHTunnelMethodType string

const (
	SourceMssqlUpdateSSHTunnelMethodTypeSourceMssqlUpdateNoTunnel               SourceMssqlUpdateSSHTunnelMethodType = "source-mssql-update_No Tunnel"
	SourceMssqlUpdateSSHTunnelMethodTypeSourceMssqlUpdateSSHKeyAuthentication   SourceMssqlUpdateSSHTunnelMethodType = "source-mssql-update_SSH Key Authentication"
	SourceMssqlUpdateSSHTunnelMethodTypeSourceMssqlUpdatePasswordAuthentication SourceMssqlUpdateSSHTunnelMethodType = "source-mssql-update_Password Authentication"
)

type SourceMssqlUpdateSSHTunnelMethod struct {
	SourceMssqlUpdateNoTunnel               *SourceMssqlUpdateNoTunnel
	SourceMssqlUpdateSSHKeyAuthentication   *SourceMssqlUpdateSSHKeyAuthentication
	SourceMssqlUpdatePasswordAuthentication *SourceMssqlUpdatePasswordAuthentication

	Type SourceMssqlUpdateSSHTunnelMethodType
}

func CreateSourceMssqlUpdateSSHTunnelMethodSourceMssqlUpdateNoTunnel(sourceMssqlUpdateNoTunnel SourceMssqlUpdateNoTunnel) SourceMssqlUpdateSSHTunnelMethod {
	typ := SourceMssqlUpdateSSHTunnelMethodTypeSourceMssqlUpdateNoTunnel

	return SourceMssqlUpdateSSHTunnelMethod{
		SourceMssqlUpdateNoTunnel: &sourceMssqlUpdateNoTunnel,
		Type:                      typ,
	}
}

func CreateSourceMssqlUpdateSSHTunnelMethodSourceMssqlUpdateSSHKeyAuthentication(sourceMssqlUpdateSSHKeyAuthentication SourceMssqlUpdateSSHKeyAuthentication) SourceMssqlUpdateSSHTunnelMethod {
	typ := SourceMssqlUpdateSSHTunnelMethodTypeSourceMssqlUpdateSSHKeyAuthentication

	return SourceMssqlUpdateSSHTunnelMethod{
		SourceMssqlUpdateSSHKeyAuthentication: &sourceMssqlUpdateSSHKeyAuthentication,
		Type:                                  typ,
	}
}

func CreateSourceMssqlUpdateSSHTunnelMethodSourceMssqlUpdatePasswordAuthentication(sourceMssqlUpdatePasswordAuthentication SourceMssqlUpdatePasswordAuthentication) SourceMssqlUpdateSSHTunnelMethod {
	typ := SourceMssqlUpdateSSHTunnelMethodTypeSourceMssqlUpdatePasswordAuthentication

	return SourceMssqlUpdateSSHTunnelMethod{
		SourceMssqlUpdatePasswordAuthentication: &sourceMssqlUpdatePasswordAuthentication,
		Type:                                    typ,
	}
}

func (u *SourceMssqlUpdateSSHTunnelMethod) UnmarshalJSON(data []byte) error {

	sourceMssqlUpdateNoTunnel := new(SourceMssqlUpdateNoTunnel)
	if err := utils.UnmarshalJSON(data, &sourceMssqlUpdateNoTunnel, "", true, true); err == nil {
		u.SourceMssqlUpdateNoTunnel = sourceMssqlUpdateNoTunnel
		u.Type = SourceMssqlUpdateSSHTunnelMethodTypeSourceMssqlUpdateNoTunnel
		return nil
	}

	sourceMssqlUpdateSSHKeyAuthentication := new(SourceMssqlUpdateSSHKeyAuthentication)
	if err := utils.UnmarshalJSON(data, &sourceMssqlUpdateSSHKeyAuthentication, "", true, true); err == nil {
		u.SourceMssqlUpdateSSHKeyAuthentication = sourceMssqlUpdateSSHKeyAuthentication
		u.Type = SourceMssqlUpdateSSHTunnelMethodTypeSourceMssqlUpdateSSHKeyAuthentication
		return nil
	}

	sourceMssqlUpdatePasswordAuthentication := new(SourceMssqlUpdatePasswordAuthentication)
	if err := utils.UnmarshalJSON(data, &sourceMssqlUpdatePasswordAuthentication, "", true, true); err == nil {
		u.SourceMssqlUpdatePasswordAuthentication = sourceMssqlUpdatePasswordAuthentication
		u.Type = SourceMssqlUpdateSSHTunnelMethodTypeSourceMssqlUpdatePasswordAuthentication
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SourceMssqlUpdateSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.SourceMssqlUpdateNoTunnel != nil {
		return utils.MarshalJSON(u.SourceMssqlUpdateNoTunnel, "", true)
	}

	if u.SourceMssqlUpdateSSHKeyAuthentication != nil {
		return utils.MarshalJSON(u.SourceMssqlUpdateSSHKeyAuthentication, "", true)
	}

	if u.SourceMssqlUpdatePasswordAuthentication != nil {
		return utils.MarshalJSON(u.SourceMssqlUpdatePasswordAuthentication, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type SourceMssqlUpdate struct {
	// The name of the database.
	Database string `json:"database"`
	// The hostname of the database.
	Host string `json:"host"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// The password associated with the username.
	Password *string `json:"password,omitempty"`
	// The port of the database.
	Port int64 `json:"port"`
	// Configures how data is extracted from the database.
	ReplicationMethod *UpdateMethod `json:"replication_method,omitempty"`
	// The list of schemas to sync from. Defaults to user. Case sensitive.
	Schemas []string `json:"schemas,omitempty"`
	// The encryption method which is used when communicating with the database.
	SslMethod *SourceMssqlUpdateSSLMethod `json:"ssl_method,omitempty"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod *SourceMssqlUpdateSSHTunnelMethod `json:"tunnel_method,omitempty"`
	// The username which is used to access the database.
	Username string `json:"username"`
}

func (o *SourceMssqlUpdate) GetDatabase() string {
	if o == nil {
		return ""
	}
	return o.Database
}

func (o *SourceMssqlUpdate) GetHost() string {
	if o == nil {
		return ""
	}
	return o.Host
}

func (o *SourceMssqlUpdate) GetJdbcURLParams() *string {
	if o == nil {
		return nil
	}
	return o.JdbcURLParams
}

func (o *SourceMssqlUpdate) GetPassword() *string {
	if o == nil {
		return nil
	}
	return o.Password
}

func (o *SourceMssqlUpdate) GetPort() int64 {
	if o == nil {
		return 0
	}
	return o.Port
}

func (o *SourceMssqlUpdate) GetReplicationMethod() *UpdateMethod {
	if o == nil {
		return nil
	}
	return o.ReplicationMethod
}

func (o *SourceMssqlUpdate) GetSchemas() []string {
	if o == nil {
		return nil
	}
	return o.Schemas
}

func (o *SourceMssqlUpdate) GetSslMethod() *SourceMssqlUpdateSSLMethod {
	if o == nil {
		return nil
	}
	return o.SslMethod
}

func (o *SourceMssqlUpdate) GetTunnelMethod() *SourceMssqlUpdateSSHTunnelMethod {
	if o == nil {
		return nil
	}
	return o.TunnelMethod
}

func (o *SourceMssqlUpdate) GetUsername() string {
	if o == nil {
		return ""
	}
	return o.Username
}
