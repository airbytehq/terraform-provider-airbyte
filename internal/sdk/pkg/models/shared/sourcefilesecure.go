// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/pkg/utils"
)

// SourceFileSecureFileFormat - The Format of the file which should be replicated (Warning: some formats may be experimental, please refer to the docs).
type SourceFileSecureFileFormat string

const (
	SourceFileSecureFileFormatCsv         SourceFileSecureFileFormat = "csv"
	SourceFileSecureFileFormatJSON        SourceFileSecureFileFormat = "json"
	SourceFileSecureFileFormatJsonl       SourceFileSecureFileFormat = "jsonl"
	SourceFileSecureFileFormatExcel       SourceFileSecureFileFormat = "excel"
	SourceFileSecureFileFormatExcelBinary SourceFileSecureFileFormat = "excel_binary"
	SourceFileSecureFileFormatFeather     SourceFileSecureFileFormat = "feather"
	SourceFileSecureFileFormatParquet     SourceFileSecureFileFormat = "parquet"
	SourceFileSecureFileFormatYaml        SourceFileSecureFileFormat = "yaml"
)

func (e SourceFileSecureFileFormat) ToPointer() *SourceFileSecureFileFormat {
	return &e
}

func (e *SourceFileSecureFileFormat) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "csv":
		fallthrough
	case "json":
		fallthrough
	case "jsonl":
		fallthrough
	case "excel":
		fallthrough
	case "excel_binary":
		fallthrough
	case "feather":
		fallthrough
	case "parquet":
		fallthrough
	case "yaml":
		*e = SourceFileSecureFileFormat(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceFileSecureFileFormat: %v", v)
	}
}

type SourceFileSecureSchemasProviderStorageProvider7Storage string

const (
	SourceFileSecureSchemasProviderStorageProvider7StorageSftp SourceFileSecureSchemasProviderStorageProvider7Storage = "SFTP"
)

func (e SourceFileSecureSchemasProviderStorageProvider7Storage) ToPointer() *SourceFileSecureSchemasProviderStorageProvider7Storage {
	return &e
}

func (e *SourceFileSecureSchemasProviderStorageProvider7Storage) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SFTP":
		*e = SourceFileSecureSchemasProviderStorageProvider7Storage(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceFileSecureSchemasProviderStorageProvider7Storage: %v", v)
	}
}

// SourceFileSecureSFTPSecureFileTransferProtocol - The storage Provider or Location of the file(s) which should be replicated.
type SourceFileSecureSFTPSecureFileTransferProtocol struct {
	Host     string                                                 `json:"host"`
	Password *string                                                `json:"password,omitempty"`
	Port     *string                                                `default:"22" json:"port"`
	storage  SourceFileSecureSchemasProviderStorageProvider7Storage `const:"SFTP" json:"storage"`
	User     string                                                 `json:"user"`
}

func (s SourceFileSecureSFTPSecureFileTransferProtocol) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceFileSecureSFTPSecureFileTransferProtocol) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceFileSecureSFTPSecureFileTransferProtocol) GetHost() string {
	if o == nil {
		return ""
	}
	return o.Host
}

func (o *SourceFileSecureSFTPSecureFileTransferProtocol) GetPassword() *string {
	if o == nil {
		return nil
	}
	return o.Password
}

func (o *SourceFileSecureSFTPSecureFileTransferProtocol) GetPort() *string {
	if o == nil {
		return nil
	}
	return o.Port
}

func (o *SourceFileSecureSFTPSecureFileTransferProtocol) GetStorage() SourceFileSecureSchemasProviderStorageProvider7Storage {
	return SourceFileSecureSchemasProviderStorageProvider7StorageSftp
}

func (o *SourceFileSecureSFTPSecureFileTransferProtocol) GetUser() string {
	if o == nil {
		return ""
	}
	return o.User
}

type SourceFileSecureSchemasProviderStorageProvider6Storage string

const (
	SourceFileSecureSchemasProviderStorageProvider6StorageScp SourceFileSecureSchemasProviderStorageProvider6Storage = "SCP"
)

func (e SourceFileSecureSchemasProviderStorageProvider6Storage) ToPointer() *SourceFileSecureSchemasProviderStorageProvider6Storage {
	return &e
}

func (e *SourceFileSecureSchemasProviderStorageProvider6Storage) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SCP":
		*e = SourceFileSecureSchemasProviderStorageProvider6Storage(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceFileSecureSchemasProviderStorageProvider6Storage: %v", v)
	}
}

// SourceFileSecureSCPSecureCopyProtocol - The storage Provider or Location of the file(s) which should be replicated.
type SourceFileSecureSCPSecureCopyProtocol struct {
	Host     string                                                 `json:"host"`
	Password *string                                                `json:"password,omitempty"`
	Port     *string                                                `default:"22" json:"port"`
	storage  SourceFileSecureSchemasProviderStorageProvider6Storage `const:"SCP" json:"storage"`
	User     string                                                 `json:"user"`
}

func (s SourceFileSecureSCPSecureCopyProtocol) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceFileSecureSCPSecureCopyProtocol) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceFileSecureSCPSecureCopyProtocol) GetHost() string {
	if o == nil {
		return ""
	}
	return o.Host
}

func (o *SourceFileSecureSCPSecureCopyProtocol) GetPassword() *string {
	if o == nil {
		return nil
	}
	return o.Password
}

func (o *SourceFileSecureSCPSecureCopyProtocol) GetPort() *string {
	if o == nil {
		return nil
	}
	return o.Port
}

func (o *SourceFileSecureSCPSecureCopyProtocol) GetStorage() SourceFileSecureSchemasProviderStorageProvider6Storage {
	return SourceFileSecureSchemasProviderStorageProvider6StorageScp
}

func (o *SourceFileSecureSCPSecureCopyProtocol) GetUser() string {
	if o == nil {
		return ""
	}
	return o.User
}

type SourceFileSecureSchemasProviderStorageProvider5Storage string

const (
	SourceFileSecureSchemasProviderStorageProvider5StorageSSH SourceFileSecureSchemasProviderStorageProvider5Storage = "SSH"
)

func (e SourceFileSecureSchemasProviderStorageProvider5Storage) ToPointer() *SourceFileSecureSchemasProviderStorageProvider5Storage {
	return &e
}

func (e *SourceFileSecureSchemasProviderStorageProvider5Storage) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH":
		*e = SourceFileSecureSchemasProviderStorageProvider5Storage(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceFileSecureSchemasProviderStorageProvider5Storage: %v", v)
	}
}

// SourceFileSecureSSHSecureShell - The storage Provider or Location of the file(s) which should be replicated.
type SourceFileSecureSSHSecureShell struct {
	Host     string                                                 `json:"host"`
	Password *string                                                `json:"password,omitempty"`
	Port     *string                                                `default:"22" json:"port"`
	storage  SourceFileSecureSchemasProviderStorageProvider5Storage `const:"SSH" json:"storage"`
	User     string                                                 `json:"user"`
}

func (s SourceFileSecureSSHSecureShell) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceFileSecureSSHSecureShell) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceFileSecureSSHSecureShell) GetHost() string {
	if o == nil {
		return ""
	}
	return o.Host
}

func (o *SourceFileSecureSSHSecureShell) GetPassword() *string {
	if o == nil {
		return nil
	}
	return o.Password
}

func (o *SourceFileSecureSSHSecureShell) GetPort() *string {
	if o == nil {
		return nil
	}
	return o.Port
}

func (o *SourceFileSecureSSHSecureShell) GetStorage() SourceFileSecureSchemasProviderStorageProvider5Storage {
	return SourceFileSecureSchemasProviderStorageProvider5StorageSSH
}

func (o *SourceFileSecureSSHSecureShell) GetUser() string {
	if o == nil {
		return ""
	}
	return o.User
}

type SourceFileSecureSchemasProviderStorageProviderStorage string

const (
	SourceFileSecureSchemasProviderStorageProviderStorageAzBlob SourceFileSecureSchemasProviderStorageProviderStorage = "AzBlob"
)

func (e SourceFileSecureSchemasProviderStorageProviderStorage) ToPointer() *SourceFileSecureSchemasProviderStorageProviderStorage {
	return &e
}

func (e *SourceFileSecureSchemasProviderStorageProviderStorage) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "AzBlob":
		*e = SourceFileSecureSchemasProviderStorageProviderStorage(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceFileSecureSchemasProviderStorageProviderStorage: %v", v)
	}
}

// SourceFileSecureAzBlobAzureBlobStorage - The storage Provider or Location of the file(s) which should be replicated.
type SourceFileSecureAzBlobAzureBlobStorage struct {
	// To access Azure Blob Storage, this connector would need credentials with the proper permissions. One option is a SAS (Shared Access Signature) token. If accessing publicly available data, this field is not necessary.
	SasToken *string `json:"sas_token,omitempty"`
	// To access Azure Blob Storage, this connector would need credentials with the proper permissions. One option is a storage account shared key (aka account key or access key). If accessing publicly available data, this field is not necessary.
	SharedKey *string                                               `json:"shared_key,omitempty"`
	storage   SourceFileSecureSchemasProviderStorageProviderStorage `const:"AzBlob" json:"storage"`
	// The globally unique name of the storage account that the desired blob sits within. See <a href="https://docs.microsoft.com/en-us/azure/storage/common/storage-account-overview" target="_blank">here</a> for more details.
	StorageAccount string `json:"storage_account"`
}

func (s SourceFileSecureAzBlobAzureBlobStorage) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceFileSecureAzBlobAzureBlobStorage) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceFileSecureAzBlobAzureBlobStorage) GetSasToken() *string {
	if o == nil {
		return nil
	}
	return o.SasToken
}

func (o *SourceFileSecureAzBlobAzureBlobStorage) GetSharedKey() *string {
	if o == nil {
		return nil
	}
	return o.SharedKey
}

func (o *SourceFileSecureAzBlobAzureBlobStorage) GetStorage() SourceFileSecureSchemasProviderStorageProviderStorage {
	return SourceFileSecureSchemasProviderStorageProviderStorageAzBlob
}

func (o *SourceFileSecureAzBlobAzureBlobStorage) GetStorageAccount() string {
	if o == nil {
		return ""
	}
	return o.StorageAccount
}

type SourceFileSecureSchemasProviderStorage string

const (
	SourceFileSecureSchemasProviderStorageS3 SourceFileSecureSchemasProviderStorage = "S3"
)

func (e SourceFileSecureSchemasProviderStorage) ToPointer() *SourceFileSecureSchemasProviderStorage {
	return &e
}

func (e *SourceFileSecureSchemasProviderStorage) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "S3":
		*e = SourceFileSecureSchemasProviderStorage(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceFileSecureSchemasProviderStorage: %v", v)
	}
}

// SourceFileSecureS3AmazonWebServices - The storage Provider or Location of the file(s) which should be replicated.
type SourceFileSecureS3AmazonWebServices struct {
	// In order to access private Buckets stored on AWS S3, this connector would need credentials with the proper permissions. If accessing publicly available data, this field is not necessary.
	AwsAccessKeyID *string `json:"aws_access_key_id,omitempty"`
	// In order to access private Buckets stored on AWS S3, this connector would need credentials with the proper permissions. If accessing publicly available data, this field is not necessary.
	AwsSecretAccessKey *string                                `json:"aws_secret_access_key,omitempty"`
	storage            SourceFileSecureSchemasProviderStorage `const:"S3" json:"storage"`
}

func (s SourceFileSecureS3AmazonWebServices) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceFileSecureS3AmazonWebServices) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceFileSecureS3AmazonWebServices) GetAwsAccessKeyID() *string {
	if o == nil {
		return nil
	}
	return o.AwsAccessKeyID
}

func (o *SourceFileSecureS3AmazonWebServices) GetAwsSecretAccessKey() *string {
	if o == nil {
		return nil
	}
	return o.AwsSecretAccessKey
}

func (o *SourceFileSecureS3AmazonWebServices) GetStorage() SourceFileSecureSchemasProviderStorage {
	return SourceFileSecureSchemasProviderStorageS3
}

type SourceFileSecureSchemasStorage string

const (
	SourceFileSecureSchemasStorageGcs SourceFileSecureSchemasStorage = "GCS"
)

func (e SourceFileSecureSchemasStorage) ToPointer() *SourceFileSecureSchemasStorage {
	return &e
}

func (e *SourceFileSecureSchemasStorage) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "GCS":
		*e = SourceFileSecureSchemasStorage(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceFileSecureSchemasStorage: %v", v)
	}
}

// SourceFileSecureGCSGoogleCloudStorage - The storage Provider or Location of the file(s) which should be replicated.
type SourceFileSecureGCSGoogleCloudStorage struct {
	// In order to access private Buckets stored on Google Cloud, this connector would need a service account json credentials with the proper permissions as described <a href="https://cloud.google.com/iam/docs/service-accounts" target="_blank">here</a>. Please generate the credentials.json file and copy/paste its content to this field (expecting JSON formats). If accessing publicly available data, this field is not necessary.
	ServiceAccountJSON *string                        `json:"service_account_json,omitempty"`
	storage            SourceFileSecureSchemasStorage `const:"GCS" json:"storage"`
}

func (s SourceFileSecureGCSGoogleCloudStorage) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceFileSecureGCSGoogleCloudStorage) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceFileSecureGCSGoogleCloudStorage) GetServiceAccountJSON() *string {
	if o == nil {
		return nil
	}
	return o.ServiceAccountJSON
}

func (o *SourceFileSecureGCSGoogleCloudStorage) GetStorage() SourceFileSecureSchemasStorage {
	return SourceFileSecureSchemasStorageGcs
}

type SourceFileSecureStorage string

const (
	SourceFileSecureStorageHTTPS SourceFileSecureStorage = "HTTPS"
)

func (e SourceFileSecureStorage) ToPointer() *SourceFileSecureStorage {
	return &e
}

func (e *SourceFileSecureStorage) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "HTTPS":
		*e = SourceFileSecureStorage(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceFileSecureStorage: %v", v)
	}
}

// SourceFileSecureHTTPSPublicWeb - The storage Provider or Location of the file(s) which should be replicated.
type SourceFileSecureHTTPSPublicWeb struct {
	storage SourceFileSecureStorage `const:"HTTPS" json:"storage"`
	// Add User-Agent to request
	UserAgent *bool `default:"false" json:"user_agent"`
}

func (s SourceFileSecureHTTPSPublicWeb) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceFileSecureHTTPSPublicWeb) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceFileSecureHTTPSPublicWeb) GetStorage() SourceFileSecureStorage {
	return SourceFileSecureStorageHTTPS
}

func (o *SourceFileSecureHTTPSPublicWeb) GetUserAgent() *bool {
	if o == nil {
		return nil
	}
	return o.UserAgent
}

type SourceFileSecureStorageProviderType string

const (
	SourceFileSecureStorageProviderTypeHTTPSPublicWeb                 SourceFileSecureStorageProviderType = "HTTPSPublicWeb"
	SourceFileSecureStorageProviderTypeGCSGoogleCloudStorage          SourceFileSecureStorageProviderType = "GCSGoogleCloudStorage"
	SourceFileSecureStorageProviderTypeS3AmazonWebServices            SourceFileSecureStorageProviderType = "S3AmazonWebServices"
	SourceFileSecureStorageProviderTypeAzBlobAzureBlobStorage         SourceFileSecureStorageProviderType = "AzBlobAzureBlobStorage"
	SourceFileSecureStorageProviderTypeSSHSecureShell                 SourceFileSecureStorageProviderType = "SSHSecureShell"
	SourceFileSecureStorageProviderTypeSCPSecureCopyProtocol          SourceFileSecureStorageProviderType = "SCPSecureCopyProtocol"
	SourceFileSecureStorageProviderTypeSFTPSecureFileTransferProtocol SourceFileSecureStorageProviderType = "SFTPSecureFileTransferProtocol"
)

type SourceFileSecureStorageProvider struct {
	HTTPSPublicWeb                 *SourceFileSecureHTTPSPublicWeb
	GCSGoogleCloudStorage          *SourceFileSecureGCSGoogleCloudStorage
	S3AmazonWebServices            *SourceFileSecureS3AmazonWebServices
	AzBlobAzureBlobStorage         *SourceFileSecureAzBlobAzureBlobStorage
	SSHSecureShell                 *SourceFileSecureSSHSecureShell
	SCPSecureCopyProtocol          *SourceFileSecureSCPSecureCopyProtocol
	SFTPSecureFileTransferProtocol *SourceFileSecureSFTPSecureFileTransferProtocol

	Type SourceFileSecureStorageProviderType
}

func CreateSourceFileSecureStorageProviderHTTPSPublicWeb(httpsPublicWeb SourceFileSecureHTTPSPublicWeb) SourceFileSecureStorageProvider {
	typ := SourceFileSecureStorageProviderTypeHTTPSPublicWeb

	return SourceFileSecureStorageProvider{
		HTTPSPublicWeb: &httpsPublicWeb,
		Type:           typ,
	}
}

func CreateSourceFileSecureStorageProviderGCSGoogleCloudStorage(gcsGoogleCloudStorage SourceFileSecureGCSGoogleCloudStorage) SourceFileSecureStorageProvider {
	typ := SourceFileSecureStorageProviderTypeGCSGoogleCloudStorage

	return SourceFileSecureStorageProvider{
		GCSGoogleCloudStorage: &gcsGoogleCloudStorage,
		Type:                  typ,
	}
}

func CreateSourceFileSecureStorageProviderS3AmazonWebServices(s3AmazonWebServices SourceFileSecureS3AmazonWebServices) SourceFileSecureStorageProvider {
	typ := SourceFileSecureStorageProviderTypeS3AmazonWebServices

	return SourceFileSecureStorageProvider{
		S3AmazonWebServices: &s3AmazonWebServices,
		Type:                typ,
	}
}

func CreateSourceFileSecureStorageProviderAzBlobAzureBlobStorage(azBlobAzureBlobStorage SourceFileSecureAzBlobAzureBlobStorage) SourceFileSecureStorageProvider {
	typ := SourceFileSecureStorageProviderTypeAzBlobAzureBlobStorage

	return SourceFileSecureStorageProvider{
		AzBlobAzureBlobStorage: &azBlobAzureBlobStorage,
		Type:                   typ,
	}
}

func CreateSourceFileSecureStorageProviderSSHSecureShell(sshSecureShell SourceFileSecureSSHSecureShell) SourceFileSecureStorageProvider {
	typ := SourceFileSecureStorageProviderTypeSSHSecureShell

	return SourceFileSecureStorageProvider{
		SSHSecureShell: &sshSecureShell,
		Type:           typ,
	}
}

func CreateSourceFileSecureStorageProviderSCPSecureCopyProtocol(scpSecureCopyProtocol SourceFileSecureSCPSecureCopyProtocol) SourceFileSecureStorageProvider {
	typ := SourceFileSecureStorageProviderTypeSCPSecureCopyProtocol

	return SourceFileSecureStorageProvider{
		SCPSecureCopyProtocol: &scpSecureCopyProtocol,
		Type:                  typ,
	}
}

func CreateSourceFileSecureStorageProviderSFTPSecureFileTransferProtocol(sftpSecureFileTransferProtocol SourceFileSecureSFTPSecureFileTransferProtocol) SourceFileSecureStorageProvider {
	typ := SourceFileSecureStorageProviderTypeSFTPSecureFileTransferProtocol

	return SourceFileSecureStorageProvider{
		SFTPSecureFileTransferProtocol: &sftpSecureFileTransferProtocol,
		Type:                           typ,
	}
}

func (u *SourceFileSecureStorageProvider) UnmarshalJSON(data []byte) error {

	httpsPublicWeb := new(SourceFileSecureHTTPSPublicWeb)
	if err := utils.UnmarshalJSON(data, &httpsPublicWeb, "", true, true); err == nil {
		u.HTTPSPublicWeb = httpsPublicWeb
		u.Type = SourceFileSecureStorageProviderTypeHTTPSPublicWeb
		return nil
	}

	gcsGoogleCloudStorage := new(SourceFileSecureGCSGoogleCloudStorage)
	if err := utils.UnmarshalJSON(data, &gcsGoogleCloudStorage, "", true, true); err == nil {
		u.GCSGoogleCloudStorage = gcsGoogleCloudStorage
		u.Type = SourceFileSecureStorageProviderTypeGCSGoogleCloudStorage
		return nil
	}

	s3AmazonWebServices := new(SourceFileSecureS3AmazonWebServices)
	if err := utils.UnmarshalJSON(data, &s3AmazonWebServices, "", true, true); err == nil {
		u.S3AmazonWebServices = s3AmazonWebServices
		u.Type = SourceFileSecureStorageProviderTypeS3AmazonWebServices
		return nil
	}

	azBlobAzureBlobStorage := new(SourceFileSecureAzBlobAzureBlobStorage)
	if err := utils.UnmarshalJSON(data, &azBlobAzureBlobStorage, "", true, true); err == nil {
		u.AzBlobAzureBlobStorage = azBlobAzureBlobStorage
		u.Type = SourceFileSecureStorageProviderTypeAzBlobAzureBlobStorage
		return nil
	}

	sshSecureShell := new(SourceFileSecureSSHSecureShell)
	if err := utils.UnmarshalJSON(data, &sshSecureShell, "", true, true); err == nil {
		u.SSHSecureShell = sshSecureShell
		u.Type = SourceFileSecureStorageProviderTypeSSHSecureShell
		return nil
	}

	scpSecureCopyProtocol := new(SourceFileSecureSCPSecureCopyProtocol)
	if err := utils.UnmarshalJSON(data, &scpSecureCopyProtocol, "", true, true); err == nil {
		u.SCPSecureCopyProtocol = scpSecureCopyProtocol
		u.Type = SourceFileSecureStorageProviderTypeSCPSecureCopyProtocol
		return nil
	}

	sftpSecureFileTransferProtocol := new(SourceFileSecureSFTPSecureFileTransferProtocol)
	if err := utils.UnmarshalJSON(data, &sftpSecureFileTransferProtocol, "", true, true); err == nil {
		u.SFTPSecureFileTransferProtocol = sftpSecureFileTransferProtocol
		u.Type = SourceFileSecureStorageProviderTypeSFTPSecureFileTransferProtocol
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SourceFileSecureStorageProvider) MarshalJSON() ([]byte, error) {
	if u.HTTPSPublicWeb != nil {
		return utils.MarshalJSON(u.HTTPSPublicWeb, "", true)
	}

	if u.GCSGoogleCloudStorage != nil {
		return utils.MarshalJSON(u.GCSGoogleCloudStorage, "", true)
	}

	if u.S3AmazonWebServices != nil {
		return utils.MarshalJSON(u.S3AmazonWebServices, "", true)
	}

	if u.AzBlobAzureBlobStorage != nil {
		return utils.MarshalJSON(u.AzBlobAzureBlobStorage, "", true)
	}

	if u.SSHSecureShell != nil {
		return utils.MarshalJSON(u.SSHSecureShell, "", true)
	}

	if u.SCPSecureCopyProtocol != nil {
		return utils.MarshalJSON(u.SCPSecureCopyProtocol, "", true)
	}

	if u.SFTPSecureFileTransferProtocol != nil {
		return utils.MarshalJSON(u.SFTPSecureFileTransferProtocol, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type FileSecure string

const (
	FileSecureFileSecure FileSecure = "file-secure"
)

func (e FileSecure) ToPointer() *FileSecure {
	return &e
}

func (e *FileSecure) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "file-secure":
		*e = FileSecure(v)
		return nil
	default:
		return fmt.Errorf("invalid value for FileSecure: %v", v)
	}
}

type SourceFileSecure struct {
	// The Name of the final table to replicate this file into (should include letters, numbers dash and underscores only).
	DatasetName string `json:"dataset_name"`
	// The Format of the file which should be replicated (Warning: some formats may be experimental, please refer to the docs).
	Format *SourceFileSecureFileFormat `default:"csv" json:"format"`
	// The storage Provider or Location of the file(s) which should be replicated.
	Provider SourceFileSecureStorageProvider `json:"provider"`
	// This should be a string in JSON format. It depends on the chosen file format to provide additional options and tune its behavior.
	ReaderOptions *string    `json:"reader_options,omitempty"`
	sourceType    FileSecure `const:"file-secure" json:"sourceType"`
	// The URL path to access the file which should be replicated.
	URL string `json:"url"`
}

func (s SourceFileSecure) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceFileSecure) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *SourceFileSecure) GetDatasetName() string {
	if o == nil {
		return ""
	}
	return o.DatasetName
}

func (o *SourceFileSecure) GetFormat() *SourceFileSecureFileFormat {
	if o == nil {
		return nil
	}
	return o.Format
}

func (o *SourceFileSecure) GetProvider() SourceFileSecureStorageProvider {
	if o == nil {
		return SourceFileSecureStorageProvider{}
	}
	return o.Provider
}

func (o *SourceFileSecure) GetReaderOptions() *string {
	if o == nil {
		return nil
	}
	return o.ReaderOptions
}

func (o *SourceFileSecure) GetSourceType() FileSecure {
	return FileSecureFileSecure
}

func (o *SourceFileSecure) GetURL() string {
	if o == nil {
		return ""
	}
	return o.URL
}
