// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/pkg/utils"
)

// SourceFileSecureFileFormat - The Format of the file which should be replicated (Warning: some formats may be experimental, please refer to the docs).
type SourceFileSecureFileFormat string

const (
	SourceFileSecureFileFormatCsv         SourceFileSecureFileFormat = "csv"
	SourceFileSecureFileFormatJSON        SourceFileSecureFileFormat = "json"
	SourceFileSecureFileFormatJsonl       SourceFileSecureFileFormat = "jsonl"
	SourceFileSecureFileFormatExcel       SourceFileSecureFileFormat = "excel"
	SourceFileSecureFileFormatExcelBinary SourceFileSecureFileFormat = "excel_binary"
	SourceFileSecureFileFormatFeather     SourceFileSecureFileFormat = "feather"
	SourceFileSecureFileFormatParquet     SourceFileSecureFileFormat = "parquet"
	SourceFileSecureFileFormatYaml        SourceFileSecureFileFormat = "yaml"
)

func (e SourceFileSecureFileFormat) ToPointer() *SourceFileSecureFileFormat {
	return &e
}

func (e *SourceFileSecureFileFormat) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "csv":
		fallthrough
	case "json":
		fallthrough
	case "jsonl":
		fallthrough
	case "excel":
		fallthrough
	case "excel_binary":
		fallthrough
	case "feather":
		fallthrough
	case "parquet":
		fallthrough
	case "yaml":
		*e = SourceFileSecureFileFormat(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceFileSecureFileFormat: %v", v)
	}
}

type SourceFileSecureSchemasProviderStorageProvider7Storage string

const (
	SourceFileSecureSchemasProviderStorageProvider7StorageSftp SourceFileSecureSchemasProviderStorageProvider7Storage = "SFTP"
)

func (e SourceFileSecureSchemasProviderStorageProvider7Storage) ToPointer() *SourceFileSecureSchemasProviderStorageProvider7Storage {
	return &e
}

func (e *SourceFileSecureSchemasProviderStorageProvider7Storage) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SFTP":
		*e = SourceFileSecureSchemasProviderStorageProvider7Storage(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceFileSecureSchemasProviderStorageProvider7Storage: %v", v)
	}
}

// SourceFileSecureSFTPSecureFileTransferProtocol - The storage Provider or Location of the file(s) which should be replicated.
type SourceFileSecureSFTPSecureFileTransferProtocol struct {
	Host     string                                                 `json:"host"`
	Password *string                                                `json:"password,omitempty"`
	Port     *string                                                `default:"22" json:"port"`
	storage  SourceFileSecureSchemasProviderStorageProvider7Storage `const:"SFTP" json:"storage"`
	User     string                                                 `json:"user"`
}

func (s SourceFileSecureSFTPSecureFileTransferProtocol) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceFileSecureSFTPSecureFileTransferProtocol) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceFileSecureSFTPSecureFileTransferProtocol) GetHost() string {
	if o == nil {
		return ""
	}
	return o.Host
}

func (o *SourceFileSecureSFTPSecureFileTransferProtocol) GetPassword() *string {
	if o == nil {
		return nil
	}
	return o.Password
}

func (o *SourceFileSecureSFTPSecureFileTransferProtocol) GetPort() *string {
	if o == nil {
		return nil
	}
	return o.Port
}

func (o *SourceFileSecureSFTPSecureFileTransferProtocol) GetStorage() SourceFileSecureSchemasProviderStorageProvider7Storage {
	return SourceFileSecureSchemasProviderStorageProvider7StorageSftp
}

func (o *SourceFileSecureSFTPSecureFileTransferProtocol) GetUser() string {
	if o == nil {
		return ""
	}
	return o.User
}

type SourceFileSecureSchemasProviderStorageProvider6Storage string

const (
	SourceFileSecureSchemasProviderStorageProvider6StorageScp SourceFileSecureSchemasProviderStorageProvider6Storage = "SCP"
)

func (e SourceFileSecureSchemasProviderStorageProvider6Storage) ToPointer() *SourceFileSecureSchemasProviderStorageProvider6Storage {
	return &e
}

func (e *SourceFileSecureSchemasProviderStorageProvider6Storage) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SCP":
		*e = SourceFileSecureSchemasProviderStorageProvider6Storage(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceFileSecureSchemasProviderStorageProvider6Storage: %v", v)
	}
}

// SourceFileSecureSCPSecureCopyProtocol - The storage Provider or Location of the file(s) which should be replicated.
type SourceFileSecureSCPSecureCopyProtocol struct {
	Host     string                                                 `json:"host"`
	Password *string                                                `json:"password,omitempty"`
	Port     *string                                                `default:"22" json:"port"`
	storage  SourceFileSecureSchemasProviderStorageProvider6Storage `const:"SCP" json:"storage"`
	User     string                                                 `json:"user"`
}

func (s SourceFileSecureSCPSecureCopyProtocol) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceFileSecureSCPSecureCopyProtocol) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceFileSecureSCPSecureCopyProtocol) GetHost() string {
	if o == nil {
		return ""
	}
	return o.Host
}

func (o *SourceFileSecureSCPSecureCopyProtocol) GetPassword() *string {
	if o == nil {
		return nil
	}
	return o.Password
}

func (o *SourceFileSecureSCPSecureCopyProtocol) GetPort() *string {
	if o == nil {
		return nil
	}
	return o.Port
}

func (o *SourceFileSecureSCPSecureCopyProtocol) GetStorage() SourceFileSecureSchemasProviderStorageProvider6Storage {
	return SourceFileSecureSchemasProviderStorageProvider6StorageScp
}

func (o *SourceFileSecureSCPSecureCopyProtocol) GetUser() string {
	if o == nil {
		return ""
	}
	return o.User
}

type SourceFileSecureSchemasProviderStorageProvider5Storage string

const (
	SourceFileSecureSchemasProviderStorageProvider5StorageSSH SourceFileSecureSchemasProviderStorageProvider5Storage = "SSH"
)

func (e SourceFileSecureSchemasProviderStorageProvider5Storage) ToPointer() *SourceFileSecureSchemasProviderStorageProvider5Storage {
	return &e
}

func (e *SourceFileSecureSchemasProviderStorageProvider5Storage) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH":
		*e = SourceFileSecureSchemasProviderStorageProvider5Storage(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceFileSecureSchemasProviderStorageProvider5Storage: %v", v)
	}
}

// SourceFileSecureSSHSecureShell - The storage Provider or Location of the file(s) which should be replicated.
type SourceFileSecureSSHSecureShell struct {
	Host     string                                                 `json:"host"`
	Password *string                                                `json:"password,omitempty"`
	Port     *string                                                `default:"22" json:"port"`
	storage  SourceFileSecureSchemasProviderStorageProvider5Storage `const:"SSH" json:"storage"`
	User     string                                                 `json:"user"`
}

func (s SourceFileSecureSSHSecureShell) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceFileSecureSSHSecureShell) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceFileSecureSSHSecureShell) GetHost() string {
	if o == nil {
		return ""
	}
	return o.Host
}

func (o *SourceFileSecureSSHSecureShell) GetPassword() *string {
	if o == nil {
		return nil
	}
	return o.Password
}

func (o *SourceFileSecureSSHSecureShell) GetPort() *string {
	if o == nil {
		return nil
	}
	return o.Port
}

func (o *SourceFileSecureSSHSecureShell) GetStorage() SourceFileSecureSchemasProviderStorageProvider5Storage {
	return SourceFileSecureSchemasProviderStorageProvider5StorageSSH
}

func (o *SourceFileSecureSSHSecureShell) GetUser() string {
	if o == nil {
		return ""
	}
	return o.User
}

type SourceFileSecureSchemasProviderStorageProviderStorage string

const (
	SourceFileSecureSchemasProviderStorageProviderStorageAzBlob SourceFileSecureSchemasProviderStorageProviderStorage = "AzBlob"
)

func (e SourceFileSecureSchemasProviderStorageProviderStorage) ToPointer() *SourceFileSecureSchemasProviderStorageProviderStorage {
	return &e
}

func (e *SourceFileSecureSchemasProviderStorageProviderStorage) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "AzBlob":
		*e = SourceFileSecureSchemasProviderStorageProviderStorage(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceFileSecureSchemasProviderStorageProviderStorage: %v", v)
	}
}

// SourceFileSecureAzBlobAzureBlobStorage - The storage Provider or Location of the file(s) which should be replicated.
type SourceFileSecureAzBlobAzureBlobStorage struct {
	// To access Azure Blob Storage, this connector would need credentials with the proper permissions. One option is a SAS (Shared Access Signature) token. If accessing publicly available data, this field is not necessary.
	SasToken *string `json:"sas_token,omitempty"`
	// To access Azure Blob Storage, this connector would need credentials with the proper permissions. One option is a storage account shared key (aka account key or access key). If accessing publicly available data, this field is not necessary.
	SharedKey *string                                               `json:"shared_key,omitempty"`
	storage   SourceFileSecureSchemasProviderStorageProviderStorage `const:"AzBlob" json:"storage"`
	// The globally unique name of the storage account that the desired blob sits within. See <a href="https://docs.microsoft.com/en-us/azure/storage/common/storage-account-overview" target="_blank">here</a> for more details.
	StorageAccount string `json:"storage_account"`
}

func (s SourceFileSecureAzBlobAzureBlobStorage) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceFileSecureAzBlobAzureBlobStorage) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceFileSecureAzBlobAzureBlobStorage) GetSasToken() *string {
	if o == nil {
		return nil
	}
	return o.SasToken
}

func (o *SourceFileSecureAzBlobAzureBlobStorage) GetSharedKey() *string {
	if o == nil {
		return nil
	}
	return o.SharedKey
}

func (o *SourceFileSecureAzBlobAzureBlobStorage) GetStorage() SourceFileSecureSchemasProviderStorageProviderStorage {
	return SourceFileSecureSchemasProviderStorageProviderStorageAzBlob
}

func (o *SourceFileSecureAzBlobAzureBlobStorage) GetStorageAccount() string {
	if o == nil {
		return ""
	}
	return o.StorageAccount
}

type SourceFileSecureSchemasProviderStorage string

const (
	SourceFileSecureSchemasProviderStorageS3 SourceFileSecureSchemasProviderStorage = "S3"
)

func (e SourceFileSecureSchemasProviderStorage) ToPointer() *SourceFileSecureSchemasProviderStorage {
	return &e
}

func (e *SourceFileSecureSchemasProviderStorage) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "S3":
		*e = SourceFileSecureSchemasProviderStorage(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceFileSecureSchemasProviderStorage: %v", v)
	}
}

// SourceFileSecureS3AmazonWebServices - The storage Provider or Location of the file(s) which should be replicated.
type SourceFileSecureS3AmazonWebServices struct {
	// In order to access private Buckets stored on AWS S3, this connector would need credentials with the proper permissions. If accessing publicly available data, this field is not necessary.
	AwsAccessKeyID *string `json:"aws_access_key_id,omitempty"`
	// In order to access private Buckets stored on AWS S3, this connector would need credentials with the proper permissions. If accessing publicly available data, this field is not necessary.
	AwsSecretAccessKey *string                                `json:"aws_secret_access_key,omitempty"`
	storage            SourceFileSecureSchemasProviderStorage `const:"S3" json:"storage"`
}

func (s SourceFileSecureS3AmazonWebServices) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceFileSecureS3AmazonWebServices) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceFileSecureS3AmazonWebServices) GetAwsAccessKeyID() *string {
	if o == nil {
		return nil
	}
	return o.AwsAccessKeyID
}

func (o *SourceFileSecureS3AmazonWebServices) GetAwsSecretAccessKey() *string {
	if o == nil {
		return nil
	}
	return o.AwsSecretAccessKey
}

func (o *SourceFileSecureS3AmazonWebServices) GetStorage() SourceFileSecureSchemasProviderStorage {
	return SourceFileSecureSchemasProviderStorageS3
}

type SourceFileSecureSchemasStorage string

const (
	SourceFileSecureSchemasStorageGcs SourceFileSecureSchemasStorage = "GCS"
)

func (e SourceFileSecureSchemasStorage) ToPointer() *SourceFileSecureSchemasStorage {
	return &e
}

func (e *SourceFileSecureSchemasStorage) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "GCS":
		*e = SourceFileSecureSchemasStorage(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceFileSecureSchemasStorage: %v", v)
	}
}

// SourceFileSecureGCSGoogleCloudStorage - The storage Provider or Location of the file(s) which should be replicated.
type SourceFileSecureGCSGoogleCloudStorage struct {
	// In order to access private Buckets stored on Google Cloud, this connector would need a service account json credentials with the proper permissions as described <a href="https://cloud.google.com/iam/docs/service-accounts" target="_blank">here</a>. Please generate the credentials.json file and copy/paste its content to this field (expecting JSON formats). If accessing publicly available data, this field is not necessary.
	ServiceAccountJSON *string                        `json:"service_account_json,omitempty"`
	storage            SourceFileSecureSchemasStorage `const:"GCS" json:"storage"`
}

func (s SourceFileSecureGCSGoogleCloudStorage) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceFileSecureGCSGoogleCloudStorage) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceFileSecureGCSGoogleCloudStorage) GetServiceAccountJSON() *string {
	if o == nil {
		return nil
	}
	return o.ServiceAccountJSON
}

func (o *SourceFileSecureGCSGoogleCloudStorage) GetStorage() SourceFileSecureSchemasStorage {
	return SourceFileSecureSchemasStorageGcs
}

type SourceFileSecureStorage string

const (
	SourceFileSecureStorageHTTPS SourceFileSecureStorage = "HTTPS"
)

func (e SourceFileSecureStorage) ToPointer() *SourceFileSecureStorage {
	return &e
}

func (e *SourceFileSecureStorage) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "HTTPS":
		*e = SourceFileSecureStorage(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceFileSecureStorage: %v", v)
	}
}

// SourceFileSecureHTTPSPublicWeb - The storage Provider or Location of the file(s) which should be replicated.
type SourceFileSecureHTTPSPublicWeb struct {
	storage SourceFileSecureStorage `const:"HTTPS" json:"storage"`
	// Add User-Agent to request
	UserAgent *bool `default:"false" json:"user_agent"`
}

func (s SourceFileSecureHTTPSPublicWeb) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceFileSecureHTTPSPublicWeb) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceFileSecureHTTPSPublicWeb) GetStorage() SourceFileSecureStorage {
	return SourceFileSecureStorageHTTPS
}

func (o *SourceFileSecureHTTPSPublicWeb) GetUserAgent() *bool {
	if o == nil {
		return nil
	}
	return o.UserAgent
}

type SourceFileSecureStorageProviderType string

const (
	SourceFileSecureStorageProviderTypeSourceFileSecureHTTPSPublicWeb                 SourceFileSecureStorageProviderType = "source-file-secure_HTTPS: Public Web"
	SourceFileSecureStorageProviderTypeSourceFileSecureGCSGoogleCloudStorage          SourceFileSecureStorageProviderType = "source-file-secure_GCS: Google Cloud Storage"
	SourceFileSecureStorageProviderTypeSourceFileSecureS3AmazonWebServices            SourceFileSecureStorageProviderType = "source-file-secure_S3: Amazon Web Services"
	SourceFileSecureStorageProviderTypeSourceFileSecureAzBlobAzureBlobStorage         SourceFileSecureStorageProviderType = "source-file-secure_AzBlob: Azure Blob Storage"
	SourceFileSecureStorageProviderTypeSourceFileSecureSSHSecureShell                 SourceFileSecureStorageProviderType = "source-file-secure_SSH: Secure Shell"
	SourceFileSecureStorageProviderTypeSourceFileSecureSCPSecureCopyProtocol          SourceFileSecureStorageProviderType = "source-file-secure_SCP: Secure copy protocol"
	SourceFileSecureStorageProviderTypeSourceFileSecureSFTPSecureFileTransferProtocol SourceFileSecureStorageProviderType = "source-file-secure_SFTP: Secure File Transfer Protocol"
)

type SourceFileSecureStorageProvider struct {
	SourceFileSecureHTTPSPublicWeb                 *SourceFileSecureHTTPSPublicWeb
	SourceFileSecureGCSGoogleCloudStorage          *SourceFileSecureGCSGoogleCloudStorage
	SourceFileSecureS3AmazonWebServices            *SourceFileSecureS3AmazonWebServices
	SourceFileSecureAzBlobAzureBlobStorage         *SourceFileSecureAzBlobAzureBlobStorage
	SourceFileSecureSSHSecureShell                 *SourceFileSecureSSHSecureShell
	SourceFileSecureSCPSecureCopyProtocol          *SourceFileSecureSCPSecureCopyProtocol
	SourceFileSecureSFTPSecureFileTransferProtocol *SourceFileSecureSFTPSecureFileTransferProtocol

	Type SourceFileSecureStorageProviderType
}

func CreateSourceFileSecureStorageProviderSourceFileSecureHTTPSPublicWeb(sourceFileSecureHTTPSPublicWeb SourceFileSecureHTTPSPublicWeb) SourceFileSecureStorageProvider {
	typ := SourceFileSecureStorageProviderTypeSourceFileSecureHTTPSPublicWeb

	return SourceFileSecureStorageProvider{
		SourceFileSecureHTTPSPublicWeb: &sourceFileSecureHTTPSPublicWeb,
		Type:                           typ,
	}
}

func CreateSourceFileSecureStorageProviderSourceFileSecureGCSGoogleCloudStorage(sourceFileSecureGCSGoogleCloudStorage SourceFileSecureGCSGoogleCloudStorage) SourceFileSecureStorageProvider {
	typ := SourceFileSecureStorageProviderTypeSourceFileSecureGCSGoogleCloudStorage

	return SourceFileSecureStorageProvider{
		SourceFileSecureGCSGoogleCloudStorage: &sourceFileSecureGCSGoogleCloudStorage,
		Type:                                  typ,
	}
}

func CreateSourceFileSecureStorageProviderSourceFileSecureS3AmazonWebServices(sourceFileSecureS3AmazonWebServices SourceFileSecureS3AmazonWebServices) SourceFileSecureStorageProvider {
	typ := SourceFileSecureStorageProviderTypeSourceFileSecureS3AmazonWebServices

	return SourceFileSecureStorageProvider{
		SourceFileSecureS3AmazonWebServices: &sourceFileSecureS3AmazonWebServices,
		Type:                                typ,
	}
}

func CreateSourceFileSecureStorageProviderSourceFileSecureAzBlobAzureBlobStorage(sourceFileSecureAzBlobAzureBlobStorage SourceFileSecureAzBlobAzureBlobStorage) SourceFileSecureStorageProvider {
	typ := SourceFileSecureStorageProviderTypeSourceFileSecureAzBlobAzureBlobStorage

	return SourceFileSecureStorageProvider{
		SourceFileSecureAzBlobAzureBlobStorage: &sourceFileSecureAzBlobAzureBlobStorage,
		Type:                                   typ,
	}
}

func CreateSourceFileSecureStorageProviderSourceFileSecureSSHSecureShell(sourceFileSecureSSHSecureShell SourceFileSecureSSHSecureShell) SourceFileSecureStorageProvider {
	typ := SourceFileSecureStorageProviderTypeSourceFileSecureSSHSecureShell

	return SourceFileSecureStorageProvider{
		SourceFileSecureSSHSecureShell: &sourceFileSecureSSHSecureShell,
		Type:                           typ,
	}
}

func CreateSourceFileSecureStorageProviderSourceFileSecureSCPSecureCopyProtocol(sourceFileSecureSCPSecureCopyProtocol SourceFileSecureSCPSecureCopyProtocol) SourceFileSecureStorageProvider {
	typ := SourceFileSecureStorageProviderTypeSourceFileSecureSCPSecureCopyProtocol

	return SourceFileSecureStorageProvider{
		SourceFileSecureSCPSecureCopyProtocol: &sourceFileSecureSCPSecureCopyProtocol,
		Type:                                  typ,
	}
}

func CreateSourceFileSecureStorageProviderSourceFileSecureSFTPSecureFileTransferProtocol(sourceFileSecureSFTPSecureFileTransferProtocol SourceFileSecureSFTPSecureFileTransferProtocol) SourceFileSecureStorageProvider {
	typ := SourceFileSecureStorageProviderTypeSourceFileSecureSFTPSecureFileTransferProtocol

	return SourceFileSecureStorageProvider{
		SourceFileSecureSFTPSecureFileTransferProtocol: &sourceFileSecureSFTPSecureFileTransferProtocol,
		Type: typ,
	}
}

func (u *SourceFileSecureStorageProvider) UnmarshalJSON(data []byte) error {

	sourceFileSecureHTTPSPublicWeb := new(SourceFileSecureHTTPSPublicWeb)
	if err := utils.UnmarshalJSON(data, &sourceFileSecureHTTPSPublicWeb, "", true, true); err == nil {
		u.SourceFileSecureHTTPSPublicWeb = sourceFileSecureHTTPSPublicWeb
		u.Type = SourceFileSecureStorageProviderTypeSourceFileSecureHTTPSPublicWeb
		return nil
	}

	sourceFileSecureGCSGoogleCloudStorage := new(SourceFileSecureGCSGoogleCloudStorage)
	if err := utils.UnmarshalJSON(data, &sourceFileSecureGCSGoogleCloudStorage, "", true, true); err == nil {
		u.SourceFileSecureGCSGoogleCloudStorage = sourceFileSecureGCSGoogleCloudStorage
		u.Type = SourceFileSecureStorageProviderTypeSourceFileSecureGCSGoogleCloudStorage
		return nil
	}

	sourceFileSecureS3AmazonWebServices := new(SourceFileSecureS3AmazonWebServices)
	if err := utils.UnmarshalJSON(data, &sourceFileSecureS3AmazonWebServices, "", true, true); err == nil {
		u.SourceFileSecureS3AmazonWebServices = sourceFileSecureS3AmazonWebServices
		u.Type = SourceFileSecureStorageProviderTypeSourceFileSecureS3AmazonWebServices
		return nil
	}

	sourceFileSecureAzBlobAzureBlobStorage := new(SourceFileSecureAzBlobAzureBlobStorage)
	if err := utils.UnmarshalJSON(data, &sourceFileSecureAzBlobAzureBlobStorage, "", true, true); err == nil {
		u.SourceFileSecureAzBlobAzureBlobStorage = sourceFileSecureAzBlobAzureBlobStorage
		u.Type = SourceFileSecureStorageProviderTypeSourceFileSecureAzBlobAzureBlobStorage
		return nil
	}

	sourceFileSecureSSHSecureShell := new(SourceFileSecureSSHSecureShell)
	if err := utils.UnmarshalJSON(data, &sourceFileSecureSSHSecureShell, "", true, true); err == nil {
		u.SourceFileSecureSSHSecureShell = sourceFileSecureSSHSecureShell
		u.Type = SourceFileSecureStorageProviderTypeSourceFileSecureSSHSecureShell
		return nil
	}

	sourceFileSecureSCPSecureCopyProtocol := new(SourceFileSecureSCPSecureCopyProtocol)
	if err := utils.UnmarshalJSON(data, &sourceFileSecureSCPSecureCopyProtocol, "", true, true); err == nil {
		u.SourceFileSecureSCPSecureCopyProtocol = sourceFileSecureSCPSecureCopyProtocol
		u.Type = SourceFileSecureStorageProviderTypeSourceFileSecureSCPSecureCopyProtocol
		return nil
	}

	sourceFileSecureSFTPSecureFileTransferProtocol := new(SourceFileSecureSFTPSecureFileTransferProtocol)
	if err := utils.UnmarshalJSON(data, &sourceFileSecureSFTPSecureFileTransferProtocol, "", true, true); err == nil {
		u.SourceFileSecureSFTPSecureFileTransferProtocol = sourceFileSecureSFTPSecureFileTransferProtocol
		u.Type = SourceFileSecureStorageProviderTypeSourceFileSecureSFTPSecureFileTransferProtocol
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SourceFileSecureStorageProvider) MarshalJSON() ([]byte, error) {
	if u.SourceFileSecureHTTPSPublicWeb != nil {
		return utils.MarshalJSON(u.SourceFileSecureHTTPSPublicWeb, "", true)
	}

	if u.SourceFileSecureGCSGoogleCloudStorage != nil {
		return utils.MarshalJSON(u.SourceFileSecureGCSGoogleCloudStorage, "", true)
	}

	if u.SourceFileSecureS3AmazonWebServices != nil {
		return utils.MarshalJSON(u.SourceFileSecureS3AmazonWebServices, "", true)
	}

	if u.SourceFileSecureAzBlobAzureBlobStorage != nil {
		return utils.MarshalJSON(u.SourceFileSecureAzBlobAzureBlobStorage, "", true)
	}

	if u.SourceFileSecureSSHSecureShell != nil {
		return utils.MarshalJSON(u.SourceFileSecureSSHSecureShell, "", true)
	}

	if u.SourceFileSecureSCPSecureCopyProtocol != nil {
		return utils.MarshalJSON(u.SourceFileSecureSCPSecureCopyProtocol, "", true)
	}

	if u.SourceFileSecureSFTPSecureFileTransferProtocol != nil {
		return utils.MarshalJSON(u.SourceFileSecureSFTPSecureFileTransferProtocol, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type FileSecure string

const (
	FileSecureFileSecure FileSecure = "file-secure"
)

func (e FileSecure) ToPointer() *FileSecure {
	return &e
}

func (e *FileSecure) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "file-secure":
		*e = FileSecure(v)
		return nil
	default:
		return fmt.Errorf("invalid value for FileSecure: %v", v)
	}
}

type SourceFileSecure struct {
	// The Name of the final table to replicate this file into (should include letters, numbers dash and underscores only).
	DatasetName string `json:"dataset_name"`
	// The Format of the file which should be replicated (Warning: some formats may be experimental, please refer to the docs).
	Format *SourceFileSecureFileFormat `default:"csv" json:"format"`
	// The storage Provider or Location of the file(s) which should be replicated.
	Provider SourceFileSecureStorageProvider `json:"provider"`
	// This should be a string in JSON format. It depends on the chosen file format to provide additional options and tune its behavior.
	ReaderOptions *string    `json:"reader_options,omitempty"`
	sourceType    FileSecure `const:"file-secure" json:"sourceType"`
	// The URL path to access the file which should be replicated.
	URL string `json:"url"`
}

func (s SourceFileSecure) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceFileSecure) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *SourceFileSecure) GetDatasetName() string {
	if o == nil {
		return ""
	}
	return o.DatasetName
}

func (o *SourceFileSecure) GetFormat() *SourceFileSecureFileFormat {
	if o == nil {
		return nil
	}
	return o.Format
}

func (o *SourceFileSecure) GetProvider() SourceFileSecureStorageProvider {
	if o == nil {
		return SourceFileSecureStorageProvider{}
	}
	return o.Provider
}

func (o *SourceFileSecure) GetReaderOptions() *string {
	if o == nil {
		return nil
	}
	return o.ReaderOptions
}

func (o *SourceFileSecure) GetSourceType() FileSecure {
	return FileSecureFileSecure
}

func (o *SourceFileSecure) GetURL() string {
	if o == nil {
		return ""
	}
	return o.URL
}
