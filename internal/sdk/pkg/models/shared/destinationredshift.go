// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/pkg/utils"
)

type Redshift string

const (
	RedshiftRedshift Redshift = "redshift"
)

func (e Redshift) ToPointer() *Redshift {
	return &e
}

func (e *Redshift) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "redshift":
		*e = Redshift(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Redshift: %v", v)
	}
}

// DestinationRedshiftSchemasTunnelMethodTunnelMethod - Connect through a jump server tunnel host using username and password authentication
type DestinationRedshiftSchemasTunnelMethodTunnelMethod string

const (
	DestinationRedshiftSchemasTunnelMethodTunnelMethodSSHPasswordAuth DestinationRedshiftSchemasTunnelMethodTunnelMethod = "SSH_PASSWORD_AUTH"
)

func (e DestinationRedshiftSchemasTunnelMethodTunnelMethod) ToPointer() *DestinationRedshiftSchemasTunnelMethodTunnelMethod {
	return &e
}

func (e *DestinationRedshiftSchemasTunnelMethodTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_PASSWORD_AUTH":
		*e = DestinationRedshiftSchemasTunnelMethodTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationRedshiftSchemasTunnelMethodTunnelMethod: %v", v)
	}
}

// DestinationRedshiftPasswordAuthentication - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type DestinationRedshiftPasswordAuthentication struct {
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and password authentication
	tunnelMethod DestinationRedshiftSchemasTunnelMethodTunnelMethod `const:"SSH_PASSWORD_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser string `json:"tunnel_user"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword string `json:"tunnel_user_password"`
}

func (d DestinationRedshiftPasswordAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationRedshiftPasswordAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationRedshiftPasswordAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *DestinationRedshiftPasswordAuthentication) GetTunnelMethod() DestinationRedshiftSchemasTunnelMethodTunnelMethod {
	return DestinationRedshiftSchemasTunnelMethodTunnelMethodSSHPasswordAuth
}

func (o *DestinationRedshiftPasswordAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *DestinationRedshiftPasswordAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

func (o *DestinationRedshiftPasswordAuthentication) GetTunnelUserPassword() string {
	if o == nil {
		return ""
	}
	return o.TunnelUserPassword
}

// DestinationRedshiftSchemasTunnelMethod - Connect through a jump server tunnel host using username and ssh key
type DestinationRedshiftSchemasTunnelMethod string

const (
	DestinationRedshiftSchemasTunnelMethodSSHKeyAuth DestinationRedshiftSchemasTunnelMethod = "SSH_KEY_AUTH"
)

func (e DestinationRedshiftSchemasTunnelMethod) ToPointer() *DestinationRedshiftSchemasTunnelMethod {
	return &e
}

func (e *DestinationRedshiftSchemasTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_KEY_AUTH":
		*e = DestinationRedshiftSchemasTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationRedshiftSchemasTunnelMethod: %v", v)
	}
}

// DestinationRedshiftSSHKeyAuthentication - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type DestinationRedshiftSSHKeyAuthentication struct {
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey string `json:"ssh_key"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and ssh key
	tunnelMethod DestinationRedshiftSchemasTunnelMethod `const:"SSH_KEY_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host.
	TunnelUser string `json:"tunnel_user"`
}

func (d DestinationRedshiftSSHKeyAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationRedshiftSSHKeyAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationRedshiftSSHKeyAuthentication) GetSSHKey() string {
	if o == nil {
		return ""
	}
	return o.SSHKey
}

func (o *DestinationRedshiftSSHKeyAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *DestinationRedshiftSSHKeyAuthentication) GetTunnelMethod() DestinationRedshiftSchemasTunnelMethod {
	return DestinationRedshiftSchemasTunnelMethodSSHKeyAuth
}

func (o *DestinationRedshiftSSHKeyAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *DestinationRedshiftSSHKeyAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

// DestinationRedshiftTunnelMethod - No ssh tunnel needed to connect to database
type DestinationRedshiftTunnelMethod string

const (
	DestinationRedshiftTunnelMethodNoTunnel DestinationRedshiftTunnelMethod = "NO_TUNNEL"
)

func (e DestinationRedshiftTunnelMethod) ToPointer() *DestinationRedshiftTunnelMethod {
	return &e
}

func (e *DestinationRedshiftTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NO_TUNNEL":
		*e = DestinationRedshiftTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationRedshiftTunnelMethod: %v", v)
	}
}

// DestinationRedshiftNoTunnel - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type DestinationRedshiftNoTunnel struct {
	// No ssh tunnel needed to connect to database
	tunnelMethod DestinationRedshiftTunnelMethod `const:"NO_TUNNEL" json:"tunnel_method"`
}

func (d DestinationRedshiftNoTunnel) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationRedshiftNoTunnel) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationRedshiftNoTunnel) GetTunnelMethod() DestinationRedshiftTunnelMethod {
	return DestinationRedshiftTunnelMethodNoTunnel
}

type DestinationRedshiftSSHTunnelMethodType string

const (
	DestinationRedshiftSSHTunnelMethodTypeDestinationRedshiftNoTunnel               DestinationRedshiftSSHTunnelMethodType = "destination-redshift_No Tunnel"
	DestinationRedshiftSSHTunnelMethodTypeDestinationRedshiftSSHKeyAuthentication   DestinationRedshiftSSHTunnelMethodType = "destination-redshift_SSH Key Authentication"
	DestinationRedshiftSSHTunnelMethodTypeDestinationRedshiftPasswordAuthentication DestinationRedshiftSSHTunnelMethodType = "destination-redshift_Password Authentication"
)

type DestinationRedshiftSSHTunnelMethod struct {
	DestinationRedshiftNoTunnel               *DestinationRedshiftNoTunnel
	DestinationRedshiftSSHKeyAuthentication   *DestinationRedshiftSSHKeyAuthentication
	DestinationRedshiftPasswordAuthentication *DestinationRedshiftPasswordAuthentication

	Type DestinationRedshiftSSHTunnelMethodType
}

func CreateDestinationRedshiftSSHTunnelMethodDestinationRedshiftNoTunnel(destinationRedshiftNoTunnel DestinationRedshiftNoTunnel) DestinationRedshiftSSHTunnelMethod {
	typ := DestinationRedshiftSSHTunnelMethodTypeDestinationRedshiftNoTunnel

	return DestinationRedshiftSSHTunnelMethod{
		DestinationRedshiftNoTunnel: &destinationRedshiftNoTunnel,
		Type:                        typ,
	}
}

func CreateDestinationRedshiftSSHTunnelMethodDestinationRedshiftSSHKeyAuthentication(destinationRedshiftSSHKeyAuthentication DestinationRedshiftSSHKeyAuthentication) DestinationRedshiftSSHTunnelMethod {
	typ := DestinationRedshiftSSHTunnelMethodTypeDestinationRedshiftSSHKeyAuthentication

	return DestinationRedshiftSSHTunnelMethod{
		DestinationRedshiftSSHKeyAuthentication: &destinationRedshiftSSHKeyAuthentication,
		Type:                                    typ,
	}
}

func CreateDestinationRedshiftSSHTunnelMethodDestinationRedshiftPasswordAuthentication(destinationRedshiftPasswordAuthentication DestinationRedshiftPasswordAuthentication) DestinationRedshiftSSHTunnelMethod {
	typ := DestinationRedshiftSSHTunnelMethodTypeDestinationRedshiftPasswordAuthentication

	return DestinationRedshiftSSHTunnelMethod{
		DestinationRedshiftPasswordAuthentication: &destinationRedshiftPasswordAuthentication,
		Type: typ,
	}
}

func (u *DestinationRedshiftSSHTunnelMethod) UnmarshalJSON(data []byte) error {

	destinationRedshiftNoTunnel := new(DestinationRedshiftNoTunnel)
	if err := utils.UnmarshalJSON(data, &destinationRedshiftNoTunnel, "", true, true); err == nil {
		u.DestinationRedshiftNoTunnel = destinationRedshiftNoTunnel
		u.Type = DestinationRedshiftSSHTunnelMethodTypeDestinationRedshiftNoTunnel
		return nil
	}

	destinationRedshiftSSHKeyAuthentication := new(DestinationRedshiftSSHKeyAuthentication)
	if err := utils.UnmarshalJSON(data, &destinationRedshiftSSHKeyAuthentication, "", true, true); err == nil {
		u.DestinationRedshiftSSHKeyAuthentication = destinationRedshiftSSHKeyAuthentication
		u.Type = DestinationRedshiftSSHTunnelMethodTypeDestinationRedshiftSSHKeyAuthentication
		return nil
	}

	destinationRedshiftPasswordAuthentication := new(DestinationRedshiftPasswordAuthentication)
	if err := utils.UnmarshalJSON(data, &destinationRedshiftPasswordAuthentication, "", true, true); err == nil {
		u.DestinationRedshiftPasswordAuthentication = destinationRedshiftPasswordAuthentication
		u.Type = DestinationRedshiftSSHTunnelMethodTypeDestinationRedshiftPasswordAuthentication
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u DestinationRedshiftSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.DestinationRedshiftNoTunnel != nil {
		return utils.MarshalJSON(u.DestinationRedshiftNoTunnel, "", true)
	}

	if u.DestinationRedshiftSSHKeyAuthentication != nil {
		return utils.MarshalJSON(u.DestinationRedshiftSSHKeyAuthentication, "", true)
	}

	if u.DestinationRedshiftPasswordAuthentication != nil {
		return utils.MarshalJSON(u.DestinationRedshiftPasswordAuthentication, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type DestinationRedshiftSchemasMethod string

const (
	DestinationRedshiftSchemasMethodStandard DestinationRedshiftSchemasMethod = "Standard"
)

func (e DestinationRedshiftSchemasMethod) ToPointer() *DestinationRedshiftSchemasMethod {
	return &e
}

func (e *DestinationRedshiftSchemasMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Standard":
		*e = DestinationRedshiftSchemasMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationRedshiftSchemasMethod: %v", v)
	}
}

// DestinationRedshiftStandard - <i>(not recommended)</i> Direct loading using SQL INSERT statements. This method is extremely inefficient and provided only for quick testing. In all other cases, you should use S3 uploading.
type DestinationRedshiftStandard struct {
	method DestinationRedshiftSchemasMethod `const:"Standard" json:"method"`
}

func (d DestinationRedshiftStandard) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationRedshiftStandard) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationRedshiftStandard) GetMethod() DestinationRedshiftSchemasMethod {
	return DestinationRedshiftSchemasMethodStandard
}

type DestinationRedshiftSchemasEncryptionType string

const (
	DestinationRedshiftSchemasEncryptionTypeAesCbcEnvelope DestinationRedshiftSchemasEncryptionType = "aes_cbc_envelope"
)

func (e DestinationRedshiftSchemasEncryptionType) ToPointer() *DestinationRedshiftSchemasEncryptionType {
	return &e
}

func (e *DestinationRedshiftSchemasEncryptionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "aes_cbc_envelope":
		*e = DestinationRedshiftSchemasEncryptionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationRedshiftSchemasEncryptionType: %v", v)
	}
}

// DestinationRedshiftAESCBCEnvelopeEncryption - Staging data will be encrypted using AES-CBC envelope encryption.
type DestinationRedshiftAESCBCEnvelopeEncryption struct {
	encryptionType *DestinationRedshiftSchemasEncryptionType `const:"aes_cbc_envelope" json:"encryption_type"`
	// The key, base64-encoded. Must be either 128, 192, or 256 bits. Leave blank to have Airbyte generate an ephemeral key for each sync.
	KeyEncryptingKey *string `json:"key_encrypting_key,omitempty"`
}

func (d DestinationRedshiftAESCBCEnvelopeEncryption) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationRedshiftAESCBCEnvelopeEncryption) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationRedshiftAESCBCEnvelopeEncryption) GetEncryptionType() *DestinationRedshiftSchemasEncryptionType {
	return DestinationRedshiftSchemasEncryptionTypeAesCbcEnvelope.ToPointer()
}

func (o *DestinationRedshiftAESCBCEnvelopeEncryption) GetKeyEncryptingKey() *string {
	if o == nil {
		return nil
	}
	return o.KeyEncryptingKey
}

type DestinationRedshiftEncryptionType string

const (
	DestinationRedshiftEncryptionTypeNone DestinationRedshiftEncryptionType = "none"
)

func (e DestinationRedshiftEncryptionType) ToPointer() *DestinationRedshiftEncryptionType {
	return &e
}

func (e *DestinationRedshiftEncryptionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "none":
		*e = DestinationRedshiftEncryptionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationRedshiftEncryptionType: %v", v)
	}
}

// DestinationRedshiftNoEncryption - Staging data will be stored in plaintext.
type DestinationRedshiftNoEncryption struct {
	encryptionType *DestinationRedshiftEncryptionType `const:"none" json:"encryption_type"`
}

func (d DestinationRedshiftNoEncryption) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationRedshiftNoEncryption) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationRedshiftNoEncryption) GetEncryptionType() *DestinationRedshiftEncryptionType {
	return DestinationRedshiftEncryptionTypeNone.ToPointer()
}

type DestinationRedshiftEncryptionUnionType string

const (
	DestinationRedshiftEncryptionUnionTypeDestinationRedshiftNoEncryption             DestinationRedshiftEncryptionUnionType = "destination-redshift_No encryption"
	DestinationRedshiftEncryptionUnionTypeDestinationRedshiftAESCBCEnvelopeEncryption DestinationRedshiftEncryptionUnionType = "destination-redshift_AES-CBC envelope encryption"
)

type DestinationRedshiftEncryption struct {
	DestinationRedshiftNoEncryption             *DestinationRedshiftNoEncryption
	DestinationRedshiftAESCBCEnvelopeEncryption *DestinationRedshiftAESCBCEnvelopeEncryption

	Type DestinationRedshiftEncryptionUnionType
}

func CreateDestinationRedshiftEncryptionDestinationRedshiftNoEncryption(destinationRedshiftNoEncryption DestinationRedshiftNoEncryption) DestinationRedshiftEncryption {
	typ := DestinationRedshiftEncryptionUnionTypeDestinationRedshiftNoEncryption

	return DestinationRedshiftEncryption{
		DestinationRedshiftNoEncryption: &destinationRedshiftNoEncryption,
		Type:                            typ,
	}
}

func CreateDestinationRedshiftEncryptionDestinationRedshiftAESCBCEnvelopeEncryption(destinationRedshiftAESCBCEnvelopeEncryption DestinationRedshiftAESCBCEnvelopeEncryption) DestinationRedshiftEncryption {
	typ := DestinationRedshiftEncryptionUnionTypeDestinationRedshiftAESCBCEnvelopeEncryption

	return DestinationRedshiftEncryption{
		DestinationRedshiftAESCBCEnvelopeEncryption: &destinationRedshiftAESCBCEnvelopeEncryption,
		Type: typ,
	}
}

func (u *DestinationRedshiftEncryption) UnmarshalJSON(data []byte) error {

	destinationRedshiftNoEncryption := new(DestinationRedshiftNoEncryption)
	if err := utils.UnmarshalJSON(data, &destinationRedshiftNoEncryption, "", true, true); err == nil {
		u.DestinationRedshiftNoEncryption = destinationRedshiftNoEncryption
		u.Type = DestinationRedshiftEncryptionUnionTypeDestinationRedshiftNoEncryption
		return nil
	}

	destinationRedshiftAESCBCEnvelopeEncryption := new(DestinationRedshiftAESCBCEnvelopeEncryption)
	if err := utils.UnmarshalJSON(data, &destinationRedshiftAESCBCEnvelopeEncryption, "", true, true); err == nil {
		u.DestinationRedshiftAESCBCEnvelopeEncryption = destinationRedshiftAESCBCEnvelopeEncryption
		u.Type = DestinationRedshiftEncryptionUnionTypeDestinationRedshiftAESCBCEnvelopeEncryption
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u DestinationRedshiftEncryption) MarshalJSON() ([]byte, error) {
	if u.DestinationRedshiftNoEncryption != nil {
		return utils.MarshalJSON(u.DestinationRedshiftNoEncryption, "", true)
	}

	if u.DestinationRedshiftAESCBCEnvelopeEncryption != nil {
		return utils.MarshalJSON(u.DestinationRedshiftAESCBCEnvelopeEncryption, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type DestinationRedshiftMethod string

const (
	DestinationRedshiftMethodS3Staging DestinationRedshiftMethod = "S3 Staging"
)

func (e DestinationRedshiftMethod) ToPointer() *DestinationRedshiftMethod {
	return &e
}

func (e *DestinationRedshiftMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "S3 Staging":
		*e = DestinationRedshiftMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationRedshiftMethod: %v", v)
	}
}

// DestinationRedshiftS3BucketRegion - The region of the S3 staging bucket.
type DestinationRedshiftS3BucketRegion string

const (
	DestinationRedshiftS3BucketRegionUnknown      DestinationRedshiftS3BucketRegion = ""
	DestinationRedshiftS3BucketRegionUsEast1      DestinationRedshiftS3BucketRegion = "us-east-1"
	DestinationRedshiftS3BucketRegionUsEast2      DestinationRedshiftS3BucketRegion = "us-east-2"
	DestinationRedshiftS3BucketRegionUsWest1      DestinationRedshiftS3BucketRegion = "us-west-1"
	DestinationRedshiftS3BucketRegionUsWest2      DestinationRedshiftS3BucketRegion = "us-west-2"
	DestinationRedshiftS3BucketRegionAfSouth1     DestinationRedshiftS3BucketRegion = "af-south-1"
	DestinationRedshiftS3BucketRegionApEast1      DestinationRedshiftS3BucketRegion = "ap-east-1"
	DestinationRedshiftS3BucketRegionApSouth1     DestinationRedshiftS3BucketRegion = "ap-south-1"
	DestinationRedshiftS3BucketRegionApNortheast1 DestinationRedshiftS3BucketRegion = "ap-northeast-1"
	DestinationRedshiftS3BucketRegionApNortheast2 DestinationRedshiftS3BucketRegion = "ap-northeast-2"
	DestinationRedshiftS3BucketRegionApNortheast3 DestinationRedshiftS3BucketRegion = "ap-northeast-3"
	DestinationRedshiftS3BucketRegionApSoutheast1 DestinationRedshiftS3BucketRegion = "ap-southeast-1"
	DestinationRedshiftS3BucketRegionApSoutheast2 DestinationRedshiftS3BucketRegion = "ap-southeast-2"
	DestinationRedshiftS3BucketRegionCaCentral1   DestinationRedshiftS3BucketRegion = "ca-central-1"
	DestinationRedshiftS3BucketRegionCnNorth1     DestinationRedshiftS3BucketRegion = "cn-north-1"
	DestinationRedshiftS3BucketRegionCnNorthwest1 DestinationRedshiftS3BucketRegion = "cn-northwest-1"
	DestinationRedshiftS3BucketRegionEuCentral1   DestinationRedshiftS3BucketRegion = "eu-central-1"
	DestinationRedshiftS3BucketRegionEuNorth1     DestinationRedshiftS3BucketRegion = "eu-north-1"
	DestinationRedshiftS3BucketRegionEuSouth1     DestinationRedshiftS3BucketRegion = "eu-south-1"
	DestinationRedshiftS3BucketRegionEuWest1      DestinationRedshiftS3BucketRegion = "eu-west-1"
	DestinationRedshiftS3BucketRegionEuWest2      DestinationRedshiftS3BucketRegion = "eu-west-2"
	DestinationRedshiftS3BucketRegionEuWest3      DestinationRedshiftS3BucketRegion = "eu-west-3"
	DestinationRedshiftS3BucketRegionSaEast1      DestinationRedshiftS3BucketRegion = "sa-east-1"
	DestinationRedshiftS3BucketRegionMeSouth1     DestinationRedshiftS3BucketRegion = "me-south-1"
)

func (e DestinationRedshiftS3BucketRegion) ToPointer() *DestinationRedshiftS3BucketRegion {
	return &e
}

func (e *DestinationRedshiftS3BucketRegion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "":
		fallthrough
	case "us-east-1":
		fallthrough
	case "us-east-2":
		fallthrough
	case "us-west-1":
		fallthrough
	case "us-west-2":
		fallthrough
	case "af-south-1":
		fallthrough
	case "ap-east-1":
		fallthrough
	case "ap-south-1":
		fallthrough
	case "ap-northeast-1":
		fallthrough
	case "ap-northeast-2":
		fallthrough
	case "ap-northeast-3":
		fallthrough
	case "ap-southeast-1":
		fallthrough
	case "ap-southeast-2":
		fallthrough
	case "ca-central-1":
		fallthrough
	case "cn-north-1":
		fallthrough
	case "cn-northwest-1":
		fallthrough
	case "eu-central-1":
		fallthrough
	case "eu-north-1":
		fallthrough
	case "eu-south-1":
		fallthrough
	case "eu-west-1":
		fallthrough
	case "eu-west-2":
		fallthrough
	case "eu-west-3":
		fallthrough
	case "sa-east-1":
		fallthrough
	case "me-south-1":
		*e = DestinationRedshiftS3BucketRegion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationRedshiftS3BucketRegion: %v", v)
	}
}

// DestinationRedshiftS3Staging - <i>(recommended)</i> Uploads data to S3 and then uses a COPY to insert the data into Redshift. COPY is recommended for production workloads for better speed and scalability. See <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/creating-bucket.html">AWS docs</a> for more details.
type DestinationRedshiftS3Staging struct {
	// This ID grants access to the above S3 staging bucket. Airbyte requires Read and Write permissions to the given bucket. See <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">AWS docs</a> on how to generate an access key ID and secret access key.
	AccessKeyID string `json:"access_key_id"`
	// How to encrypt the staging data
	Encryption *DestinationRedshiftEncryption `json:"encryption,omitempty"`
	// Number of file buffers allocated for writing data. Increasing this number is beneficial for connections using Change Data Capture (CDC) and up to the number of streams within a connection. Increasing the number of file buffers past the maximum number of streams has deteriorating effects
	FileBufferCount *int64 `default:"10" json:"file_buffer_count"`
	// The pattern allows you to set the file-name format for the S3 staging file(s)
	FileNamePattern *string                   `json:"file_name_pattern,omitempty"`
	method          DestinationRedshiftMethod `const:"S3 Staging" json:"method"`
	// Whether to delete the staging files from S3 after completing the sync. See <a href="https://docs.airbyte.com/integrations/destinations/redshift/#:~:text=the%20root%20directory.-,Purge%20Staging%20Data,-Whether%20to%20delete"> docs</a> for details.
	PurgeStagingData *bool `default:"true" json:"purge_staging_data"`
	// The name of the staging S3 bucket.
	S3BucketName string `json:"s3_bucket_name"`
	// The directory under the S3 bucket where data will be written. If not provided, then defaults to the root directory. See <a href="https://docs.aws.amazon.com/prescriptive-guidance/latest/defining-bucket-names-data-lakes/faq.html#:~:text=be%20globally%20unique.-,For%20S3%20bucket%20paths,-%2C%20you%20can%20use">path's name recommendations</a> for more details.
	S3BucketPath *string `json:"s3_bucket_path,omitempty"`
	// The region of the S3 staging bucket.
	S3BucketRegion *DestinationRedshiftS3BucketRegion `default:"" json:"s3_bucket_region"`
	// The corresponding secret to the above access key id. See <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">AWS docs</a> on how to generate an access key ID and secret access key.
	SecretAccessKey string `json:"secret_access_key"`
}

func (d DestinationRedshiftS3Staging) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationRedshiftS3Staging) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationRedshiftS3Staging) GetAccessKeyID() string {
	if o == nil {
		return ""
	}
	return o.AccessKeyID
}

func (o *DestinationRedshiftS3Staging) GetEncryption() *DestinationRedshiftEncryption {
	if o == nil {
		return nil
	}
	return o.Encryption
}

func (o *DestinationRedshiftS3Staging) GetFileBufferCount() *int64 {
	if o == nil {
		return nil
	}
	return o.FileBufferCount
}

func (o *DestinationRedshiftS3Staging) GetFileNamePattern() *string {
	if o == nil {
		return nil
	}
	return o.FileNamePattern
}

func (o *DestinationRedshiftS3Staging) GetMethod() DestinationRedshiftMethod {
	return DestinationRedshiftMethodS3Staging
}

func (o *DestinationRedshiftS3Staging) GetPurgeStagingData() *bool {
	if o == nil {
		return nil
	}
	return o.PurgeStagingData
}

func (o *DestinationRedshiftS3Staging) GetS3BucketName() string {
	if o == nil {
		return ""
	}
	return o.S3BucketName
}

func (o *DestinationRedshiftS3Staging) GetS3BucketPath() *string {
	if o == nil {
		return nil
	}
	return o.S3BucketPath
}

func (o *DestinationRedshiftS3Staging) GetS3BucketRegion() *DestinationRedshiftS3BucketRegion {
	if o == nil {
		return nil
	}
	return o.S3BucketRegion
}

func (o *DestinationRedshiftS3Staging) GetSecretAccessKey() string {
	if o == nil {
		return ""
	}
	return o.SecretAccessKey
}

type DestinationRedshiftUploadingMethodType string

const (
	DestinationRedshiftUploadingMethodTypeDestinationRedshiftS3Staging DestinationRedshiftUploadingMethodType = "destination-redshift_S3 Staging"
	DestinationRedshiftUploadingMethodTypeDestinationRedshiftStandard  DestinationRedshiftUploadingMethodType = "destination-redshift_Standard"
)

type DestinationRedshiftUploadingMethod struct {
	DestinationRedshiftS3Staging *DestinationRedshiftS3Staging
	DestinationRedshiftStandard  *DestinationRedshiftStandard

	Type DestinationRedshiftUploadingMethodType
}

func CreateDestinationRedshiftUploadingMethodDestinationRedshiftS3Staging(destinationRedshiftS3Staging DestinationRedshiftS3Staging) DestinationRedshiftUploadingMethod {
	typ := DestinationRedshiftUploadingMethodTypeDestinationRedshiftS3Staging

	return DestinationRedshiftUploadingMethod{
		DestinationRedshiftS3Staging: &destinationRedshiftS3Staging,
		Type:                         typ,
	}
}

func CreateDestinationRedshiftUploadingMethodDestinationRedshiftStandard(destinationRedshiftStandard DestinationRedshiftStandard) DestinationRedshiftUploadingMethod {
	typ := DestinationRedshiftUploadingMethodTypeDestinationRedshiftStandard

	return DestinationRedshiftUploadingMethod{
		DestinationRedshiftStandard: &destinationRedshiftStandard,
		Type:                        typ,
	}
}

func (u *DestinationRedshiftUploadingMethod) UnmarshalJSON(data []byte) error {

	destinationRedshiftStandard := new(DestinationRedshiftStandard)
	if err := utils.UnmarshalJSON(data, &destinationRedshiftStandard, "", true, true); err == nil {
		u.DestinationRedshiftStandard = destinationRedshiftStandard
		u.Type = DestinationRedshiftUploadingMethodTypeDestinationRedshiftStandard
		return nil
	}

	destinationRedshiftS3Staging := new(DestinationRedshiftS3Staging)
	if err := utils.UnmarshalJSON(data, &destinationRedshiftS3Staging, "", true, true); err == nil {
		u.DestinationRedshiftS3Staging = destinationRedshiftS3Staging
		u.Type = DestinationRedshiftUploadingMethodTypeDestinationRedshiftS3Staging
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u DestinationRedshiftUploadingMethod) MarshalJSON() ([]byte, error) {
	if u.DestinationRedshiftS3Staging != nil {
		return utils.MarshalJSON(u.DestinationRedshiftS3Staging, "", true)
	}

	if u.DestinationRedshiftStandard != nil {
		return utils.MarshalJSON(u.DestinationRedshiftStandard, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type DestinationRedshift struct {
	// Name of the database.
	Database        string   `json:"database"`
	destinationType Redshift `const:"redshift" json:"destinationType"`
	// Host Endpoint of the Redshift Cluster (must include the cluster-id, region and end with .redshift.amazonaws.com)
	Host string `json:"host"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// Password associated with the username.
	Password string `json:"password"`
	// Port of the database.
	Port *int64 `default:"5439" json:"port"`
	// The default schema tables are written to if the source does not specify a namespace. Unless specifically configured, the usual value for this field is "public".
	Schema *string `default:"public" json:"schema"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod *DestinationRedshiftSSHTunnelMethod `json:"tunnel_method,omitempty"`
	// The way data will be uploaded to Redshift.
	UploadingMethod *DestinationRedshiftUploadingMethod `json:"uploading_method,omitempty"`
	// Username to use to access the database.
	Username string `json:"username"`
}

func (d DestinationRedshift) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationRedshift) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *DestinationRedshift) GetDatabase() string {
	if o == nil {
		return ""
	}
	return o.Database
}

func (o *DestinationRedshift) GetDestinationType() Redshift {
	return RedshiftRedshift
}

func (o *DestinationRedshift) GetHost() string {
	if o == nil {
		return ""
	}
	return o.Host
}

func (o *DestinationRedshift) GetJdbcURLParams() *string {
	if o == nil {
		return nil
	}
	return o.JdbcURLParams
}

func (o *DestinationRedshift) GetPassword() string {
	if o == nil {
		return ""
	}
	return o.Password
}

func (o *DestinationRedshift) GetPort() *int64 {
	if o == nil {
		return nil
	}
	return o.Port
}

func (o *DestinationRedshift) GetSchema() *string {
	if o == nil {
		return nil
	}
	return o.Schema
}

func (o *DestinationRedshift) GetTunnelMethod() *DestinationRedshiftSSHTunnelMethod {
	if o == nil {
		return nil
	}
	return o.TunnelMethod
}

func (o *DestinationRedshift) GetUploadingMethod() *DestinationRedshiftUploadingMethod {
	if o == nil {
		return nil
	}
	return o.UploadingMethod
}

func (o *DestinationRedshift) GetUsername() string {
	if o == nil {
		return ""
	}
	return o.Username
}
