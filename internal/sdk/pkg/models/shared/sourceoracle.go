// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"airbyte/internal/sdk/pkg/utils"
	"encoding/json"
	"errors"
	"fmt"
)

type SourceOracleConnectBySystemIDSIDConnectionType string

const (
	SourceOracleConnectBySystemIDSIDConnectionTypeSid SourceOracleConnectBySystemIDSIDConnectionType = "sid"
)

func (e SourceOracleConnectBySystemIDSIDConnectionType) ToPointer() *SourceOracleConnectBySystemIDSIDConnectionType {
	return &e
}

func (e *SourceOracleConnectBySystemIDSIDConnectionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "sid":
		*e = SourceOracleConnectBySystemIDSIDConnectionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceOracleConnectBySystemIDSIDConnectionType: %v", v)
	}
}

// SourceOracleConnectBySystemIDSID - Use SID (Oracle System Identifier)
type SourceOracleConnectBySystemIDSID struct {
	connectionType *SourceOracleConnectBySystemIDSIDConnectionType `const:"sid" json:"connection_type"`
	Sid            string                                          `json:"sid"`
}

func (s SourceOracleConnectBySystemIDSID) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceOracleConnectBySystemIDSID) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceOracleConnectBySystemIDSID) GetConnectionType() *SourceOracleConnectBySystemIDSIDConnectionType {
	return SourceOracleConnectBySystemIDSIDConnectionTypeSid.ToPointer()
}

func (o *SourceOracleConnectBySystemIDSID) GetSid() string {
	if o == nil {
		return ""
	}
	return o.Sid
}

type SourceOracleConnectByServiceNameConnectionType string

const (
	SourceOracleConnectByServiceNameConnectionTypeServiceName SourceOracleConnectByServiceNameConnectionType = "service_name"
)

func (e SourceOracleConnectByServiceNameConnectionType) ToPointer() *SourceOracleConnectByServiceNameConnectionType {
	return &e
}

func (e *SourceOracleConnectByServiceNameConnectionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "service_name":
		*e = SourceOracleConnectByServiceNameConnectionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceOracleConnectByServiceNameConnectionType: %v", v)
	}
}

// SourceOracleConnectByServiceName - Use service name
type SourceOracleConnectByServiceName struct {
	connectionType *SourceOracleConnectByServiceNameConnectionType `const:"service_name" json:"connection_type"`
	ServiceName    string                                          `json:"service_name"`
}

func (s SourceOracleConnectByServiceName) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceOracleConnectByServiceName) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceOracleConnectByServiceName) GetConnectionType() *SourceOracleConnectByServiceNameConnectionType {
	return SourceOracleConnectByServiceNameConnectionTypeServiceName.ToPointer()
}

func (o *SourceOracleConnectByServiceName) GetServiceName() string {
	if o == nil {
		return ""
	}
	return o.ServiceName
}

type SourceOracleConnectByType string

const (
	SourceOracleConnectByTypeSourceOracleConnectByServiceName SourceOracleConnectByType = "source-oracle_Connect by_Service name"
	SourceOracleConnectByTypeSourceOracleConnectBySystemIDSID SourceOracleConnectByType = "source-oracle_Connect by_System ID (SID)"
)

type SourceOracleConnectBy struct {
	SourceOracleConnectByServiceName *SourceOracleConnectByServiceName
	SourceOracleConnectBySystemIDSID *SourceOracleConnectBySystemIDSID

	Type SourceOracleConnectByType
}

func CreateSourceOracleConnectBySourceOracleConnectByServiceName(sourceOracleConnectByServiceName SourceOracleConnectByServiceName) SourceOracleConnectBy {
	typ := SourceOracleConnectByTypeSourceOracleConnectByServiceName

	return SourceOracleConnectBy{
		SourceOracleConnectByServiceName: &sourceOracleConnectByServiceName,
		Type:                             typ,
	}
}

func CreateSourceOracleConnectBySourceOracleConnectBySystemIDSID(sourceOracleConnectBySystemIDSID SourceOracleConnectBySystemIDSID) SourceOracleConnectBy {
	typ := SourceOracleConnectByTypeSourceOracleConnectBySystemIDSID

	return SourceOracleConnectBy{
		SourceOracleConnectBySystemIDSID: &sourceOracleConnectBySystemIDSID,
		Type:                             typ,
	}
}

func (u *SourceOracleConnectBy) UnmarshalJSON(data []byte) error {

	sourceOracleConnectByServiceName := new(SourceOracleConnectByServiceName)
	if err := utils.UnmarshalJSON(data, &sourceOracleConnectByServiceName, "", true, true); err == nil {
		u.SourceOracleConnectByServiceName = sourceOracleConnectByServiceName
		u.Type = SourceOracleConnectByTypeSourceOracleConnectByServiceName
		return nil
	}

	sourceOracleConnectBySystemIDSID := new(SourceOracleConnectBySystemIDSID)
	if err := utils.UnmarshalJSON(data, &sourceOracleConnectBySystemIDSID, "", true, true); err == nil {
		u.SourceOracleConnectBySystemIDSID = sourceOracleConnectBySystemIDSID
		u.Type = SourceOracleConnectByTypeSourceOracleConnectBySystemIDSID
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SourceOracleConnectBy) MarshalJSON() ([]byte, error) {
	if u.SourceOracleConnectByServiceName != nil {
		return utils.MarshalJSON(u.SourceOracleConnectByServiceName, "", true)
	}

	if u.SourceOracleConnectBySystemIDSID != nil {
		return utils.MarshalJSON(u.SourceOracleConnectBySystemIDSID, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type SourceOracleEncryptionTLSEncryptedVerifyCertificateEncryptionMethod string

const (
	SourceOracleEncryptionTLSEncryptedVerifyCertificateEncryptionMethodEncryptedVerifyCertificate SourceOracleEncryptionTLSEncryptedVerifyCertificateEncryptionMethod = "encrypted_verify_certificate"
)

func (e SourceOracleEncryptionTLSEncryptedVerifyCertificateEncryptionMethod) ToPointer() *SourceOracleEncryptionTLSEncryptedVerifyCertificateEncryptionMethod {
	return &e
}

func (e *SourceOracleEncryptionTLSEncryptedVerifyCertificateEncryptionMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "encrypted_verify_certificate":
		*e = SourceOracleEncryptionTLSEncryptedVerifyCertificateEncryptionMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceOracleEncryptionTLSEncryptedVerifyCertificateEncryptionMethod: %v", v)
	}
}

// SourceOracleEncryptionTLSEncryptedVerifyCertificate - Verify and use the certificate provided by the server.
type SourceOracleEncryptionTLSEncryptedVerifyCertificate struct {
	encryptionMethod *SourceOracleEncryptionTLSEncryptedVerifyCertificateEncryptionMethod `const:"encrypted_verify_certificate" json:"encryption_method"`
	// Privacy Enhanced Mail (PEM) files are concatenated certificate containers frequently used in certificate installations.
	SslCertificate string `json:"ssl_certificate"`
}

func (s SourceOracleEncryptionTLSEncryptedVerifyCertificate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceOracleEncryptionTLSEncryptedVerifyCertificate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceOracleEncryptionTLSEncryptedVerifyCertificate) GetEncryptionMethod() *SourceOracleEncryptionTLSEncryptedVerifyCertificateEncryptionMethod {
	return SourceOracleEncryptionTLSEncryptedVerifyCertificateEncryptionMethodEncryptedVerifyCertificate.ToPointer()
}

func (o *SourceOracleEncryptionTLSEncryptedVerifyCertificate) GetSslCertificate() string {
	if o == nil {
		return ""
	}
	return o.SslCertificate
}

// SourceOracleEncryptionNativeNetworkEncryptionNNEEncryptionAlgorithm - This parameter defines what encryption algorithm is used.
type SourceOracleEncryptionNativeNetworkEncryptionNNEEncryptionAlgorithm string

const (
	SourceOracleEncryptionNativeNetworkEncryptionNNEEncryptionAlgorithmAes256      SourceOracleEncryptionNativeNetworkEncryptionNNEEncryptionAlgorithm = "AES256"
	SourceOracleEncryptionNativeNetworkEncryptionNNEEncryptionAlgorithmRc456       SourceOracleEncryptionNativeNetworkEncryptionNNEEncryptionAlgorithm = "RC4_56"
	SourceOracleEncryptionNativeNetworkEncryptionNNEEncryptionAlgorithmThreeDes168 SourceOracleEncryptionNativeNetworkEncryptionNNEEncryptionAlgorithm = "3DES168"
)

func (e SourceOracleEncryptionNativeNetworkEncryptionNNEEncryptionAlgorithm) ToPointer() *SourceOracleEncryptionNativeNetworkEncryptionNNEEncryptionAlgorithm {
	return &e
}

func (e *SourceOracleEncryptionNativeNetworkEncryptionNNEEncryptionAlgorithm) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "AES256":
		fallthrough
	case "RC4_56":
		fallthrough
	case "3DES168":
		*e = SourceOracleEncryptionNativeNetworkEncryptionNNEEncryptionAlgorithm(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceOracleEncryptionNativeNetworkEncryptionNNEEncryptionAlgorithm: %v", v)
	}
}

type SourceOracleEncryptionNativeNetworkEncryptionNNEEncryptionMethod string

const (
	SourceOracleEncryptionNativeNetworkEncryptionNNEEncryptionMethodClientNne SourceOracleEncryptionNativeNetworkEncryptionNNEEncryptionMethod = "client_nne"
)

func (e SourceOracleEncryptionNativeNetworkEncryptionNNEEncryptionMethod) ToPointer() *SourceOracleEncryptionNativeNetworkEncryptionNNEEncryptionMethod {
	return &e
}

func (e *SourceOracleEncryptionNativeNetworkEncryptionNNEEncryptionMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "client_nne":
		*e = SourceOracleEncryptionNativeNetworkEncryptionNNEEncryptionMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceOracleEncryptionNativeNetworkEncryptionNNEEncryptionMethod: %v", v)
	}
}

// SourceOracleEncryptionNativeNetworkEncryptionNNE - The native network encryption gives you the ability to encrypt database connections, without the configuration overhead of TCP/IP and SSL/TLS and without the need to open and listen on different ports.
type SourceOracleEncryptionNativeNetworkEncryptionNNE struct {
	// This parameter defines what encryption algorithm is used.
	EncryptionAlgorithm *SourceOracleEncryptionNativeNetworkEncryptionNNEEncryptionAlgorithm `default:"AES256" json:"encryption_algorithm"`
	encryptionMethod    *SourceOracleEncryptionNativeNetworkEncryptionNNEEncryptionMethod    `const:"client_nne" json:"encryption_method"`
}

func (s SourceOracleEncryptionNativeNetworkEncryptionNNE) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceOracleEncryptionNativeNetworkEncryptionNNE) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceOracleEncryptionNativeNetworkEncryptionNNE) GetEncryptionAlgorithm() *SourceOracleEncryptionNativeNetworkEncryptionNNEEncryptionAlgorithm {
	if o == nil {
		return nil
	}
	return o.EncryptionAlgorithm
}

func (o *SourceOracleEncryptionNativeNetworkEncryptionNNE) GetEncryptionMethod() *SourceOracleEncryptionNativeNetworkEncryptionNNEEncryptionMethod {
	return SourceOracleEncryptionNativeNetworkEncryptionNNEEncryptionMethodClientNne.ToPointer()
}

type SourceOracleEncryptionType string

const (
	SourceOracleEncryptionTypeSourceOracleEncryptionNativeNetworkEncryptionNNE    SourceOracleEncryptionType = "source-oracle_Encryption_Native Network Encryption (NNE)"
	SourceOracleEncryptionTypeSourceOracleEncryptionTLSEncryptedVerifyCertificate SourceOracleEncryptionType = "source-oracle_Encryption_TLS Encrypted (verify certificate)"
)

type SourceOracleEncryption struct {
	SourceOracleEncryptionNativeNetworkEncryptionNNE    *SourceOracleEncryptionNativeNetworkEncryptionNNE
	SourceOracleEncryptionTLSEncryptedVerifyCertificate *SourceOracleEncryptionTLSEncryptedVerifyCertificate

	Type SourceOracleEncryptionType
}

func CreateSourceOracleEncryptionSourceOracleEncryptionNativeNetworkEncryptionNNE(sourceOracleEncryptionNativeNetworkEncryptionNNE SourceOracleEncryptionNativeNetworkEncryptionNNE) SourceOracleEncryption {
	typ := SourceOracleEncryptionTypeSourceOracleEncryptionNativeNetworkEncryptionNNE

	return SourceOracleEncryption{
		SourceOracleEncryptionNativeNetworkEncryptionNNE: &sourceOracleEncryptionNativeNetworkEncryptionNNE,
		Type: typ,
	}
}

func CreateSourceOracleEncryptionSourceOracleEncryptionTLSEncryptedVerifyCertificate(sourceOracleEncryptionTLSEncryptedVerifyCertificate SourceOracleEncryptionTLSEncryptedVerifyCertificate) SourceOracleEncryption {
	typ := SourceOracleEncryptionTypeSourceOracleEncryptionTLSEncryptedVerifyCertificate

	return SourceOracleEncryption{
		SourceOracleEncryptionTLSEncryptedVerifyCertificate: &sourceOracleEncryptionTLSEncryptedVerifyCertificate,
		Type: typ,
	}
}

func (u *SourceOracleEncryption) UnmarshalJSON(data []byte) error {

	sourceOracleEncryptionNativeNetworkEncryptionNNE := new(SourceOracleEncryptionNativeNetworkEncryptionNNE)
	if err := utils.UnmarshalJSON(data, &sourceOracleEncryptionNativeNetworkEncryptionNNE, "", true, true); err == nil {
		u.SourceOracleEncryptionNativeNetworkEncryptionNNE = sourceOracleEncryptionNativeNetworkEncryptionNNE
		u.Type = SourceOracleEncryptionTypeSourceOracleEncryptionNativeNetworkEncryptionNNE
		return nil
	}

	sourceOracleEncryptionTLSEncryptedVerifyCertificate := new(SourceOracleEncryptionTLSEncryptedVerifyCertificate)
	if err := utils.UnmarshalJSON(data, &sourceOracleEncryptionTLSEncryptedVerifyCertificate, "", true, true); err == nil {
		u.SourceOracleEncryptionTLSEncryptedVerifyCertificate = sourceOracleEncryptionTLSEncryptedVerifyCertificate
		u.Type = SourceOracleEncryptionTypeSourceOracleEncryptionTLSEncryptedVerifyCertificate
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SourceOracleEncryption) MarshalJSON() ([]byte, error) {
	if u.SourceOracleEncryptionNativeNetworkEncryptionNNE != nil {
		return utils.MarshalJSON(u.SourceOracleEncryptionNativeNetworkEncryptionNNE, "", true)
	}

	if u.SourceOracleEncryptionTLSEncryptedVerifyCertificate != nil {
		return utils.MarshalJSON(u.SourceOracleEncryptionTLSEncryptedVerifyCertificate, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type SourceOracleOracle string

const (
	SourceOracleOracleOracle SourceOracleOracle = "oracle"
)

func (e SourceOracleOracle) ToPointer() *SourceOracleOracle {
	return &e
}

func (e *SourceOracleOracle) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "oracle":
		*e = SourceOracleOracle(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceOracleOracle: %v", v)
	}
}

// SourceOracleSSHTunnelMethodPasswordAuthenticationTunnelMethod - Connect through a jump server tunnel host using username and password authentication
type SourceOracleSSHTunnelMethodPasswordAuthenticationTunnelMethod string

const (
	SourceOracleSSHTunnelMethodPasswordAuthenticationTunnelMethodSSHPasswordAuth SourceOracleSSHTunnelMethodPasswordAuthenticationTunnelMethod = "SSH_PASSWORD_AUTH"
)

func (e SourceOracleSSHTunnelMethodPasswordAuthenticationTunnelMethod) ToPointer() *SourceOracleSSHTunnelMethodPasswordAuthenticationTunnelMethod {
	return &e
}

func (e *SourceOracleSSHTunnelMethodPasswordAuthenticationTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_PASSWORD_AUTH":
		*e = SourceOracleSSHTunnelMethodPasswordAuthenticationTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceOracleSSHTunnelMethodPasswordAuthenticationTunnelMethod: %v", v)
	}
}

// SourceOracleSSHTunnelMethodPasswordAuthentication - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceOracleSSHTunnelMethodPasswordAuthentication struct {
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and password authentication
	tunnelMethod SourceOracleSSHTunnelMethodPasswordAuthenticationTunnelMethod `const:"SSH_PASSWORD_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser string `json:"tunnel_user"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword string `json:"tunnel_user_password"`
}

func (s SourceOracleSSHTunnelMethodPasswordAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceOracleSSHTunnelMethodPasswordAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceOracleSSHTunnelMethodPasswordAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *SourceOracleSSHTunnelMethodPasswordAuthentication) GetTunnelMethod() SourceOracleSSHTunnelMethodPasswordAuthenticationTunnelMethod {
	return SourceOracleSSHTunnelMethodPasswordAuthenticationTunnelMethodSSHPasswordAuth
}

func (o *SourceOracleSSHTunnelMethodPasswordAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *SourceOracleSSHTunnelMethodPasswordAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

func (o *SourceOracleSSHTunnelMethodPasswordAuthentication) GetTunnelUserPassword() string {
	if o == nil {
		return ""
	}
	return o.TunnelUserPassword
}

// SourceOracleSSHTunnelMethodSSHKeyAuthenticationTunnelMethod - Connect through a jump server tunnel host using username and ssh key
type SourceOracleSSHTunnelMethodSSHKeyAuthenticationTunnelMethod string

const (
	SourceOracleSSHTunnelMethodSSHKeyAuthenticationTunnelMethodSSHKeyAuth SourceOracleSSHTunnelMethodSSHKeyAuthenticationTunnelMethod = "SSH_KEY_AUTH"
)

func (e SourceOracleSSHTunnelMethodSSHKeyAuthenticationTunnelMethod) ToPointer() *SourceOracleSSHTunnelMethodSSHKeyAuthenticationTunnelMethod {
	return &e
}

func (e *SourceOracleSSHTunnelMethodSSHKeyAuthenticationTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_KEY_AUTH":
		*e = SourceOracleSSHTunnelMethodSSHKeyAuthenticationTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceOracleSSHTunnelMethodSSHKeyAuthenticationTunnelMethod: %v", v)
	}
}

// SourceOracleSSHTunnelMethodSSHKeyAuthentication - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceOracleSSHTunnelMethodSSHKeyAuthentication struct {
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey string `json:"ssh_key"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and ssh key
	tunnelMethod SourceOracleSSHTunnelMethodSSHKeyAuthenticationTunnelMethod `const:"SSH_KEY_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host.
	TunnelUser string `json:"tunnel_user"`
}

func (s SourceOracleSSHTunnelMethodSSHKeyAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceOracleSSHTunnelMethodSSHKeyAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceOracleSSHTunnelMethodSSHKeyAuthentication) GetSSHKey() string {
	if o == nil {
		return ""
	}
	return o.SSHKey
}

func (o *SourceOracleSSHTunnelMethodSSHKeyAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *SourceOracleSSHTunnelMethodSSHKeyAuthentication) GetTunnelMethod() SourceOracleSSHTunnelMethodSSHKeyAuthenticationTunnelMethod {
	return SourceOracleSSHTunnelMethodSSHKeyAuthenticationTunnelMethodSSHKeyAuth
}

func (o *SourceOracleSSHTunnelMethodSSHKeyAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *SourceOracleSSHTunnelMethodSSHKeyAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

// SourceOracleSSHTunnelMethodNoTunnelTunnelMethod - No ssh tunnel needed to connect to database
type SourceOracleSSHTunnelMethodNoTunnelTunnelMethod string

const (
	SourceOracleSSHTunnelMethodNoTunnelTunnelMethodNoTunnel SourceOracleSSHTunnelMethodNoTunnelTunnelMethod = "NO_TUNNEL"
)

func (e SourceOracleSSHTunnelMethodNoTunnelTunnelMethod) ToPointer() *SourceOracleSSHTunnelMethodNoTunnelTunnelMethod {
	return &e
}

func (e *SourceOracleSSHTunnelMethodNoTunnelTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NO_TUNNEL":
		*e = SourceOracleSSHTunnelMethodNoTunnelTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceOracleSSHTunnelMethodNoTunnelTunnelMethod: %v", v)
	}
}

// SourceOracleSSHTunnelMethodNoTunnel - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceOracleSSHTunnelMethodNoTunnel struct {
	// No ssh tunnel needed to connect to database
	tunnelMethod SourceOracleSSHTunnelMethodNoTunnelTunnelMethod `const:"NO_TUNNEL" json:"tunnel_method"`
}

func (s SourceOracleSSHTunnelMethodNoTunnel) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceOracleSSHTunnelMethodNoTunnel) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceOracleSSHTunnelMethodNoTunnel) GetTunnelMethod() SourceOracleSSHTunnelMethodNoTunnelTunnelMethod {
	return SourceOracleSSHTunnelMethodNoTunnelTunnelMethodNoTunnel
}

type SourceOracleSSHTunnelMethodType string

const (
	SourceOracleSSHTunnelMethodTypeSourceOracleSSHTunnelMethodNoTunnel               SourceOracleSSHTunnelMethodType = "source-oracle_SSH Tunnel Method_No Tunnel"
	SourceOracleSSHTunnelMethodTypeSourceOracleSSHTunnelMethodSSHKeyAuthentication   SourceOracleSSHTunnelMethodType = "source-oracle_SSH Tunnel Method_SSH Key Authentication"
	SourceOracleSSHTunnelMethodTypeSourceOracleSSHTunnelMethodPasswordAuthentication SourceOracleSSHTunnelMethodType = "source-oracle_SSH Tunnel Method_Password Authentication"
)

type SourceOracleSSHTunnelMethod struct {
	SourceOracleSSHTunnelMethodNoTunnel               *SourceOracleSSHTunnelMethodNoTunnel
	SourceOracleSSHTunnelMethodSSHKeyAuthentication   *SourceOracleSSHTunnelMethodSSHKeyAuthentication
	SourceOracleSSHTunnelMethodPasswordAuthentication *SourceOracleSSHTunnelMethodPasswordAuthentication

	Type SourceOracleSSHTunnelMethodType
}

func CreateSourceOracleSSHTunnelMethodSourceOracleSSHTunnelMethodNoTunnel(sourceOracleSSHTunnelMethodNoTunnel SourceOracleSSHTunnelMethodNoTunnel) SourceOracleSSHTunnelMethod {
	typ := SourceOracleSSHTunnelMethodTypeSourceOracleSSHTunnelMethodNoTunnel

	return SourceOracleSSHTunnelMethod{
		SourceOracleSSHTunnelMethodNoTunnel: &sourceOracleSSHTunnelMethodNoTunnel,
		Type:                                typ,
	}
}

func CreateSourceOracleSSHTunnelMethodSourceOracleSSHTunnelMethodSSHKeyAuthentication(sourceOracleSSHTunnelMethodSSHKeyAuthentication SourceOracleSSHTunnelMethodSSHKeyAuthentication) SourceOracleSSHTunnelMethod {
	typ := SourceOracleSSHTunnelMethodTypeSourceOracleSSHTunnelMethodSSHKeyAuthentication

	return SourceOracleSSHTunnelMethod{
		SourceOracleSSHTunnelMethodSSHKeyAuthentication: &sourceOracleSSHTunnelMethodSSHKeyAuthentication,
		Type: typ,
	}
}

func CreateSourceOracleSSHTunnelMethodSourceOracleSSHTunnelMethodPasswordAuthentication(sourceOracleSSHTunnelMethodPasswordAuthentication SourceOracleSSHTunnelMethodPasswordAuthentication) SourceOracleSSHTunnelMethod {
	typ := SourceOracleSSHTunnelMethodTypeSourceOracleSSHTunnelMethodPasswordAuthentication

	return SourceOracleSSHTunnelMethod{
		SourceOracleSSHTunnelMethodPasswordAuthentication: &sourceOracleSSHTunnelMethodPasswordAuthentication,
		Type: typ,
	}
}

func (u *SourceOracleSSHTunnelMethod) UnmarshalJSON(data []byte) error {

	sourceOracleSSHTunnelMethodNoTunnel := new(SourceOracleSSHTunnelMethodNoTunnel)
	if err := utils.UnmarshalJSON(data, &sourceOracleSSHTunnelMethodNoTunnel, "", true, true); err == nil {
		u.SourceOracleSSHTunnelMethodNoTunnel = sourceOracleSSHTunnelMethodNoTunnel
		u.Type = SourceOracleSSHTunnelMethodTypeSourceOracleSSHTunnelMethodNoTunnel
		return nil
	}

	sourceOracleSSHTunnelMethodSSHKeyAuthentication := new(SourceOracleSSHTunnelMethodSSHKeyAuthentication)
	if err := utils.UnmarshalJSON(data, &sourceOracleSSHTunnelMethodSSHKeyAuthentication, "", true, true); err == nil {
		u.SourceOracleSSHTunnelMethodSSHKeyAuthentication = sourceOracleSSHTunnelMethodSSHKeyAuthentication
		u.Type = SourceOracleSSHTunnelMethodTypeSourceOracleSSHTunnelMethodSSHKeyAuthentication
		return nil
	}

	sourceOracleSSHTunnelMethodPasswordAuthentication := new(SourceOracleSSHTunnelMethodPasswordAuthentication)
	if err := utils.UnmarshalJSON(data, &sourceOracleSSHTunnelMethodPasswordAuthentication, "", true, true); err == nil {
		u.SourceOracleSSHTunnelMethodPasswordAuthentication = sourceOracleSSHTunnelMethodPasswordAuthentication
		u.Type = SourceOracleSSHTunnelMethodTypeSourceOracleSSHTunnelMethodPasswordAuthentication
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SourceOracleSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.SourceOracleSSHTunnelMethodNoTunnel != nil {
		return utils.MarshalJSON(u.SourceOracleSSHTunnelMethodNoTunnel, "", true)
	}

	if u.SourceOracleSSHTunnelMethodSSHKeyAuthentication != nil {
		return utils.MarshalJSON(u.SourceOracleSSHTunnelMethodSSHKeyAuthentication, "", true)
	}

	if u.SourceOracleSSHTunnelMethodPasswordAuthentication != nil {
		return utils.MarshalJSON(u.SourceOracleSSHTunnelMethodPasswordAuthentication, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type SourceOracle struct {
	// Connect data that will be used for DB connection
	ConnectionData *SourceOracleConnectBy `json:"connection_data,omitempty"`
	// The encryption method with is used when communicating with the database.
	Encryption SourceOracleEncryption `json:"encryption"`
	// Hostname of the database.
	Host string `json:"host"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// The password associated with the username.
	Password *string `json:"password,omitempty"`
	// Port of the database.
	// Oracle Corporations recommends the following port numbers:
	// 1521 - Default listening port for client connections to the listener.
	// 2484 - Recommended and officially registered listening port for client connections to the listener using TCP/IP with SSL
	Port *int64 `default:"1521" json:"port"`
	// The list of schemas to sync from. Defaults to user. Case sensitive.
	Schemas    []string           `json:"schemas,omitempty"`
	sourceType SourceOracleOracle `const:"oracle" json:"sourceType"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod *SourceOracleSSHTunnelMethod `json:"tunnel_method,omitempty"`
	// The username which is used to access the database.
	Username string `json:"username"`
}

func (s SourceOracle) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceOracle) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *SourceOracle) GetConnectionData() *SourceOracleConnectBy {
	if o == nil {
		return nil
	}
	return o.ConnectionData
}

func (o *SourceOracle) GetEncryption() SourceOracleEncryption {
	if o == nil {
		return SourceOracleEncryption{}
	}
	return o.Encryption
}

func (o *SourceOracle) GetHost() string {
	if o == nil {
		return ""
	}
	return o.Host
}

func (o *SourceOracle) GetJdbcURLParams() *string {
	if o == nil {
		return nil
	}
	return o.JdbcURLParams
}

func (o *SourceOracle) GetPassword() *string {
	if o == nil {
		return nil
	}
	return o.Password
}

func (o *SourceOracle) GetPort() *int64 {
	if o == nil {
		return nil
	}
	return o.Port
}

func (o *SourceOracle) GetSchemas() []string {
	if o == nil {
		return nil
	}
	return o.Schemas
}

func (o *SourceOracle) GetSourceType() SourceOracleOracle {
	return SourceOracleOracleOracle
}

func (o *SourceOracle) GetTunnelMethod() *SourceOracleSSHTunnelMethod {
	if o == nil {
		return nil
	}
	return o.TunnelMethod
}

func (o *SourceOracle) GetUsername() string {
	if o == nil {
		return ""
	}
	return o.Username
}
