// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"airbyte/internal/sdk/pkg/utils"
	"encoding/json"
	"errors"
	"fmt"
)

type DestinationAzureBlobStorageAzureBlobStorage string

const (
	DestinationAzureBlobStorageAzureBlobStorageAzureBlobStorage DestinationAzureBlobStorageAzureBlobStorage = "azure-blob-storage"
)

func (e DestinationAzureBlobStorageAzureBlobStorage) ToPointer() *DestinationAzureBlobStorageAzureBlobStorage {
	return &e
}

func (e *DestinationAzureBlobStorageAzureBlobStorage) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "azure-blob-storage":
		*e = DestinationAzureBlobStorageAzureBlobStorage(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationAzureBlobStorageAzureBlobStorage: %v", v)
	}
}

type DestinationAzureBlobStorageOutputFormatJSONLinesNewlineDelimitedJSONFormatType string

const (
	DestinationAzureBlobStorageOutputFormatJSONLinesNewlineDelimitedJSONFormatTypeJsonl DestinationAzureBlobStorageOutputFormatJSONLinesNewlineDelimitedJSONFormatType = "JSONL"
)

func (e DestinationAzureBlobStorageOutputFormatJSONLinesNewlineDelimitedJSONFormatType) ToPointer() *DestinationAzureBlobStorageOutputFormatJSONLinesNewlineDelimitedJSONFormatType {
	return &e
}

func (e *DestinationAzureBlobStorageOutputFormatJSONLinesNewlineDelimitedJSONFormatType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "JSONL":
		*e = DestinationAzureBlobStorageOutputFormatJSONLinesNewlineDelimitedJSONFormatType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationAzureBlobStorageOutputFormatJSONLinesNewlineDelimitedJSONFormatType: %v", v)
	}
}

// DestinationAzureBlobStorageOutputFormatJSONLinesNewlineDelimitedJSON - Output data format
type DestinationAzureBlobStorageOutputFormatJSONLinesNewlineDelimitedJSON struct {
	formatType DestinationAzureBlobStorageOutputFormatJSONLinesNewlineDelimitedJSONFormatType `const:"JSONL" json:"format_type"`
}

func (d DestinationAzureBlobStorageOutputFormatJSONLinesNewlineDelimitedJSON) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationAzureBlobStorageOutputFormatJSONLinesNewlineDelimitedJSON) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationAzureBlobStorageOutputFormatJSONLinesNewlineDelimitedJSON) GetFormatType() DestinationAzureBlobStorageOutputFormatJSONLinesNewlineDelimitedJSONFormatType {
	return DestinationAzureBlobStorageOutputFormatJSONLinesNewlineDelimitedJSONFormatTypeJsonl
}

// DestinationAzureBlobStorageOutputFormatCSVCommaSeparatedValuesNormalizationFlattening - Whether the input json data should be normalized (flattened) in the output CSV. Please refer to docs for details.
type DestinationAzureBlobStorageOutputFormatCSVCommaSeparatedValuesNormalizationFlattening string

const (
	DestinationAzureBlobStorageOutputFormatCSVCommaSeparatedValuesNormalizationFlatteningNoFlattening        DestinationAzureBlobStorageOutputFormatCSVCommaSeparatedValuesNormalizationFlattening = "No flattening"
	DestinationAzureBlobStorageOutputFormatCSVCommaSeparatedValuesNormalizationFlatteningRootLevelFlattening DestinationAzureBlobStorageOutputFormatCSVCommaSeparatedValuesNormalizationFlattening = "Root level flattening"
)

func (e DestinationAzureBlobStorageOutputFormatCSVCommaSeparatedValuesNormalizationFlattening) ToPointer() *DestinationAzureBlobStorageOutputFormatCSVCommaSeparatedValuesNormalizationFlattening {
	return &e
}

func (e *DestinationAzureBlobStorageOutputFormatCSVCommaSeparatedValuesNormalizationFlattening) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "No flattening":
		fallthrough
	case "Root level flattening":
		*e = DestinationAzureBlobStorageOutputFormatCSVCommaSeparatedValuesNormalizationFlattening(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationAzureBlobStorageOutputFormatCSVCommaSeparatedValuesNormalizationFlattening: %v", v)
	}
}

type DestinationAzureBlobStorageOutputFormatCSVCommaSeparatedValuesFormatType string

const (
	DestinationAzureBlobStorageOutputFormatCSVCommaSeparatedValuesFormatTypeCsv DestinationAzureBlobStorageOutputFormatCSVCommaSeparatedValuesFormatType = "CSV"
)

func (e DestinationAzureBlobStorageOutputFormatCSVCommaSeparatedValuesFormatType) ToPointer() *DestinationAzureBlobStorageOutputFormatCSVCommaSeparatedValuesFormatType {
	return &e
}

func (e *DestinationAzureBlobStorageOutputFormatCSVCommaSeparatedValuesFormatType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CSV":
		*e = DestinationAzureBlobStorageOutputFormatCSVCommaSeparatedValuesFormatType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationAzureBlobStorageOutputFormatCSVCommaSeparatedValuesFormatType: %v", v)
	}
}

// DestinationAzureBlobStorageOutputFormatCSVCommaSeparatedValues - Output data format
type DestinationAzureBlobStorageOutputFormatCSVCommaSeparatedValues struct {
	// Whether the input json data should be normalized (flattened) in the output CSV. Please refer to docs for details.
	Flattening *DestinationAzureBlobStorageOutputFormatCSVCommaSeparatedValuesNormalizationFlattening `default:"No flattening" json:"flattening"`
	formatType DestinationAzureBlobStorageOutputFormatCSVCommaSeparatedValuesFormatType               `const:"CSV" json:"format_type"`
}

func (d DestinationAzureBlobStorageOutputFormatCSVCommaSeparatedValues) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationAzureBlobStorageOutputFormatCSVCommaSeparatedValues) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationAzureBlobStorageOutputFormatCSVCommaSeparatedValues) GetFlattening() *DestinationAzureBlobStorageOutputFormatCSVCommaSeparatedValuesNormalizationFlattening {
	if o == nil {
		return nil
	}
	return o.Flattening
}

func (o *DestinationAzureBlobStorageOutputFormatCSVCommaSeparatedValues) GetFormatType() DestinationAzureBlobStorageOutputFormatCSVCommaSeparatedValuesFormatType {
	return DestinationAzureBlobStorageOutputFormatCSVCommaSeparatedValuesFormatTypeCsv
}

type DestinationAzureBlobStorageOutputFormatType string

const (
	DestinationAzureBlobStorageOutputFormatTypeDestinationAzureBlobStorageOutputFormatCSVCommaSeparatedValues       DestinationAzureBlobStorageOutputFormatType = "destination-azure-blob-storage_Output Format_CSV: Comma-Separated Values"
	DestinationAzureBlobStorageOutputFormatTypeDestinationAzureBlobStorageOutputFormatJSONLinesNewlineDelimitedJSON DestinationAzureBlobStorageOutputFormatType = "destination-azure-blob-storage_Output Format_JSON Lines: newline-delimited JSON"
)

type DestinationAzureBlobStorageOutputFormat struct {
	DestinationAzureBlobStorageOutputFormatCSVCommaSeparatedValues       *DestinationAzureBlobStorageOutputFormatCSVCommaSeparatedValues
	DestinationAzureBlobStorageOutputFormatJSONLinesNewlineDelimitedJSON *DestinationAzureBlobStorageOutputFormatJSONLinesNewlineDelimitedJSON

	Type DestinationAzureBlobStorageOutputFormatType
}

func CreateDestinationAzureBlobStorageOutputFormatDestinationAzureBlobStorageOutputFormatCSVCommaSeparatedValues(destinationAzureBlobStorageOutputFormatCSVCommaSeparatedValues DestinationAzureBlobStorageOutputFormatCSVCommaSeparatedValues) DestinationAzureBlobStorageOutputFormat {
	typ := DestinationAzureBlobStorageOutputFormatTypeDestinationAzureBlobStorageOutputFormatCSVCommaSeparatedValues

	return DestinationAzureBlobStorageOutputFormat{
		DestinationAzureBlobStorageOutputFormatCSVCommaSeparatedValues: &destinationAzureBlobStorageOutputFormatCSVCommaSeparatedValues,
		Type: typ,
	}
}

func CreateDestinationAzureBlobStorageOutputFormatDestinationAzureBlobStorageOutputFormatJSONLinesNewlineDelimitedJSON(destinationAzureBlobStorageOutputFormatJSONLinesNewlineDelimitedJSON DestinationAzureBlobStorageOutputFormatJSONLinesNewlineDelimitedJSON) DestinationAzureBlobStorageOutputFormat {
	typ := DestinationAzureBlobStorageOutputFormatTypeDestinationAzureBlobStorageOutputFormatJSONLinesNewlineDelimitedJSON

	return DestinationAzureBlobStorageOutputFormat{
		DestinationAzureBlobStorageOutputFormatJSONLinesNewlineDelimitedJSON: &destinationAzureBlobStorageOutputFormatJSONLinesNewlineDelimitedJSON,
		Type: typ,
	}
}

func (u *DestinationAzureBlobStorageOutputFormat) UnmarshalJSON(data []byte) error {

	destinationAzureBlobStorageOutputFormatJSONLinesNewlineDelimitedJSON := new(DestinationAzureBlobStorageOutputFormatJSONLinesNewlineDelimitedJSON)
	if err := utils.UnmarshalJSON(data, &destinationAzureBlobStorageOutputFormatJSONLinesNewlineDelimitedJSON, "", true, true); err == nil {
		u.DestinationAzureBlobStorageOutputFormatJSONLinesNewlineDelimitedJSON = destinationAzureBlobStorageOutputFormatJSONLinesNewlineDelimitedJSON
		u.Type = DestinationAzureBlobStorageOutputFormatTypeDestinationAzureBlobStorageOutputFormatJSONLinesNewlineDelimitedJSON
		return nil
	}

	destinationAzureBlobStorageOutputFormatCSVCommaSeparatedValues := new(DestinationAzureBlobStorageOutputFormatCSVCommaSeparatedValues)
	if err := utils.UnmarshalJSON(data, &destinationAzureBlobStorageOutputFormatCSVCommaSeparatedValues, "", true, true); err == nil {
		u.DestinationAzureBlobStorageOutputFormatCSVCommaSeparatedValues = destinationAzureBlobStorageOutputFormatCSVCommaSeparatedValues
		u.Type = DestinationAzureBlobStorageOutputFormatTypeDestinationAzureBlobStorageOutputFormatCSVCommaSeparatedValues
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u DestinationAzureBlobStorageOutputFormat) MarshalJSON() ([]byte, error) {
	if u.DestinationAzureBlobStorageOutputFormatCSVCommaSeparatedValues != nil {
		return utils.MarshalJSON(u.DestinationAzureBlobStorageOutputFormatCSVCommaSeparatedValues, "", true)
	}

	if u.DestinationAzureBlobStorageOutputFormatJSONLinesNewlineDelimitedJSON != nil {
		return utils.MarshalJSON(u.DestinationAzureBlobStorageOutputFormatJSONLinesNewlineDelimitedJSON, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type DestinationAzureBlobStorage struct {
	// The Azure blob storage account key.
	AzureBlobStorageAccountKey string `json:"azure_blob_storage_account_key"`
	// The account's name of the Azure Blob Storage.
	AzureBlobStorageAccountName string `json:"azure_blob_storage_account_name"`
	// The name of the Azure blob storage container. If not exists - will be created automatically. May be empty, then will be created automatically airbytecontainer+timestamp
	AzureBlobStorageContainerName *string `json:"azure_blob_storage_container_name,omitempty"`
	// This is Azure Blob Storage endpoint domain name. Leave default value (or leave it empty if run container from command line) to use Microsoft native from example.
	AzureBlobStorageEndpointDomainName *string `default:"blob.core.windows.net" json:"azure_blob_storage_endpoint_domain_name"`
	// The amount of megabytes to buffer for the output stream to Azure. This will impact memory footprint on workers, but may need adjustment for performance and appropriate block size in Azure.
	AzureBlobStorageOutputBufferSize *int64 `default:"5" json:"azure_blob_storage_output_buffer_size"`
	// The amount of megabytes after which the connector should spill the records in a new blob object. Make sure to configure size greater than individual records. Enter 0 if not applicable
	AzureBlobStorageSpillSize *int64                                      `default:"500" json:"azure_blob_storage_spill_size"`
	destinationType           DestinationAzureBlobStorageAzureBlobStorage `const:"azure-blob-storage" json:"destinationType"`
	// Output data format
	Format DestinationAzureBlobStorageOutputFormat `json:"format"`
}

func (d DestinationAzureBlobStorage) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationAzureBlobStorage) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *DestinationAzureBlobStorage) GetAzureBlobStorageAccountKey() string {
	if o == nil {
		return ""
	}
	return o.AzureBlobStorageAccountKey
}

func (o *DestinationAzureBlobStorage) GetAzureBlobStorageAccountName() string {
	if o == nil {
		return ""
	}
	return o.AzureBlobStorageAccountName
}

func (o *DestinationAzureBlobStorage) GetAzureBlobStorageContainerName() *string {
	if o == nil {
		return nil
	}
	return o.AzureBlobStorageContainerName
}

func (o *DestinationAzureBlobStorage) GetAzureBlobStorageEndpointDomainName() *string {
	if o == nil {
		return nil
	}
	return o.AzureBlobStorageEndpointDomainName
}

func (o *DestinationAzureBlobStorage) GetAzureBlobStorageOutputBufferSize() *int64 {
	if o == nil {
		return nil
	}
	return o.AzureBlobStorageOutputBufferSize
}

func (o *DestinationAzureBlobStorage) GetAzureBlobStorageSpillSize() *int64 {
	if o == nil {
		return nil
	}
	return o.AzureBlobStorageSpillSize
}

func (o *DestinationAzureBlobStorage) GetDestinationType() DestinationAzureBlobStorageAzureBlobStorage {
	return DestinationAzureBlobStorageAzureBlobStorageAzureBlobStorage
}

func (o *DestinationAzureBlobStorage) GetFormat() DestinationAzureBlobStorageOutputFormat {
	if o == nil {
		return DestinationAzureBlobStorageOutputFormat{}
	}
	return o.Format
}
