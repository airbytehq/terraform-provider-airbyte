// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"airbyte/internal/sdk/pkg/utils"
	"encoding/json"
	"errors"
	"fmt"
)

type DestinationPostgresUpdateSSLModesVerifyFullMode string

const (
	DestinationPostgresUpdateSSLModesVerifyFullModeVerifyFull DestinationPostgresUpdateSSLModesVerifyFullMode = "verify-full"
)

func (e DestinationPostgresUpdateSSLModesVerifyFullMode) ToPointer() *DestinationPostgresUpdateSSLModesVerifyFullMode {
	return &e
}

func (e *DestinationPostgresUpdateSSLModesVerifyFullMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "verify-full":
		*e = DestinationPostgresUpdateSSLModesVerifyFullMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationPostgresUpdateSSLModesVerifyFullMode: %v", v)
	}
}

// DestinationPostgresUpdateSSLModesVerifyFull - Verify-full SSL mode.
type DestinationPostgresUpdateSSLModesVerifyFull struct {
	// CA certificate
	CaCertificate string `json:"ca_certificate"`
	// Client certificate
	ClientCertificate string `json:"client_certificate"`
	// Client key
	ClientKey string `json:"client_key"`
	// Password for keystorage. This field is optional. If you do not add it - the password will be generated automatically.
	ClientKeyPassword *string                                          `json:"client_key_password,omitempty"`
	mode              *DestinationPostgresUpdateSSLModesVerifyFullMode `const:"verify-full" json:"mode"`
}

func (d DestinationPostgresUpdateSSLModesVerifyFull) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationPostgresUpdateSSLModesVerifyFull) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationPostgresUpdateSSLModesVerifyFull) GetCaCertificate() string {
	if o == nil {
		return ""
	}
	return o.CaCertificate
}

func (o *DestinationPostgresUpdateSSLModesVerifyFull) GetClientCertificate() string {
	if o == nil {
		return ""
	}
	return o.ClientCertificate
}

func (o *DestinationPostgresUpdateSSLModesVerifyFull) GetClientKey() string {
	if o == nil {
		return ""
	}
	return o.ClientKey
}

func (o *DestinationPostgresUpdateSSLModesVerifyFull) GetClientKeyPassword() *string {
	if o == nil {
		return nil
	}
	return o.ClientKeyPassword
}

func (o *DestinationPostgresUpdateSSLModesVerifyFull) GetMode() *DestinationPostgresUpdateSSLModesVerifyFullMode {
	return DestinationPostgresUpdateSSLModesVerifyFullModeVerifyFull.ToPointer()
}

type DestinationPostgresUpdateSSLModesVerifyCaMode string

const (
	DestinationPostgresUpdateSSLModesVerifyCaModeVerifyCa DestinationPostgresUpdateSSLModesVerifyCaMode = "verify-ca"
)

func (e DestinationPostgresUpdateSSLModesVerifyCaMode) ToPointer() *DestinationPostgresUpdateSSLModesVerifyCaMode {
	return &e
}

func (e *DestinationPostgresUpdateSSLModesVerifyCaMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "verify-ca":
		*e = DestinationPostgresUpdateSSLModesVerifyCaMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationPostgresUpdateSSLModesVerifyCaMode: %v", v)
	}
}

// DestinationPostgresUpdateSSLModesVerifyCa - Verify-ca SSL mode.
type DestinationPostgresUpdateSSLModesVerifyCa struct {
	// CA certificate
	CaCertificate string `json:"ca_certificate"`
	// Password for keystorage. This field is optional. If you do not add it - the password will be generated automatically.
	ClientKeyPassword *string                                        `json:"client_key_password,omitempty"`
	mode              *DestinationPostgresUpdateSSLModesVerifyCaMode `const:"verify-ca" json:"mode"`
}

func (d DestinationPostgresUpdateSSLModesVerifyCa) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationPostgresUpdateSSLModesVerifyCa) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationPostgresUpdateSSLModesVerifyCa) GetCaCertificate() string {
	if o == nil {
		return ""
	}
	return o.CaCertificate
}

func (o *DestinationPostgresUpdateSSLModesVerifyCa) GetClientKeyPassword() *string {
	if o == nil {
		return nil
	}
	return o.ClientKeyPassword
}

func (o *DestinationPostgresUpdateSSLModesVerifyCa) GetMode() *DestinationPostgresUpdateSSLModesVerifyCaMode {
	return DestinationPostgresUpdateSSLModesVerifyCaModeVerifyCa.ToPointer()
}

type DestinationPostgresUpdateSSLModesRequireMode string

const (
	DestinationPostgresUpdateSSLModesRequireModeRequire DestinationPostgresUpdateSSLModesRequireMode = "require"
)

func (e DestinationPostgresUpdateSSLModesRequireMode) ToPointer() *DestinationPostgresUpdateSSLModesRequireMode {
	return &e
}

func (e *DestinationPostgresUpdateSSLModesRequireMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "require":
		*e = DestinationPostgresUpdateSSLModesRequireMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationPostgresUpdateSSLModesRequireMode: %v", v)
	}
}

// DestinationPostgresUpdateSSLModesRequire - Require SSL mode.
type DestinationPostgresUpdateSSLModesRequire struct {
	mode *DestinationPostgresUpdateSSLModesRequireMode `const:"require" json:"mode"`
}

func (d DestinationPostgresUpdateSSLModesRequire) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationPostgresUpdateSSLModesRequire) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationPostgresUpdateSSLModesRequire) GetMode() *DestinationPostgresUpdateSSLModesRequireMode {
	return DestinationPostgresUpdateSSLModesRequireModeRequire.ToPointer()
}

type DestinationPostgresUpdateSSLModesPreferMode string

const (
	DestinationPostgresUpdateSSLModesPreferModePrefer DestinationPostgresUpdateSSLModesPreferMode = "prefer"
)

func (e DestinationPostgresUpdateSSLModesPreferMode) ToPointer() *DestinationPostgresUpdateSSLModesPreferMode {
	return &e
}

func (e *DestinationPostgresUpdateSSLModesPreferMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "prefer":
		*e = DestinationPostgresUpdateSSLModesPreferMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationPostgresUpdateSSLModesPreferMode: %v", v)
	}
}

// DestinationPostgresUpdateSSLModesPrefer - Prefer SSL mode.
type DestinationPostgresUpdateSSLModesPrefer struct {
	mode *DestinationPostgresUpdateSSLModesPreferMode `const:"prefer" json:"mode"`
}

func (d DestinationPostgresUpdateSSLModesPrefer) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationPostgresUpdateSSLModesPrefer) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationPostgresUpdateSSLModesPrefer) GetMode() *DestinationPostgresUpdateSSLModesPreferMode {
	return DestinationPostgresUpdateSSLModesPreferModePrefer.ToPointer()
}

type DestinationPostgresUpdateSSLModesAllowMode string

const (
	DestinationPostgresUpdateSSLModesAllowModeAllow DestinationPostgresUpdateSSLModesAllowMode = "allow"
)

func (e DestinationPostgresUpdateSSLModesAllowMode) ToPointer() *DestinationPostgresUpdateSSLModesAllowMode {
	return &e
}

func (e *DestinationPostgresUpdateSSLModesAllowMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "allow":
		*e = DestinationPostgresUpdateSSLModesAllowMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationPostgresUpdateSSLModesAllowMode: %v", v)
	}
}

// DestinationPostgresUpdateSSLModesAllow - Allow SSL mode.
type DestinationPostgresUpdateSSLModesAllow struct {
	mode *DestinationPostgresUpdateSSLModesAllowMode `const:"allow" json:"mode"`
}

func (d DestinationPostgresUpdateSSLModesAllow) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationPostgresUpdateSSLModesAllow) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationPostgresUpdateSSLModesAllow) GetMode() *DestinationPostgresUpdateSSLModesAllowMode {
	return DestinationPostgresUpdateSSLModesAllowModeAllow.ToPointer()
}

type DestinationPostgresUpdateSSLModesDisableMode string

const (
	DestinationPostgresUpdateSSLModesDisableModeDisable DestinationPostgresUpdateSSLModesDisableMode = "disable"
)

func (e DestinationPostgresUpdateSSLModesDisableMode) ToPointer() *DestinationPostgresUpdateSSLModesDisableMode {
	return &e
}

func (e *DestinationPostgresUpdateSSLModesDisableMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "disable":
		*e = DestinationPostgresUpdateSSLModesDisableMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationPostgresUpdateSSLModesDisableMode: %v", v)
	}
}

// DestinationPostgresUpdateSSLModesDisable - Disable SSL.
type DestinationPostgresUpdateSSLModesDisable struct {
	mode *DestinationPostgresUpdateSSLModesDisableMode `const:"disable" json:"mode"`
}

func (d DestinationPostgresUpdateSSLModesDisable) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationPostgresUpdateSSLModesDisable) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationPostgresUpdateSSLModesDisable) GetMode() *DestinationPostgresUpdateSSLModesDisableMode {
	return DestinationPostgresUpdateSSLModesDisableModeDisable.ToPointer()
}

type DestinationPostgresUpdateSSLModesType string

const (
	DestinationPostgresUpdateSSLModesTypeDestinationPostgresUpdateSSLModesDisable    DestinationPostgresUpdateSSLModesType = "destination-postgres-update_SSL modes_disable"
	DestinationPostgresUpdateSSLModesTypeDestinationPostgresUpdateSSLModesAllow      DestinationPostgresUpdateSSLModesType = "destination-postgres-update_SSL modes_allow"
	DestinationPostgresUpdateSSLModesTypeDestinationPostgresUpdateSSLModesPrefer     DestinationPostgresUpdateSSLModesType = "destination-postgres-update_SSL modes_prefer"
	DestinationPostgresUpdateSSLModesTypeDestinationPostgresUpdateSSLModesRequire    DestinationPostgresUpdateSSLModesType = "destination-postgres-update_SSL modes_require"
	DestinationPostgresUpdateSSLModesTypeDestinationPostgresUpdateSSLModesVerifyCa   DestinationPostgresUpdateSSLModesType = "destination-postgres-update_SSL modes_verify-ca"
	DestinationPostgresUpdateSSLModesTypeDestinationPostgresUpdateSSLModesVerifyFull DestinationPostgresUpdateSSLModesType = "destination-postgres-update_SSL modes_verify-full"
)

type DestinationPostgresUpdateSSLModes struct {
	DestinationPostgresUpdateSSLModesDisable    *DestinationPostgresUpdateSSLModesDisable
	DestinationPostgresUpdateSSLModesAllow      *DestinationPostgresUpdateSSLModesAllow
	DestinationPostgresUpdateSSLModesPrefer     *DestinationPostgresUpdateSSLModesPrefer
	DestinationPostgresUpdateSSLModesRequire    *DestinationPostgresUpdateSSLModesRequire
	DestinationPostgresUpdateSSLModesVerifyCa   *DestinationPostgresUpdateSSLModesVerifyCa
	DestinationPostgresUpdateSSLModesVerifyFull *DestinationPostgresUpdateSSLModesVerifyFull

	Type DestinationPostgresUpdateSSLModesType
}

func CreateDestinationPostgresUpdateSSLModesDestinationPostgresUpdateSSLModesDisable(destinationPostgresUpdateSSLModesDisable DestinationPostgresUpdateSSLModesDisable) DestinationPostgresUpdateSSLModes {
	typ := DestinationPostgresUpdateSSLModesTypeDestinationPostgresUpdateSSLModesDisable

	return DestinationPostgresUpdateSSLModes{
		DestinationPostgresUpdateSSLModesDisable: &destinationPostgresUpdateSSLModesDisable,
		Type:                                     typ,
	}
}

func CreateDestinationPostgresUpdateSSLModesDestinationPostgresUpdateSSLModesAllow(destinationPostgresUpdateSSLModesAllow DestinationPostgresUpdateSSLModesAllow) DestinationPostgresUpdateSSLModes {
	typ := DestinationPostgresUpdateSSLModesTypeDestinationPostgresUpdateSSLModesAllow

	return DestinationPostgresUpdateSSLModes{
		DestinationPostgresUpdateSSLModesAllow: &destinationPostgresUpdateSSLModesAllow,
		Type:                                   typ,
	}
}

func CreateDestinationPostgresUpdateSSLModesDestinationPostgresUpdateSSLModesPrefer(destinationPostgresUpdateSSLModesPrefer DestinationPostgresUpdateSSLModesPrefer) DestinationPostgresUpdateSSLModes {
	typ := DestinationPostgresUpdateSSLModesTypeDestinationPostgresUpdateSSLModesPrefer

	return DestinationPostgresUpdateSSLModes{
		DestinationPostgresUpdateSSLModesPrefer: &destinationPostgresUpdateSSLModesPrefer,
		Type:                                    typ,
	}
}

func CreateDestinationPostgresUpdateSSLModesDestinationPostgresUpdateSSLModesRequire(destinationPostgresUpdateSSLModesRequire DestinationPostgresUpdateSSLModesRequire) DestinationPostgresUpdateSSLModes {
	typ := DestinationPostgresUpdateSSLModesTypeDestinationPostgresUpdateSSLModesRequire

	return DestinationPostgresUpdateSSLModes{
		DestinationPostgresUpdateSSLModesRequire: &destinationPostgresUpdateSSLModesRequire,
		Type:                                     typ,
	}
}

func CreateDestinationPostgresUpdateSSLModesDestinationPostgresUpdateSSLModesVerifyCa(destinationPostgresUpdateSSLModesVerifyCa DestinationPostgresUpdateSSLModesVerifyCa) DestinationPostgresUpdateSSLModes {
	typ := DestinationPostgresUpdateSSLModesTypeDestinationPostgresUpdateSSLModesVerifyCa

	return DestinationPostgresUpdateSSLModes{
		DestinationPostgresUpdateSSLModesVerifyCa: &destinationPostgresUpdateSSLModesVerifyCa,
		Type: typ,
	}
}

func CreateDestinationPostgresUpdateSSLModesDestinationPostgresUpdateSSLModesVerifyFull(destinationPostgresUpdateSSLModesVerifyFull DestinationPostgresUpdateSSLModesVerifyFull) DestinationPostgresUpdateSSLModes {
	typ := DestinationPostgresUpdateSSLModesTypeDestinationPostgresUpdateSSLModesVerifyFull

	return DestinationPostgresUpdateSSLModes{
		DestinationPostgresUpdateSSLModesVerifyFull: &destinationPostgresUpdateSSLModesVerifyFull,
		Type: typ,
	}
}

func (u *DestinationPostgresUpdateSSLModes) UnmarshalJSON(data []byte) error {

	destinationPostgresUpdateSSLModesDisable := new(DestinationPostgresUpdateSSLModesDisable)
	if err := utils.UnmarshalJSON(data, &destinationPostgresUpdateSSLModesDisable, "", true, true); err == nil {
		u.DestinationPostgresUpdateSSLModesDisable = destinationPostgresUpdateSSLModesDisable
		u.Type = DestinationPostgresUpdateSSLModesTypeDestinationPostgresUpdateSSLModesDisable
		return nil
	}

	destinationPostgresUpdateSSLModesAllow := new(DestinationPostgresUpdateSSLModesAllow)
	if err := utils.UnmarshalJSON(data, &destinationPostgresUpdateSSLModesAllow, "", true, true); err == nil {
		u.DestinationPostgresUpdateSSLModesAllow = destinationPostgresUpdateSSLModesAllow
		u.Type = DestinationPostgresUpdateSSLModesTypeDestinationPostgresUpdateSSLModesAllow
		return nil
	}

	destinationPostgresUpdateSSLModesPrefer := new(DestinationPostgresUpdateSSLModesPrefer)
	if err := utils.UnmarshalJSON(data, &destinationPostgresUpdateSSLModesPrefer, "", true, true); err == nil {
		u.DestinationPostgresUpdateSSLModesPrefer = destinationPostgresUpdateSSLModesPrefer
		u.Type = DestinationPostgresUpdateSSLModesTypeDestinationPostgresUpdateSSLModesPrefer
		return nil
	}

	destinationPostgresUpdateSSLModesRequire := new(DestinationPostgresUpdateSSLModesRequire)
	if err := utils.UnmarshalJSON(data, &destinationPostgresUpdateSSLModesRequire, "", true, true); err == nil {
		u.DestinationPostgresUpdateSSLModesRequire = destinationPostgresUpdateSSLModesRequire
		u.Type = DestinationPostgresUpdateSSLModesTypeDestinationPostgresUpdateSSLModesRequire
		return nil
	}

	destinationPostgresUpdateSSLModesVerifyCa := new(DestinationPostgresUpdateSSLModesVerifyCa)
	if err := utils.UnmarshalJSON(data, &destinationPostgresUpdateSSLModesVerifyCa, "", true, true); err == nil {
		u.DestinationPostgresUpdateSSLModesVerifyCa = destinationPostgresUpdateSSLModesVerifyCa
		u.Type = DestinationPostgresUpdateSSLModesTypeDestinationPostgresUpdateSSLModesVerifyCa
		return nil
	}

	destinationPostgresUpdateSSLModesVerifyFull := new(DestinationPostgresUpdateSSLModesVerifyFull)
	if err := utils.UnmarshalJSON(data, &destinationPostgresUpdateSSLModesVerifyFull, "", true, true); err == nil {
		u.DestinationPostgresUpdateSSLModesVerifyFull = destinationPostgresUpdateSSLModesVerifyFull
		u.Type = DestinationPostgresUpdateSSLModesTypeDestinationPostgresUpdateSSLModesVerifyFull
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u DestinationPostgresUpdateSSLModes) MarshalJSON() ([]byte, error) {
	if u.DestinationPostgresUpdateSSLModesDisable != nil {
		return utils.MarshalJSON(u.DestinationPostgresUpdateSSLModesDisable, "", true)
	}

	if u.DestinationPostgresUpdateSSLModesAllow != nil {
		return utils.MarshalJSON(u.DestinationPostgresUpdateSSLModesAllow, "", true)
	}

	if u.DestinationPostgresUpdateSSLModesPrefer != nil {
		return utils.MarshalJSON(u.DestinationPostgresUpdateSSLModesPrefer, "", true)
	}

	if u.DestinationPostgresUpdateSSLModesRequire != nil {
		return utils.MarshalJSON(u.DestinationPostgresUpdateSSLModesRequire, "", true)
	}

	if u.DestinationPostgresUpdateSSLModesVerifyCa != nil {
		return utils.MarshalJSON(u.DestinationPostgresUpdateSSLModesVerifyCa, "", true)
	}

	if u.DestinationPostgresUpdateSSLModesVerifyFull != nil {
		return utils.MarshalJSON(u.DestinationPostgresUpdateSSLModesVerifyFull, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

// DestinationPostgresUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod - Connect through a jump server tunnel host using username and password authentication
type DestinationPostgresUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod string

const (
	DestinationPostgresUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethodSSHPasswordAuth DestinationPostgresUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod = "SSH_PASSWORD_AUTH"
)

func (e DestinationPostgresUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod) ToPointer() *DestinationPostgresUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod {
	return &e
}

func (e *DestinationPostgresUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_PASSWORD_AUTH":
		*e = DestinationPostgresUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationPostgresUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod: %v", v)
	}
}

// DestinationPostgresUpdateSSHTunnelMethodPasswordAuthentication - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type DestinationPostgresUpdateSSHTunnelMethodPasswordAuthentication struct {
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and password authentication
	tunnelMethod DestinationPostgresUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod `const:"SSH_PASSWORD_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser string `json:"tunnel_user"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword string `json:"tunnel_user_password"`
}

func (d DestinationPostgresUpdateSSHTunnelMethodPasswordAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationPostgresUpdateSSHTunnelMethodPasswordAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationPostgresUpdateSSHTunnelMethodPasswordAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *DestinationPostgresUpdateSSHTunnelMethodPasswordAuthentication) GetTunnelMethod() DestinationPostgresUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod {
	return DestinationPostgresUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethodSSHPasswordAuth
}

func (o *DestinationPostgresUpdateSSHTunnelMethodPasswordAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *DestinationPostgresUpdateSSHTunnelMethodPasswordAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

func (o *DestinationPostgresUpdateSSHTunnelMethodPasswordAuthentication) GetTunnelUserPassword() string {
	if o == nil {
		return ""
	}
	return o.TunnelUserPassword
}

// DestinationPostgresUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod - Connect through a jump server tunnel host using username and ssh key
type DestinationPostgresUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod string

const (
	DestinationPostgresUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethodSSHKeyAuth DestinationPostgresUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod = "SSH_KEY_AUTH"
)

func (e DestinationPostgresUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod) ToPointer() *DestinationPostgresUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod {
	return &e
}

func (e *DestinationPostgresUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_KEY_AUTH":
		*e = DestinationPostgresUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationPostgresUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod: %v", v)
	}
}

// DestinationPostgresUpdateSSHTunnelMethodSSHKeyAuthentication - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type DestinationPostgresUpdateSSHTunnelMethodSSHKeyAuthentication struct {
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey string `json:"ssh_key"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and ssh key
	tunnelMethod DestinationPostgresUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod `const:"SSH_KEY_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host.
	TunnelUser string `json:"tunnel_user"`
}

func (d DestinationPostgresUpdateSSHTunnelMethodSSHKeyAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationPostgresUpdateSSHTunnelMethodSSHKeyAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationPostgresUpdateSSHTunnelMethodSSHKeyAuthentication) GetSSHKey() string {
	if o == nil {
		return ""
	}
	return o.SSHKey
}

func (o *DestinationPostgresUpdateSSHTunnelMethodSSHKeyAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *DestinationPostgresUpdateSSHTunnelMethodSSHKeyAuthentication) GetTunnelMethod() DestinationPostgresUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod {
	return DestinationPostgresUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethodSSHKeyAuth
}

func (o *DestinationPostgresUpdateSSHTunnelMethodSSHKeyAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *DestinationPostgresUpdateSSHTunnelMethodSSHKeyAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

// DestinationPostgresUpdateSSHTunnelMethodNoTunnelTunnelMethod - No ssh tunnel needed to connect to database
type DestinationPostgresUpdateSSHTunnelMethodNoTunnelTunnelMethod string

const (
	DestinationPostgresUpdateSSHTunnelMethodNoTunnelTunnelMethodNoTunnel DestinationPostgresUpdateSSHTunnelMethodNoTunnelTunnelMethod = "NO_TUNNEL"
)

func (e DestinationPostgresUpdateSSHTunnelMethodNoTunnelTunnelMethod) ToPointer() *DestinationPostgresUpdateSSHTunnelMethodNoTunnelTunnelMethod {
	return &e
}

func (e *DestinationPostgresUpdateSSHTunnelMethodNoTunnelTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NO_TUNNEL":
		*e = DestinationPostgresUpdateSSHTunnelMethodNoTunnelTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationPostgresUpdateSSHTunnelMethodNoTunnelTunnelMethod: %v", v)
	}
}

// DestinationPostgresUpdateSSHTunnelMethodNoTunnel - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type DestinationPostgresUpdateSSHTunnelMethodNoTunnel struct {
	// No ssh tunnel needed to connect to database
	tunnelMethod DestinationPostgresUpdateSSHTunnelMethodNoTunnelTunnelMethod `const:"NO_TUNNEL" json:"tunnel_method"`
}

func (d DestinationPostgresUpdateSSHTunnelMethodNoTunnel) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationPostgresUpdateSSHTunnelMethodNoTunnel) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationPostgresUpdateSSHTunnelMethodNoTunnel) GetTunnelMethod() DestinationPostgresUpdateSSHTunnelMethodNoTunnelTunnelMethod {
	return DestinationPostgresUpdateSSHTunnelMethodNoTunnelTunnelMethodNoTunnel
}

type DestinationPostgresUpdateSSHTunnelMethodType string

const (
	DestinationPostgresUpdateSSHTunnelMethodTypeDestinationPostgresUpdateSSHTunnelMethodNoTunnel               DestinationPostgresUpdateSSHTunnelMethodType = "destination-postgres-update_SSH Tunnel Method_No Tunnel"
	DestinationPostgresUpdateSSHTunnelMethodTypeDestinationPostgresUpdateSSHTunnelMethodSSHKeyAuthentication   DestinationPostgresUpdateSSHTunnelMethodType = "destination-postgres-update_SSH Tunnel Method_SSH Key Authentication"
	DestinationPostgresUpdateSSHTunnelMethodTypeDestinationPostgresUpdateSSHTunnelMethodPasswordAuthentication DestinationPostgresUpdateSSHTunnelMethodType = "destination-postgres-update_SSH Tunnel Method_Password Authentication"
)

type DestinationPostgresUpdateSSHTunnelMethod struct {
	DestinationPostgresUpdateSSHTunnelMethodNoTunnel               *DestinationPostgresUpdateSSHTunnelMethodNoTunnel
	DestinationPostgresUpdateSSHTunnelMethodSSHKeyAuthentication   *DestinationPostgresUpdateSSHTunnelMethodSSHKeyAuthentication
	DestinationPostgresUpdateSSHTunnelMethodPasswordAuthentication *DestinationPostgresUpdateSSHTunnelMethodPasswordAuthentication

	Type DestinationPostgresUpdateSSHTunnelMethodType
}

func CreateDestinationPostgresUpdateSSHTunnelMethodDestinationPostgresUpdateSSHTunnelMethodNoTunnel(destinationPostgresUpdateSSHTunnelMethodNoTunnel DestinationPostgresUpdateSSHTunnelMethodNoTunnel) DestinationPostgresUpdateSSHTunnelMethod {
	typ := DestinationPostgresUpdateSSHTunnelMethodTypeDestinationPostgresUpdateSSHTunnelMethodNoTunnel

	return DestinationPostgresUpdateSSHTunnelMethod{
		DestinationPostgresUpdateSSHTunnelMethodNoTunnel: &destinationPostgresUpdateSSHTunnelMethodNoTunnel,
		Type: typ,
	}
}

func CreateDestinationPostgresUpdateSSHTunnelMethodDestinationPostgresUpdateSSHTunnelMethodSSHKeyAuthentication(destinationPostgresUpdateSSHTunnelMethodSSHKeyAuthentication DestinationPostgresUpdateSSHTunnelMethodSSHKeyAuthentication) DestinationPostgresUpdateSSHTunnelMethod {
	typ := DestinationPostgresUpdateSSHTunnelMethodTypeDestinationPostgresUpdateSSHTunnelMethodSSHKeyAuthentication

	return DestinationPostgresUpdateSSHTunnelMethod{
		DestinationPostgresUpdateSSHTunnelMethodSSHKeyAuthentication: &destinationPostgresUpdateSSHTunnelMethodSSHKeyAuthentication,
		Type: typ,
	}
}

func CreateDestinationPostgresUpdateSSHTunnelMethodDestinationPostgresUpdateSSHTunnelMethodPasswordAuthentication(destinationPostgresUpdateSSHTunnelMethodPasswordAuthentication DestinationPostgresUpdateSSHTunnelMethodPasswordAuthentication) DestinationPostgresUpdateSSHTunnelMethod {
	typ := DestinationPostgresUpdateSSHTunnelMethodTypeDestinationPostgresUpdateSSHTunnelMethodPasswordAuthentication

	return DestinationPostgresUpdateSSHTunnelMethod{
		DestinationPostgresUpdateSSHTunnelMethodPasswordAuthentication: &destinationPostgresUpdateSSHTunnelMethodPasswordAuthentication,
		Type: typ,
	}
}

func (u *DestinationPostgresUpdateSSHTunnelMethod) UnmarshalJSON(data []byte) error {

	destinationPostgresUpdateSSHTunnelMethodNoTunnel := new(DestinationPostgresUpdateSSHTunnelMethodNoTunnel)
	if err := utils.UnmarshalJSON(data, &destinationPostgresUpdateSSHTunnelMethodNoTunnel, "", true, true); err == nil {
		u.DestinationPostgresUpdateSSHTunnelMethodNoTunnel = destinationPostgresUpdateSSHTunnelMethodNoTunnel
		u.Type = DestinationPostgresUpdateSSHTunnelMethodTypeDestinationPostgresUpdateSSHTunnelMethodNoTunnel
		return nil
	}

	destinationPostgresUpdateSSHTunnelMethodSSHKeyAuthentication := new(DestinationPostgresUpdateSSHTunnelMethodSSHKeyAuthentication)
	if err := utils.UnmarshalJSON(data, &destinationPostgresUpdateSSHTunnelMethodSSHKeyAuthentication, "", true, true); err == nil {
		u.DestinationPostgresUpdateSSHTunnelMethodSSHKeyAuthentication = destinationPostgresUpdateSSHTunnelMethodSSHKeyAuthentication
		u.Type = DestinationPostgresUpdateSSHTunnelMethodTypeDestinationPostgresUpdateSSHTunnelMethodSSHKeyAuthentication
		return nil
	}

	destinationPostgresUpdateSSHTunnelMethodPasswordAuthentication := new(DestinationPostgresUpdateSSHTunnelMethodPasswordAuthentication)
	if err := utils.UnmarshalJSON(data, &destinationPostgresUpdateSSHTunnelMethodPasswordAuthentication, "", true, true); err == nil {
		u.DestinationPostgresUpdateSSHTunnelMethodPasswordAuthentication = destinationPostgresUpdateSSHTunnelMethodPasswordAuthentication
		u.Type = DestinationPostgresUpdateSSHTunnelMethodTypeDestinationPostgresUpdateSSHTunnelMethodPasswordAuthentication
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u DestinationPostgresUpdateSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.DestinationPostgresUpdateSSHTunnelMethodNoTunnel != nil {
		return utils.MarshalJSON(u.DestinationPostgresUpdateSSHTunnelMethodNoTunnel, "", true)
	}

	if u.DestinationPostgresUpdateSSHTunnelMethodSSHKeyAuthentication != nil {
		return utils.MarshalJSON(u.DestinationPostgresUpdateSSHTunnelMethodSSHKeyAuthentication, "", true)
	}

	if u.DestinationPostgresUpdateSSHTunnelMethodPasswordAuthentication != nil {
		return utils.MarshalJSON(u.DestinationPostgresUpdateSSHTunnelMethodPasswordAuthentication, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type DestinationPostgresUpdate struct {
	// Name of the database.
	Database string `json:"database"`
	// Hostname of the database.
	Host string `json:"host"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// Password associated with the username.
	Password *string `json:"password,omitempty"`
	// Port of the database.
	Port *int64 `default:"5432" json:"port"`
	// The default schema tables are written to if the source does not specify a namespace. The usual value for this field is "public".
	Schema *string `default:"public" json:"schema"`
	// SSL connection modes.
	//  <b>disable</b> - Chose this mode to disable encryption of communication between Airbyte and destination database
	//  <b>allow</b> - Chose this mode to enable encryption only when required by the source database
	//  <b>prefer</b> - Chose this mode to allow unencrypted connection only if the source database does not support encryption
	//  <b>require</b> - Chose this mode to always require encryption. If the source database server does not support encryption, connection will fail
	//   <b>verify-ca</b> - Chose this mode to always require encryption and to verify that the source database server has a valid SSL certificate
	//   <b>verify-full</b> - This is the most secure mode. Chose this mode to always require encryption and to verify the identity of the source database server
	//  See more information - <a href="https://jdbc.postgresql.org/documentation/head/ssl-client.html"> in the docs</a>.
	SslMode *DestinationPostgresUpdateSSLModes `json:"ssl_mode,omitempty"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod *DestinationPostgresUpdateSSHTunnelMethod `json:"tunnel_method,omitempty"`
	// Username to use to access the database.
	Username string `json:"username"`
}

func (d DestinationPostgresUpdate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationPostgresUpdate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *DestinationPostgresUpdate) GetDatabase() string {
	if o == nil {
		return ""
	}
	return o.Database
}

func (o *DestinationPostgresUpdate) GetHost() string {
	if o == nil {
		return ""
	}
	return o.Host
}

func (o *DestinationPostgresUpdate) GetJdbcURLParams() *string {
	if o == nil {
		return nil
	}
	return o.JdbcURLParams
}

func (o *DestinationPostgresUpdate) GetPassword() *string {
	if o == nil {
		return nil
	}
	return o.Password
}

func (o *DestinationPostgresUpdate) GetPort() *int64 {
	if o == nil {
		return nil
	}
	return o.Port
}

func (o *DestinationPostgresUpdate) GetSchema() *string {
	if o == nil {
		return nil
	}
	return o.Schema
}

func (o *DestinationPostgresUpdate) GetSslMode() *DestinationPostgresUpdateSSLModes {
	if o == nil {
		return nil
	}
	return o.SslMode
}

func (o *DestinationPostgresUpdate) GetTunnelMethod() *DestinationPostgresUpdateSSHTunnelMethod {
	if o == nil {
		return nil
	}
	return o.TunnelMethod
}

func (o *DestinationPostgresUpdate) GetUsername() string {
	if o == nil {
		return ""
	}
	return o.Username
}
