// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"airbyte/internal/sdk/pkg/utils"
	"encoding/json"
	"errors"
	"fmt"
)

type SourcePostgresUpdateUpdateMethodScanChangesWithUserDefinedCursorMethod string

const (
	SourcePostgresUpdateUpdateMethodScanChangesWithUserDefinedCursorMethodStandard SourcePostgresUpdateUpdateMethodScanChangesWithUserDefinedCursorMethod = "Standard"
)

func (e SourcePostgresUpdateUpdateMethodScanChangesWithUserDefinedCursorMethod) ToPointer() *SourcePostgresUpdateUpdateMethodScanChangesWithUserDefinedCursorMethod {
	return &e
}

func (e *SourcePostgresUpdateUpdateMethodScanChangesWithUserDefinedCursorMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Standard":
		*e = SourcePostgresUpdateUpdateMethodScanChangesWithUserDefinedCursorMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresUpdateUpdateMethodScanChangesWithUserDefinedCursorMethod: %v", v)
	}
}

// SourcePostgresUpdateUpdateMethodScanChangesWithUserDefinedCursor - Incrementally detects new inserts and updates using the <a href="https://docs.airbyte.com/understanding-airbyte/connections/incremental-append/#user-defined-cursor">cursor column</a> chosen when configuring a connection (e.g. created_at, updated_at).
type SourcePostgresUpdateUpdateMethodScanChangesWithUserDefinedCursor struct {
	method SourcePostgresUpdateUpdateMethodScanChangesWithUserDefinedCursorMethod `const:"Standard" json:"method"`
}

func (s SourcePostgresUpdateUpdateMethodScanChangesWithUserDefinedCursor) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresUpdateUpdateMethodScanChangesWithUserDefinedCursor) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresUpdateUpdateMethodScanChangesWithUserDefinedCursor) GetMethod() SourcePostgresUpdateUpdateMethodScanChangesWithUserDefinedCursorMethod {
	return SourcePostgresUpdateUpdateMethodScanChangesWithUserDefinedCursorMethodStandard
}

type SourcePostgresUpdateUpdateMethodDetectChangesWithXminSystemColumnMethod string

const (
	SourcePostgresUpdateUpdateMethodDetectChangesWithXminSystemColumnMethodXmin SourcePostgresUpdateUpdateMethodDetectChangesWithXminSystemColumnMethod = "Xmin"
)

func (e SourcePostgresUpdateUpdateMethodDetectChangesWithXminSystemColumnMethod) ToPointer() *SourcePostgresUpdateUpdateMethodDetectChangesWithXminSystemColumnMethod {
	return &e
}

func (e *SourcePostgresUpdateUpdateMethodDetectChangesWithXminSystemColumnMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Xmin":
		*e = SourcePostgresUpdateUpdateMethodDetectChangesWithXminSystemColumnMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresUpdateUpdateMethodDetectChangesWithXminSystemColumnMethod: %v", v)
	}
}

// SourcePostgresUpdateUpdateMethodDetectChangesWithXminSystemColumn - <i>Recommended</i> - Incrementally reads new inserts and updates via Postgres <a href="https://docs.airbyte.com/integrations/sources/postgres/#xmin">Xmin system column</a>. Only recommended for tables up to 500GB.
type SourcePostgresUpdateUpdateMethodDetectChangesWithXminSystemColumn struct {
	method SourcePostgresUpdateUpdateMethodDetectChangesWithXminSystemColumnMethod `const:"Xmin" json:"method"`
}

func (s SourcePostgresUpdateUpdateMethodDetectChangesWithXminSystemColumn) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresUpdateUpdateMethodDetectChangesWithXminSystemColumn) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresUpdateUpdateMethodDetectChangesWithXminSystemColumn) GetMethod() SourcePostgresUpdateUpdateMethodDetectChangesWithXminSystemColumnMethod {
	return SourcePostgresUpdateUpdateMethodDetectChangesWithXminSystemColumnMethodXmin
}

// SourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDCLSNCommitBehaviour - Determines when Airbtye should flush the LSN of processed WAL logs in the source database. `After loading Data in the destination` is default. If `While reading Data` is selected, in case of a downstream failure (while loading data into the destination), next sync would result in a full sync.
type SourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDCLSNCommitBehaviour string

const (
	SourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDCLSNCommitBehaviourWhileReadingData                 SourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDCLSNCommitBehaviour = "While reading Data"
	SourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDCLSNCommitBehaviourAfterLoadingDataInTheDestination SourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDCLSNCommitBehaviour = "After loading Data in the destination"
)

func (e SourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDCLSNCommitBehaviour) ToPointer() *SourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDCLSNCommitBehaviour {
	return &e
}

func (e *SourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDCLSNCommitBehaviour) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "While reading Data":
		fallthrough
	case "After loading Data in the destination":
		*e = SourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDCLSNCommitBehaviour(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDCLSNCommitBehaviour: %v", v)
	}
}

type SourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDCMethod string

const (
	SourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDCMethodCdc SourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDCMethod = "CDC"
)

func (e SourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDCMethod) ToPointer() *SourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDCMethod {
	return &e
}

func (e *SourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDCMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CDC":
		*e = SourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDCMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDCMethod: %v", v)
	}
}

// SourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDCPlugin - A logical decoding plugin installed on the PostgreSQL server.
type SourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDCPlugin string

const (
	SourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDCPluginPgoutput SourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDCPlugin = "pgoutput"
)

func (e SourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDCPlugin) ToPointer() *SourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDCPlugin {
	return &e
}

func (e *SourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDCPlugin) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "pgoutput":
		*e = SourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDCPlugin(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDCPlugin: %v", v)
	}
}

// SourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDC - <i>Recommended</i> - Incrementally reads new inserts, updates, and deletes using the Postgres <a href="https://docs.airbyte.com/integrations/sources/postgres/#cdc">write-ahead log (WAL)</a>. This needs to be configured on the source database itself. Recommended for tables of any size.
type SourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDC struct {
	AdditionalProperties interface{} `additionalProperties:"true" json:"-"`
	// The amount of time the connector will wait when it launches to determine if there is new data to sync or not. Defaults to 300 seconds. Valid range: 120 seconds to 1200 seconds. Read about <a href="https://docs.airbyte.com/integrations/sources/postgres#step-5-optional-set-up-initial-waiting-time">initial waiting time</a>.
	InitialWaitingSeconds *int64 `default:"300" json:"initial_waiting_seconds"`
	// Determines when Airbtye should flush the LSN of processed WAL logs in the source database. `After loading Data in the destination` is default. If `While reading Data` is selected, in case of a downstream failure (while loading data into the destination), next sync would result in a full sync.
	LsnCommitBehaviour *SourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDCLSNCommitBehaviour `default:"After loading Data in the destination" json:"lsn_commit_behaviour"`
	method             SourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDCMethod              `const:"CDC" json:"method"`
	// A logical decoding plugin installed on the PostgreSQL server.
	Plugin *SourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDCPlugin `default:"pgoutput" json:"plugin"`
	// A Postgres publication used for consuming changes. Read about <a href="https://docs.airbyte.com/integrations/sources/postgres#step-4-create-publications-and-replication-identities-for-tables">publications and replication identities</a>.
	Publication string `json:"publication"`
	// The size of the internal queue. This may interfere with memory consumption and efficiency of the connector, please be careful.
	QueueSize *int64 `default:"10000" json:"queue_size"`
	// A plugin logical replication slot. Read about <a href="https://docs.airbyte.com/integrations/sources/postgres#step-3-create-replication-slot">replication slots</a>.
	ReplicationSlot string `json:"replication_slot"`
}

func (s SourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDC) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDC) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDC) GetAdditionalProperties() interface{} {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *SourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDC) GetInitialWaitingSeconds() *int64 {
	if o == nil {
		return nil
	}
	return o.InitialWaitingSeconds
}

func (o *SourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDC) GetLsnCommitBehaviour() *SourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDCLSNCommitBehaviour {
	if o == nil {
		return nil
	}
	return o.LsnCommitBehaviour
}

func (o *SourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDC) GetMethod() SourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDCMethod {
	return SourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDCMethodCdc
}

func (o *SourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDC) GetPlugin() *SourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDCPlugin {
	if o == nil {
		return nil
	}
	return o.Plugin
}

func (o *SourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDC) GetPublication() string {
	if o == nil {
		return ""
	}
	return o.Publication
}

func (o *SourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDC) GetQueueSize() *int64 {
	if o == nil {
		return nil
	}
	return o.QueueSize
}

func (o *SourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDC) GetReplicationSlot() string {
	if o == nil {
		return ""
	}
	return o.ReplicationSlot
}

type SourcePostgresUpdateUpdateMethodType string

const (
	SourcePostgresUpdateUpdateMethodTypeSourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDC  SourcePostgresUpdateUpdateMethodType = "source-postgres-update_Update Method_Read Changes using Write-Ahead Log (CDC)"
	SourcePostgresUpdateUpdateMethodTypeSourcePostgresUpdateUpdateMethodDetectChangesWithXminSystemColumn SourcePostgresUpdateUpdateMethodType = "source-postgres-update_Update Method_Detect Changes with Xmin System Column"
	SourcePostgresUpdateUpdateMethodTypeSourcePostgresUpdateUpdateMethodScanChangesWithUserDefinedCursor  SourcePostgresUpdateUpdateMethodType = "source-postgres-update_Update Method_Scan Changes with User Defined Cursor"
)

type SourcePostgresUpdateUpdateMethod struct {
	SourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDC  *SourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDC
	SourcePostgresUpdateUpdateMethodDetectChangesWithXminSystemColumn *SourcePostgresUpdateUpdateMethodDetectChangesWithXminSystemColumn
	SourcePostgresUpdateUpdateMethodScanChangesWithUserDefinedCursor  *SourcePostgresUpdateUpdateMethodScanChangesWithUserDefinedCursor

	Type SourcePostgresUpdateUpdateMethodType
}

func CreateSourcePostgresUpdateUpdateMethodSourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDC(sourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDC SourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDC) SourcePostgresUpdateUpdateMethod {
	typ := SourcePostgresUpdateUpdateMethodTypeSourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDC

	return SourcePostgresUpdateUpdateMethod{
		SourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDC: &sourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDC,
		Type: typ,
	}
}

func CreateSourcePostgresUpdateUpdateMethodSourcePostgresUpdateUpdateMethodDetectChangesWithXminSystemColumn(sourcePostgresUpdateUpdateMethodDetectChangesWithXminSystemColumn SourcePostgresUpdateUpdateMethodDetectChangesWithXminSystemColumn) SourcePostgresUpdateUpdateMethod {
	typ := SourcePostgresUpdateUpdateMethodTypeSourcePostgresUpdateUpdateMethodDetectChangesWithXminSystemColumn

	return SourcePostgresUpdateUpdateMethod{
		SourcePostgresUpdateUpdateMethodDetectChangesWithXminSystemColumn: &sourcePostgresUpdateUpdateMethodDetectChangesWithXminSystemColumn,
		Type: typ,
	}
}

func CreateSourcePostgresUpdateUpdateMethodSourcePostgresUpdateUpdateMethodScanChangesWithUserDefinedCursor(sourcePostgresUpdateUpdateMethodScanChangesWithUserDefinedCursor SourcePostgresUpdateUpdateMethodScanChangesWithUserDefinedCursor) SourcePostgresUpdateUpdateMethod {
	typ := SourcePostgresUpdateUpdateMethodTypeSourcePostgresUpdateUpdateMethodScanChangesWithUserDefinedCursor

	return SourcePostgresUpdateUpdateMethod{
		SourcePostgresUpdateUpdateMethodScanChangesWithUserDefinedCursor: &sourcePostgresUpdateUpdateMethodScanChangesWithUserDefinedCursor,
		Type: typ,
	}
}

func (u *SourcePostgresUpdateUpdateMethod) UnmarshalJSON(data []byte) error {

	sourcePostgresUpdateUpdateMethodDetectChangesWithXminSystemColumn := new(SourcePostgresUpdateUpdateMethodDetectChangesWithXminSystemColumn)
	if err := utils.UnmarshalJSON(data, &sourcePostgresUpdateUpdateMethodDetectChangesWithXminSystemColumn, "", true, true); err == nil {
		u.SourcePostgresUpdateUpdateMethodDetectChangesWithXminSystemColumn = sourcePostgresUpdateUpdateMethodDetectChangesWithXminSystemColumn
		u.Type = SourcePostgresUpdateUpdateMethodTypeSourcePostgresUpdateUpdateMethodDetectChangesWithXminSystemColumn
		return nil
	}

	sourcePostgresUpdateUpdateMethodScanChangesWithUserDefinedCursor := new(SourcePostgresUpdateUpdateMethodScanChangesWithUserDefinedCursor)
	if err := utils.UnmarshalJSON(data, &sourcePostgresUpdateUpdateMethodScanChangesWithUserDefinedCursor, "", true, true); err == nil {
		u.SourcePostgresUpdateUpdateMethodScanChangesWithUserDefinedCursor = sourcePostgresUpdateUpdateMethodScanChangesWithUserDefinedCursor
		u.Type = SourcePostgresUpdateUpdateMethodTypeSourcePostgresUpdateUpdateMethodScanChangesWithUserDefinedCursor
		return nil
	}

	sourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDC := new(SourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDC)
	if err := utils.UnmarshalJSON(data, &sourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDC, "", true, true); err == nil {
		u.SourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDC = sourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDC
		u.Type = SourcePostgresUpdateUpdateMethodTypeSourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDC
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SourcePostgresUpdateUpdateMethod) MarshalJSON() ([]byte, error) {
	if u.SourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDC != nil {
		return utils.MarshalJSON(u.SourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDC, "", true)
	}

	if u.SourcePostgresUpdateUpdateMethodDetectChangesWithXminSystemColumn != nil {
		return utils.MarshalJSON(u.SourcePostgresUpdateUpdateMethodDetectChangesWithXminSystemColumn, "", true)
	}

	if u.SourcePostgresUpdateUpdateMethodScanChangesWithUserDefinedCursor != nil {
		return utils.MarshalJSON(u.SourcePostgresUpdateUpdateMethodScanChangesWithUserDefinedCursor, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type SourcePostgresUpdateSSLModesVerifyFullMode string

const (
	SourcePostgresUpdateSSLModesVerifyFullModeVerifyFull SourcePostgresUpdateSSLModesVerifyFullMode = "verify-full"
)

func (e SourcePostgresUpdateSSLModesVerifyFullMode) ToPointer() *SourcePostgresUpdateSSLModesVerifyFullMode {
	return &e
}

func (e *SourcePostgresUpdateSSLModesVerifyFullMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "verify-full":
		*e = SourcePostgresUpdateSSLModesVerifyFullMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresUpdateSSLModesVerifyFullMode: %v", v)
	}
}

// SourcePostgresUpdateSSLModesVerifyFull - This is the most secure mode. Always require encryption and verifies the identity of the source database server.
type SourcePostgresUpdateSSLModesVerifyFull struct {
	AdditionalProperties interface{} `additionalProperties:"true" json:"-"`
	// CA certificate
	CaCertificate string `json:"ca_certificate"`
	// Client certificate
	ClientCertificate *string `json:"client_certificate,omitempty"`
	// Client key
	ClientKey *string `json:"client_key,omitempty"`
	// Password for keystorage. If you do not add it - the password will be generated automatically.
	ClientKeyPassword *string                                    `json:"client_key_password,omitempty"`
	mode              SourcePostgresUpdateSSLModesVerifyFullMode `const:"verify-full" json:"mode"`
}

func (s SourcePostgresUpdateSSLModesVerifyFull) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresUpdateSSLModesVerifyFull) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresUpdateSSLModesVerifyFull) GetAdditionalProperties() interface{} {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *SourcePostgresUpdateSSLModesVerifyFull) GetCaCertificate() string {
	if o == nil {
		return ""
	}
	return o.CaCertificate
}

func (o *SourcePostgresUpdateSSLModesVerifyFull) GetClientCertificate() *string {
	if o == nil {
		return nil
	}
	return o.ClientCertificate
}

func (o *SourcePostgresUpdateSSLModesVerifyFull) GetClientKey() *string {
	if o == nil {
		return nil
	}
	return o.ClientKey
}

func (o *SourcePostgresUpdateSSLModesVerifyFull) GetClientKeyPassword() *string {
	if o == nil {
		return nil
	}
	return o.ClientKeyPassword
}

func (o *SourcePostgresUpdateSSLModesVerifyFull) GetMode() SourcePostgresUpdateSSLModesVerifyFullMode {
	return SourcePostgresUpdateSSLModesVerifyFullModeVerifyFull
}

type SourcePostgresUpdateSSLModesVerifyCaMode string

const (
	SourcePostgresUpdateSSLModesVerifyCaModeVerifyCa SourcePostgresUpdateSSLModesVerifyCaMode = "verify-ca"
)

func (e SourcePostgresUpdateSSLModesVerifyCaMode) ToPointer() *SourcePostgresUpdateSSLModesVerifyCaMode {
	return &e
}

func (e *SourcePostgresUpdateSSLModesVerifyCaMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "verify-ca":
		*e = SourcePostgresUpdateSSLModesVerifyCaMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresUpdateSSLModesVerifyCaMode: %v", v)
	}
}

// SourcePostgresUpdateSSLModesVerifyCa - Always require encryption and verifies that the source database server has a valid SSL certificate.
type SourcePostgresUpdateSSLModesVerifyCa struct {
	AdditionalProperties interface{} `additionalProperties:"true" json:"-"`
	// CA certificate
	CaCertificate string `json:"ca_certificate"`
	// Client certificate
	ClientCertificate *string `json:"client_certificate,omitempty"`
	// Client key
	ClientKey *string `json:"client_key,omitempty"`
	// Password for keystorage. If you do not add it - the password will be generated automatically.
	ClientKeyPassword *string                                  `json:"client_key_password,omitempty"`
	mode              SourcePostgresUpdateSSLModesVerifyCaMode `const:"verify-ca" json:"mode"`
}

func (s SourcePostgresUpdateSSLModesVerifyCa) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresUpdateSSLModesVerifyCa) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresUpdateSSLModesVerifyCa) GetAdditionalProperties() interface{} {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *SourcePostgresUpdateSSLModesVerifyCa) GetCaCertificate() string {
	if o == nil {
		return ""
	}
	return o.CaCertificate
}

func (o *SourcePostgresUpdateSSLModesVerifyCa) GetClientCertificate() *string {
	if o == nil {
		return nil
	}
	return o.ClientCertificate
}

func (o *SourcePostgresUpdateSSLModesVerifyCa) GetClientKey() *string {
	if o == nil {
		return nil
	}
	return o.ClientKey
}

func (o *SourcePostgresUpdateSSLModesVerifyCa) GetClientKeyPassword() *string {
	if o == nil {
		return nil
	}
	return o.ClientKeyPassword
}

func (o *SourcePostgresUpdateSSLModesVerifyCa) GetMode() SourcePostgresUpdateSSLModesVerifyCaMode {
	return SourcePostgresUpdateSSLModesVerifyCaModeVerifyCa
}

type SourcePostgresUpdateSSLModesRequireMode string

const (
	SourcePostgresUpdateSSLModesRequireModeRequire SourcePostgresUpdateSSLModesRequireMode = "require"
)

func (e SourcePostgresUpdateSSLModesRequireMode) ToPointer() *SourcePostgresUpdateSSLModesRequireMode {
	return &e
}

func (e *SourcePostgresUpdateSSLModesRequireMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "require":
		*e = SourcePostgresUpdateSSLModesRequireMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresUpdateSSLModesRequireMode: %v", v)
	}
}

// SourcePostgresUpdateSSLModesRequire - Always require encryption. If the source database server does not support encryption, connection will fail.
type SourcePostgresUpdateSSLModesRequire struct {
	AdditionalProperties interface{}                             `additionalProperties:"true" json:"-"`
	mode                 SourcePostgresUpdateSSLModesRequireMode `const:"require" json:"mode"`
}

func (s SourcePostgresUpdateSSLModesRequire) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresUpdateSSLModesRequire) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresUpdateSSLModesRequire) GetAdditionalProperties() interface{} {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *SourcePostgresUpdateSSLModesRequire) GetMode() SourcePostgresUpdateSSLModesRequireMode {
	return SourcePostgresUpdateSSLModesRequireModeRequire
}

type SourcePostgresUpdateSSLModesPreferMode string

const (
	SourcePostgresUpdateSSLModesPreferModePrefer SourcePostgresUpdateSSLModesPreferMode = "prefer"
)

func (e SourcePostgresUpdateSSLModesPreferMode) ToPointer() *SourcePostgresUpdateSSLModesPreferMode {
	return &e
}

func (e *SourcePostgresUpdateSSLModesPreferMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "prefer":
		*e = SourcePostgresUpdateSSLModesPreferMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresUpdateSSLModesPreferMode: %v", v)
	}
}

// SourcePostgresUpdateSSLModesPrefer - Allows unencrypted connection only if the source database does not support encryption.
type SourcePostgresUpdateSSLModesPrefer struct {
	AdditionalProperties interface{}                            `additionalProperties:"true" json:"-"`
	mode                 SourcePostgresUpdateSSLModesPreferMode `const:"prefer" json:"mode"`
}

func (s SourcePostgresUpdateSSLModesPrefer) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresUpdateSSLModesPrefer) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresUpdateSSLModesPrefer) GetAdditionalProperties() interface{} {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *SourcePostgresUpdateSSLModesPrefer) GetMode() SourcePostgresUpdateSSLModesPreferMode {
	return SourcePostgresUpdateSSLModesPreferModePrefer
}

type SourcePostgresUpdateSSLModesAllowMode string

const (
	SourcePostgresUpdateSSLModesAllowModeAllow SourcePostgresUpdateSSLModesAllowMode = "allow"
)

func (e SourcePostgresUpdateSSLModesAllowMode) ToPointer() *SourcePostgresUpdateSSLModesAllowMode {
	return &e
}

func (e *SourcePostgresUpdateSSLModesAllowMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "allow":
		*e = SourcePostgresUpdateSSLModesAllowMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresUpdateSSLModesAllowMode: %v", v)
	}
}

// SourcePostgresUpdateSSLModesAllow - Enables encryption only when required by the source database.
type SourcePostgresUpdateSSLModesAllow struct {
	AdditionalProperties interface{}                           `additionalProperties:"true" json:"-"`
	mode                 SourcePostgresUpdateSSLModesAllowMode `const:"allow" json:"mode"`
}

func (s SourcePostgresUpdateSSLModesAllow) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresUpdateSSLModesAllow) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresUpdateSSLModesAllow) GetAdditionalProperties() interface{} {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *SourcePostgresUpdateSSLModesAllow) GetMode() SourcePostgresUpdateSSLModesAllowMode {
	return SourcePostgresUpdateSSLModesAllowModeAllow
}

type SourcePostgresUpdateSSLModesDisableMode string

const (
	SourcePostgresUpdateSSLModesDisableModeDisable SourcePostgresUpdateSSLModesDisableMode = "disable"
)

func (e SourcePostgresUpdateSSLModesDisableMode) ToPointer() *SourcePostgresUpdateSSLModesDisableMode {
	return &e
}

func (e *SourcePostgresUpdateSSLModesDisableMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "disable":
		*e = SourcePostgresUpdateSSLModesDisableMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresUpdateSSLModesDisableMode: %v", v)
	}
}

// SourcePostgresUpdateSSLModesDisable - Disables encryption of communication between Airbyte and source database.
type SourcePostgresUpdateSSLModesDisable struct {
	AdditionalProperties interface{}                             `additionalProperties:"true" json:"-"`
	mode                 SourcePostgresUpdateSSLModesDisableMode `const:"disable" json:"mode"`
}

func (s SourcePostgresUpdateSSLModesDisable) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresUpdateSSLModesDisable) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresUpdateSSLModesDisable) GetAdditionalProperties() interface{} {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *SourcePostgresUpdateSSLModesDisable) GetMode() SourcePostgresUpdateSSLModesDisableMode {
	return SourcePostgresUpdateSSLModesDisableModeDisable
}

type SourcePostgresUpdateSSLModesType string

const (
	SourcePostgresUpdateSSLModesTypeSourcePostgresUpdateSSLModesDisable    SourcePostgresUpdateSSLModesType = "source-postgres-update_SSL Modes_disable"
	SourcePostgresUpdateSSLModesTypeSourcePostgresUpdateSSLModesAllow      SourcePostgresUpdateSSLModesType = "source-postgres-update_SSL Modes_allow"
	SourcePostgresUpdateSSLModesTypeSourcePostgresUpdateSSLModesPrefer     SourcePostgresUpdateSSLModesType = "source-postgres-update_SSL Modes_prefer"
	SourcePostgresUpdateSSLModesTypeSourcePostgresUpdateSSLModesRequire    SourcePostgresUpdateSSLModesType = "source-postgres-update_SSL Modes_require"
	SourcePostgresUpdateSSLModesTypeSourcePostgresUpdateSSLModesVerifyCa   SourcePostgresUpdateSSLModesType = "source-postgres-update_SSL Modes_verify-ca"
	SourcePostgresUpdateSSLModesTypeSourcePostgresUpdateSSLModesVerifyFull SourcePostgresUpdateSSLModesType = "source-postgres-update_SSL Modes_verify-full"
)

type SourcePostgresUpdateSSLModes struct {
	SourcePostgresUpdateSSLModesDisable    *SourcePostgresUpdateSSLModesDisable
	SourcePostgresUpdateSSLModesAllow      *SourcePostgresUpdateSSLModesAllow
	SourcePostgresUpdateSSLModesPrefer     *SourcePostgresUpdateSSLModesPrefer
	SourcePostgresUpdateSSLModesRequire    *SourcePostgresUpdateSSLModesRequire
	SourcePostgresUpdateSSLModesVerifyCa   *SourcePostgresUpdateSSLModesVerifyCa
	SourcePostgresUpdateSSLModesVerifyFull *SourcePostgresUpdateSSLModesVerifyFull

	Type SourcePostgresUpdateSSLModesType
}

func CreateSourcePostgresUpdateSSLModesSourcePostgresUpdateSSLModesDisable(sourcePostgresUpdateSSLModesDisable SourcePostgresUpdateSSLModesDisable) SourcePostgresUpdateSSLModes {
	typ := SourcePostgresUpdateSSLModesTypeSourcePostgresUpdateSSLModesDisable

	return SourcePostgresUpdateSSLModes{
		SourcePostgresUpdateSSLModesDisable: &sourcePostgresUpdateSSLModesDisable,
		Type:                                typ,
	}
}

func CreateSourcePostgresUpdateSSLModesSourcePostgresUpdateSSLModesAllow(sourcePostgresUpdateSSLModesAllow SourcePostgresUpdateSSLModesAllow) SourcePostgresUpdateSSLModes {
	typ := SourcePostgresUpdateSSLModesTypeSourcePostgresUpdateSSLModesAllow

	return SourcePostgresUpdateSSLModes{
		SourcePostgresUpdateSSLModesAllow: &sourcePostgresUpdateSSLModesAllow,
		Type:                              typ,
	}
}

func CreateSourcePostgresUpdateSSLModesSourcePostgresUpdateSSLModesPrefer(sourcePostgresUpdateSSLModesPrefer SourcePostgresUpdateSSLModesPrefer) SourcePostgresUpdateSSLModes {
	typ := SourcePostgresUpdateSSLModesTypeSourcePostgresUpdateSSLModesPrefer

	return SourcePostgresUpdateSSLModes{
		SourcePostgresUpdateSSLModesPrefer: &sourcePostgresUpdateSSLModesPrefer,
		Type:                               typ,
	}
}

func CreateSourcePostgresUpdateSSLModesSourcePostgresUpdateSSLModesRequire(sourcePostgresUpdateSSLModesRequire SourcePostgresUpdateSSLModesRequire) SourcePostgresUpdateSSLModes {
	typ := SourcePostgresUpdateSSLModesTypeSourcePostgresUpdateSSLModesRequire

	return SourcePostgresUpdateSSLModes{
		SourcePostgresUpdateSSLModesRequire: &sourcePostgresUpdateSSLModesRequire,
		Type:                                typ,
	}
}

func CreateSourcePostgresUpdateSSLModesSourcePostgresUpdateSSLModesVerifyCa(sourcePostgresUpdateSSLModesVerifyCa SourcePostgresUpdateSSLModesVerifyCa) SourcePostgresUpdateSSLModes {
	typ := SourcePostgresUpdateSSLModesTypeSourcePostgresUpdateSSLModesVerifyCa

	return SourcePostgresUpdateSSLModes{
		SourcePostgresUpdateSSLModesVerifyCa: &sourcePostgresUpdateSSLModesVerifyCa,
		Type:                                 typ,
	}
}

func CreateSourcePostgresUpdateSSLModesSourcePostgresUpdateSSLModesVerifyFull(sourcePostgresUpdateSSLModesVerifyFull SourcePostgresUpdateSSLModesVerifyFull) SourcePostgresUpdateSSLModes {
	typ := SourcePostgresUpdateSSLModesTypeSourcePostgresUpdateSSLModesVerifyFull

	return SourcePostgresUpdateSSLModes{
		SourcePostgresUpdateSSLModesVerifyFull: &sourcePostgresUpdateSSLModesVerifyFull,
		Type:                                   typ,
	}
}

func (u *SourcePostgresUpdateSSLModes) UnmarshalJSON(data []byte) error {

	sourcePostgresUpdateSSLModesDisable := new(SourcePostgresUpdateSSLModesDisable)
	if err := utils.UnmarshalJSON(data, &sourcePostgresUpdateSSLModesDisable, "", true, true); err == nil {
		u.SourcePostgresUpdateSSLModesDisable = sourcePostgresUpdateSSLModesDisable
		u.Type = SourcePostgresUpdateSSLModesTypeSourcePostgresUpdateSSLModesDisable
		return nil
	}

	sourcePostgresUpdateSSLModesAllow := new(SourcePostgresUpdateSSLModesAllow)
	if err := utils.UnmarshalJSON(data, &sourcePostgresUpdateSSLModesAllow, "", true, true); err == nil {
		u.SourcePostgresUpdateSSLModesAllow = sourcePostgresUpdateSSLModesAllow
		u.Type = SourcePostgresUpdateSSLModesTypeSourcePostgresUpdateSSLModesAllow
		return nil
	}

	sourcePostgresUpdateSSLModesPrefer := new(SourcePostgresUpdateSSLModesPrefer)
	if err := utils.UnmarshalJSON(data, &sourcePostgresUpdateSSLModesPrefer, "", true, true); err == nil {
		u.SourcePostgresUpdateSSLModesPrefer = sourcePostgresUpdateSSLModesPrefer
		u.Type = SourcePostgresUpdateSSLModesTypeSourcePostgresUpdateSSLModesPrefer
		return nil
	}

	sourcePostgresUpdateSSLModesRequire := new(SourcePostgresUpdateSSLModesRequire)
	if err := utils.UnmarshalJSON(data, &sourcePostgresUpdateSSLModesRequire, "", true, true); err == nil {
		u.SourcePostgresUpdateSSLModesRequire = sourcePostgresUpdateSSLModesRequire
		u.Type = SourcePostgresUpdateSSLModesTypeSourcePostgresUpdateSSLModesRequire
		return nil
	}

	sourcePostgresUpdateSSLModesVerifyCa := new(SourcePostgresUpdateSSLModesVerifyCa)
	if err := utils.UnmarshalJSON(data, &sourcePostgresUpdateSSLModesVerifyCa, "", true, true); err == nil {
		u.SourcePostgresUpdateSSLModesVerifyCa = sourcePostgresUpdateSSLModesVerifyCa
		u.Type = SourcePostgresUpdateSSLModesTypeSourcePostgresUpdateSSLModesVerifyCa
		return nil
	}

	sourcePostgresUpdateSSLModesVerifyFull := new(SourcePostgresUpdateSSLModesVerifyFull)
	if err := utils.UnmarshalJSON(data, &sourcePostgresUpdateSSLModesVerifyFull, "", true, true); err == nil {
		u.SourcePostgresUpdateSSLModesVerifyFull = sourcePostgresUpdateSSLModesVerifyFull
		u.Type = SourcePostgresUpdateSSLModesTypeSourcePostgresUpdateSSLModesVerifyFull
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SourcePostgresUpdateSSLModes) MarshalJSON() ([]byte, error) {
	if u.SourcePostgresUpdateSSLModesDisable != nil {
		return utils.MarshalJSON(u.SourcePostgresUpdateSSLModesDisable, "", true)
	}

	if u.SourcePostgresUpdateSSLModesAllow != nil {
		return utils.MarshalJSON(u.SourcePostgresUpdateSSLModesAllow, "", true)
	}

	if u.SourcePostgresUpdateSSLModesPrefer != nil {
		return utils.MarshalJSON(u.SourcePostgresUpdateSSLModesPrefer, "", true)
	}

	if u.SourcePostgresUpdateSSLModesRequire != nil {
		return utils.MarshalJSON(u.SourcePostgresUpdateSSLModesRequire, "", true)
	}

	if u.SourcePostgresUpdateSSLModesVerifyCa != nil {
		return utils.MarshalJSON(u.SourcePostgresUpdateSSLModesVerifyCa, "", true)
	}

	if u.SourcePostgresUpdateSSLModesVerifyFull != nil {
		return utils.MarshalJSON(u.SourcePostgresUpdateSSLModesVerifyFull, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

// SourcePostgresUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod - Connect through a jump server tunnel host using username and password authentication
type SourcePostgresUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod string

const (
	SourcePostgresUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethodSSHPasswordAuth SourcePostgresUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod = "SSH_PASSWORD_AUTH"
)

func (e SourcePostgresUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod) ToPointer() *SourcePostgresUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod {
	return &e
}

func (e *SourcePostgresUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_PASSWORD_AUTH":
		*e = SourcePostgresUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod: %v", v)
	}
}

// SourcePostgresUpdateSSHTunnelMethodPasswordAuthentication - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourcePostgresUpdateSSHTunnelMethodPasswordAuthentication struct {
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and password authentication
	tunnelMethod SourcePostgresUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod `const:"SSH_PASSWORD_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser string `json:"tunnel_user"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword string `json:"tunnel_user_password"`
}

func (s SourcePostgresUpdateSSHTunnelMethodPasswordAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresUpdateSSHTunnelMethodPasswordAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresUpdateSSHTunnelMethodPasswordAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *SourcePostgresUpdateSSHTunnelMethodPasswordAuthentication) GetTunnelMethod() SourcePostgresUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod {
	return SourcePostgresUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethodSSHPasswordAuth
}

func (o *SourcePostgresUpdateSSHTunnelMethodPasswordAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *SourcePostgresUpdateSSHTunnelMethodPasswordAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

func (o *SourcePostgresUpdateSSHTunnelMethodPasswordAuthentication) GetTunnelUserPassword() string {
	if o == nil {
		return ""
	}
	return o.TunnelUserPassword
}

// SourcePostgresUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod - Connect through a jump server tunnel host using username and ssh key
type SourcePostgresUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod string

const (
	SourcePostgresUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethodSSHKeyAuth SourcePostgresUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod = "SSH_KEY_AUTH"
)

func (e SourcePostgresUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod) ToPointer() *SourcePostgresUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod {
	return &e
}

func (e *SourcePostgresUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_KEY_AUTH":
		*e = SourcePostgresUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod: %v", v)
	}
}

// SourcePostgresUpdateSSHTunnelMethodSSHKeyAuthentication - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourcePostgresUpdateSSHTunnelMethodSSHKeyAuthentication struct {
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey string `json:"ssh_key"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and ssh key
	tunnelMethod SourcePostgresUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod `const:"SSH_KEY_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host.
	TunnelUser string `json:"tunnel_user"`
}

func (s SourcePostgresUpdateSSHTunnelMethodSSHKeyAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresUpdateSSHTunnelMethodSSHKeyAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresUpdateSSHTunnelMethodSSHKeyAuthentication) GetSSHKey() string {
	if o == nil {
		return ""
	}
	return o.SSHKey
}

func (o *SourcePostgresUpdateSSHTunnelMethodSSHKeyAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *SourcePostgresUpdateSSHTunnelMethodSSHKeyAuthentication) GetTunnelMethod() SourcePostgresUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod {
	return SourcePostgresUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethodSSHKeyAuth
}

func (o *SourcePostgresUpdateSSHTunnelMethodSSHKeyAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *SourcePostgresUpdateSSHTunnelMethodSSHKeyAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

// SourcePostgresUpdateSSHTunnelMethodNoTunnelTunnelMethod - No ssh tunnel needed to connect to database
type SourcePostgresUpdateSSHTunnelMethodNoTunnelTunnelMethod string

const (
	SourcePostgresUpdateSSHTunnelMethodNoTunnelTunnelMethodNoTunnel SourcePostgresUpdateSSHTunnelMethodNoTunnelTunnelMethod = "NO_TUNNEL"
)

func (e SourcePostgresUpdateSSHTunnelMethodNoTunnelTunnelMethod) ToPointer() *SourcePostgresUpdateSSHTunnelMethodNoTunnelTunnelMethod {
	return &e
}

func (e *SourcePostgresUpdateSSHTunnelMethodNoTunnelTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NO_TUNNEL":
		*e = SourcePostgresUpdateSSHTunnelMethodNoTunnelTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresUpdateSSHTunnelMethodNoTunnelTunnelMethod: %v", v)
	}
}

// SourcePostgresUpdateSSHTunnelMethodNoTunnel - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourcePostgresUpdateSSHTunnelMethodNoTunnel struct {
	// No ssh tunnel needed to connect to database
	tunnelMethod SourcePostgresUpdateSSHTunnelMethodNoTunnelTunnelMethod `const:"NO_TUNNEL" json:"tunnel_method"`
}

func (s SourcePostgresUpdateSSHTunnelMethodNoTunnel) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresUpdateSSHTunnelMethodNoTunnel) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresUpdateSSHTunnelMethodNoTunnel) GetTunnelMethod() SourcePostgresUpdateSSHTunnelMethodNoTunnelTunnelMethod {
	return SourcePostgresUpdateSSHTunnelMethodNoTunnelTunnelMethodNoTunnel
}

type SourcePostgresUpdateSSHTunnelMethodType string

const (
	SourcePostgresUpdateSSHTunnelMethodTypeSourcePostgresUpdateSSHTunnelMethodNoTunnel               SourcePostgresUpdateSSHTunnelMethodType = "source-postgres-update_SSH Tunnel Method_No Tunnel"
	SourcePostgresUpdateSSHTunnelMethodTypeSourcePostgresUpdateSSHTunnelMethodSSHKeyAuthentication   SourcePostgresUpdateSSHTunnelMethodType = "source-postgres-update_SSH Tunnel Method_SSH Key Authentication"
	SourcePostgresUpdateSSHTunnelMethodTypeSourcePostgresUpdateSSHTunnelMethodPasswordAuthentication SourcePostgresUpdateSSHTunnelMethodType = "source-postgres-update_SSH Tunnel Method_Password Authentication"
)

type SourcePostgresUpdateSSHTunnelMethod struct {
	SourcePostgresUpdateSSHTunnelMethodNoTunnel               *SourcePostgresUpdateSSHTunnelMethodNoTunnel
	SourcePostgresUpdateSSHTunnelMethodSSHKeyAuthentication   *SourcePostgresUpdateSSHTunnelMethodSSHKeyAuthentication
	SourcePostgresUpdateSSHTunnelMethodPasswordAuthentication *SourcePostgresUpdateSSHTunnelMethodPasswordAuthentication

	Type SourcePostgresUpdateSSHTunnelMethodType
}

func CreateSourcePostgresUpdateSSHTunnelMethodSourcePostgresUpdateSSHTunnelMethodNoTunnel(sourcePostgresUpdateSSHTunnelMethodNoTunnel SourcePostgresUpdateSSHTunnelMethodNoTunnel) SourcePostgresUpdateSSHTunnelMethod {
	typ := SourcePostgresUpdateSSHTunnelMethodTypeSourcePostgresUpdateSSHTunnelMethodNoTunnel

	return SourcePostgresUpdateSSHTunnelMethod{
		SourcePostgresUpdateSSHTunnelMethodNoTunnel: &sourcePostgresUpdateSSHTunnelMethodNoTunnel,
		Type: typ,
	}
}

func CreateSourcePostgresUpdateSSHTunnelMethodSourcePostgresUpdateSSHTunnelMethodSSHKeyAuthentication(sourcePostgresUpdateSSHTunnelMethodSSHKeyAuthentication SourcePostgresUpdateSSHTunnelMethodSSHKeyAuthentication) SourcePostgresUpdateSSHTunnelMethod {
	typ := SourcePostgresUpdateSSHTunnelMethodTypeSourcePostgresUpdateSSHTunnelMethodSSHKeyAuthentication

	return SourcePostgresUpdateSSHTunnelMethod{
		SourcePostgresUpdateSSHTunnelMethodSSHKeyAuthentication: &sourcePostgresUpdateSSHTunnelMethodSSHKeyAuthentication,
		Type: typ,
	}
}

func CreateSourcePostgresUpdateSSHTunnelMethodSourcePostgresUpdateSSHTunnelMethodPasswordAuthentication(sourcePostgresUpdateSSHTunnelMethodPasswordAuthentication SourcePostgresUpdateSSHTunnelMethodPasswordAuthentication) SourcePostgresUpdateSSHTunnelMethod {
	typ := SourcePostgresUpdateSSHTunnelMethodTypeSourcePostgresUpdateSSHTunnelMethodPasswordAuthentication

	return SourcePostgresUpdateSSHTunnelMethod{
		SourcePostgresUpdateSSHTunnelMethodPasswordAuthentication: &sourcePostgresUpdateSSHTunnelMethodPasswordAuthentication,
		Type: typ,
	}
}

func (u *SourcePostgresUpdateSSHTunnelMethod) UnmarshalJSON(data []byte) error {

	sourcePostgresUpdateSSHTunnelMethodNoTunnel := new(SourcePostgresUpdateSSHTunnelMethodNoTunnel)
	if err := utils.UnmarshalJSON(data, &sourcePostgresUpdateSSHTunnelMethodNoTunnel, "", true, true); err == nil {
		u.SourcePostgresUpdateSSHTunnelMethodNoTunnel = sourcePostgresUpdateSSHTunnelMethodNoTunnel
		u.Type = SourcePostgresUpdateSSHTunnelMethodTypeSourcePostgresUpdateSSHTunnelMethodNoTunnel
		return nil
	}

	sourcePostgresUpdateSSHTunnelMethodSSHKeyAuthentication := new(SourcePostgresUpdateSSHTunnelMethodSSHKeyAuthentication)
	if err := utils.UnmarshalJSON(data, &sourcePostgresUpdateSSHTunnelMethodSSHKeyAuthentication, "", true, true); err == nil {
		u.SourcePostgresUpdateSSHTunnelMethodSSHKeyAuthentication = sourcePostgresUpdateSSHTunnelMethodSSHKeyAuthentication
		u.Type = SourcePostgresUpdateSSHTunnelMethodTypeSourcePostgresUpdateSSHTunnelMethodSSHKeyAuthentication
		return nil
	}

	sourcePostgresUpdateSSHTunnelMethodPasswordAuthentication := new(SourcePostgresUpdateSSHTunnelMethodPasswordAuthentication)
	if err := utils.UnmarshalJSON(data, &sourcePostgresUpdateSSHTunnelMethodPasswordAuthentication, "", true, true); err == nil {
		u.SourcePostgresUpdateSSHTunnelMethodPasswordAuthentication = sourcePostgresUpdateSSHTunnelMethodPasswordAuthentication
		u.Type = SourcePostgresUpdateSSHTunnelMethodTypeSourcePostgresUpdateSSHTunnelMethodPasswordAuthentication
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SourcePostgresUpdateSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.SourcePostgresUpdateSSHTunnelMethodNoTunnel != nil {
		return utils.MarshalJSON(u.SourcePostgresUpdateSSHTunnelMethodNoTunnel, "", true)
	}

	if u.SourcePostgresUpdateSSHTunnelMethodSSHKeyAuthentication != nil {
		return utils.MarshalJSON(u.SourcePostgresUpdateSSHTunnelMethodSSHKeyAuthentication, "", true)
	}

	if u.SourcePostgresUpdateSSHTunnelMethodPasswordAuthentication != nil {
		return utils.MarshalJSON(u.SourcePostgresUpdateSSHTunnelMethodPasswordAuthentication, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type SourcePostgresUpdate struct {
	// Name of the database.
	Database string `json:"database"`
	// Hostname of the database.
	Host string `json:"host"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (Eg. key1=value1&key2=value2&key3=value3). For more information read about <a href="https://jdbc.postgresql.org/documentation/head/connect.html">JDBC URL parameters</a>.
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// Password associated with the username.
	Password *string `json:"password,omitempty"`
	// Port of the database.
	Port *int64 `default:"5432" json:"port"`
	// Configures how data is extracted from the database.
	ReplicationMethod *SourcePostgresUpdateUpdateMethod `json:"replication_method,omitempty"`
	// The list of schemas (case sensitive) to sync from. Defaults to public.
	Schemas []string `json:"schemas,omitempty"`
	// SSL connection modes.
	//   Read more <a href="https://jdbc.postgresql.org/documentation/head/ssl-client.html"> in the docs</a>.
	SslMode *SourcePostgresUpdateSSLModes `json:"ssl_mode,omitempty"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod *SourcePostgresUpdateSSHTunnelMethod `json:"tunnel_method,omitempty"`
	// Username to access the database.
	Username string `json:"username"`
}

func (s SourcePostgresUpdate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresUpdate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresUpdate) GetDatabase() string {
	if o == nil {
		return ""
	}
	return o.Database
}

func (o *SourcePostgresUpdate) GetHost() string {
	if o == nil {
		return ""
	}
	return o.Host
}

func (o *SourcePostgresUpdate) GetJdbcURLParams() *string {
	if o == nil {
		return nil
	}
	return o.JdbcURLParams
}

func (o *SourcePostgresUpdate) GetPassword() *string {
	if o == nil {
		return nil
	}
	return o.Password
}

func (o *SourcePostgresUpdate) GetPort() *int64 {
	if o == nil {
		return nil
	}
	return o.Port
}

func (o *SourcePostgresUpdate) GetReplicationMethod() *SourcePostgresUpdateUpdateMethod {
	if o == nil {
		return nil
	}
	return o.ReplicationMethod
}

func (o *SourcePostgresUpdate) GetSchemas() []string {
	if o == nil {
		return nil
	}
	return o.Schemas
}

func (o *SourcePostgresUpdate) GetSslMode() *SourcePostgresUpdateSSLModes {
	if o == nil {
		return nil
	}
	return o.SslMode
}

func (o *SourcePostgresUpdate) GetTunnelMethod() *SourcePostgresUpdateSSHTunnelMethod {
	if o == nil {
		return nil
	}
	return o.TunnelMethod
}

func (o *SourcePostgresUpdate) GetUsername() string {
	if o == nil {
		return ""
	}
	return o.Username
}
