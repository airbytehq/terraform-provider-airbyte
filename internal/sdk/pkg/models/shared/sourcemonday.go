// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
)

type SourceMondayAuthorizationMethodAPITokenAuthType string

const (
	SourceMondayAuthorizationMethodAPITokenAuthTypeAPIToken SourceMondayAuthorizationMethodAPITokenAuthType = "api_token"
)

func (e SourceMondayAuthorizationMethodAPITokenAuthType) ToPointer() *SourceMondayAuthorizationMethodAPITokenAuthType {
	return &e
}

func (e *SourceMondayAuthorizationMethodAPITokenAuthType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "api_token":
		*e = SourceMondayAuthorizationMethodAPITokenAuthType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMondayAuthorizationMethodAPITokenAuthType: %v", v)
	}
}

type SourceMondayAuthorizationMethodAPIToken struct {
	// API Token for making authenticated requests.
	APIToken string                                          `json:"api_token"`
	AuthType SourceMondayAuthorizationMethodAPITokenAuthType `json:"auth_type"`
}

type SourceMondayAuthorizationMethodOAuth20AuthType string

const (
	SourceMondayAuthorizationMethodOAuth20AuthTypeOauth20 SourceMondayAuthorizationMethodOAuth20AuthType = "oauth2.0"
)

func (e SourceMondayAuthorizationMethodOAuth20AuthType) ToPointer() *SourceMondayAuthorizationMethodOAuth20AuthType {
	return &e
}

func (e *SourceMondayAuthorizationMethodOAuth20AuthType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "oauth2.0":
		*e = SourceMondayAuthorizationMethodOAuth20AuthType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMondayAuthorizationMethodOAuth20AuthType: %v", v)
	}
}

type SourceMondayAuthorizationMethodOAuth20 struct {
	// Access Token for making authenticated requests.
	AccessToken string                                         `json:"access_token"`
	AuthType    SourceMondayAuthorizationMethodOAuth20AuthType `json:"auth_type"`
	// The Client ID of your OAuth application.
	ClientID string `json:"client_id"`
	// The Client Secret of your OAuth application.
	ClientSecret string `json:"client_secret"`
	// Slug/subdomain of the account, or the first part of the URL that comes before .monday.com
	Subdomain *string `json:"subdomain,omitempty"`
}

type SourceMondayAuthorizationMethodType string

const (
	SourceMondayAuthorizationMethodTypeSourceMondayAuthorizationMethodOAuth20  SourceMondayAuthorizationMethodType = "source-monday_Authorization Method_OAuth2.0"
	SourceMondayAuthorizationMethodTypeSourceMondayAuthorizationMethodAPIToken SourceMondayAuthorizationMethodType = "source-monday_Authorization Method_API Token"
)

type SourceMondayAuthorizationMethod struct {
	SourceMondayAuthorizationMethodOAuth20  *SourceMondayAuthorizationMethodOAuth20
	SourceMondayAuthorizationMethodAPIToken *SourceMondayAuthorizationMethodAPIToken

	Type SourceMondayAuthorizationMethodType
}

func CreateSourceMondayAuthorizationMethodSourceMondayAuthorizationMethodOAuth20(sourceMondayAuthorizationMethodOAuth20 SourceMondayAuthorizationMethodOAuth20) SourceMondayAuthorizationMethod {
	typ := SourceMondayAuthorizationMethodTypeSourceMondayAuthorizationMethodOAuth20

	return SourceMondayAuthorizationMethod{
		SourceMondayAuthorizationMethodOAuth20: &sourceMondayAuthorizationMethodOAuth20,
		Type:                                   typ,
	}
}

func CreateSourceMondayAuthorizationMethodSourceMondayAuthorizationMethodAPIToken(sourceMondayAuthorizationMethodAPIToken SourceMondayAuthorizationMethodAPIToken) SourceMondayAuthorizationMethod {
	typ := SourceMondayAuthorizationMethodTypeSourceMondayAuthorizationMethodAPIToken

	return SourceMondayAuthorizationMethod{
		SourceMondayAuthorizationMethodAPIToken: &sourceMondayAuthorizationMethodAPIToken,
		Type:                                    typ,
	}
}

func (u *SourceMondayAuthorizationMethod) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	sourceMondayAuthorizationMethodAPIToken := new(SourceMondayAuthorizationMethodAPIToken)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sourceMondayAuthorizationMethodAPIToken); err == nil {
		u.SourceMondayAuthorizationMethodAPIToken = sourceMondayAuthorizationMethodAPIToken
		u.Type = SourceMondayAuthorizationMethodTypeSourceMondayAuthorizationMethodAPIToken
		return nil
	}

	sourceMondayAuthorizationMethodOAuth20 := new(SourceMondayAuthorizationMethodOAuth20)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sourceMondayAuthorizationMethodOAuth20); err == nil {
		u.SourceMondayAuthorizationMethodOAuth20 = sourceMondayAuthorizationMethodOAuth20
		u.Type = SourceMondayAuthorizationMethodTypeSourceMondayAuthorizationMethodOAuth20
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SourceMondayAuthorizationMethod) MarshalJSON() ([]byte, error) {
	if u.SourceMondayAuthorizationMethodAPIToken != nil {
		return json.Marshal(u.SourceMondayAuthorizationMethodAPIToken)
	}

	if u.SourceMondayAuthorizationMethodOAuth20 != nil {
		return json.Marshal(u.SourceMondayAuthorizationMethodOAuth20)
	}

	return nil, nil
}

type SourceMondayMonday string

const (
	SourceMondayMondayMonday SourceMondayMonday = "monday"
)

func (e SourceMondayMonday) ToPointer() *SourceMondayMonday {
	return &e
}

func (e *SourceMondayMonday) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "monday":
		*e = SourceMondayMonday(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMondayMonday: %v", v)
	}
}

type SourceMonday struct {
	Credentials *SourceMondayAuthorizationMethod `json:"credentials,omitempty"`
	SourceType  SourceMondayMonday               `json:"sourceType"`
}
