// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
)

// DestinationRedshiftUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod - Connect through a jump server tunnel host using username and password authentication
type DestinationRedshiftUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod string

const (
	DestinationRedshiftUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethodSSHPasswordAuth DestinationRedshiftUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod = "SSH_PASSWORD_AUTH"
)

func (e DestinationRedshiftUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod) ToPointer() *DestinationRedshiftUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod {
	return &e
}

func (e *DestinationRedshiftUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_PASSWORD_AUTH":
		*e = DestinationRedshiftUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationRedshiftUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod: %v", v)
	}
}

// DestinationRedshiftUpdateSSHTunnelMethodPasswordAuthentication - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type DestinationRedshiftUpdateSSHTunnelMethodPasswordAuthentication struct {
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and password authentication
	TunnelMethod DestinationRedshiftUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod `json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort int64 `json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser string `json:"tunnel_user"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword string `json:"tunnel_user_password"`
}

// DestinationRedshiftUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod - Connect through a jump server tunnel host using username and ssh key
type DestinationRedshiftUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod string

const (
	DestinationRedshiftUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethodSSHKeyAuth DestinationRedshiftUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod = "SSH_KEY_AUTH"
)

func (e DestinationRedshiftUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod) ToPointer() *DestinationRedshiftUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod {
	return &e
}

func (e *DestinationRedshiftUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_KEY_AUTH":
		*e = DestinationRedshiftUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationRedshiftUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod: %v", v)
	}
}

// DestinationRedshiftUpdateSSHTunnelMethodSSHKeyAuthentication - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type DestinationRedshiftUpdateSSHTunnelMethodSSHKeyAuthentication struct {
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey string `json:"ssh_key"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and ssh key
	TunnelMethod DestinationRedshiftUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod `json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort int64 `json:"tunnel_port"`
	// OS-level username for logging into the jump server host.
	TunnelUser string `json:"tunnel_user"`
}

// DestinationRedshiftUpdateSSHTunnelMethodNoTunnelTunnelMethod - No ssh tunnel needed to connect to database
type DestinationRedshiftUpdateSSHTunnelMethodNoTunnelTunnelMethod string

const (
	DestinationRedshiftUpdateSSHTunnelMethodNoTunnelTunnelMethodNoTunnel DestinationRedshiftUpdateSSHTunnelMethodNoTunnelTunnelMethod = "NO_TUNNEL"
)

func (e DestinationRedshiftUpdateSSHTunnelMethodNoTunnelTunnelMethod) ToPointer() *DestinationRedshiftUpdateSSHTunnelMethodNoTunnelTunnelMethod {
	return &e
}

func (e *DestinationRedshiftUpdateSSHTunnelMethodNoTunnelTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NO_TUNNEL":
		*e = DestinationRedshiftUpdateSSHTunnelMethodNoTunnelTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationRedshiftUpdateSSHTunnelMethodNoTunnelTunnelMethod: %v", v)
	}
}

// DestinationRedshiftUpdateSSHTunnelMethodNoTunnel - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type DestinationRedshiftUpdateSSHTunnelMethodNoTunnel struct {
	// No ssh tunnel needed to connect to database
	TunnelMethod DestinationRedshiftUpdateSSHTunnelMethodNoTunnelTunnelMethod `json:"tunnel_method"`
}

type DestinationRedshiftUpdateSSHTunnelMethodType string

const (
	DestinationRedshiftUpdateSSHTunnelMethodTypeDestinationRedshiftUpdateSSHTunnelMethodNoTunnel               DestinationRedshiftUpdateSSHTunnelMethodType = "destination-redshift-update_SSH Tunnel Method_No Tunnel"
	DestinationRedshiftUpdateSSHTunnelMethodTypeDestinationRedshiftUpdateSSHTunnelMethodSSHKeyAuthentication   DestinationRedshiftUpdateSSHTunnelMethodType = "destination-redshift-update_SSH Tunnel Method_SSH Key Authentication"
	DestinationRedshiftUpdateSSHTunnelMethodTypeDestinationRedshiftUpdateSSHTunnelMethodPasswordAuthentication DestinationRedshiftUpdateSSHTunnelMethodType = "destination-redshift-update_SSH Tunnel Method_Password Authentication"
)

type DestinationRedshiftUpdateSSHTunnelMethod struct {
	DestinationRedshiftUpdateSSHTunnelMethodNoTunnel               *DestinationRedshiftUpdateSSHTunnelMethodNoTunnel
	DestinationRedshiftUpdateSSHTunnelMethodSSHKeyAuthentication   *DestinationRedshiftUpdateSSHTunnelMethodSSHKeyAuthentication
	DestinationRedshiftUpdateSSHTunnelMethodPasswordAuthentication *DestinationRedshiftUpdateSSHTunnelMethodPasswordAuthentication

	Type DestinationRedshiftUpdateSSHTunnelMethodType
}

func CreateDestinationRedshiftUpdateSSHTunnelMethodDestinationRedshiftUpdateSSHTunnelMethodNoTunnel(destinationRedshiftUpdateSSHTunnelMethodNoTunnel DestinationRedshiftUpdateSSHTunnelMethodNoTunnel) DestinationRedshiftUpdateSSHTunnelMethod {
	typ := DestinationRedshiftUpdateSSHTunnelMethodTypeDestinationRedshiftUpdateSSHTunnelMethodNoTunnel

	return DestinationRedshiftUpdateSSHTunnelMethod{
		DestinationRedshiftUpdateSSHTunnelMethodNoTunnel: &destinationRedshiftUpdateSSHTunnelMethodNoTunnel,
		Type: typ,
	}
}

func CreateDestinationRedshiftUpdateSSHTunnelMethodDestinationRedshiftUpdateSSHTunnelMethodSSHKeyAuthentication(destinationRedshiftUpdateSSHTunnelMethodSSHKeyAuthentication DestinationRedshiftUpdateSSHTunnelMethodSSHKeyAuthentication) DestinationRedshiftUpdateSSHTunnelMethod {
	typ := DestinationRedshiftUpdateSSHTunnelMethodTypeDestinationRedshiftUpdateSSHTunnelMethodSSHKeyAuthentication

	return DestinationRedshiftUpdateSSHTunnelMethod{
		DestinationRedshiftUpdateSSHTunnelMethodSSHKeyAuthentication: &destinationRedshiftUpdateSSHTunnelMethodSSHKeyAuthentication,
		Type: typ,
	}
}

func CreateDestinationRedshiftUpdateSSHTunnelMethodDestinationRedshiftUpdateSSHTunnelMethodPasswordAuthentication(destinationRedshiftUpdateSSHTunnelMethodPasswordAuthentication DestinationRedshiftUpdateSSHTunnelMethodPasswordAuthentication) DestinationRedshiftUpdateSSHTunnelMethod {
	typ := DestinationRedshiftUpdateSSHTunnelMethodTypeDestinationRedshiftUpdateSSHTunnelMethodPasswordAuthentication

	return DestinationRedshiftUpdateSSHTunnelMethod{
		DestinationRedshiftUpdateSSHTunnelMethodPasswordAuthentication: &destinationRedshiftUpdateSSHTunnelMethodPasswordAuthentication,
		Type: typ,
	}
}

func (u *DestinationRedshiftUpdateSSHTunnelMethod) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	destinationRedshiftUpdateSSHTunnelMethodNoTunnel := new(DestinationRedshiftUpdateSSHTunnelMethodNoTunnel)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationRedshiftUpdateSSHTunnelMethodNoTunnel); err == nil {
		u.DestinationRedshiftUpdateSSHTunnelMethodNoTunnel = destinationRedshiftUpdateSSHTunnelMethodNoTunnel
		u.Type = DestinationRedshiftUpdateSSHTunnelMethodTypeDestinationRedshiftUpdateSSHTunnelMethodNoTunnel
		return nil
	}

	destinationRedshiftUpdateSSHTunnelMethodSSHKeyAuthentication := new(DestinationRedshiftUpdateSSHTunnelMethodSSHKeyAuthentication)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationRedshiftUpdateSSHTunnelMethodSSHKeyAuthentication); err == nil {
		u.DestinationRedshiftUpdateSSHTunnelMethodSSHKeyAuthentication = destinationRedshiftUpdateSSHTunnelMethodSSHKeyAuthentication
		u.Type = DestinationRedshiftUpdateSSHTunnelMethodTypeDestinationRedshiftUpdateSSHTunnelMethodSSHKeyAuthentication
		return nil
	}

	destinationRedshiftUpdateSSHTunnelMethodPasswordAuthentication := new(DestinationRedshiftUpdateSSHTunnelMethodPasswordAuthentication)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationRedshiftUpdateSSHTunnelMethodPasswordAuthentication); err == nil {
		u.DestinationRedshiftUpdateSSHTunnelMethodPasswordAuthentication = destinationRedshiftUpdateSSHTunnelMethodPasswordAuthentication
		u.Type = DestinationRedshiftUpdateSSHTunnelMethodTypeDestinationRedshiftUpdateSSHTunnelMethodPasswordAuthentication
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u DestinationRedshiftUpdateSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.DestinationRedshiftUpdateSSHTunnelMethodNoTunnel != nil {
		return json.Marshal(u.DestinationRedshiftUpdateSSHTunnelMethodNoTunnel)
	}

	if u.DestinationRedshiftUpdateSSHTunnelMethodSSHKeyAuthentication != nil {
		return json.Marshal(u.DestinationRedshiftUpdateSSHTunnelMethodSSHKeyAuthentication)
	}

	if u.DestinationRedshiftUpdateSSHTunnelMethodPasswordAuthentication != nil {
		return json.Marshal(u.DestinationRedshiftUpdateSSHTunnelMethodPasswordAuthentication)
	}

	return nil, nil
}

type DestinationRedshiftUpdateUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryptionEncryptionType string

const (
	DestinationRedshiftUpdateUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryptionEncryptionTypeAesCbcEnvelope DestinationRedshiftUpdateUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryptionEncryptionType = "aes_cbc_envelope"
)

func (e DestinationRedshiftUpdateUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryptionEncryptionType) ToPointer() *DestinationRedshiftUpdateUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryptionEncryptionType {
	return &e
}

func (e *DestinationRedshiftUpdateUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryptionEncryptionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "aes_cbc_envelope":
		*e = DestinationRedshiftUpdateUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryptionEncryptionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationRedshiftUpdateUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryptionEncryptionType: %v", v)
	}
}

// DestinationRedshiftUpdateUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryption - Staging data will be encrypted using AES-CBC envelope encryption.
type DestinationRedshiftUpdateUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryption struct {
	EncryptionType DestinationRedshiftUpdateUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryptionEncryptionType `json:"encryption_type"`
	// The key, base64-encoded. Must be either 128, 192, or 256 bits. Leave blank to have Airbyte generate an ephemeral key for each sync.
	KeyEncryptingKey *string `json:"key_encrypting_key,omitempty"`
}

type DestinationRedshiftUpdateUploadingMethodS3StagingEncryptionNoEncryptionEncryptionType string

const (
	DestinationRedshiftUpdateUploadingMethodS3StagingEncryptionNoEncryptionEncryptionTypeNone DestinationRedshiftUpdateUploadingMethodS3StagingEncryptionNoEncryptionEncryptionType = "none"
)

func (e DestinationRedshiftUpdateUploadingMethodS3StagingEncryptionNoEncryptionEncryptionType) ToPointer() *DestinationRedshiftUpdateUploadingMethodS3StagingEncryptionNoEncryptionEncryptionType {
	return &e
}

func (e *DestinationRedshiftUpdateUploadingMethodS3StagingEncryptionNoEncryptionEncryptionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "none":
		*e = DestinationRedshiftUpdateUploadingMethodS3StagingEncryptionNoEncryptionEncryptionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationRedshiftUpdateUploadingMethodS3StagingEncryptionNoEncryptionEncryptionType: %v", v)
	}
}

// DestinationRedshiftUpdateUploadingMethodS3StagingEncryptionNoEncryption - Staging data will be stored in plaintext.
type DestinationRedshiftUpdateUploadingMethodS3StagingEncryptionNoEncryption struct {
	EncryptionType DestinationRedshiftUpdateUploadingMethodS3StagingEncryptionNoEncryptionEncryptionType `json:"encryption_type"`
}

type DestinationRedshiftUpdateUploadingMethodS3StagingEncryptionType string

const (
	DestinationRedshiftUpdateUploadingMethodS3StagingEncryptionTypeDestinationRedshiftUpdateUploadingMethodS3StagingEncryptionNoEncryption             DestinationRedshiftUpdateUploadingMethodS3StagingEncryptionType = "destination-redshift-update_Uploading Method_S3 Staging_Encryption_No encryption"
	DestinationRedshiftUpdateUploadingMethodS3StagingEncryptionTypeDestinationRedshiftUpdateUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryption DestinationRedshiftUpdateUploadingMethodS3StagingEncryptionType = "destination-redshift-update_Uploading Method_S3 Staging_Encryption_AES-CBC envelope encryption"
)

type DestinationRedshiftUpdateUploadingMethodS3StagingEncryption struct {
	DestinationRedshiftUpdateUploadingMethodS3StagingEncryptionNoEncryption             *DestinationRedshiftUpdateUploadingMethodS3StagingEncryptionNoEncryption
	DestinationRedshiftUpdateUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryption *DestinationRedshiftUpdateUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryption

	Type DestinationRedshiftUpdateUploadingMethodS3StagingEncryptionType
}

func CreateDestinationRedshiftUpdateUploadingMethodS3StagingEncryptionDestinationRedshiftUpdateUploadingMethodS3StagingEncryptionNoEncryption(destinationRedshiftUpdateUploadingMethodS3StagingEncryptionNoEncryption DestinationRedshiftUpdateUploadingMethodS3StagingEncryptionNoEncryption) DestinationRedshiftUpdateUploadingMethodS3StagingEncryption {
	typ := DestinationRedshiftUpdateUploadingMethodS3StagingEncryptionTypeDestinationRedshiftUpdateUploadingMethodS3StagingEncryptionNoEncryption

	return DestinationRedshiftUpdateUploadingMethodS3StagingEncryption{
		DestinationRedshiftUpdateUploadingMethodS3StagingEncryptionNoEncryption: &destinationRedshiftUpdateUploadingMethodS3StagingEncryptionNoEncryption,
		Type: typ,
	}
}

func CreateDestinationRedshiftUpdateUploadingMethodS3StagingEncryptionDestinationRedshiftUpdateUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryption(destinationRedshiftUpdateUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryption DestinationRedshiftUpdateUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryption) DestinationRedshiftUpdateUploadingMethodS3StagingEncryption {
	typ := DestinationRedshiftUpdateUploadingMethodS3StagingEncryptionTypeDestinationRedshiftUpdateUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryption

	return DestinationRedshiftUpdateUploadingMethodS3StagingEncryption{
		DestinationRedshiftUpdateUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryption: &destinationRedshiftUpdateUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryption,
		Type: typ,
	}
}

func (u *DestinationRedshiftUpdateUploadingMethodS3StagingEncryption) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	destinationRedshiftUpdateUploadingMethodS3StagingEncryptionNoEncryption := new(DestinationRedshiftUpdateUploadingMethodS3StagingEncryptionNoEncryption)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationRedshiftUpdateUploadingMethodS3StagingEncryptionNoEncryption); err == nil {
		u.DestinationRedshiftUpdateUploadingMethodS3StagingEncryptionNoEncryption = destinationRedshiftUpdateUploadingMethodS3StagingEncryptionNoEncryption
		u.Type = DestinationRedshiftUpdateUploadingMethodS3StagingEncryptionTypeDestinationRedshiftUpdateUploadingMethodS3StagingEncryptionNoEncryption
		return nil
	}

	destinationRedshiftUpdateUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryption := new(DestinationRedshiftUpdateUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryption)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationRedshiftUpdateUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryption); err == nil {
		u.DestinationRedshiftUpdateUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryption = destinationRedshiftUpdateUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryption
		u.Type = DestinationRedshiftUpdateUploadingMethodS3StagingEncryptionTypeDestinationRedshiftUpdateUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryption
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u DestinationRedshiftUpdateUploadingMethodS3StagingEncryption) MarshalJSON() ([]byte, error) {
	if u.DestinationRedshiftUpdateUploadingMethodS3StagingEncryptionNoEncryption != nil {
		return json.Marshal(u.DestinationRedshiftUpdateUploadingMethodS3StagingEncryptionNoEncryption)
	}

	if u.DestinationRedshiftUpdateUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryption != nil {
		return json.Marshal(u.DestinationRedshiftUpdateUploadingMethodS3StagingEncryptionAESCBCEnvelopeEncryption)
	}

	return nil, nil
}

type DestinationRedshiftUpdateUploadingMethodS3StagingMethod string

const (
	DestinationRedshiftUpdateUploadingMethodS3StagingMethodS3Staging DestinationRedshiftUpdateUploadingMethodS3StagingMethod = "S3 Staging"
)

func (e DestinationRedshiftUpdateUploadingMethodS3StagingMethod) ToPointer() *DestinationRedshiftUpdateUploadingMethodS3StagingMethod {
	return &e
}

func (e *DestinationRedshiftUpdateUploadingMethodS3StagingMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "S3 Staging":
		*e = DestinationRedshiftUpdateUploadingMethodS3StagingMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationRedshiftUpdateUploadingMethodS3StagingMethod: %v", v)
	}
}

// DestinationRedshiftUpdateUploadingMethodS3StagingS3BucketRegion - The region of the S3 staging bucket to use if utilising a COPY strategy. See <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/creating-bucket.html#:~:text=In-,Region,-%2C%20choose%20the%20AWS">AWS docs</a> for details.
type DestinationRedshiftUpdateUploadingMethodS3StagingS3BucketRegion string

const (
	DestinationRedshiftUpdateUploadingMethodS3StagingS3BucketRegionUnknown      DestinationRedshiftUpdateUploadingMethodS3StagingS3BucketRegion = ""
	DestinationRedshiftUpdateUploadingMethodS3StagingS3BucketRegionUsEast1      DestinationRedshiftUpdateUploadingMethodS3StagingS3BucketRegion = "us-east-1"
	DestinationRedshiftUpdateUploadingMethodS3StagingS3BucketRegionUsEast2      DestinationRedshiftUpdateUploadingMethodS3StagingS3BucketRegion = "us-east-2"
	DestinationRedshiftUpdateUploadingMethodS3StagingS3BucketRegionUsWest1      DestinationRedshiftUpdateUploadingMethodS3StagingS3BucketRegion = "us-west-1"
	DestinationRedshiftUpdateUploadingMethodS3StagingS3BucketRegionUsWest2      DestinationRedshiftUpdateUploadingMethodS3StagingS3BucketRegion = "us-west-2"
	DestinationRedshiftUpdateUploadingMethodS3StagingS3BucketRegionAfSouth1     DestinationRedshiftUpdateUploadingMethodS3StagingS3BucketRegion = "af-south-1"
	DestinationRedshiftUpdateUploadingMethodS3StagingS3BucketRegionApEast1      DestinationRedshiftUpdateUploadingMethodS3StagingS3BucketRegion = "ap-east-1"
	DestinationRedshiftUpdateUploadingMethodS3StagingS3BucketRegionApSouth1     DestinationRedshiftUpdateUploadingMethodS3StagingS3BucketRegion = "ap-south-1"
	DestinationRedshiftUpdateUploadingMethodS3StagingS3BucketRegionApNortheast1 DestinationRedshiftUpdateUploadingMethodS3StagingS3BucketRegion = "ap-northeast-1"
	DestinationRedshiftUpdateUploadingMethodS3StagingS3BucketRegionApNortheast2 DestinationRedshiftUpdateUploadingMethodS3StagingS3BucketRegion = "ap-northeast-2"
	DestinationRedshiftUpdateUploadingMethodS3StagingS3BucketRegionApNortheast3 DestinationRedshiftUpdateUploadingMethodS3StagingS3BucketRegion = "ap-northeast-3"
	DestinationRedshiftUpdateUploadingMethodS3StagingS3BucketRegionApSoutheast1 DestinationRedshiftUpdateUploadingMethodS3StagingS3BucketRegion = "ap-southeast-1"
	DestinationRedshiftUpdateUploadingMethodS3StagingS3BucketRegionApSoutheast2 DestinationRedshiftUpdateUploadingMethodS3StagingS3BucketRegion = "ap-southeast-2"
	DestinationRedshiftUpdateUploadingMethodS3StagingS3BucketRegionCaCentral1   DestinationRedshiftUpdateUploadingMethodS3StagingS3BucketRegion = "ca-central-1"
	DestinationRedshiftUpdateUploadingMethodS3StagingS3BucketRegionCnNorth1     DestinationRedshiftUpdateUploadingMethodS3StagingS3BucketRegion = "cn-north-1"
	DestinationRedshiftUpdateUploadingMethodS3StagingS3BucketRegionCnNorthwest1 DestinationRedshiftUpdateUploadingMethodS3StagingS3BucketRegion = "cn-northwest-1"
	DestinationRedshiftUpdateUploadingMethodS3StagingS3BucketRegionEuCentral1   DestinationRedshiftUpdateUploadingMethodS3StagingS3BucketRegion = "eu-central-1"
	DestinationRedshiftUpdateUploadingMethodS3StagingS3BucketRegionEuNorth1     DestinationRedshiftUpdateUploadingMethodS3StagingS3BucketRegion = "eu-north-1"
	DestinationRedshiftUpdateUploadingMethodS3StagingS3BucketRegionEuSouth1     DestinationRedshiftUpdateUploadingMethodS3StagingS3BucketRegion = "eu-south-1"
	DestinationRedshiftUpdateUploadingMethodS3StagingS3BucketRegionEuWest1      DestinationRedshiftUpdateUploadingMethodS3StagingS3BucketRegion = "eu-west-1"
	DestinationRedshiftUpdateUploadingMethodS3StagingS3BucketRegionEuWest2      DestinationRedshiftUpdateUploadingMethodS3StagingS3BucketRegion = "eu-west-2"
	DestinationRedshiftUpdateUploadingMethodS3StagingS3BucketRegionEuWest3      DestinationRedshiftUpdateUploadingMethodS3StagingS3BucketRegion = "eu-west-3"
	DestinationRedshiftUpdateUploadingMethodS3StagingS3BucketRegionSaEast1      DestinationRedshiftUpdateUploadingMethodS3StagingS3BucketRegion = "sa-east-1"
	DestinationRedshiftUpdateUploadingMethodS3StagingS3BucketRegionMeSouth1     DestinationRedshiftUpdateUploadingMethodS3StagingS3BucketRegion = "me-south-1"
)

func (e DestinationRedshiftUpdateUploadingMethodS3StagingS3BucketRegion) ToPointer() *DestinationRedshiftUpdateUploadingMethodS3StagingS3BucketRegion {
	return &e
}

func (e *DestinationRedshiftUpdateUploadingMethodS3StagingS3BucketRegion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "":
		fallthrough
	case "us-east-1":
		fallthrough
	case "us-east-2":
		fallthrough
	case "us-west-1":
		fallthrough
	case "us-west-2":
		fallthrough
	case "af-south-1":
		fallthrough
	case "ap-east-1":
		fallthrough
	case "ap-south-1":
		fallthrough
	case "ap-northeast-1":
		fallthrough
	case "ap-northeast-2":
		fallthrough
	case "ap-northeast-3":
		fallthrough
	case "ap-southeast-1":
		fallthrough
	case "ap-southeast-2":
		fallthrough
	case "ca-central-1":
		fallthrough
	case "cn-north-1":
		fallthrough
	case "cn-northwest-1":
		fallthrough
	case "eu-central-1":
		fallthrough
	case "eu-north-1":
		fallthrough
	case "eu-south-1":
		fallthrough
	case "eu-west-1":
		fallthrough
	case "eu-west-2":
		fallthrough
	case "eu-west-3":
		fallthrough
	case "sa-east-1":
		fallthrough
	case "me-south-1":
		*e = DestinationRedshiftUpdateUploadingMethodS3StagingS3BucketRegion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationRedshiftUpdateUploadingMethodS3StagingS3BucketRegion: %v", v)
	}
}

// DestinationRedshiftUpdateUploadingMethodS3Staging - The method how the data will be uploaded to the database.
type DestinationRedshiftUpdateUploadingMethodS3Staging struct {
	// This ID grants access to the above S3 staging bucket. Airbyte requires Read and Write permissions to the given bucket. See <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">AWS docs</a> on how to generate an access key ID and secret access key.
	AccessKeyID string `json:"access_key_id"`
	// How to encrypt the staging data
	Encryption *DestinationRedshiftUpdateUploadingMethodS3StagingEncryption `json:"encryption,omitempty"`
	// Number of file buffers allocated for writing data. Increasing this number is beneficial for connections using Change Data Capture (CDC) and up to the number of streams within a connection. Increasing the number of file buffers past the maximum number of streams has deteriorating effects
	FileBufferCount *int64 `json:"file_buffer_count,omitempty"`
	// The pattern allows you to set the file-name format for the S3 staging file(s)
	FileNamePattern *string                                                 `json:"file_name_pattern,omitempty"`
	Method          DestinationRedshiftUpdateUploadingMethodS3StagingMethod `json:"method"`
	// Whether to delete the staging files from S3 after completing the sync. See <a href="https://docs.airbyte.com/integrations/destinations/redshift/#:~:text=the%20root%20directory.-,Purge%20Staging%20Data,-Whether%20to%20delete"> docs</a> for details.
	PurgeStagingData *bool `json:"purge_staging_data,omitempty"`
	// The name of the staging S3 bucket to use if utilising a COPY strategy. COPY is recommended for production workloads for better speed and scalability. See <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/creating-bucket.html">AWS docs</a> for more details.
	S3BucketName string `json:"s3_bucket_name"`
	// The directory under the S3 bucket where data will be written. If not provided, then defaults to the root directory. See <a href="https://docs.aws.amazon.com/prescriptive-guidance/latest/defining-bucket-names-data-lakes/faq.html#:~:text=be%20globally%20unique.-,For%20S3%20bucket%20paths,-%2C%20you%20can%20use">path's name recommendations</a> for more details.
	S3BucketPath *string `json:"s3_bucket_path,omitempty"`
	// The region of the S3 staging bucket to use if utilising a COPY strategy. See <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/creating-bucket.html#:~:text=In-,Region,-%2C%20choose%20the%20AWS">AWS docs</a> for details.
	S3BucketRegion DestinationRedshiftUpdateUploadingMethodS3StagingS3BucketRegion `json:"s3_bucket_region"`
	// The corresponding secret to the above access key id. See <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">AWS docs</a> on how to generate an access key ID and secret access key.
	SecretAccessKey string `json:"secret_access_key"`
}

type DestinationRedshiftUpdateUploadingMethodStandardMethod string

const (
	DestinationRedshiftUpdateUploadingMethodStandardMethodStandard DestinationRedshiftUpdateUploadingMethodStandardMethod = "Standard"
)

func (e DestinationRedshiftUpdateUploadingMethodStandardMethod) ToPointer() *DestinationRedshiftUpdateUploadingMethodStandardMethod {
	return &e
}

func (e *DestinationRedshiftUpdateUploadingMethodStandardMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Standard":
		*e = DestinationRedshiftUpdateUploadingMethodStandardMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationRedshiftUpdateUploadingMethodStandardMethod: %v", v)
	}
}

// DestinationRedshiftUpdateUploadingMethodStandard - The method how the data will be uploaded to the database.
type DestinationRedshiftUpdateUploadingMethodStandard struct {
	Method DestinationRedshiftUpdateUploadingMethodStandardMethod `json:"method"`
}

type DestinationRedshiftUpdateUploadingMethodType string

const (
	DestinationRedshiftUpdateUploadingMethodTypeDestinationRedshiftUpdateUploadingMethodStandard  DestinationRedshiftUpdateUploadingMethodType = "destination-redshift-update_Uploading Method_Standard"
	DestinationRedshiftUpdateUploadingMethodTypeDestinationRedshiftUpdateUploadingMethodS3Staging DestinationRedshiftUpdateUploadingMethodType = "destination-redshift-update_Uploading Method_S3 Staging"
)

type DestinationRedshiftUpdateUploadingMethod struct {
	DestinationRedshiftUpdateUploadingMethodStandard  *DestinationRedshiftUpdateUploadingMethodStandard
	DestinationRedshiftUpdateUploadingMethodS3Staging *DestinationRedshiftUpdateUploadingMethodS3Staging

	Type DestinationRedshiftUpdateUploadingMethodType
}

func CreateDestinationRedshiftUpdateUploadingMethodDestinationRedshiftUpdateUploadingMethodStandard(destinationRedshiftUpdateUploadingMethodStandard DestinationRedshiftUpdateUploadingMethodStandard) DestinationRedshiftUpdateUploadingMethod {
	typ := DestinationRedshiftUpdateUploadingMethodTypeDestinationRedshiftUpdateUploadingMethodStandard

	return DestinationRedshiftUpdateUploadingMethod{
		DestinationRedshiftUpdateUploadingMethodStandard: &destinationRedshiftUpdateUploadingMethodStandard,
		Type: typ,
	}
}

func CreateDestinationRedshiftUpdateUploadingMethodDestinationRedshiftUpdateUploadingMethodS3Staging(destinationRedshiftUpdateUploadingMethodS3Staging DestinationRedshiftUpdateUploadingMethodS3Staging) DestinationRedshiftUpdateUploadingMethod {
	typ := DestinationRedshiftUpdateUploadingMethodTypeDestinationRedshiftUpdateUploadingMethodS3Staging

	return DestinationRedshiftUpdateUploadingMethod{
		DestinationRedshiftUpdateUploadingMethodS3Staging: &destinationRedshiftUpdateUploadingMethodS3Staging,
		Type: typ,
	}
}

func (u *DestinationRedshiftUpdateUploadingMethod) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	destinationRedshiftUpdateUploadingMethodStandard := new(DestinationRedshiftUpdateUploadingMethodStandard)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationRedshiftUpdateUploadingMethodStandard); err == nil {
		u.DestinationRedshiftUpdateUploadingMethodStandard = destinationRedshiftUpdateUploadingMethodStandard
		u.Type = DestinationRedshiftUpdateUploadingMethodTypeDestinationRedshiftUpdateUploadingMethodStandard
		return nil
	}

	destinationRedshiftUpdateUploadingMethodS3Staging := new(DestinationRedshiftUpdateUploadingMethodS3Staging)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationRedshiftUpdateUploadingMethodS3Staging); err == nil {
		u.DestinationRedshiftUpdateUploadingMethodS3Staging = destinationRedshiftUpdateUploadingMethodS3Staging
		u.Type = DestinationRedshiftUpdateUploadingMethodTypeDestinationRedshiftUpdateUploadingMethodS3Staging
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u DestinationRedshiftUpdateUploadingMethod) MarshalJSON() ([]byte, error) {
	if u.DestinationRedshiftUpdateUploadingMethodStandard != nil {
		return json.Marshal(u.DestinationRedshiftUpdateUploadingMethodStandard)
	}

	if u.DestinationRedshiftUpdateUploadingMethodS3Staging != nil {
		return json.Marshal(u.DestinationRedshiftUpdateUploadingMethodS3Staging)
	}

	return nil, nil
}

type DestinationRedshiftUpdate struct {
	// Name of the database.
	Database string `json:"database"`
	// Host Endpoint of the Redshift Cluster (must include the cluster-id, region and end with .redshift.amazonaws.com)
	Host string `json:"host"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// Password associated with the username.
	Password string `json:"password"`
	// Port of the database.
	Port int64 `json:"port"`
	// The default schema tables are written to if the source does not specify a namespace. Unless specifically configured, the usual value for this field is "public".
	Schema string `json:"schema"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod *DestinationRedshiftUpdateSSHTunnelMethod `json:"tunnel_method,omitempty"`
	// The method how the data will be uploaded to the database.
	UploadingMethod *DestinationRedshiftUpdateUploadingMethod `json:"uploading_method,omitempty"`
	// Username to use to access the database.
	Username string `json:"username"`
}
