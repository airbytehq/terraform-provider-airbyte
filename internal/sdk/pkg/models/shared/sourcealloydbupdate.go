// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/pkg/utils"
)

type SourceAlloydbUpdateSchemasReplicationMethodMethod string

const (
	SourceAlloydbUpdateSchemasReplicationMethodMethodStandard SourceAlloydbUpdateSchemasReplicationMethodMethod = "Standard"
)

func (e SourceAlloydbUpdateSchemasReplicationMethodMethod) ToPointer() *SourceAlloydbUpdateSchemasReplicationMethodMethod {
	return &e
}

func (e *SourceAlloydbUpdateSchemasReplicationMethodMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Standard":
		*e = SourceAlloydbUpdateSchemasReplicationMethodMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceAlloydbUpdateSchemasReplicationMethodMethod: %v", v)
	}
}

// SourceAlloydbUpdateStandard - Standard replication requires no setup on the DB side but will not be able to represent deletions incrementally.
type SourceAlloydbUpdateStandard struct {
	method SourceAlloydbUpdateSchemasReplicationMethodMethod `const:"Standard" json:"method"`
}

func (s SourceAlloydbUpdateStandard) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceAlloydbUpdateStandard) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceAlloydbUpdateStandard) GetMethod() SourceAlloydbUpdateSchemasReplicationMethodMethod {
	return SourceAlloydbUpdateSchemasReplicationMethodMethodStandard
}

// LSNCommitBehaviour - Determines when Airbtye should flush the LSN of processed WAL logs in the source database. `After loading Data in the destination` is default. If `While reading Data` is selected, in case of a downstream failure (while loading data into the destination), next sync would result in a full sync.
type LSNCommitBehaviour string

const (
	LSNCommitBehaviourWhileReadingData                 LSNCommitBehaviour = "While reading Data"
	LSNCommitBehaviourAfterLoadingDataInTheDestination LSNCommitBehaviour = "After loading Data in the destination"
)

func (e LSNCommitBehaviour) ToPointer() *LSNCommitBehaviour {
	return &e
}

func (e *LSNCommitBehaviour) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "While reading Data":
		fallthrough
	case "After loading Data in the destination":
		*e = LSNCommitBehaviour(v)
		return nil
	default:
		return fmt.Errorf("invalid value for LSNCommitBehaviour: %v", v)
	}
}

type SourceAlloydbUpdateSchemasMethod string

const (
	SourceAlloydbUpdateSchemasMethodCdc SourceAlloydbUpdateSchemasMethod = "CDC"
)

func (e SourceAlloydbUpdateSchemasMethod) ToPointer() *SourceAlloydbUpdateSchemasMethod {
	return &e
}

func (e *SourceAlloydbUpdateSchemasMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CDC":
		*e = SourceAlloydbUpdateSchemasMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceAlloydbUpdateSchemasMethod: %v", v)
	}
}

// Plugin - A logical decoding plugin installed on the PostgreSQL server.
type Plugin string

const (
	PluginPgoutput Plugin = "pgoutput"
)

func (e Plugin) ToPointer() *Plugin {
	return &e
}

func (e *Plugin) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "pgoutput":
		*e = Plugin(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Plugin: %v", v)
	}
}

// LogicalReplicationCDC - Logical replication uses the Postgres write-ahead log (WAL) to detect inserts, updates, and deletes. This needs to be configured on the source database itself. Only available on Postgres 10 and above. Read the <a href="https://docs.airbyte.com/integrations/sources/postgres">docs</a>.
type LogicalReplicationCDC struct {
	AdditionalProperties interface{} `additionalProperties:"true" json:"-"`
	// The amount of time the connector will wait when it launches to determine if there is new data to sync or not. Defaults to 300 seconds. Valid range: 120 seconds to 1200 seconds. Read about <a href="https://docs.airbyte.com/integrations/sources/postgres#step-5-optional-set-up-initial-waiting-time">initial waiting time</a>.
	InitialWaitingSeconds *int64 `default:"300" json:"initial_waiting_seconds"`
	// Determines when Airbtye should flush the LSN of processed WAL logs in the source database. `After loading Data in the destination` is default. If `While reading Data` is selected, in case of a downstream failure (while loading data into the destination), next sync would result in a full sync.
	LsnCommitBehaviour *LSNCommitBehaviour              `default:"After loading Data in the destination" json:"lsn_commit_behaviour"`
	method             SourceAlloydbUpdateSchemasMethod `const:"CDC" json:"method"`
	// A logical decoding plugin installed on the PostgreSQL server.
	Plugin *Plugin `default:"pgoutput" json:"plugin"`
	// A Postgres publication used for consuming changes. Read about <a href="https://docs.airbyte.com/integrations/sources/postgres#step-4-create-publications-and-replication-identities-for-tables">publications and replication identities</a>.
	Publication string `json:"publication"`
	// The size of the internal queue. This may interfere with memory consumption and efficiency of the connector, please be careful.
	QueueSize *int64 `default:"10000" json:"queue_size"`
	// A plugin logical replication slot. Read about <a href="https://docs.airbyte.com/integrations/sources/postgres#step-3-create-replication-slot">replication slots</a>.
	ReplicationSlot string `json:"replication_slot"`
}

func (l LogicalReplicationCDC) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *LogicalReplicationCDC) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *LogicalReplicationCDC) GetAdditionalProperties() interface{} {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *LogicalReplicationCDC) GetInitialWaitingSeconds() *int64 {
	if o == nil {
		return nil
	}
	return o.InitialWaitingSeconds
}

func (o *LogicalReplicationCDC) GetLsnCommitBehaviour() *LSNCommitBehaviour {
	if o == nil {
		return nil
	}
	return o.LsnCommitBehaviour
}

func (o *LogicalReplicationCDC) GetMethod() SourceAlloydbUpdateSchemasMethod {
	return SourceAlloydbUpdateSchemasMethodCdc
}

func (o *LogicalReplicationCDC) GetPlugin() *Plugin {
	if o == nil {
		return nil
	}
	return o.Plugin
}

func (o *LogicalReplicationCDC) GetPublication() string {
	if o == nil {
		return ""
	}
	return o.Publication
}

func (o *LogicalReplicationCDC) GetQueueSize() *int64 {
	if o == nil {
		return nil
	}
	return o.QueueSize
}

func (o *LogicalReplicationCDC) GetReplicationSlot() string {
	if o == nil {
		return ""
	}
	return o.ReplicationSlot
}

type SourceAlloydbUpdateMethod string

const (
	SourceAlloydbUpdateMethodXmin SourceAlloydbUpdateMethod = "Xmin"
)

func (e SourceAlloydbUpdateMethod) ToPointer() *SourceAlloydbUpdateMethod {
	return &e
}

func (e *SourceAlloydbUpdateMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Xmin":
		*e = SourceAlloydbUpdateMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceAlloydbUpdateMethod: %v", v)
	}
}

// StandardXmin - Xmin replication requires no setup on the DB side but will not be able to represent deletions incrementally.
type StandardXmin struct {
	method SourceAlloydbUpdateMethod `const:"Xmin" json:"method"`
}

func (s StandardXmin) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *StandardXmin) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *StandardXmin) GetMethod() SourceAlloydbUpdateMethod {
	return SourceAlloydbUpdateMethodXmin
}

type ReplicationMethodType string

const (
	ReplicationMethodTypeStandardXmin                ReplicationMethodType = "Standard (Xmin)"
	ReplicationMethodTypeLogicalReplicationCDC       ReplicationMethodType = "Logical Replication (CDC)"
	ReplicationMethodTypeSourceAlloydbUpdateStandard ReplicationMethodType = "source-alloydb-update_Standard"
)

type ReplicationMethod struct {
	StandardXmin                *StandardXmin
	LogicalReplicationCDC       *LogicalReplicationCDC
	SourceAlloydbUpdateStandard *SourceAlloydbUpdateStandard

	Type ReplicationMethodType
}

func CreateReplicationMethodStandardXmin(standardXmin StandardXmin) ReplicationMethod {
	typ := ReplicationMethodTypeStandardXmin

	return ReplicationMethod{
		StandardXmin: &standardXmin,
		Type:         typ,
	}
}

func CreateReplicationMethodLogicalReplicationCDC(logicalReplicationCDC LogicalReplicationCDC) ReplicationMethod {
	typ := ReplicationMethodTypeLogicalReplicationCDC

	return ReplicationMethod{
		LogicalReplicationCDC: &logicalReplicationCDC,
		Type:                  typ,
	}
}

func CreateReplicationMethodSourceAlloydbUpdateStandard(sourceAlloydbUpdateStandard SourceAlloydbUpdateStandard) ReplicationMethod {
	typ := ReplicationMethodTypeSourceAlloydbUpdateStandard

	return ReplicationMethod{
		SourceAlloydbUpdateStandard: &sourceAlloydbUpdateStandard,
		Type:                        typ,
	}
}

func (u *ReplicationMethod) UnmarshalJSON(data []byte) error {

	standardXmin := new(StandardXmin)
	if err := utils.UnmarshalJSON(data, &standardXmin, "", true, true); err == nil {
		u.StandardXmin = standardXmin
		u.Type = ReplicationMethodTypeStandardXmin
		return nil
	}

	sourceAlloydbUpdateStandard := new(SourceAlloydbUpdateStandard)
	if err := utils.UnmarshalJSON(data, &sourceAlloydbUpdateStandard, "", true, true); err == nil {
		u.SourceAlloydbUpdateStandard = sourceAlloydbUpdateStandard
		u.Type = ReplicationMethodTypeSourceAlloydbUpdateStandard
		return nil
	}

	logicalReplicationCDC := new(LogicalReplicationCDC)
	if err := utils.UnmarshalJSON(data, &logicalReplicationCDC, "", true, true); err == nil {
		u.LogicalReplicationCDC = logicalReplicationCDC
		u.Type = ReplicationMethodTypeLogicalReplicationCDC
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u ReplicationMethod) MarshalJSON() ([]byte, error) {
	if u.StandardXmin != nil {
		return utils.MarshalJSON(u.StandardXmin, "", true)
	}

	if u.LogicalReplicationCDC != nil {
		return utils.MarshalJSON(u.LogicalReplicationCDC, "", true)
	}

	if u.SourceAlloydbUpdateStandard != nil {
		return utils.MarshalJSON(u.SourceAlloydbUpdateStandard, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type SourceAlloydbUpdateSchemasSSLModeSSLModes6Mode string

const (
	SourceAlloydbUpdateSchemasSSLModeSSLModes6ModeVerifyFull SourceAlloydbUpdateSchemasSSLModeSSLModes6Mode = "verify-full"
)

func (e SourceAlloydbUpdateSchemasSSLModeSSLModes6Mode) ToPointer() *SourceAlloydbUpdateSchemasSSLModeSSLModes6Mode {
	return &e
}

func (e *SourceAlloydbUpdateSchemasSSLModeSSLModes6Mode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "verify-full":
		*e = SourceAlloydbUpdateSchemasSSLModeSSLModes6Mode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceAlloydbUpdateSchemasSSLModeSSLModes6Mode: %v", v)
	}
}

// SourceAlloydbUpdateVerifyFull - This is the most secure mode. Always require encryption and verifies the identity of the source database server.
type SourceAlloydbUpdateVerifyFull struct {
	AdditionalProperties interface{} `additionalProperties:"true" json:"-"`
	// CA certificate
	CaCertificate string `json:"ca_certificate"`
	// Client certificate
	ClientCertificate *string `json:"client_certificate,omitempty"`
	// Client key
	ClientKey *string `json:"client_key,omitempty"`
	// Password for keystorage. If you do not add it - the password will be generated automatically.
	ClientKeyPassword *string                                        `json:"client_key_password,omitempty"`
	mode              SourceAlloydbUpdateSchemasSSLModeSSLModes6Mode `const:"verify-full" json:"mode"`
}

func (s SourceAlloydbUpdateVerifyFull) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceAlloydbUpdateVerifyFull) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceAlloydbUpdateVerifyFull) GetAdditionalProperties() interface{} {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *SourceAlloydbUpdateVerifyFull) GetCaCertificate() string {
	if o == nil {
		return ""
	}
	return o.CaCertificate
}

func (o *SourceAlloydbUpdateVerifyFull) GetClientCertificate() *string {
	if o == nil {
		return nil
	}
	return o.ClientCertificate
}

func (o *SourceAlloydbUpdateVerifyFull) GetClientKey() *string {
	if o == nil {
		return nil
	}
	return o.ClientKey
}

func (o *SourceAlloydbUpdateVerifyFull) GetClientKeyPassword() *string {
	if o == nil {
		return nil
	}
	return o.ClientKeyPassword
}

func (o *SourceAlloydbUpdateVerifyFull) GetMode() SourceAlloydbUpdateSchemasSSLModeSSLModes6Mode {
	return SourceAlloydbUpdateSchemasSSLModeSSLModes6ModeVerifyFull
}

type SourceAlloydbUpdateSchemasSSLModeSSLModes5Mode string

const (
	SourceAlloydbUpdateSchemasSSLModeSSLModes5ModeVerifyCa SourceAlloydbUpdateSchemasSSLModeSSLModes5Mode = "verify-ca"
)

func (e SourceAlloydbUpdateSchemasSSLModeSSLModes5Mode) ToPointer() *SourceAlloydbUpdateSchemasSSLModeSSLModes5Mode {
	return &e
}

func (e *SourceAlloydbUpdateSchemasSSLModeSSLModes5Mode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "verify-ca":
		*e = SourceAlloydbUpdateSchemasSSLModeSSLModes5Mode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceAlloydbUpdateSchemasSSLModeSSLModes5Mode: %v", v)
	}
}

// SourceAlloydbUpdateVerifyCa - Always require encryption and verifies that the source database server has a valid SSL certificate.
type SourceAlloydbUpdateVerifyCa struct {
	AdditionalProperties interface{} `additionalProperties:"true" json:"-"`
	// CA certificate
	CaCertificate string `json:"ca_certificate"`
	// Client certificate
	ClientCertificate *string `json:"client_certificate,omitempty"`
	// Client key
	ClientKey *string `json:"client_key,omitempty"`
	// Password for keystorage. If you do not add it - the password will be generated automatically.
	ClientKeyPassword *string                                        `json:"client_key_password,omitempty"`
	mode              SourceAlloydbUpdateSchemasSSLModeSSLModes5Mode `const:"verify-ca" json:"mode"`
}

func (s SourceAlloydbUpdateVerifyCa) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceAlloydbUpdateVerifyCa) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceAlloydbUpdateVerifyCa) GetAdditionalProperties() interface{} {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *SourceAlloydbUpdateVerifyCa) GetCaCertificate() string {
	if o == nil {
		return ""
	}
	return o.CaCertificate
}

func (o *SourceAlloydbUpdateVerifyCa) GetClientCertificate() *string {
	if o == nil {
		return nil
	}
	return o.ClientCertificate
}

func (o *SourceAlloydbUpdateVerifyCa) GetClientKey() *string {
	if o == nil {
		return nil
	}
	return o.ClientKey
}

func (o *SourceAlloydbUpdateVerifyCa) GetClientKeyPassword() *string {
	if o == nil {
		return nil
	}
	return o.ClientKeyPassword
}

func (o *SourceAlloydbUpdateVerifyCa) GetMode() SourceAlloydbUpdateSchemasSSLModeSSLModes5Mode {
	return SourceAlloydbUpdateSchemasSSLModeSSLModes5ModeVerifyCa
}

type SourceAlloydbUpdateSchemasSSLModeSSLModesMode string

const (
	SourceAlloydbUpdateSchemasSSLModeSSLModesModeRequire SourceAlloydbUpdateSchemasSSLModeSSLModesMode = "require"
)

func (e SourceAlloydbUpdateSchemasSSLModeSSLModesMode) ToPointer() *SourceAlloydbUpdateSchemasSSLModeSSLModesMode {
	return &e
}

func (e *SourceAlloydbUpdateSchemasSSLModeSSLModesMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "require":
		*e = SourceAlloydbUpdateSchemasSSLModeSSLModesMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceAlloydbUpdateSchemasSSLModeSSLModesMode: %v", v)
	}
}

// SourceAlloydbUpdateRequire - Always require encryption. If the source database server does not support encryption, connection will fail.
type SourceAlloydbUpdateRequire struct {
	AdditionalProperties interface{}                                   `additionalProperties:"true" json:"-"`
	mode                 SourceAlloydbUpdateSchemasSSLModeSSLModesMode `const:"require" json:"mode"`
}

func (s SourceAlloydbUpdateRequire) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceAlloydbUpdateRequire) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceAlloydbUpdateRequire) GetAdditionalProperties() interface{} {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *SourceAlloydbUpdateRequire) GetMode() SourceAlloydbUpdateSchemasSSLModeSSLModesMode {
	return SourceAlloydbUpdateSchemasSSLModeSSLModesModeRequire
}

type SourceAlloydbUpdateSchemasSslModeMode string

const (
	SourceAlloydbUpdateSchemasSslModeModePrefer SourceAlloydbUpdateSchemasSslModeMode = "prefer"
)

func (e SourceAlloydbUpdateSchemasSslModeMode) ToPointer() *SourceAlloydbUpdateSchemasSslModeMode {
	return &e
}

func (e *SourceAlloydbUpdateSchemasSslModeMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "prefer":
		*e = SourceAlloydbUpdateSchemasSslModeMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceAlloydbUpdateSchemasSslModeMode: %v", v)
	}
}

// SourceAlloydbUpdatePrefer - Allows unencrypted connection only if the source database does not support encryption.
type SourceAlloydbUpdatePrefer struct {
	AdditionalProperties interface{}                           `additionalProperties:"true" json:"-"`
	mode                 SourceAlloydbUpdateSchemasSslModeMode `const:"prefer" json:"mode"`
}

func (s SourceAlloydbUpdatePrefer) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceAlloydbUpdatePrefer) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceAlloydbUpdatePrefer) GetAdditionalProperties() interface{} {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *SourceAlloydbUpdatePrefer) GetMode() SourceAlloydbUpdateSchemasSslModeMode {
	return SourceAlloydbUpdateSchemasSslModeModePrefer
}

type SourceAlloydbUpdateSchemasMode string

const (
	SourceAlloydbUpdateSchemasModeAllow SourceAlloydbUpdateSchemasMode = "allow"
)

func (e SourceAlloydbUpdateSchemasMode) ToPointer() *SourceAlloydbUpdateSchemasMode {
	return &e
}

func (e *SourceAlloydbUpdateSchemasMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "allow":
		*e = SourceAlloydbUpdateSchemasMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceAlloydbUpdateSchemasMode: %v", v)
	}
}

// SourceAlloydbUpdateAllow - Enables encryption only when required by the source database.
type SourceAlloydbUpdateAllow struct {
	AdditionalProperties interface{}                    `additionalProperties:"true" json:"-"`
	mode                 SourceAlloydbUpdateSchemasMode `const:"allow" json:"mode"`
}

func (s SourceAlloydbUpdateAllow) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceAlloydbUpdateAllow) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceAlloydbUpdateAllow) GetAdditionalProperties() interface{} {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *SourceAlloydbUpdateAllow) GetMode() SourceAlloydbUpdateSchemasMode {
	return SourceAlloydbUpdateSchemasModeAllow
}

type SourceAlloydbUpdateMode string

const (
	SourceAlloydbUpdateModeDisable SourceAlloydbUpdateMode = "disable"
)

func (e SourceAlloydbUpdateMode) ToPointer() *SourceAlloydbUpdateMode {
	return &e
}

func (e *SourceAlloydbUpdateMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "disable":
		*e = SourceAlloydbUpdateMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceAlloydbUpdateMode: %v", v)
	}
}

// SourceAlloydbUpdateDisable - Disables encryption of communication between Airbyte and source database.
type SourceAlloydbUpdateDisable struct {
	AdditionalProperties interface{}             `additionalProperties:"true" json:"-"`
	mode                 SourceAlloydbUpdateMode `const:"disable" json:"mode"`
}

func (s SourceAlloydbUpdateDisable) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceAlloydbUpdateDisable) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceAlloydbUpdateDisable) GetAdditionalProperties() interface{} {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *SourceAlloydbUpdateDisable) GetMode() SourceAlloydbUpdateMode {
	return SourceAlloydbUpdateModeDisable
}

type SourceAlloydbUpdateSSLModesType string

const (
	SourceAlloydbUpdateSSLModesTypeSourceAlloydbUpdateDisable    SourceAlloydbUpdateSSLModesType = "source-alloydb-update_disable"
	SourceAlloydbUpdateSSLModesTypeSourceAlloydbUpdateAllow      SourceAlloydbUpdateSSLModesType = "source-alloydb-update_allow"
	SourceAlloydbUpdateSSLModesTypeSourceAlloydbUpdatePrefer     SourceAlloydbUpdateSSLModesType = "source-alloydb-update_prefer"
	SourceAlloydbUpdateSSLModesTypeSourceAlloydbUpdateRequire    SourceAlloydbUpdateSSLModesType = "source-alloydb-update_require"
	SourceAlloydbUpdateSSLModesTypeSourceAlloydbUpdateVerifyCa   SourceAlloydbUpdateSSLModesType = "source-alloydb-update_verify-ca"
	SourceAlloydbUpdateSSLModesTypeSourceAlloydbUpdateVerifyFull SourceAlloydbUpdateSSLModesType = "source-alloydb-update_verify-full"
)

type SourceAlloydbUpdateSSLModes struct {
	SourceAlloydbUpdateDisable    *SourceAlloydbUpdateDisable
	SourceAlloydbUpdateAllow      *SourceAlloydbUpdateAllow
	SourceAlloydbUpdatePrefer     *SourceAlloydbUpdatePrefer
	SourceAlloydbUpdateRequire    *SourceAlloydbUpdateRequire
	SourceAlloydbUpdateVerifyCa   *SourceAlloydbUpdateVerifyCa
	SourceAlloydbUpdateVerifyFull *SourceAlloydbUpdateVerifyFull

	Type SourceAlloydbUpdateSSLModesType
}

func CreateSourceAlloydbUpdateSSLModesSourceAlloydbUpdateDisable(sourceAlloydbUpdateDisable SourceAlloydbUpdateDisable) SourceAlloydbUpdateSSLModes {
	typ := SourceAlloydbUpdateSSLModesTypeSourceAlloydbUpdateDisable

	return SourceAlloydbUpdateSSLModes{
		SourceAlloydbUpdateDisable: &sourceAlloydbUpdateDisable,
		Type:                       typ,
	}
}

func CreateSourceAlloydbUpdateSSLModesSourceAlloydbUpdateAllow(sourceAlloydbUpdateAllow SourceAlloydbUpdateAllow) SourceAlloydbUpdateSSLModes {
	typ := SourceAlloydbUpdateSSLModesTypeSourceAlloydbUpdateAllow

	return SourceAlloydbUpdateSSLModes{
		SourceAlloydbUpdateAllow: &sourceAlloydbUpdateAllow,
		Type:                     typ,
	}
}

func CreateSourceAlloydbUpdateSSLModesSourceAlloydbUpdatePrefer(sourceAlloydbUpdatePrefer SourceAlloydbUpdatePrefer) SourceAlloydbUpdateSSLModes {
	typ := SourceAlloydbUpdateSSLModesTypeSourceAlloydbUpdatePrefer

	return SourceAlloydbUpdateSSLModes{
		SourceAlloydbUpdatePrefer: &sourceAlloydbUpdatePrefer,
		Type:                      typ,
	}
}

func CreateSourceAlloydbUpdateSSLModesSourceAlloydbUpdateRequire(sourceAlloydbUpdateRequire SourceAlloydbUpdateRequire) SourceAlloydbUpdateSSLModes {
	typ := SourceAlloydbUpdateSSLModesTypeSourceAlloydbUpdateRequire

	return SourceAlloydbUpdateSSLModes{
		SourceAlloydbUpdateRequire: &sourceAlloydbUpdateRequire,
		Type:                       typ,
	}
}

func CreateSourceAlloydbUpdateSSLModesSourceAlloydbUpdateVerifyCa(sourceAlloydbUpdateVerifyCa SourceAlloydbUpdateVerifyCa) SourceAlloydbUpdateSSLModes {
	typ := SourceAlloydbUpdateSSLModesTypeSourceAlloydbUpdateVerifyCa

	return SourceAlloydbUpdateSSLModes{
		SourceAlloydbUpdateVerifyCa: &sourceAlloydbUpdateVerifyCa,
		Type:                        typ,
	}
}

func CreateSourceAlloydbUpdateSSLModesSourceAlloydbUpdateVerifyFull(sourceAlloydbUpdateVerifyFull SourceAlloydbUpdateVerifyFull) SourceAlloydbUpdateSSLModes {
	typ := SourceAlloydbUpdateSSLModesTypeSourceAlloydbUpdateVerifyFull

	return SourceAlloydbUpdateSSLModes{
		SourceAlloydbUpdateVerifyFull: &sourceAlloydbUpdateVerifyFull,
		Type:                          typ,
	}
}

func (u *SourceAlloydbUpdateSSLModes) UnmarshalJSON(data []byte) error {

	sourceAlloydbUpdateDisable := new(SourceAlloydbUpdateDisable)
	if err := utils.UnmarshalJSON(data, &sourceAlloydbUpdateDisable, "", true, true); err == nil {
		u.SourceAlloydbUpdateDisable = sourceAlloydbUpdateDisable
		u.Type = SourceAlloydbUpdateSSLModesTypeSourceAlloydbUpdateDisable
		return nil
	}

	sourceAlloydbUpdateAllow := new(SourceAlloydbUpdateAllow)
	if err := utils.UnmarshalJSON(data, &sourceAlloydbUpdateAllow, "", true, true); err == nil {
		u.SourceAlloydbUpdateAllow = sourceAlloydbUpdateAllow
		u.Type = SourceAlloydbUpdateSSLModesTypeSourceAlloydbUpdateAllow
		return nil
	}

	sourceAlloydbUpdatePrefer := new(SourceAlloydbUpdatePrefer)
	if err := utils.UnmarshalJSON(data, &sourceAlloydbUpdatePrefer, "", true, true); err == nil {
		u.SourceAlloydbUpdatePrefer = sourceAlloydbUpdatePrefer
		u.Type = SourceAlloydbUpdateSSLModesTypeSourceAlloydbUpdatePrefer
		return nil
	}

	sourceAlloydbUpdateRequire := new(SourceAlloydbUpdateRequire)
	if err := utils.UnmarshalJSON(data, &sourceAlloydbUpdateRequire, "", true, true); err == nil {
		u.SourceAlloydbUpdateRequire = sourceAlloydbUpdateRequire
		u.Type = SourceAlloydbUpdateSSLModesTypeSourceAlloydbUpdateRequire
		return nil
	}

	sourceAlloydbUpdateVerifyCa := new(SourceAlloydbUpdateVerifyCa)
	if err := utils.UnmarshalJSON(data, &sourceAlloydbUpdateVerifyCa, "", true, true); err == nil {
		u.SourceAlloydbUpdateVerifyCa = sourceAlloydbUpdateVerifyCa
		u.Type = SourceAlloydbUpdateSSLModesTypeSourceAlloydbUpdateVerifyCa
		return nil
	}

	sourceAlloydbUpdateVerifyFull := new(SourceAlloydbUpdateVerifyFull)
	if err := utils.UnmarshalJSON(data, &sourceAlloydbUpdateVerifyFull, "", true, true); err == nil {
		u.SourceAlloydbUpdateVerifyFull = sourceAlloydbUpdateVerifyFull
		u.Type = SourceAlloydbUpdateSSLModesTypeSourceAlloydbUpdateVerifyFull
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SourceAlloydbUpdateSSLModes) MarshalJSON() ([]byte, error) {
	if u.SourceAlloydbUpdateDisable != nil {
		return utils.MarshalJSON(u.SourceAlloydbUpdateDisable, "", true)
	}

	if u.SourceAlloydbUpdateAllow != nil {
		return utils.MarshalJSON(u.SourceAlloydbUpdateAllow, "", true)
	}

	if u.SourceAlloydbUpdatePrefer != nil {
		return utils.MarshalJSON(u.SourceAlloydbUpdatePrefer, "", true)
	}

	if u.SourceAlloydbUpdateRequire != nil {
		return utils.MarshalJSON(u.SourceAlloydbUpdateRequire, "", true)
	}

	if u.SourceAlloydbUpdateVerifyCa != nil {
		return utils.MarshalJSON(u.SourceAlloydbUpdateVerifyCa, "", true)
	}

	if u.SourceAlloydbUpdateVerifyFull != nil {
		return utils.MarshalJSON(u.SourceAlloydbUpdateVerifyFull, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

// SourceAlloydbUpdateSchemasTunnelMethodTunnelMethod - Connect through a jump server tunnel host using username and password authentication
type SourceAlloydbUpdateSchemasTunnelMethodTunnelMethod string

const (
	SourceAlloydbUpdateSchemasTunnelMethodTunnelMethodSSHPasswordAuth SourceAlloydbUpdateSchemasTunnelMethodTunnelMethod = "SSH_PASSWORD_AUTH"
)

func (e SourceAlloydbUpdateSchemasTunnelMethodTunnelMethod) ToPointer() *SourceAlloydbUpdateSchemasTunnelMethodTunnelMethod {
	return &e
}

func (e *SourceAlloydbUpdateSchemasTunnelMethodTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_PASSWORD_AUTH":
		*e = SourceAlloydbUpdateSchemasTunnelMethodTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceAlloydbUpdateSchemasTunnelMethodTunnelMethod: %v", v)
	}
}

// SourceAlloydbUpdatePasswordAuthentication - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceAlloydbUpdatePasswordAuthentication struct {
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and password authentication
	tunnelMethod SourceAlloydbUpdateSchemasTunnelMethodTunnelMethod `const:"SSH_PASSWORD_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser string `json:"tunnel_user"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword string `json:"tunnel_user_password"`
}

func (s SourceAlloydbUpdatePasswordAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceAlloydbUpdatePasswordAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceAlloydbUpdatePasswordAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *SourceAlloydbUpdatePasswordAuthentication) GetTunnelMethod() SourceAlloydbUpdateSchemasTunnelMethodTunnelMethod {
	return SourceAlloydbUpdateSchemasTunnelMethodTunnelMethodSSHPasswordAuth
}

func (o *SourceAlloydbUpdatePasswordAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *SourceAlloydbUpdatePasswordAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

func (o *SourceAlloydbUpdatePasswordAuthentication) GetTunnelUserPassword() string {
	if o == nil {
		return ""
	}
	return o.TunnelUserPassword
}

// SourceAlloydbUpdateSchemasTunnelMethod - Connect through a jump server tunnel host using username and ssh key
type SourceAlloydbUpdateSchemasTunnelMethod string

const (
	SourceAlloydbUpdateSchemasTunnelMethodSSHKeyAuth SourceAlloydbUpdateSchemasTunnelMethod = "SSH_KEY_AUTH"
)

func (e SourceAlloydbUpdateSchemasTunnelMethod) ToPointer() *SourceAlloydbUpdateSchemasTunnelMethod {
	return &e
}

func (e *SourceAlloydbUpdateSchemasTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_KEY_AUTH":
		*e = SourceAlloydbUpdateSchemasTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceAlloydbUpdateSchemasTunnelMethod: %v", v)
	}
}

// SourceAlloydbUpdateSSHKeyAuthentication - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceAlloydbUpdateSSHKeyAuthentication struct {
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey string `json:"ssh_key"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and ssh key
	tunnelMethod SourceAlloydbUpdateSchemasTunnelMethod `const:"SSH_KEY_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host.
	TunnelUser string `json:"tunnel_user"`
}

func (s SourceAlloydbUpdateSSHKeyAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceAlloydbUpdateSSHKeyAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceAlloydbUpdateSSHKeyAuthentication) GetSSHKey() string {
	if o == nil {
		return ""
	}
	return o.SSHKey
}

func (o *SourceAlloydbUpdateSSHKeyAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *SourceAlloydbUpdateSSHKeyAuthentication) GetTunnelMethod() SourceAlloydbUpdateSchemasTunnelMethod {
	return SourceAlloydbUpdateSchemasTunnelMethodSSHKeyAuth
}

func (o *SourceAlloydbUpdateSSHKeyAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *SourceAlloydbUpdateSSHKeyAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

// SourceAlloydbUpdateTunnelMethod - No ssh tunnel needed to connect to database
type SourceAlloydbUpdateTunnelMethod string

const (
	SourceAlloydbUpdateTunnelMethodNoTunnel SourceAlloydbUpdateTunnelMethod = "NO_TUNNEL"
)

func (e SourceAlloydbUpdateTunnelMethod) ToPointer() *SourceAlloydbUpdateTunnelMethod {
	return &e
}

func (e *SourceAlloydbUpdateTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NO_TUNNEL":
		*e = SourceAlloydbUpdateTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceAlloydbUpdateTunnelMethod: %v", v)
	}
}

// SourceAlloydbUpdateNoTunnel - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceAlloydbUpdateNoTunnel struct {
	// No ssh tunnel needed to connect to database
	tunnelMethod SourceAlloydbUpdateTunnelMethod `const:"NO_TUNNEL" json:"tunnel_method"`
}

func (s SourceAlloydbUpdateNoTunnel) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceAlloydbUpdateNoTunnel) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceAlloydbUpdateNoTunnel) GetTunnelMethod() SourceAlloydbUpdateTunnelMethod {
	return SourceAlloydbUpdateTunnelMethodNoTunnel
}

type SourceAlloydbUpdateSSHTunnelMethodType string

const (
	SourceAlloydbUpdateSSHTunnelMethodTypeSourceAlloydbUpdateNoTunnel               SourceAlloydbUpdateSSHTunnelMethodType = "source-alloydb-update_No Tunnel"
	SourceAlloydbUpdateSSHTunnelMethodTypeSourceAlloydbUpdateSSHKeyAuthentication   SourceAlloydbUpdateSSHTunnelMethodType = "source-alloydb-update_SSH Key Authentication"
	SourceAlloydbUpdateSSHTunnelMethodTypeSourceAlloydbUpdatePasswordAuthentication SourceAlloydbUpdateSSHTunnelMethodType = "source-alloydb-update_Password Authentication"
)

type SourceAlloydbUpdateSSHTunnelMethod struct {
	SourceAlloydbUpdateNoTunnel               *SourceAlloydbUpdateNoTunnel
	SourceAlloydbUpdateSSHKeyAuthentication   *SourceAlloydbUpdateSSHKeyAuthentication
	SourceAlloydbUpdatePasswordAuthentication *SourceAlloydbUpdatePasswordAuthentication

	Type SourceAlloydbUpdateSSHTunnelMethodType
}

func CreateSourceAlloydbUpdateSSHTunnelMethodSourceAlloydbUpdateNoTunnel(sourceAlloydbUpdateNoTunnel SourceAlloydbUpdateNoTunnel) SourceAlloydbUpdateSSHTunnelMethod {
	typ := SourceAlloydbUpdateSSHTunnelMethodTypeSourceAlloydbUpdateNoTunnel

	return SourceAlloydbUpdateSSHTunnelMethod{
		SourceAlloydbUpdateNoTunnel: &sourceAlloydbUpdateNoTunnel,
		Type:                        typ,
	}
}

func CreateSourceAlloydbUpdateSSHTunnelMethodSourceAlloydbUpdateSSHKeyAuthentication(sourceAlloydbUpdateSSHKeyAuthentication SourceAlloydbUpdateSSHKeyAuthentication) SourceAlloydbUpdateSSHTunnelMethod {
	typ := SourceAlloydbUpdateSSHTunnelMethodTypeSourceAlloydbUpdateSSHKeyAuthentication

	return SourceAlloydbUpdateSSHTunnelMethod{
		SourceAlloydbUpdateSSHKeyAuthentication: &sourceAlloydbUpdateSSHKeyAuthentication,
		Type:                                    typ,
	}
}

func CreateSourceAlloydbUpdateSSHTunnelMethodSourceAlloydbUpdatePasswordAuthentication(sourceAlloydbUpdatePasswordAuthentication SourceAlloydbUpdatePasswordAuthentication) SourceAlloydbUpdateSSHTunnelMethod {
	typ := SourceAlloydbUpdateSSHTunnelMethodTypeSourceAlloydbUpdatePasswordAuthentication

	return SourceAlloydbUpdateSSHTunnelMethod{
		SourceAlloydbUpdatePasswordAuthentication: &sourceAlloydbUpdatePasswordAuthentication,
		Type: typ,
	}
}

func (u *SourceAlloydbUpdateSSHTunnelMethod) UnmarshalJSON(data []byte) error {

	sourceAlloydbUpdateNoTunnel := new(SourceAlloydbUpdateNoTunnel)
	if err := utils.UnmarshalJSON(data, &sourceAlloydbUpdateNoTunnel, "", true, true); err == nil {
		u.SourceAlloydbUpdateNoTunnel = sourceAlloydbUpdateNoTunnel
		u.Type = SourceAlloydbUpdateSSHTunnelMethodTypeSourceAlloydbUpdateNoTunnel
		return nil
	}

	sourceAlloydbUpdateSSHKeyAuthentication := new(SourceAlloydbUpdateSSHKeyAuthentication)
	if err := utils.UnmarshalJSON(data, &sourceAlloydbUpdateSSHKeyAuthentication, "", true, true); err == nil {
		u.SourceAlloydbUpdateSSHKeyAuthentication = sourceAlloydbUpdateSSHKeyAuthentication
		u.Type = SourceAlloydbUpdateSSHTunnelMethodTypeSourceAlloydbUpdateSSHKeyAuthentication
		return nil
	}

	sourceAlloydbUpdatePasswordAuthentication := new(SourceAlloydbUpdatePasswordAuthentication)
	if err := utils.UnmarshalJSON(data, &sourceAlloydbUpdatePasswordAuthentication, "", true, true); err == nil {
		u.SourceAlloydbUpdatePasswordAuthentication = sourceAlloydbUpdatePasswordAuthentication
		u.Type = SourceAlloydbUpdateSSHTunnelMethodTypeSourceAlloydbUpdatePasswordAuthentication
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SourceAlloydbUpdateSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.SourceAlloydbUpdateNoTunnel != nil {
		return utils.MarshalJSON(u.SourceAlloydbUpdateNoTunnel, "", true)
	}

	if u.SourceAlloydbUpdateSSHKeyAuthentication != nil {
		return utils.MarshalJSON(u.SourceAlloydbUpdateSSHKeyAuthentication, "", true)
	}

	if u.SourceAlloydbUpdatePasswordAuthentication != nil {
		return utils.MarshalJSON(u.SourceAlloydbUpdatePasswordAuthentication, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type SourceAlloydbUpdate struct {
	// Name of the database.
	Database string `json:"database"`
	// Hostname of the database.
	Host string `json:"host"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (Eg. key1=value1&key2=value2&key3=value3). For more information read about <a href="https://jdbc.postgresql.org/documentation/head/connect.html">JDBC URL parameters</a>.
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// Password associated with the username.
	Password *string `json:"password,omitempty"`
	// Port of the database.
	Port *int64 `default:"5432" json:"port"`
	// Replication method for extracting data from the database.
	ReplicationMethod *ReplicationMethod `json:"replication_method,omitempty"`
	// The list of schemas (case sensitive) to sync from. Defaults to public.
	Schemas []string `json:"schemas,omitempty"`
	// SSL connection modes.
	//   Read more <a href="https://jdbc.postgresql.org/documentation/head/ssl-client.html"> in the docs</a>.
	SslMode *SourceAlloydbUpdateSSLModes `json:"ssl_mode,omitempty"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod *SourceAlloydbUpdateSSHTunnelMethod `json:"tunnel_method,omitempty"`
	// Username to access the database.
	Username string `json:"username"`
}

func (s SourceAlloydbUpdate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceAlloydbUpdate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *SourceAlloydbUpdate) GetDatabase() string {
	if o == nil {
		return ""
	}
	return o.Database
}

func (o *SourceAlloydbUpdate) GetHost() string {
	if o == nil {
		return ""
	}
	return o.Host
}

func (o *SourceAlloydbUpdate) GetJdbcURLParams() *string {
	if o == nil {
		return nil
	}
	return o.JdbcURLParams
}

func (o *SourceAlloydbUpdate) GetPassword() *string {
	if o == nil {
		return nil
	}
	return o.Password
}

func (o *SourceAlloydbUpdate) GetPort() *int64 {
	if o == nil {
		return nil
	}
	return o.Port
}

func (o *SourceAlloydbUpdate) GetReplicationMethod() *ReplicationMethod {
	if o == nil {
		return nil
	}
	return o.ReplicationMethod
}

func (o *SourceAlloydbUpdate) GetSchemas() []string {
	if o == nil {
		return nil
	}
	return o.Schemas
}

func (o *SourceAlloydbUpdate) GetSslMode() *SourceAlloydbUpdateSSLModes {
	if o == nil {
		return nil
	}
	return o.SslMode
}

func (o *SourceAlloydbUpdate) GetTunnelMethod() *SourceAlloydbUpdateSSHTunnelMethod {
	if o == nil {
		return nil
	}
	return o.TunnelMethod
}

func (o *SourceAlloydbUpdate) GetUsername() string {
	if o == nil {
		return ""
	}
	return o.Username
}
