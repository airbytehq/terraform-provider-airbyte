// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"airbyte/internal/sdk/pkg/utils"
	"encoding/json"
	"errors"
	"fmt"
)

type SourceAlloydbUpdateReplicationMethodStandardMethod string

const (
	SourceAlloydbUpdateReplicationMethodStandardMethodStandard SourceAlloydbUpdateReplicationMethodStandardMethod = "Standard"
)

func (e SourceAlloydbUpdateReplicationMethodStandardMethod) ToPointer() *SourceAlloydbUpdateReplicationMethodStandardMethod {
	return &e
}

func (e *SourceAlloydbUpdateReplicationMethodStandardMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Standard":
		*e = SourceAlloydbUpdateReplicationMethodStandardMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceAlloydbUpdateReplicationMethodStandardMethod: %v", v)
	}
}

// SourceAlloydbUpdateReplicationMethodStandard - Standard replication requires no setup on the DB side but will not be able to represent deletions incrementally.
type SourceAlloydbUpdateReplicationMethodStandard struct {
	method SourceAlloydbUpdateReplicationMethodStandardMethod `const:"Standard" json:"method"`
}

func (s SourceAlloydbUpdateReplicationMethodStandard) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceAlloydbUpdateReplicationMethodStandard) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceAlloydbUpdateReplicationMethodStandard) GetMethod() SourceAlloydbUpdateReplicationMethodStandardMethod {
	return SourceAlloydbUpdateReplicationMethodStandardMethodStandard
}

// SourceAlloydbUpdateReplicationMethodLogicalReplicationCDCLSNCommitBehaviour - Determines when Airbtye should flush the LSN of processed WAL logs in the source database. `After loading Data in the destination` is default. If `While reading Data` is selected, in case of a downstream failure (while loading data into the destination), next sync would result in a full sync.
type SourceAlloydbUpdateReplicationMethodLogicalReplicationCDCLSNCommitBehaviour string

const (
	SourceAlloydbUpdateReplicationMethodLogicalReplicationCDCLSNCommitBehaviourWhileReadingData                 SourceAlloydbUpdateReplicationMethodLogicalReplicationCDCLSNCommitBehaviour = "While reading Data"
	SourceAlloydbUpdateReplicationMethodLogicalReplicationCDCLSNCommitBehaviourAfterLoadingDataInTheDestination SourceAlloydbUpdateReplicationMethodLogicalReplicationCDCLSNCommitBehaviour = "After loading Data in the destination"
)

func (e SourceAlloydbUpdateReplicationMethodLogicalReplicationCDCLSNCommitBehaviour) ToPointer() *SourceAlloydbUpdateReplicationMethodLogicalReplicationCDCLSNCommitBehaviour {
	return &e
}

func (e *SourceAlloydbUpdateReplicationMethodLogicalReplicationCDCLSNCommitBehaviour) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "While reading Data":
		fallthrough
	case "After loading Data in the destination":
		*e = SourceAlloydbUpdateReplicationMethodLogicalReplicationCDCLSNCommitBehaviour(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceAlloydbUpdateReplicationMethodLogicalReplicationCDCLSNCommitBehaviour: %v", v)
	}
}

type SourceAlloydbUpdateReplicationMethodLogicalReplicationCDCMethod string

const (
	SourceAlloydbUpdateReplicationMethodLogicalReplicationCDCMethodCdc SourceAlloydbUpdateReplicationMethodLogicalReplicationCDCMethod = "CDC"
)

func (e SourceAlloydbUpdateReplicationMethodLogicalReplicationCDCMethod) ToPointer() *SourceAlloydbUpdateReplicationMethodLogicalReplicationCDCMethod {
	return &e
}

func (e *SourceAlloydbUpdateReplicationMethodLogicalReplicationCDCMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CDC":
		*e = SourceAlloydbUpdateReplicationMethodLogicalReplicationCDCMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceAlloydbUpdateReplicationMethodLogicalReplicationCDCMethod: %v", v)
	}
}

// SourceAlloydbUpdateReplicationMethodLogicalReplicationCDCPlugin - A logical decoding plugin installed on the PostgreSQL server.
type SourceAlloydbUpdateReplicationMethodLogicalReplicationCDCPlugin string

const (
	SourceAlloydbUpdateReplicationMethodLogicalReplicationCDCPluginPgoutput SourceAlloydbUpdateReplicationMethodLogicalReplicationCDCPlugin = "pgoutput"
)

func (e SourceAlloydbUpdateReplicationMethodLogicalReplicationCDCPlugin) ToPointer() *SourceAlloydbUpdateReplicationMethodLogicalReplicationCDCPlugin {
	return &e
}

func (e *SourceAlloydbUpdateReplicationMethodLogicalReplicationCDCPlugin) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "pgoutput":
		*e = SourceAlloydbUpdateReplicationMethodLogicalReplicationCDCPlugin(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceAlloydbUpdateReplicationMethodLogicalReplicationCDCPlugin: %v", v)
	}
}

// SourceAlloydbUpdateReplicationMethodLogicalReplicationCDC - Logical replication uses the Postgres write-ahead log (WAL) to detect inserts, updates, and deletes. This needs to be configured on the source database itself. Only available on Postgres 10 and above. Read the <a href="https://docs.airbyte.com/integrations/sources/postgres">docs</a>.
type SourceAlloydbUpdateReplicationMethodLogicalReplicationCDC struct {
	AdditionalProperties interface{} `additionalProperties:"true" json:"-"`
	// The amount of time the connector will wait when it launches to determine if there is new data to sync or not. Defaults to 300 seconds. Valid range: 120 seconds to 1200 seconds. Read about <a href="https://docs.airbyte.com/integrations/sources/postgres#step-5-optional-set-up-initial-waiting-time">initial waiting time</a>.
	InitialWaitingSeconds *int64 `default:"300" json:"initial_waiting_seconds"`
	// Determines when Airbtye should flush the LSN of processed WAL logs in the source database. `After loading Data in the destination` is default. If `While reading Data` is selected, in case of a downstream failure (while loading data into the destination), next sync would result in a full sync.
	LsnCommitBehaviour *SourceAlloydbUpdateReplicationMethodLogicalReplicationCDCLSNCommitBehaviour `default:"After loading Data in the destination" json:"lsn_commit_behaviour"`
	method             SourceAlloydbUpdateReplicationMethodLogicalReplicationCDCMethod              `const:"CDC" json:"method"`
	// A logical decoding plugin installed on the PostgreSQL server.
	Plugin *SourceAlloydbUpdateReplicationMethodLogicalReplicationCDCPlugin `default:"pgoutput" json:"plugin"`
	// A Postgres publication used for consuming changes. Read about <a href="https://docs.airbyte.com/integrations/sources/postgres#step-4-create-publications-and-replication-identities-for-tables">publications and replication identities</a>.
	Publication string `json:"publication"`
	// The size of the internal queue. This may interfere with memory consumption and efficiency of the connector, please be careful.
	QueueSize *int64 `default:"10000" json:"queue_size"`
	// A plugin logical replication slot. Read about <a href="https://docs.airbyte.com/integrations/sources/postgres#step-3-create-replication-slot">replication slots</a>.
	ReplicationSlot string `json:"replication_slot"`
}

func (s SourceAlloydbUpdateReplicationMethodLogicalReplicationCDC) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceAlloydbUpdateReplicationMethodLogicalReplicationCDC) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceAlloydbUpdateReplicationMethodLogicalReplicationCDC) GetAdditionalProperties() interface{} {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *SourceAlloydbUpdateReplicationMethodLogicalReplicationCDC) GetInitialWaitingSeconds() *int64 {
	if o == nil {
		return nil
	}
	return o.InitialWaitingSeconds
}

func (o *SourceAlloydbUpdateReplicationMethodLogicalReplicationCDC) GetLsnCommitBehaviour() *SourceAlloydbUpdateReplicationMethodLogicalReplicationCDCLSNCommitBehaviour {
	if o == nil {
		return nil
	}
	return o.LsnCommitBehaviour
}

func (o *SourceAlloydbUpdateReplicationMethodLogicalReplicationCDC) GetMethod() SourceAlloydbUpdateReplicationMethodLogicalReplicationCDCMethod {
	return SourceAlloydbUpdateReplicationMethodLogicalReplicationCDCMethodCdc
}

func (o *SourceAlloydbUpdateReplicationMethodLogicalReplicationCDC) GetPlugin() *SourceAlloydbUpdateReplicationMethodLogicalReplicationCDCPlugin {
	if o == nil {
		return nil
	}
	return o.Plugin
}

func (o *SourceAlloydbUpdateReplicationMethodLogicalReplicationCDC) GetPublication() string {
	if o == nil {
		return ""
	}
	return o.Publication
}

func (o *SourceAlloydbUpdateReplicationMethodLogicalReplicationCDC) GetQueueSize() *int64 {
	if o == nil {
		return nil
	}
	return o.QueueSize
}

func (o *SourceAlloydbUpdateReplicationMethodLogicalReplicationCDC) GetReplicationSlot() string {
	if o == nil {
		return ""
	}
	return o.ReplicationSlot
}

type SourceAlloydbUpdateReplicationMethodStandardXminMethod string

const (
	SourceAlloydbUpdateReplicationMethodStandardXminMethodXmin SourceAlloydbUpdateReplicationMethodStandardXminMethod = "Xmin"
)

func (e SourceAlloydbUpdateReplicationMethodStandardXminMethod) ToPointer() *SourceAlloydbUpdateReplicationMethodStandardXminMethod {
	return &e
}

func (e *SourceAlloydbUpdateReplicationMethodStandardXminMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Xmin":
		*e = SourceAlloydbUpdateReplicationMethodStandardXminMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceAlloydbUpdateReplicationMethodStandardXminMethod: %v", v)
	}
}

// SourceAlloydbUpdateReplicationMethodStandardXmin - Xmin replication requires no setup on the DB side but will not be able to represent deletions incrementally.
type SourceAlloydbUpdateReplicationMethodStandardXmin struct {
	method SourceAlloydbUpdateReplicationMethodStandardXminMethod `const:"Xmin" json:"method"`
}

func (s SourceAlloydbUpdateReplicationMethodStandardXmin) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceAlloydbUpdateReplicationMethodStandardXmin) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceAlloydbUpdateReplicationMethodStandardXmin) GetMethod() SourceAlloydbUpdateReplicationMethodStandardXminMethod {
	return SourceAlloydbUpdateReplicationMethodStandardXminMethodXmin
}

type SourceAlloydbUpdateReplicationMethodType string

const (
	SourceAlloydbUpdateReplicationMethodTypeSourceAlloydbUpdateReplicationMethodStandardXmin          SourceAlloydbUpdateReplicationMethodType = "source-alloydb-update_Replication Method_Standard (Xmin)"
	SourceAlloydbUpdateReplicationMethodTypeSourceAlloydbUpdateReplicationMethodLogicalReplicationCDC SourceAlloydbUpdateReplicationMethodType = "source-alloydb-update_Replication Method_Logical Replication (CDC)"
	SourceAlloydbUpdateReplicationMethodTypeSourceAlloydbUpdateReplicationMethodStandard              SourceAlloydbUpdateReplicationMethodType = "source-alloydb-update_Replication Method_Standard"
)

type SourceAlloydbUpdateReplicationMethod struct {
	SourceAlloydbUpdateReplicationMethodStandardXmin          *SourceAlloydbUpdateReplicationMethodStandardXmin
	SourceAlloydbUpdateReplicationMethodLogicalReplicationCDC *SourceAlloydbUpdateReplicationMethodLogicalReplicationCDC
	SourceAlloydbUpdateReplicationMethodStandard              *SourceAlloydbUpdateReplicationMethodStandard

	Type SourceAlloydbUpdateReplicationMethodType
}

func CreateSourceAlloydbUpdateReplicationMethodSourceAlloydbUpdateReplicationMethodStandardXmin(sourceAlloydbUpdateReplicationMethodStandardXmin SourceAlloydbUpdateReplicationMethodStandardXmin) SourceAlloydbUpdateReplicationMethod {
	typ := SourceAlloydbUpdateReplicationMethodTypeSourceAlloydbUpdateReplicationMethodStandardXmin

	return SourceAlloydbUpdateReplicationMethod{
		SourceAlloydbUpdateReplicationMethodStandardXmin: &sourceAlloydbUpdateReplicationMethodStandardXmin,
		Type: typ,
	}
}

func CreateSourceAlloydbUpdateReplicationMethodSourceAlloydbUpdateReplicationMethodLogicalReplicationCDC(sourceAlloydbUpdateReplicationMethodLogicalReplicationCDC SourceAlloydbUpdateReplicationMethodLogicalReplicationCDC) SourceAlloydbUpdateReplicationMethod {
	typ := SourceAlloydbUpdateReplicationMethodTypeSourceAlloydbUpdateReplicationMethodLogicalReplicationCDC

	return SourceAlloydbUpdateReplicationMethod{
		SourceAlloydbUpdateReplicationMethodLogicalReplicationCDC: &sourceAlloydbUpdateReplicationMethodLogicalReplicationCDC,
		Type: typ,
	}
}

func CreateSourceAlloydbUpdateReplicationMethodSourceAlloydbUpdateReplicationMethodStandard(sourceAlloydbUpdateReplicationMethodStandard SourceAlloydbUpdateReplicationMethodStandard) SourceAlloydbUpdateReplicationMethod {
	typ := SourceAlloydbUpdateReplicationMethodTypeSourceAlloydbUpdateReplicationMethodStandard

	return SourceAlloydbUpdateReplicationMethod{
		SourceAlloydbUpdateReplicationMethodStandard: &sourceAlloydbUpdateReplicationMethodStandard,
		Type: typ,
	}
}

func (u *SourceAlloydbUpdateReplicationMethod) UnmarshalJSON(data []byte) error {

	sourceAlloydbUpdateReplicationMethodStandardXmin := new(SourceAlloydbUpdateReplicationMethodStandardXmin)
	if err := utils.UnmarshalJSON(data, &sourceAlloydbUpdateReplicationMethodStandardXmin, "", true, true); err == nil {
		u.SourceAlloydbUpdateReplicationMethodStandardXmin = sourceAlloydbUpdateReplicationMethodStandardXmin
		u.Type = SourceAlloydbUpdateReplicationMethodTypeSourceAlloydbUpdateReplicationMethodStandardXmin
		return nil
	}

	sourceAlloydbUpdateReplicationMethodStandard := new(SourceAlloydbUpdateReplicationMethodStandard)
	if err := utils.UnmarshalJSON(data, &sourceAlloydbUpdateReplicationMethodStandard, "", true, true); err == nil {
		u.SourceAlloydbUpdateReplicationMethodStandard = sourceAlloydbUpdateReplicationMethodStandard
		u.Type = SourceAlloydbUpdateReplicationMethodTypeSourceAlloydbUpdateReplicationMethodStandard
		return nil
	}

	sourceAlloydbUpdateReplicationMethodLogicalReplicationCDC := new(SourceAlloydbUpdateReplicationMethodLogicalReplicationCDC)
	if err := utils.UnmarshalJSON(data, &sourceAlloydbUpdateReplicationMethodLogicalReplicationCDC, "", true, true); err == nil {
		u.SourceAlloydbUpdateReplicationMethodLogicalReplicationCDC = sourceAlloydbUpdateReplicationMethodLogicalReplicationCDC
		u.Type = SourceAlloydbUpdateReplicationMethodTypeSourceAlloydbUpdateReplicationMethodLogicalReplicationCDC
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SourceAlloydbUpdateReplicationMethod) MarshalJSON() ([]byte, error) {
	if u.SourceAlloydbUpdateReplicationMethodStandardXmin != nil {
		return utils.MarshalJSON(u.SourceAlloydbUpdateReplicationMethodStandardXmin, "", true)
	}

	if u.SourceAlloydbUpdateReplicationMethodLogicalReplicationCDC != nil {
		return utils.MarshalJSON(u.SourceAlloydbUpdateReplicationMethodLogicalReplicationCDC, "", true)
	}

	if u.SourceAlloydbUpdateReplicationMethodStandard != nil {
		return utils.MarshalJSON(u.SourceAlloydbUpdateReplicationMethodStandard, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type SourceAlloydbUpdateSSLModesVerifyFullMode string

const (
	SourceAlloydbUpdateSSLModesVerifyFullModeVerifyFull SourceAlloydbUpdateSSLModesVerifyFullMode = "verify-full"
)

func (e SourceAlloydbUpdateSSLModesVerifyFullMode) ToPointer() *SourceAlloydbUpdateSSLModesVerifyFullMode {
	return &e
}

func (e *SourceAlloydbUpdateSSLModesVerifyFullMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "verify-full":
		*e = SourceAlloydbUpdateSSLModesVerifyFullMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceAlloydbUpdateSSLModesVerifyFullMode: %v", v)
	}
}

// SourceAlloydbUpdateSSLModesVerifyFull - This is the most secure mode. Always require encryption and verifies the identity of the source database server.
type SourceAlloydbUpdateSSLModesVerifyFull struct {
	AdditionalProperties interface{} `additionalProperties:"true" json:"-"`
	// CA certificate
	CaCertificate string `json:"ca_certificate"`
	// Client certificate
	ClientCertificate *string `json:"client_certificate,omitempty"`
	// Client key
	ClientKey *string `json:"client_key,omitempty"`
	// Password for keystorage. If you do not add it - the password will be generated automatically.
	ClientKeyPassword *string                                   `json:"client_key_password,omitempty"`
	mode              SourceAlloydbUpdateSSLModesVerifyFullMode `const:"verify-full" json:"mode"`
}

func (s SourceAlloydbUpdateSSLModesVerifyFull) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceAlloydbUpdateSSLModesVerifyFull) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceAlloydbUpdateSSLModesVerifyFull) GetAdditionalProperties() interface{} {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *SourceAlloydbUpdateSSLModesVerifyFull) GetCaCertificate() string {
	if o == nil {
		return ""
	}
	return o.CaCertificate
}

func (o *SourceAlloydbUpdateSSLModesVerifyFull) GetClientCertificate() *string {
	if o == nil {
		return nil
	}
	return o.ClientCertificate
}

func (o *SourceAlloydbUpdateSSLModesVerifyFull) GetClientKey() *string {
	if o == nil {
		return nil
	}
	return o.ClientKey
}

func (o *SourceAlloydbUpdateSSLModesVerifyFull) GetClientKeyPassword() *string {
	if o == nil {
		return nil
	}
	return o.ClientKeyPassword
}

func (o *SourceAlloydbUpdateSSLModesVerifyFull) GetMode() SourceAlloydbUpdateSSLModesVerifyFullMode {
	return SourceAlloydbUpdateSSLModesVerifyFullModeVerifyFull
}

type SourceAlloydbUpdateSSLModesVerifyCaMode string

const (
	SourceAlloydbUpdateSSLModesVerifyCaModeVerifyCa SourceAlloydbUpdateSSLModesVerifyCaMode = "verify-ca"
)

func (e SourceAlloydbUpdateSSLModesVerifyCaMode) ToPointer() *SourceAlloydbUpdateSSLModesVerifyCaMode {
	return &e
}

func (e *SourceAlloydbUpdateSSLModesVerifyCaMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "verify-ca":
		*e = SourceAlloydbUpdateSSLModesVerifyCaMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceAlloydbUpdateSSLModesVerifyCaMode: %v", v)
	}
}

// SourceAlloydbUpdateSSLModesVerifyCa - Always require encryption and verifies that the source database server has a valid SSL certificate.
type SourceAlloydbUpdateSSLModesVerifyCa struct {
	AdditionalProperties interface{} `additionalProperties:"true" json:"-"`
	// CA certificate
	CaCertificate string `json:"ca_certificate"`
	// Client certificate
	ClientCertificate *string `json:"client_certificate,omitempty"`
	// Client key
	ClientKey *string `json:"client_key,omitempty"`
	// Password for keystorage. If you do not add it - the password will be generated automatically.
	ClientKeyPassword *string                                 `json:"client_key_password,omitempty"`
	mode              SourceAlloydbUpdateSSLModesVerifyCaMode `const:"verify-ca" json:"mode"`
}

func (s SourceAlloydbUpdateSSLModesVerifyCa) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceAlloydbUpdateSSLModesVerifyCa) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceAlloydbUpdateSSLModesVerifyCa) GetAdditionalProperties() interface{} {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *SourceAlloydbUpdateSSLModesVerifyCa) GetCaCertificate() string {
	if o == nil {
		return ""
	}
	return o.CaCertificate
}

func (o *SourceAlloydbUpdateSSLModesVerifyCa) GetClientCertificate() *string {
	if o == nil {
		return nil
	}
	return o.ClientCertificate
}

func (o *SourceAlloydbUpdateSSLModesVerifyCa) GetClientKey() *string {
	if o == nil {
		return nil
	}
	return o.ClientKey
}

func (o *SourceAlloydbUpdateSSLModesVerifyCa) GetClientKeyPassword() *string {
	if o == nil {
		return nil
	}
	return o.ClientKeyPassword
}

func (o *SourceAlloydbUpdateSSLModesVerifyCa) GetMode() SourceAlloydbUpdateSSLModesVerifyCaMode {
	return SourceAlloydbUpdateSSLModesVerifyCaModeVerifyCa
}

type SourceAlloydbUpdateSSLModesRequireMode string

const (
	SourceAlloydbUpdateSSLModesRequireModeRequire SourceAlloydbUpdateSSLModesRequireMode = "require"
)

func (e SourceAlloydbUpdateSSLModesRequireMode) ToPointer() *SourceAlloydbUpdateSSLModesRequireMode {
	return &e
}

func (e *SourceAlloydbUpdateSSLModesRequireMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "require":
		*e = SourceAlloydbUpdateSSLModesRequireMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceAlloydbUpdateSSLModesRequireMode: %v", v)
	}
}

// SourceAlloydbUpdateSSLModesRequire - Always require encryption. If the source database server does not support encryption, connection will fail.
type SourceAlloydbUpdateSSLModesRequire struct {
	AdditionalProperties interface{}                            `additionalProperties:"true" json:"-"`
	mode                 SourceAlloydbUpdateSSLModesRequireMode `const:"require" json:"mode"`
}

func (s SourceAlloydbUpdateSSLModesRequire) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceAlloydbUpdateSSLModesRequire) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceAlloydbUpdateSSLModesRequire) GetAdditionalProperties() interface{} {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *SourceAlloydbUpdateSSLModesRequire) GetMode() SourceAlloydbUpdateSSLModesRequireMode {
	return SourceAlloydbUpdateSSLModesRequireModeRequire
}

type SourceAlloydbUpdateSSLModesPreferMode string

const (
	SourceAlloydbUpdateSSLModesPreferModePrefer SourceAlloydbUpdateSSLModesPreferMode = "prefer"
)

func (e SourceAlloydbUpdateSSLModesPreferMode) ToPointer() *SourceAlloydbUpdateSSLModesPreferMode {
	return &e
}

func (e *SourceAlloydbUpdateSSLModesPreferMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "prefer":
		*e = SourceAlloydbUpdateSSLModesPreferMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceAlloydbUpdateSSLModesPreferMode: %v", v)
	}
}

// SourceAlloydbUpdateSSLModesPrefer - Allows unencrypted connection only if the source database does not support encryption.
type SourceAlloydbUpdateSSLModesPrefer struct {
	AdditionalProperties interface{}                           `additionalProperties:"true" json:"-"`
	mode                 SourceAlloydbUpdateSSLModesPreferMode `const:"prefer" json:"mode"`
}

func (s SourceAlloydbUpdateSSLModesPrefer) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceAlloydbUpdateSSLModesPrefer) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceAlloydbUpdateSSLModesPrefer) GetAdditionalProperties() interface{} {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *SourceAlloydbUpdateSSLModesPrefer) GetMode() SourceAlloydbUpdateSSLModesPreferMode {
	return SourceAlloydbUpdateSSLModesPreferModePrefer
}

type SourceAlloydbUpdateSSLModesAllowMode string

const (
	SourceAlloydbUpdateSSLModesAllowModeAllow SourceAlloydbUpdateSSLModesAllowMode = "allow"
)

func (e SourceAlloydbUpdateSSLModesAllowMode) ToPointer() *SourceAlloydbUpdateSSLModesAllowMode {
	return &e
}

func (e *SourceAlloydbUpdateSSLModesAllowMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "allow":
		*e = SourceAlloydbUpdateSSLModesAllowMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceAlloydbUpdateSSLModesAllowMode: %v", v)
	}
}

// SourceAlloydbUpdateSSLModesAllow - Enables encryption only when required by the source database.
type SourceAlloydbUpdateSSLModesAllow struct {
	AdditionalProperties interface{}                          `additionalProperties:"true" json:"-"`
	mode                 SourceAlloydbUpdateSSLModesAllowMode `const:"allow" json:"mode"`
}

func (s SourceAlloydbUpdateSSLModesAllow) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceAlloydbUpdateSSLModesAllow) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceAlloydbUpdateSSLModesAllow) GetAdditionalProperties() interface{} {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *SourceAlloydbUpdateSSLModesAllow) GetMode() SourceAlloydbUpdateSSLModesAllowMode {
	return SourceAlloydbUpdateSSLModesAllowModeAllow
}

type SourceAlloydbUpdateSSLModesDisableMode string

const (
	SourceAlloydbUpdateSSLModesDisableModeDisable SourceAlloydbUpdateSSLModesDisableMode = "disable"
)

func (e SourceAlloydbUpdateSSLModesDisableMode) ToPointer() *SourceAlloydbUpdateSSLModesDisableMode {
	return &e
}

func (e *SourceAlloydbUpdateSSLModesDisableMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "disable":
		*e = SourceAlloydbUpdateSSLModesDisableMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceAlloydbUpdateSSLModesDisableMode: %v", v)
	}
}

// SourceAlloydbUpdateSSLModesDisable - Disables encryption of communication between Airbyte and source database.
type SourceAlloydbUpdateSSLModesDisable struct {
	AdditionalProperties interface{}                            `additionalProperties:"true" json:"-"`
	mode                 SourceAlloydbUpdateSSLModesDisableMode `const:"disable" json:"mode"`
}

func (s SourceAlloydbUpdateSSLModesDisable) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceAlloydbUpdateSSLModesDisable) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceAlloydbUpdateSSLModesDisable) GetAdditionalProperties() interface{} {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *SourceAlloydbUpdateSSLModesDisable) GetMode() SourceAlloydbUpdateSSLModesDisableMode {
	return SourceAlloydbUpdateSSLModesDisableModeDisable
}

type SourceAlloydbUpdateSSLModesType string

const (
	SourceAlloydbUpdateSSLModesTypeSourceAlloydbUpdateSSLModesDisable    SourceAlloydbUpdateSSLModesType = "source-alloydb-update_SSL Modes_disable"
	SourceAlloydbUpdateSSLModesTypeSourceAlloydbUpdateSSLModesAllow      SourceAlloydbUpdateSSLModesType = "source-alloydb-update_SSL Modes_allow"
	SourceAlloydbUpdateSSLModesTypeSourceAlloydbUpdateSSLModesPrefer     SourceAlloydbUpdateSSLModesType = "source-alloydb-update_SSL Modes_prefer"
	SourceAlloydbUpdateSSLModesTypeSourceAlloydbUpdateSSLModesRequire    SourceAlloydbUpdateSSLModesType = "source-alloydb-update_SSL Modes_require"
	SourceAlloydbUpdateSSLModesTypeSourceAlloydbUpdateSSLModesVerifyCa   SourceAlloydbUpdateSSLModesType = "source-alloydb-update_SSL Modes_verify-ca"
	SourceAlloydbUpdateSSLModesTypeSourceAlloydbUpdateSSLModesVerifyFull SourceAlloydbUpdateSSLModesType = "source-alloydb-update_SSL Modes_verify-full"
)

type SourceAlloydbUpdateSSLModes struct {
	SourceAlloydbUpdateSSLModesDisable    *SourceAlloydbUpdateSSLModesDisable
	SourceAlloydbUpdateSSLModesAllow      *SourceAlloydbUpdateSSLModesAllow
	SourceAlloydbUpdateSSLModesPrefer     *SourceAlloydbUpdateSSLModesPrefer
	SourceAlloydbUpdateSSLModesRequire    *SourceAlloydbUpdateSSLModesRequire
	SourceAlloydbUpdateSSLModesVerifyCa   *SourceAlloydbUpdateSSLModesVerifyCa
	SourceAlloydbUpdateSSLModesVerifyFull *SourceAlloydbUpdateSSLModesVerifyFull

	Type SourceAlloydbUpdateSSLModesType
}

func CreateSourceAlloydbUpdateSSLModesSourceAlloydbUpdateSSLModesDisable(sourceAlloydbUpdateSSLModesDisable SourceAlloydbUpdateSSLModesDisable) SourceAlloydbUpdateSSLModes {
	typ := SourceAlloydbUpdateSSLModesTypeSourceAlloydbUpdateSSLModesDisable

	return SourceAlloydbUpdateSSLModes{
		SourceAlloydbUpdateSSLModesDisable: &sourceAlloydbUpdateSSLModesDisable,
		Type:                               typ,
	}
}

func CreateSourceAlloydbUpdateSSLModesSourceAlloydbUpdateSSLModesAllow(sourceAlloydbUpdateSSLModesAllow SourceAlloydbUpdateSSLModesAllow) SourceAlloydbUpdateSSLModes {
	typ := SourceAlloydbUpdateSSLModesTypeSourceAlloydbUpdateSSLModesAllow

	return SourceAlloydbUpdateSSLModes{
		SourceAlloydbUpdateSSLModesAllow: &sourceAlloydbUpdateSSLModesAllow,
		Type:                             typ,
	}
}

func CreateSourceAlloydbUpdateSSLModesSourceAlloydbUpdateSSLModesPrefer(sourceAlloydbUpdateSSLModesPrefer SourceAlloydbUpdateSSLModesPrefer) SourceAlloydbUpdateSSLModes {
	typ := SourceAlloydbUpdateSSLModesTypeSourceAlloydbUpdateSSLModesPrefer

	return SourceAlloydbUpdateSSLModes{
		SourceAlloydbUpdateSSLModesPrefer: &sourceAlloydbUpdateSSLModesPrefer,
		Type:                              typ,
	}
}

func CreateSourceAlloydbUpdateSSLModesSourceAlloydbUpdateSSLModesRequire(sourceAlloydbUpdateSSLModesRequire SourceAlloydbUpdateSSLModesRequire) SourceAlloydbUpdateSSLModes {
	typ := SourceAlloydbUpdateSSLModesTypeSourceAlloydbUpdateSSLModesRequire

	return SourceAlloydbUpdateSSLModes{
		SourceAlloydbUpdateSSLModesRequire: &sourceAlloydbUpdateSSLModesRequire,
		Type:                               typ,
	}
}

func CreateSourceAlloydbUpdateSSLModesSourceAlloydbUpdateSSLModesVerifyCa(sourceAlloydbUpdateSSLModesVerifyCa SourceAlloydbUpdateSSLModesVerifyCa) SourceAlloydbUpdateSSLModes {
	typ := SourceAlloydbUpdateSSLModesTypeSourceAlloydbUpdateSSLModesVerifyCa

	return SourceAlloydbUpdateSSLModes{
		SourceAlloydbUpdateSSLModesVerifyCa: &sourceAlloydbUpdateSSLModesVerifyCa,
		Type:                                typ,
	}
}

func CreateSourceAlloydbUpdateSSLModesSourceAlloydbUpdateSSLModesVerifyFull(sourceAlloydbUpdateSSLModesVerifyFull SourceAlloydbUpdateSSLModesVerifyFull) SourceAlloydbUpdateSSLModes {
	typ := SourceAlloydbUpdateSSLModesTypeSourceAlloydbUpdateSSLModesVerifyFull

	return SourceAlloydbUpdateSSLModes{
		SourceAlloydbUpdateSSLModesVerifyFull: &sourceAlloydbUpdateSSLModesVerifyFull,
		Type:                                  typ,
	}
}

func (u *SourceAlloydbUpdateSSLModes) UnmarshalJSON(data []byte) error {

	sourceAlloydbUpdateSSLModesDisable := new(SourceAlloydbUpdateSSLModesDisable)
	if err := utils.UnmarshalJSON(data, &sourceAlloydbUpdateSSLModesDisable, "", true, true); err == nil {
		u.SourceAlloydbUpdateSSLModesDisable = sourceAlloydbUpdateSSLModesDisable
		u.Type = SourceAlloydbUpdateSSLModesTypeSourceAlloydbUpdateSSLModesDisable
		return nil
	}

	sourceAlloydbUpdateSSLModesAllow := new(SourceAlloydbUpdateSSLModesAllow)
	if err := utils.UnmarshalJSON(data, &sourceAlloydbUpdateSSLModesAllow, "", true, true); err == nil {
		u.SourceAlloydbUpdateSSLModesAllow = sourceAlloydbUpdateSSLModesAllow
		u.Type = SourceAlloydbUpdateSSLModesTypeSourceAlloydbUpdateSSLModesAllow
		return nil
	}

	sourceAlloydbUpdateSSLModesPrefer := new(SourceAlloydbUpdateSSLModesPrefer)
	if err := utils.UnmarshalJSON(data, &sourceAlloydbUpdateSSLModesPrefer, "", true, true); err == nil {
		u.SourceAlloydbUpdateSSLModesPrefer = sourceAlloydbUpdateSSLModesPrefer
		u.Type = SourceAlloydbUpdateSSLModesTypeSourceAlloydbUpdateSSLModesPrefer
		return nil
	}

	sourceAlloydbUpdateSSLModesRequire := new(SourceAlloydbUpdateSSLModesRequire)
	if err := utils.UnmarshalJSON(data, &sourceAlloydbUpdateSSLModesRequire, "", true, true); err == nil {
		u.SourceAlloydbUpdateSSLModesRequire = sourceAlloydbUpdateSSLModesRequire
		u.Type = SourceAlloydbUpdateSSLModesTypeSourceAlloydbUpdateSSLModesRequire
		return nil
	}

	sourceAlloydbUpdateSSLModesVerifyCa := new(SourceAlloydbUpdateSSLModesVerifyCa)
	if err := utils.UnmarshalJSON(data, &sourceAlloydbUpdateSSLModesVerifyCa, "", true, true); err == nil {
		u.SourceAlloydbUpdateSSLModesVerifyCa = sourceAlloydbUpdateSSLModesVerifyCa
		u.Type = SourceAlloydbUpdateSSLModesTypeSourceAlloydbUpdateSSLModesVerifyCa
		return nil
	}

	sourceAlloydbUpdateSSLModesVerifyFull := new(SourceAlloydbUpdateSSLModesVerifyFull)
	if err := utils.UnmarshalJSON(data, &sourceAlloydbUpdateSSLModesVerifyFull, "", true, true); err == nil {
		u.SourceAlloydbUpdateSSLModesVerifyFull = sourceAlloydbUpdateSSLModesVerifyFull
		u.Type = SourceAlloydbUpdateSSLModesTypeSourceAlloydbUpdateSSLModesVerifyFull
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SourceAlloydbUpdateSSLModes) MarshalJSON() ([]byte, error) {
	if u.SourceAlloydbUpdateSSLModesDisable != nil {
		return utils.MarshalJSON(u.SourceAlloydbUpdateSSLModesDisable, "", true)
	}

	if u.SourceAlloydbUpdateSSLModesAllow != nil {
		return utils.MarshalJSON(u.SourceAlloydbUpdateSSLModesAllow, "", true)
	}

	if u.SourceAlloydbUpdateSSLModesPrefer != nil {
		return utils.MarshalJSON(u.SourceAlloydbUpdateSSLModesPrefer, "", true)
	}

	if u.SourceAlloydbUpdateSSLModesRequire != nil {
		return utils.MarshalJSON(u.SourceAlloydbUpdateSSLModesRequire, "", true)
	}

	if u.SourceAlloydbUpdateSSLModesVerifyCa != nil {
		return utils.MarshalJSON(u.SourceAlloydbUpdateSSLModesVerifyCa, "", true)
	}

	if u.SourceAlloydbUpdateSSLModesVerifyFull != nil {
		return utils.MarshalJSON(u.SourceAlloydbUpdateSSLModesVerifyFull, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

// SourceAlloydbUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod - Connect through a jump server tunnel host using username and password authentication
type SourceAlloydbUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod string

const (
	SourceAlloydbUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethodSSHPasswordAuth SourceAlloydbUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod = "SSH_PASSWORD_AUTH"
)

func (e SourceAlloydbUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod) ToPointer() *SourceAlloydbUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod {
	return &e
}

func (e *SourceAlloydbUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_PASSWORD_AUTH":
		*e = SourceAlloydbUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceAlloydbUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod: %v", v)
	}
}

// SourceAlloydbUpdateSSHTunnelMethodPasswordAuthentication - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceAlloydbUpdateSSHTunnelMethodPasswordAuthentication struct {
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and password authentication
	tunnelMethod SourceAlloydbUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod `const:"SSH_PASSWORD_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser string `json:"tunnel_user"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword string `json:"tunnel_user_password"`
}

func (s SourceAlloydbUpdateSSHTunnelMethodPasswordAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceAlloydbUpdateSSHTunnelMethodPasswordAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceAlloydbUpdateSSHTunnelMethodPasswordAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *SourceAlloydbUpdateSSHTunnelMethodPasswordAuthentication) GetTunnelMethod() SourceAlloydbUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethod {
	return SourceAlloydbUpdateSSHTunnelMethodPasswordAuthenticationTunnelMethodSSHPasswordAuth
}

func (o *SourceAlloydbUpdateSSHTunnelMethodPasswordAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *SourceAlloydbUpdateSSHTunnelMethodPasswordAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

func (o *SourceAlloydbUpdateSSHTunnelMethodPasswordAuthentication) GetTunnelUserPassword() string {
	if o == nil {
		return ""
	}
	return o.TunnelUserPassword
}

// SourceAlloydbUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod - Connect through a jump server tunnel host using username and ssh key
type SourceAlloydbUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod string

const (
	SourceAlloydbUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethodSSHKeyAuth SourceAlloydbUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod = "SSH_KEY_AUTH"
)

func (e SourceAlloydbUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod) ToPointer() *SourceAlloydbUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod {
	return &e
}

func (e *SourceAlloydbUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_KEY_AUTH":
		*e = SourceAlloydbUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceAlloydbUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod: %v", v)
	}
}

// SourceAlloydbUpdateSSHTunnelMethodSSHKeyAuthentication - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceAlloydbUpdateSSHTunnelMethodSSHKeyAuthentication struct {
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey string `json:"ssh_key"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and ssh key
	tunnelMethod SourceAlloydbUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod `const:"SSH_KEY_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host.
	TunnelUser string `json:"tunnel_user"`
}

func (s SourceAlloydbUpdateSSHTunnelMethodSSHKeyAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceAlloydbUpdateSSHTunnelMethodSSHKeyAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceAlloydbUpdateSSHTunnelMethodSSHKeyAuthentication) GetSSHKey() string {
	if o == nil {
		return ""
	}
	return o.SSHKey
}

func (o *SourceAlloydbUpdateSSHTunnelMethodSSHKeyAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *SourceAlloydbUpdateSSHTunnelMethodSSHKeyAuthentication) GetTunnelMethod() SourceAlloydbUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethod {
	return SourceAlloydbUpdateSSHTunnelMethodSSHKeyAuthenticationTunnelMethodSSHKeyAuth
}

func (o *SourceAlloydbUpdateSSHTunnelMethodSSHKeyAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *SourceAlloydbUpdateSSHTunnelMethodSSHKeyAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

// SourceAlloydbUpdateSSHTunnelMethodNoTunnelTunnelMethod - No ssh tunnel needed to connect to database
type SourceAlloydbUpdateSSHTunnelMethodNoTunnelTunnelMethod string

const (
	SourceAlloydbUpdateSSHTunnelMethodNoTunnelTunnelMethodNoTunnel SourceAlloydbUpdateSSHTunnelMethodNoTunnelTunnelMethod = "NO_TUNNEL"
)

func (e SourceAlloydbUpdateSSHTunnelMethodNoTunnelTunnelMethod) ToPointer() *SourceAlloydbUpdateSSHTunnelMethodNoTunnelTunnelMethod {
	return &e
}

func (e *SourceAlloydbUpdateSSHTunnelMethodNoTunnelTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NO_TUNNEL":
		*e = SourceAlloydbUpdateSSHTunnelMethodNoTunnelTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceAlloydbUpdateSSHTunnelMethodNoTunnelTunnelMethod: %v", v)
	}
}

// SourceAlloydbUpdateSSHTunnelMethodNoTunnel - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceAlloydbUpdateSSHTunnelMethodNoTunnel struct {
	// No ssh tunnel needed to connect to database
	tunnelMethod SourceAlloydbUpdateSSHTunnelMethodNoTunnelTunnelMethod `const:"NO_TUNNEL" json:"tunnel_method"`
}

func (s SourceAlloydbUpdateSSHTunnelMethodNoTunnel) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceAlloydbUpdateSSHTunnelMethodNoTunnel) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceAlloydbUpdateSSHTunnelMethodNoTunnel) GetTunnelMethod() SourceAlloydbUpdateSSHTunnelMethodNoTunnelTunnelMethod {
	return SourceAlloydbUpdateSSHTunnelMethodNoTunnelTunnelMethodNoTunnel
}

type SourceAlloydbUpdateSSHTunnelMethodType string

const (
	SourceAlloydbUpdateSSHTunnelMethodTypeSourceAlloydbUpdateSSHTunnelMethodNoTunnel               SourceAlloydbUpdateSSHTunnelMethodType = "source-alloydb-update_SSH Tunnel Method_No Tunnel"
	SourceAlloydbUpdateSSHTunnelMethodTypeSourceAlloydbUpdateSSHTunnelMethodSSHKeyAuthentication   SourceAlloydbUpdateSSHTunnelMethodType = "source-alloydb-update_SSH Tunnel Method_SSH Key Authentication"
	SourceAlloydbUpdateSSHTunnelMethodTypeSourceAlloydbUpdateSSHTunnelMethodPasswordAuthentication SourceAlloydbUpdateSSHTunnelMethodType = "source-alloydb-update_SSH Tunnel Method_Password Authentication"
)

type SourceAlloydbUpdateSSHTunnelMethod struct {
	SourceAlloydbUpdateSSHTunnelMethodNoTunnel               *SourceAlloydbUpdateSSHTunnelMethodNoTunnel
	SourceAlloydbUpdateSSHTunnelMethodSSHKeyAuthentication   *SourceAlloydbUpdateSSHTunnelMethodSSHKeyAuthentication
	SourceAlloydbUpdateSSHTunnelMethodPasswordAuthentication *SourceAlloydbUpdateSSHTunnelMethodPasswordAuthentication

	Type SourceAlloydbUpdateSSHTunnelMethodType
}

func CreateSourceAlloydbUpdateSSHTunnelMethodSourceAlloydbUpdateSSHTunnelMethodNoTunnel(sourceAlloydbUpdateSSHTunnelMethodNoTunnel SourceAlloydbUpdateSSHTunnelMethodNoTunnel) SourceAlloydbUpdateSSHTunnelMethod {
	typ := SourceAlloydbUpdateSSHTunnelMethodTypeSourceAlloydbUpdateSSHTunnelMethodNoTunnel

	return SourceAlloydbUpdateSSHTunnelMethod{
		SourceAlloydbUpdateSSHTunnelMethodNoTunnel: &sourceAlloydbUpdateSSHTunnelMethodNoTunnel,
		Type: typ,
	}
}

func CreateSourceAlloydbUpdateSSHTunnelMethodSourceAlloydbUpdateSSHTunnelMethodSSHKeyAuthentication(sourceAlloydbUpdateSSHTunnelMethodSSHKeyAuthentication SourceAlloydbUpdateSSHTunnelMethodSSHKeyAuthentication) SourceAlloydbUpdateSSHTunnelMethod {
	typ := SourceAlloydbUpdateSSHTunnelMethodTypeSourceAlloydbUpdateSSHTunnelMethodSSHKeyAuthentication

	return SourceAlloydbUpdateSSHTunnelMethod{
		SourceAlloydbUpdateSSHTunnelMethodSSHKeyAuthentication: &sourceAlloydbUpdateSSHTunnelMethodSSHKeyAuthentication,
		Type: typ,
	}
}

func CreateSourceAlloydbUpdateSSHTunnelMethodSourceAlloydbUpdateSSHTunnelMethodPasswordAuthentication(sourceAlloydbUpdateSSHTunnelMethodPasswordAuthentication SourceAlloydbUpdateSSHTunnelMethodPasswordAuthentication) SourceAlloydbUpdateSSHTunnelMethod {
	typ := SourceAlloydbUpdateSSHTunnelMethodTypeSourceAlloydbUpdateSSHTunnelMethodPasswordAuthentication

	return SourceAlloydbUpdateSSHTunnelMethod{
		SourceAlloydbUpdateSSHTunnelMethodPasswordAuthentication: &sourceAlloydbUpdateSSHTunnelMethodPasswordAuthentication,
		Type: typ,
	}
}

func (u *SourceAlloydbUpdateSSHTunnelMethod) UnmarshalJSON(data []byte) error {

	sourceAlloydbUpdateSSHTunnelMethodNoTunnel := new(SourceAlloydbUpdateSSHTunnelMethodNoTunnel)
	if err := utils.UnmarshalJSON(data, &sourceAlloydbUpdateSSHTunnelMethodNoTunnel, "", true, true); err == nil {
		u.SourceAlloydbUpdateSSHTunnelMethodNoTunnel = sourceAlloydbUpdateSSHTunnelMethodNoTunnel
		u.Type = SourceAlloydbUpdateSSHTunnelMethodTypeSourceAlloydbUpdateSSHTunnelMethodNoTunnel
		return nil
	}

	sourceAlloydbUpdateSSHTunnelMethodSSHKeyAuthentication := new(SourceAlloydbUpdateSSHTunnelMethodSSHKeyAuthentication)
	if err := utils.UnmarshalJSON(data, &sourceAlloydbUpdateSSHTunnelMethodSSHKeyAuthentication, "", true, true); err == nil {
		u.SourceAlloydbUpdateSSHTunnelMethodSSHKeyAuthentication = sourceAlloydbUpdateSSHTunnelMethodSSHKeyAuthentication
		u.Type = SourceAlloydbUpdateSSHTunnelMethodTypeSourceAlloydbUpdateSSHTunnelMethodSSHKeyAuthentication
		return nil
	}

	sourceAlloydbUpdateSSHTunnelMethodPasswordAuthentication := new(SourceAlloydbUpdateSSHTunnelMethodPasswordAuthentication)
	if err := utils.UnmarshalJSON(data, &sourceAlloydbUpdateSSHTunnelMethodPasswordAuthentication, "", true, true); err == nil {
		u.SourceAlloydbUpdateSSHTunnelMethodPasswordAuthentication = sourceAlloydbUpdateSSHTunnelMethodPasswordAuthentication
		u.Type = SourceAlloydbUpdateSSHTunnelMethodTypeSourceAlloydbUpdateSSHTunnelMethodPasswordAuthentication
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SourceAlloydbUpdateSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.SourceAlloydbUpdateSSHTunnelMethodNoTunnel != nil {
		return utils.MarshalJSON(u.SourceAlloydbUpdateSSHTunnelMethodNoTunnel, "", true)
	}

	if u.SourceAlloydbUpdateSSHTunnelMethodSSHKeyAuthentication != nil {
		return utils.MarshalJSON(u.SourceAlloydbUpdateSSHTunnelMethodSSHKeyAuthentication, "", true)
	}

	if u.SourceAlloydbUpdateSSHTunnelMethodPasswordAuthentication != nil {
		return utils.MarshalJSON(u.SourceAlloydbUpdateSSHTunnelMethodPasswordAuthentication, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type SourceAlloydbUpdate struct {
	// Name of the database.
	Database string `json:"database"`
	// Hostname of the database.
	Host string `json:"host"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (Eg. key1=value1&key2=value2&key3=value3). For more information read about <a href="https://jdbc.postgresql.org/documentation/head/connect.html">JDBC URL parameters</a>.
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// Password associated with the username.
	Password *string `json:"password,omitempty"`
	// Port of the database.
	Port *int64 `default:"5432" json:"port"`
	// Replication method for extracting data from the database.
	ReplicationMethod *SourceAlloydbUpdateReplicationMethod `json:"replication_method,omitempty"`
	// The list of schemas (case sensitive) to sync from. Defaults to public.
	Schemas []string `json:"schemas,omitempty"`
	// SSL connection modes.
	//   Read more <a href="https://jdbc.postgresql.org/documentation/head/ssl-client.html"> in the docs</a>.
	SslMode *SourceAlloydbUpdateSSLModes `json:"ssl_mode,omitempty"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod *SourceAlloydbUpdateSSHTunnelMethod `json:"tunnel_method,omitempty"`
	// Username to access the database.
	Username string `json:"username"`
}

func (s SourceAlloydbUpdate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceAlloydbUpdate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *SourceAlloydbUpdate) GetDatabase() string {
	if o == nil {
		return ""
	}
	return o.Database
}

func (o *SourceAlloydbUpdate) GetHost() string {
	if o == nil {
		return ""
	}
	return o.Host
}

func (o *SourceAlloydbUpdate) GetJdbcURLParams() *string {
	if o == nil {
		return nil
	}
	return o.JdbcURLParams
}

func (o *SourceAlloydbUpdate) GetPassword() *string {
	if o == nil {
		return nil
	}
	return o.Password
}

func (o *SourceAlloydbUpdate) GetPort() *int64 {
	if o == nil {
		return nil
	}
	return o.Port
}

func (o *SourceAlloydbUpdate) GetReplicationMethod() *SourceAlloydbUpdateReplicationMethod {
	if o == nil {
		return nil
	}
	return o.ReplicationMethod
}

func (o *SourceAlloydbUpdate) GetSchemas() []string {
	if o == nil {
		return nil
	}
	return o.Schemas
}

func (o *SourceAlloydbUpdate) GetSslMode() *SourceAlloydbUpdateSSLModes {
	if o == nil {
		return nil
	}
	return o.SslMode
}

func (o *SourceAlloydbUpdate) GetTunnelMethod() *SourceAlloydbUpdateSSHTunnelMethod {
	if o == nil {
		return nil
	}
	return o.TunnelMethod
}

func (o *SourceAlloydbUpdate) GetUsername() string {
	if o == nil {
		return ""
	}
	return o.Username
}
