// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/pkg/utils"
)

type SourceE2eTestCloudUpdateType string

const (
	SourceE2eTestCloudUpdateTypeMultiStream SourceE2eTestCloudUpdateType = "MULTI_STREAM"
)

func (e SourceE2eTestCloudUpdateType) ToPointer() *SourceE2eTestCloudUpdateType {
	return &e
}

func (e *SourceE2eTestCloudUpdateType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "MULTI_STREAM":
		*e = SourceE2eTestCloudUpdateType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceE2eTestCloudUpdateType: %v", v)
	}
}

// MultiSchema - A catalog with multiple data streams, each with a different schema.
type MultiSchema struct {
	// A Json object specifying multiple data streams and their schemas. Each key in this object is one stream name. Each value is the schema for that stream. The schema should be compatible with <a href="https://json-schema.org/draft-07/json-schema-release-notes.html">draft-07</a>. See <a href="https://cswr.github.io/JsonSchema/spec/introduction/">this doc</a> for examples.
	StreamSchemas *string                       `default:"{ "stream1": { "type": "object", "properties": { "field1": { "type": "string" } } }, "stream2": { "type": "object", "properties": { "field1": { "type": "boolean" } } } }" json:"stream_schemas"`
	type_         *SourceE2eTestCloudUpdateType `const:"MULTI_STREAM" json:"type"`
}

func (m MultiSchema) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(m, "", false)
}

func (m *MultiSchema) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &m, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *MultiSchema) GetStreamSchemas() *string {
	if o == nil {
		return nil
	}
	return o.StreamSchemas
}

func (o *MultiSchema) GetType() *SourceE2eTestCloudUpdateType {
	return SourceE2eTestCloudUpdateTypeMultiStream.ToPointer()
}

type SourceE2eTestCloudUpdateSchemasType string

const (
	SourceE2eTestCloudUpdateSchemasTypeSingleStream SourceE2eTestCloudUpdateSchemasType = "SINGLE_STREAM"
)

func (e SourceE2eTestCloudUpdateSchemasType) ToPointer() *SourceE2eTestCloudUpdateSchemasType {
	return &e
}

func (e *SourceE2eTestCloudUpdateSchemasType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SINGLE_STREAM":
		*e = SourceE2eTestCloudUpdateSchemasType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceE2eTestCloudUpdateSchemasType: %v", v)
	}
}

// SingleSchema - A catalog with one or multiple streams that share the same schema.
type SingleSchema struct {
	// Duplicate the stream for easy load testing. Each stream name will have a number suffix. For example, if the stream name is "ds", the duplicated streams will be "ds_0", "ds_1", etc.
	StreamDuplication *int64 `default:"1" json:"stream_duplication"`
	// Name of the data stream.
	StreamName *string `default:"data_stream" json:"stream_name"`
	// A Json schema for the stream. The schema should be compatible with <a href="https://json-schema.org/draft-07/json-schema-release-notes.html">draft-07</a>. See <a href="https://cswr.github.io/JsonSchema/spec/introduction/">this doc</a> for examples.
	StreamSchema *string                              `default:"{ "type": "object", "properties": { "column1": { "type": "string" } } }" json:"stream_schema"`
	type_        *SourceE2eTestCloudUpdateSchemasType `const:"SINGLE_STREAM" json:"type"`
}

func (s SingleSchema) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SingleSchema) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SingleSchema) GetStreamDuplication() *int64 {
	if o == nil {
		return nil
	}
	return o.StreamDuplication
}

func (o *SingleSchema) GetStreamName() *string {
	if o == nil {
		return nil
	}
	return o.StreamName
}

func (o *SingleSchema) GetStreamSchema() *string {
	if o == nil {
		return nil
	}
	return o.StreamSchema
}

func (o *SingleSchema) GetType() *SourceE2eTestCloudUpdateSchemasType {
	return SourceE2eTestCloudUpdateSchemasTypeSingleStream.ToPointer()
}

type MockCatalogType string

const (
	MockCatalogTypeSingleSchema MockCatalogType = "Single Schema"
	MockCatalogTypeMultiSchema  MockCatalogType = "Multi Schema"
)

type MockCatalog struct {
	SingleSchema *SingleSchema
	MultiSchema  *MultiSchema

	Type MockCatalogType
}

func CreateMockCatalogSingleSchema(singleSchema SingleSchema) MockCatalog {
	typ := MockCatalogTypeSingleSchema

	return MockCatalog{
		SingleSchema: &singleSchema,
		Type:         typ,
	}
}

func CreateMockCatalogMultiSchema(multiSchema MultiSchema) MockCatalog {
	typ := MockCatalogTypeMultiSchema

	return MockCatalog{
		MultiSchema: &multiSchema,
		Type:        typ,
	}
}

func (u *MockCatalog) UnmarshalJSON(data []byte) error {

	multiSchema := new(MultiSchema)
	if err := utils.UnmarshalJSON(data, &multiSchema, "", true, true); err == nil {
		u.MultiSchema = multiSchema
		u.Type = MockCatalogTypeMultiSchema
		return nil
	}

	singleSchema := new(SingleSchema)
	if err := utils.UnmarshalJSON(data, &singleSchema, "", true, true); err == nil {
		u.SingleSchema = singleSchema
		u.Type = MockCatalogTypeSingleSchema
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u MockCatalog) MarshalJSON() ([]byte, error) {
	if u.SingleSchema != nil {
		return utils.MarshalJSON(u.SingleSchema, "", true)
	}

	if u.MultiSchema != nil {
		return utils.MarshalJSON(u.MultiSchema, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type Type string

const (
	TypeContinuousFeed Type = "CONTINUOUS_FEED"
)

func (e Type) ToPointer() *Type {
	return &e
}

func (e *Type) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CONTINUOUS_FEED":
		*e = Type(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Type: %v", v)
	}
}

type SourceE2eTestCloudUpdate struct {
	// Number of records to emit per stream. Min 1. Max 100 billion.
	MaxMessages *int64 `default:"100" json:"max_messages"`
	// Interval between messages in ms. Min 0 ms. Max 60000 ms (1 minute).
	MessageIntervalMs *int64      `default:"0" json:"message_interval_ms"`
	MockCatalog       MockCatalog `json:"mock_catalog"`
	// When the seed is unspecified, the current time millis will be used as the seed. Range: [0, 1000000].
	Seed  *int64 `default:"0" json:"seed"`
	type_ *Type  `const:"CONTINUOUS_FEED" json:"type"`
}

func (s SourceE2eTestCloudUpdate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceE2eTestCloudUpdate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *SourceE2eTestCloudUpdate) GetMaxMessages() *int64 {
	if o == nil {
		return nil
	}
	return o.MaxMessages
}

func (o *SourceE2eTestCloudUpdate) GetMessageIntervalMs() *int64 {
	if o == nil {
		return nil
	}
	return o.MessageIntervalMs
}

func (o *SourceE2eTestCloudUpdate) GetMockCatalog() MockCatalog {
	if o == nil {
		return MockCatalog{}
	}
	return o.MockCatalog
}

func (o *SourceE2eTestCloudUpdate) GetSeed() *int64 {
	if o == nil {
		return nil
	}
	return o.Seed
}

func (o *SourceE2eTestCloudUpdate) GetType() *Type {
	return TypeContinuousFeed.ToPointer()
}
