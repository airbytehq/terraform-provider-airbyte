// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
)

type SourceFakerFaker string

const (
	SourceFakerFakerFaker SourceFakerFaker = "faker"
)

func (e SourceFakerFaker) ToPointer() *SourceFakerFaker {
	return &e
}

func (e *SourceFakerFaker) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "faker":
		*e = SourceFakerFaker(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceFakerFaker: %v", v)
	}
}

type SourceFaker struct {
	// Should the updated_at values for every record be new each sync?  Setting this to false will case the source to stop emitting records after COUNT records have been emitted.
	AlwaysUpdated *bool `json:"always_updated,omitempty"`
	// How many users should be generated in total.  This setting does not apply to the purchases or products stream.
	Count int64 `json:"count"`
	// How many parallel workers should we use to generate fake data?  Choose a value equal to the number of CPUs you will allocate to this source.
	Parallelism *int64 `json:"parallelism,omitempty"`
	// How many fake records will be in each page (stream slice), before a state message is emitted?
	RecordsPerSlice *int64 `json:"records_per_slice,omitempty"`
	// Manually control the faker random seed to return the same values on subsequent runs (leave -1 for random)
	Seed       *int64           `json:"seed,omitempty"`
	SourceType SourceFakerFaker `json:"sourceType"`
}
