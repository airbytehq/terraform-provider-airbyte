// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/pkg/utils"
)

type SourcePostgresSchemasReplicationMethodMethod string

const (
	SourcePostgresSchemasReplicationMethodMethodStandard SourcePostgresSchemasReplicationMethodMethod = "Standard"
)

func (e SourcePostgresSchemasReplicationMethodMethod) ToPointer() *SourcePostgresSchemasReplicationMethodMethod {
	return &e
}

func (e *SourcePostgresSchemasReplicationMethodMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Standard":
		*e = SourcePostgresSchemasReplicationMethodMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresSchemasReplicationMethodMethod: %v", v)
	}
}

// SourcePostgresScanChangesWithUserDefinedCursor - Incrementally detects new inserts and updates using the <a href="https://docs.airbyte.com/understanding-airbyte/connections/incremental-append/#user-defined-cursor">cursor column</a> chosen when configuring a connection (e.g. created_at, updated_at).
type SourcePostgresScanChangesWithUserDefinedCursor struct {
	method SourcePostgresSchemasReplicationMethodMethod `const:"Standard" json:"method"`
}

func (s SourcePostgresScanChangesWithUserDefinedCursor) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresScanChangesWithUserDefinedCursor) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresScanChangesWithUserDefinedCursor) GetMethod() SourcePostgresSchemasReplicationMethodMethod {
	return SourcePostgresSchemasReplicationMethodMethodStandard
}

type SourcePostgresSchemasMethod string

const (
	SourcePostgresSchemasMethodXmin SourcePostgresSchemasMethod = "Xmin"
)

func (e SourcePostgresSchemasMethod) ToPointer() *SourcePostgresSchemasMethod {
	return &e
}

func (e *SourcePostgresSchemasMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Xmin":
		*e = SourcePostgresSchemasMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresSchemasMethod: %v", v)
	}
}

// SourcePostgresDetectChangesWithXminSystemColumn - <i>Recommended</i> - Incrementally reads new inserts and updates via Postgres <a href="https://docs.airbyte.com/integrations/sources/postgres/#xmin">Xmin system column</a>. Only recommended for tables up to 500GB.
type SourcePostgresDetectChangesWithXminSystemColumn struct {
	method SourcePostgresSchemasMethod `const:"Xmin" json:"method"`
}

func (s SourcePostgresDetectChangesWithXminSystemColumn) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresDetectChangesWithXminSystemColumn) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresDetectChangesWithXminSystemColumn) GetMethod() SourcePostgresSchemasMethod {
	return SourcePostgresSchemasMethodXmin
}

// SourcePostgresLSNCommitBehaviour - Determines when Airbtye should flush the LSN of processed WAL logs in the source database. `After loading Data in the destination` is default. If `While reading Data` is selected, in case of a downstream failure (while loading data into the destination), next sync would result in a full sync.
type SourcePostgresLSNCommitBehaviour string

const (
	SourcePostgresLSNCommitBehaviourWhileReadingData                 SourcePostgresLSNCommitBehaviour = "While reading Data"
	SourcePostgresLSNCommitBehaviourAfterLoadingDataInTheDestination SourcePostgresLSNCommitBehaviour = "After loading Data in the destination"
)

func (e SourcePostgresLSNCommitBehaviour) ToPointer() *SourcePostgresLSNCommitBehaviour {
	return &e
}

func (e *SourcePostgresLSNCommitBehaviour) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "While reading Data":
		fallthrough
	case "After loading Data in the destination":
		*e = SourcePostgresLSNCommitBehaviour(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresLSNCommitBehaviour: %v", v)
	}
}

type SourcePostgresMethod string

const (
	SourcePostgresMethodCdc SourcePostgresMethod = "CDC"
)

func (e SourcePostgresMethod) ToPointer() *SourcePostgresMethod {
	return &e
}

func (e *SourcePostgresMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CDC":
		*e = SourcePostgresMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresMethod: %v", v)
	}
}

// SourcePostgresPlugin - A logical decoding plugin installed on the PostgreSQL server.
type SourcePostgresPlugin string

const (
	SourcePostgresPluginPgoutput SourcePostgresPlugin = "pgoutput"
)

func (e SourcePostgresPlugin) ToPointer() *SourcePostgresPlugin {
	return &e
}

func (e *SourcePostgresPlugin) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "pgoutput":
		*e = SourcePostgresPlugin(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresPlugin: %v", v)
	}
}

// SourcePostgresReadChangesUsingWriteAheadLogCDC - <i>Recommended</i> - Incrementally reads new inserts, updates, and deletes using the Postgres <a href="https://docs.airbyte.com/integrations/sources/postgres/#cdc">write-ahead log (WAL)</a>. This needs to be configured on the source database itself. Recommended for tables of any size.
type SourcePostgresReadChangesUsingWriteAheadLogCDC struct {
	AdditionalProperties interface{} `additionalProperties:"true" json:"-"`
	// The amount of time the connector will wait when it launches to determine if there is new data to sync or not. Defaults to 300 seconds. Valid range: 120 seconds to 1200 seconds. Read about <a href="https://docs.airbyte.com/integrations/sources/postgres#step-5-optional-set-up-initial-waiting-time">initial waiting time</a>.
	InitialWaitingSeconds *int64 `default:"300" json:"initial_waiting_seconds"`
	// Determines when Airbtye should flush the LSN of processed WAL logs in the source database. `After loading Data in the destination` is default. If `While reading Data` is selected, in case of a downstream failure (while loading data into the destination), next sync would result in a full sync.
	LsnCommitBehaviour *SourcePostgresLSNCommitBehaviour `default:"After loading Data in the destination" json:"lsn_commit_behaviour"`
	method             SourcePostgresMethod              `const:"CDC" json:"method"`
	// A logical decoding plugin installed on the PostgreSQL server.
	Plugin *SourcePostgresPlugin `default:"pgoutput" json:"plugin"`
	// A Postgres publication used for consuming changes. Read about <a href="https://docs.airbyte.com/integrations/sources/postgres#step-4-create-publications-and-replication-identities-for-tables">publications and replication identities</a>.
	Publication string `json:"publication"`
	// The size of the internal queue. This may interfere with memory consumption and efficiency of the connector, please be careful.
	QueueSize *int64 `default:"10000" json:"queue_size"`
	// A plugin logical replication slot. Read about <a href="https://docs.airbyte.com/integrations/sources/postgres#step-3-create-replication-slot">replication slots</a>.
	ReplicationSlot string `json:"replication_slot"`
}

func (s SourcePostgresReadChangesUsingWriteAheadLogCDC) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresReadChangesUsingWriteAheadLogCDC) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresReadChangesUsingWriteAheadLogCDC) GetAdditionalProperties() interface{} {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *SourcePostgresReadChangesUsingWriteAheadLogCDC) GetInitialWaitingSeconds() *int64 {
	if o == nil {
		return nil
	}
	return o.InitialWaitingSeconds
}

func (o *SourcePostgresReadChangesUsingWriteAheadLogCDC) GetLsnCommitBehaviour() *SourcePostgresLSNCommitBehaviour {
	if o == nil {
		return nil
	}
	return o.LsnCommitBehaviour
}

func (o *SourcePostgresReadChangesUsingWriteAheadLogCDC) GetMethod() SourcePostgresMethod {
	return SourcePostgresMethodCdc
}

func (o *SourcePostgresReadChangesUsingWriteAheadLogCDC) GetPlugin() *SourcePostgresPlugin {
	if o == nil {
		return nil
	}
	return o.Plugin
}

func (o *SourcePostgresReadChangesUsingWriteAheadLogCDC) GetPublication() string {
	if o == nil {
		return ""
	}
	return o.Publication
}

func (o *SourcePostgresReadChangesUsingWriteAheadLogCDC) GetQueueSize() *int64 {
	if o == nil {
		return nil
	}
	return o.QueueSize
}

func (o *SourcePostgresReadChangesUsingWriteAheadLogCDC) GetReplicationSlot() string {
	if o == nil {
		return ""
	}
	return o.ReplicationSlot
}

type SourcePostgresUpdateMethodType string

const (
	SourcePostgresUpdateMethodTypeReadChangesUsingWriteAheadLogCDC  SourcePostgresUpdateMethodType = "ReadChangesUsingWriteAheadLogCDC"
	SourcePostgresUpdateMethodTypeDetectChangesWithXminSystemColumn SourcePostgresUpdateMethodType = "DetectChangesWithXminSystemColumn"
	SourcePostgresUpdateMethodTypeScanChangesWithUserDefinedCursor  SourcePostgresUpdateMethodType = "ScanChangesWithUserDefinedCursor"
)

type SourcePostgresUpdateMethod struct {
	ReadChangesUsingWriteAheadLogCDC  *SourcePostgresReadChangesUsingWriteAheadLogCDC
	DetectChangesWithXminSystemColumn *SourcePostgresDetectChangesWithXminSystemColumn
	ScanChangesWithUserDefinedCursor  *SourcePostgresScanChangesWithUserDefinedCursor

	Type SourcePostgresUpdateMethodType
}

func CreateSourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDC(readChangesUsingWriteAheadLogCDC SourcePostgresReadChangesUsingWriteAheadLogCDC) SourcePostgresUpdateMethod {
	typ := SourcePostgresUpdateMethodTypeReadChangesUsingWriteAheadLogCDC

	return SourcePostgresUpdateMethod{
		ReadChangesUsingWriteAheadLogCDC: &readChangesUsingWriteAheadLogCDC,
		Type:                             typ,
	}
}

func CreateSourcePostgresUpdateMethodDetectChangesWithXminSystemColumn(detectChangesWithXminSystemColumn SourcePostgresDetectChangesWithXminSystemColumn) SourcePostgresUpdateMethod {
	typ := SourcePostgresUpdateMethodTypeDetectChangesWithXminSystemColumn

	return SourcePostgresUpdateMethod{
		DetectChangesWithXminSystemColumn: &detectChangesWithXminSystemColumn,
		Type:                              typ,
	}
}

func CreateSourcePostgresUpdateMethodScanChangesWithUserDefinedCursor(scanChangesWithUserDefinedCursor SourcePostgresScanChangesWithUserDefinedCursor) SourcePostgresUpdateMethod {
	typ := SourcePostgresUpdateMethodTypeScanChangesWithUserDefinedCursor

	return SourcePostgresUpdateMethod{
		ScanChangesWithUserDefinedCursor: &scanChangesWithUserDefinedCursor,
		Type:                             typ,
	}
}

func (u *SourcePostgresUpdateMethod) UnmarshalJSON(data []byte) error {

	detectChangesWithXminSystemColumn := new(SourcePostgresDetectChangesWithXminSystemColumn)
	if err := utils.UnmarshalJSON(data, &detectChangesWithXminSystemColumn, "", true, true); err == nil {
		u.DetectChangesWithXminSystemColumn = detectChangesWithXminSystemColumn
		u.Type = SourcePostgresUpdateMethodTypeDetectChangesWithXminSystemColumn
		return nil
	}

	scanChangesWithUserDefinedCursor := new(SourcePostgresScanChangesWithUserDefinedCursor)
	if err := utils.UnmarshalJSON(data, &scanChangesWithUserDefinedCursor, "", true, true); err == nil {
		u.ScanChangesWithUserDefinedCursor = scanChangesWithUserDefinedCursor
		u.Type = SourcePostgresUpdateMethodTypeScanChangesWithUserDefinedCursor
		return nil
	}

	readChangesUsingWriteAheadLogCDC := new(SourcePostgresReadChangesUsingWriteAheadLogCDC)
	if err := utils.UnmarshalJSON(data, &readChangesUsingWriteAheadLogCDC, "", true, true); err == nil {
		u.ReadChangesUsingWriteAheadLogCDC = readChangesUsingWriteAheadLogCDC
		u.Type = SourcePostgresUpdateMethodTypeReadChangesUsingWriteAheadLogCDC
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SourcePostgresUpdateMethod) MarshalJSON() ([]byte, error) {
	if u.ReadChangesUsingWriteAheadLogCDC != nil {
		return utils.MarshalJSON(u.ReadChangesUsingWriteAheadLogCDC, "", true)
	}

	if u.DetectChangesWithXminSystemColumn != nil {
		return utils.MarshalJSON(u.DetectChangesWithXminSystemColumn, "", true)
	}

	if u.ScanChangesWithUserDefinedCursor != nil {
		return utils.MarshalJSON(u.ScanChangesWithUserDefinedCursor, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type SourcePostgresPostgres string

const (
	SourcePostgresPostgresPostgres SourcePostgresPostgres = "postgres"
)

func (e SourcePostgresPostgres) ToPointer() *SourcePostgresPostgres {
	return &e
}

func (e *SourcePostgresPostgres) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "postgres":
		*e = SourcePostgresPostgres(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresPostgres: %v", v)
	}
}

type SourcePostgresSchemasSSLModeSSLModes6Mode string

const (
	SourcePostgresSchemasSSLModeSSLModes6ModeVerifyFull SourcePostgresSchemasSSLModeSSLModes6Mode = "verify-full"
)

func (e SourcePostgresSchemasSSLModeSSLModes6Mode) ToPointer() *SourcePostgresSchemasSSLModeSSLModes6Mode {
	return &e
}

func (e *SourcePostgresSchemasSSLModeSSLModes6Mode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "verify-full":
		*e = SourcePostgresSchemasSSLModeSSLModes6Mode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresSchemasSSLModeSSLModes6Mode: %v", v)
	}
}

// SourcePostgresVerifyFull - This is the most secure mode. Always require encryption and verifies the identity of the source database server.
type SourcePostgresVerifyFull struct {
	AdditionalProperties interface{} `additionalProperties:"true" json:"-"`
	// CA certificate
	CaCertificate string `json:"ca_certificate"`
	// Client certificate
	ClientCertificate *string `json:"client_certificate,omitempty"`
	// Client key
	ClientKey *string `json:"client_key,omitempty"`
	// Password for keystorage. If you do not add it - the password will be generated automatically.
	ClientKeyPassword *string                                   `json:"client_key_password,omitempty"`
	mode              SourcePostgresSchemasSSLModeSSLModes6Mode `const:"verify-full" json:"mode"`
}

func (s SourcePostgresVerifyFull) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresVerifyFull) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresVerifyFull) GetAdditionalProperties() interface{} {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *SourcePostgresVerifyFull) GetCaCertificate() string {
	if o == nil {
		return ""
	}
	return o.CaCertificate
}

func (o *SourcePostgresVerifyFull) GetClientCertificate() *string {
	if o == nil {
		return nil
	}
	return o.ClientCertificate
}

func (o *SourcePostgresVerifyFull) GetClientKey() *string {
	if o == nil {
		return nil
	}
	return o.ClientKey
}

func (o *SourcePostgresVerifyFull) GetClientKeyPassword() *string {
	if o == nil {
		return nil
	}
	return o.ClientKeyPassword
}

func (o *SourcePostgresVerifyFull) GetMode() SourcePostgresSchemasSSLModeSSLModes6Mode {
	return SourcePostgresSchemasSSLModeSSLModes6ModeVerifyFull
}

type SourcePostgresSchemasSSLModeSSLModes5Mode string

const (
	SourcePostgresSchemasSSLModeSSLModes5ModeVerifyCa SourcePostgresSchemasSSLModeSSLModes5Mode = "verify-ca"
)

func (e SourcePostgresSchemasSSLModeSSLModes5Mode) ToPointer() *SourcePostgresSchemasSSLModeSSLModes5Mode {
	return &e
}

func (e *SourcePostgresSchemasSSLModeSSLModes5Mode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "verify-ca":
		*e = SourcePostgresSchemasSSLModeSSLModes5Mode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresSchemasSSLModeSSLModes5Mode: %v", v)
	}
}

// SourcePostgresVerifyCa - Always require encryption and verifies that the source database server has a valid SSL certificate.
type SourcePostgresVerifyCa struct {
	AdditionalProperties interface{} `additionalProperties:"true" json:"-"`
	// CA certificate
	CaCertificate string `json:"ca_certificate"`
	// Client certificate
	ClientCertificate *string `json:"client_certificate,omitempty"`
	// Client key
	ClientKey *string `json:"client_key,omitempty"`
	// Password for keystorage. If you do not add it - the password will be generated automatically.
	ClientKeyPassword *string                                   `json:"client_key_password,omitempty"`
	mode              SourcePostgresSchemasSSLModeSSLModes5Mode `const:"verify-ca" json:"mode"`
}

func (s SourcePostgresVerifyCa) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresVerifyCa) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresVerifyCa) GetAdditionalProperties() interface{} {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *SourcePostgresVerifyCa) GetCaCertificate() string {
	if o == nil {
		return ""
	}
	return o.CaCertificate
}

func (o *SourcePostgresVerifyCa) GetClientCertificate() *string {
	if o == nil {
		return nil
	}
	return o.ClientCertificate
}

func (o *SourcePostgresVerifyCa) GetClientKey() *string {
	if o == nil {
		return nil
	}
	return o.ClientKey
}

func (o *SourcePostgresVerifyCa) GetClientKeyPassword() *string {
	if o == nil {
		return nil
	}
	return o.ClientKeyPassword
}

func (o *SourcePostgresVerifyCa) GetMode() SourcePostgresSchemasSSLModeSSLModes5Mode {
	return SourcePostgresSchemasSSLModeSSLModes5ModeVerifyCa
}

type SourcePostgresSchemasSSLModeSSLModesMode string

const (
	SourcePostgresSchemasSSLModeSSLModesModeRequire SourcePostgresSchemasSSLModeSSLModesMode = "require"
)

func (e SourcePostgresSchemasSSLModeSSLModesMode) ToPointer() *SourcePostgresSchemasSSLModeSSLModesMode {
	return &e
}

func (e *SourcePostgresSchemasSSLModeSSLModesMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "require":
		*e = SourcePostgresSchemasSSLModeSSLModesMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresSchemasSSLModeSSLModesMode: %v", v)
	}
}

// SourcePostgresRequire - Always require encryption. If the source database server does not support encryption, connection will fail.
type SourcePostgresRequire struct {
	AdditionalProperties interface{}                              `additionalProperties:"true" json:"-"`
	mode                 SourcePostgresSchemasSSLModeSSLModesMode `const:"require" json:"mode"`
}

func (s SourcePostgresRequire) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresRequire) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresRequire) GetAdditionalProperties() interface{} {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *SourcePostgresRequire) GetMode() SourcePostgresSchemasSSLModeSSLModesMode {
	return SourcePostgresSchemasSSLModeSSLModesModeRequire
}

type SourcePostgresSchemasSslModeMode string

const (
	SourcePostgresSchemasSslModeModePrefer SourcePostgresSchemasSslModeMode = "prefer"
)

func (e SourcePostgresSchemasSslModeMode) ToPointer() *SourcePostgresSchemasSslModeMode {
	return &e
}

func (e *SourcePostgresSchemasSslModeMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "prefer":
		*e = SourcePostgresSchemasSslModeMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresSchemasSslModeMode: %v", v)
	}
}

// SourcePostgresPrefer - Allows unencrypted connection only if the source database does not support encryption.
type SourcePostgresPrefer struct {
	AdditionalProperties interface{}                      `additionalProperties:"true" json:"-"`
	mode                 SourcePostgresSchemasSslModeMode `const:"prefer" json:"mode"`
}

func (s SourcePostgresPrefer) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresPrefer) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresPrefer) GetAdditionalProperties() interface{} {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *SourcePostgresPrefer) GetMode() SourcePostgresSchemasSslModeMode {
	return SourcePostgresSchemasSslModeModePrefer
}

type SourcePostgresSchemasMode string

const (
	SourcePostgresSchemasModeAllow SourcePostgresSchemasMode = "allow"
)

func (e SourcePostgresSchemasMode) ToPointer() *SourcePostgresSchemasMode {
	return &e
}

func (e *SourcePostgresSchemasMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "allow":
		*e = SourcePostgresSchemasMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresSchemasMode: %v", v)
	}
}

// SourcePostgresAllow - Enables encryption only when required by the source database.
type SourcePostgresAllow struct {
	AdditionalProperties interface{}               `additionalProperties:"true" json:"-"`
	mode                 SourcePostgresSchemasMode `const:"allow" json:"mode"`
}

func (s SourcePostgresAllow) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresAllow) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresAllow) GetAdditionalProperties() interface{} {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *SourcePostgresAllow) GetMode() SourcePostgresSchemasMode {
	return SourcePostgresSchemasModeAllow
}

type SourcePostgresMode string

const (
	SourcePostgresModeDisable SourcePostgresMode = "disable"
)

func (e SourcePostgresMode) ToPointer() *SourcePostgresMode {
	return &e
}

func (e *SourcePostgresMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "disable":
		*e = SourcePostgresMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresMode: %v", v)
	}
}

// SourcePostgresDisable - Disables encryption of communication between Airbyte and source database.
type SourcePostgresDisable struct {
	AdditionalProperties interface{}        `additionalProperties:"true" json:"-"`
	mode                 SourcePostgresMode `const:"disable" json:"mode"`
}

func (s SourcePostgresDisable) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresDisable) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresDisable) GetAdditionalProperties() interface{} {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *SourcePostgresDisable) GetMode() SourcePostgresMode {
	return SourcePostgresModeDisable
}

type SourcePostgresSSLModesType string

const (
	SourcePostgresSSLModesTypeDisable    SourcePostgresSSLModesType = "Disable"
	SourcePostgresSSLModesTypeAllow      SourcePostgresSSLModesType = "Allow"
	SourcePostgresSSLModesTypePrefer     SourcePostgresSSLModesType = "Prefer"
	SourcePostgresSSLModesTypeRequire    SourcePostgresSSLModesType = "Require"
	SourcePostgresSSLModesTypeVerifyCa   SourcePostgresSSLModesType = "VerifyCa"
	SourcePostgresSSLModesTypeVerifyFull SourcePostgresSSLModesType = "VerifyFull"
)

type SourcePostgresSSLModes struct {
	Disable    *SourcePostgresDisable
	Allow      *SourcePostgresAllow
	Prefer     *SourcePostgresPrefer
	Require    *SourcePostgresRequire
	VerifyCa   *SourcePostgresVerifyCa
	VerifyFull *SourcePostgresVerifyFull

	Type SourcePostgresSSLModesType
}

func CreateSourcePostgresSSLModesDisable(disable SourcePostgresDisable) SourcePostgresSSLModes {
	typ := SourcePostgresSSLModesTypeDisable

	return SourcePostgresSSLModes{
		Disable: &disable,
		Type:    typ,
	}
}

func CreateSourcePostgresSSLModesAllow(allow SourcePostgresAllow) SourcePostgresSSLModes {
	typ := SourcePostgresSSLModesTypeAllow

	return SourcePostgresSSLModes{
		Allow: &allow,
		Type:  typ,
	}
}

func CreateSourcePostgresSSLModesPrefer(prefer SourcePostgresPrefer) SourcePostgresSSLModes {
	typ := SourcePostgresSSLModesTypePrefer

	return SourcePostgresSSLModes{
		Prefer: &prefer,
		Type:   typ,
	}
}

func CreateSourcePostgresSSLModesRequire(require SourcePostgresRequire) SourcePostgresSSLModes {
	typ := SourcePostgresSSLModesTypeRequire

	return SourcePostgresSSLModes{
		Require: &require,
		Type:    typ,
	}
}

func CreateSourcePostgresSSLModesVerifyCa(verifyCa SourcePostgresVerifyCa) SourcePostgresSSLModes {
	typ := SourcePostgresSSLModesTypeVerifyCa

	return SourcePostgresSSLModes{
		VerifyCa: &verifyCa,
		Type:     typ,
	}
}

func CreateSourcePostgresSSLModesVerifyFull(verifyFull SourcePostgresVerifyFull) SourcePostgresSSLModes {
	typ := SourcePostgresSSLModesTypeVerifyFull

	return SourcePostgresSSLModes{
		VerifyFull: &verifyFull,
		Type:       typ,
	}
}

func (u *SourcePostgresSSLModes) UnmarshalJSON(data []byte) error {

	disable := new(SourcePostgresDisable)
	if err := utils.UnmarshalJSON(data, &disable, "", true, true); err == nil {
		u.Disable = disable
		u.Type = SourcePostgresSSLModesTypeDisable
		return nil
	}

	allow := new(SourcePostgresAllow)
	if err := utils.UnmarshalJSON(data, &allow, "", true, true); err == nil {
		u.Allow = allow
		u.Type = SourcePostgresSSLModesTypeAllow
		return nil
	}

	prefer := new(SourcePostgresPrefer)
	if err := utils.UnmarshalJSON(data, &prefer, "", true, true); err == nil {
		u.Prefer = prefer
		u.Type = SourcePostgresSSLModesTypePrefer
		return nil
	}

	require := new(SourcePostgresRequire)
	if err := utils.UnmarshalJSON(data, &require, "", true, true); err == nil {
		u.Require = require
		u.Type = SourcePostgresSSLModesTypeRequire
		return nil
	}

	verifyCa := new(SourcePostgresVerifyCa)
	if err := utils.UnmarshalJSON(data, &verifyCa, "", true, true); err == nil {
		u.VerifyCa = verifyCa
		u.Type = SourcePostgresSSLModesTypeVerifyCa
		return nil
	}

	verifyFull := new(SourcePostgresVerifyFull)
	if err := utils.UnmarshalJSON(data, &verifyFull, "", true, true); err == nil {
		u.VerifyFull = verifyFull
		u.Type = SourcePostgresSSLModesTypeVerifyFull
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SourcePostgresSSLModes) MarshalJSON() ([]byte, error) {
	if u.Disable != nil {
		return utils.MarshalJSON(u.Disable, "", true)
	}

	if u.Allow != nil {
		return utils.MarshalJSON(u.Allow, "", true)
	}

	if u.Prefer != nil {
		return utils.MarshalJSON(u.Prefer, "", true)
	}

	if u.Require != nil {
		return utils.MarshalJSON(u.Require, "", true)
	}

	if u.VerifyCa != nil {
		return utils.MarshalJSON(u.VerifyCa, "", true)
	}

	if u.VerifyFull != nil {
		return utils.MarshalJSON(u.VerifyFull, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

// SourcePostgresSchemasTunnelMethodTunnelMethod - Connect through a jump server tunnel host using username and password authentication
type SourcePostgresSchemasTunnelMethodTunnelMethod string

const (
	SourcePostgresSchemasTunnelMethodTunnelMethodSSHPasswordAuth SourcePostgresSchemasTunnelMethodTunnelMethod = "SSH_PASSWORD_AUTH"
)

func (e SourcePostgresSchemasTunnelMethodTunnelMethod) ToPointer() *SourcePostgresSchemasTunnelMethodTunnelMethod {
	return &e
}

func (e *SourcePostgresSchemasTunnelMethodTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_PASSWORD_AUTH":
		*e = SourcePostgresSchemasTunnelMethodTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresSchemasTunnelMethodTunnelMethod: %v", v)
	}
}

// SourcePostgresPasswordAuthentication - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourcePostgresPasswordAuthentication struct {
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and password authentication
	tunnelMethod SourcePostgresSchemasTunnelMethodTunnelMethod `const:"SSH_PASSWORD_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser string `json:"tunnel_user"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword string `json:"tunnel_user_password"`
}

func (s SourcePostgresPasswordAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresPasswordAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresPasswordAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *SourcePostgresPasswordAuthentication) GetTunnelMethod() SourcePostgresSchemasTunnelMethodTunnelMethod {
	return SourcePostgresSchemasTunnelMethodTunnelMethodSSHPasswordAuth
}

func (o *SourcePostgresPasswordAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *SourcePostgresPasswordAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

func (o *SourcePostgresPasswordAuthentication) GetTunnelUserPassword() string {
	if o == nil {
		return ""
	}
	return o.TunnelUserPassword
}

// SourcePostgresSchemasTunnelMethod - Connect through a jump server tunnel host using username and ssh key
type SourcePostgresSchemasTunnelMethod string

const (
	SourcePostgresSchemasTunnelMethodSSHKeyAuth SourcePostgresSchemasTunnelMethod = "SSH_KEY_AUTH"
)

func (e SourcePostgresSchemasTunnelMethod) ToPointer() *SourcePostgresSchemasTunnelMethod {
	return &e
}

func (e *SourcePostgresSchemasTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_KEY_AUTH":
		*e = SourcePostgresSchemasTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresSchemasTunnelMethod: %v", v)
	}
}

// SourcePostgresSSHKeyAuthentication - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourcePostgresSSHKeyAuthentication struct {
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey string `json:"ssh_key"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and ssh key
	tunnelMethod SourcePostgresSchemasTunnelMethod `const:"SSH_KEY_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host.
	TunnelUser string `json:"tunnel_user"`
}

func (s SourcePostgresSSHKeyAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresSSHKeyAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresSSHKeyAuthentication) GetSSHKey() string {
	if o == nil {
		return ""
	}
	return o.SSHKey
}

func (o *SourcePostgresSSHKeyAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *SourcePostgresSSHKeyAuthentication) GetTunnelMethod() SourcePostgresSchemasTunnelMethod {
	return SourcePostgresSchemasTunnelMethodSSHKeyAuth
}

func (o *SourcePostgresSSHKeyAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *SourcePostgresSSHKeyAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

// SourcePostgresTunnelMethod - No ssh tunnel needed to connect to database
type SourcePostgresTunnelMethod string

const (
	SourcePostgresTunnelMethodNoTunnel SourcePostgresTunnelMethod = "NO_TUNNEL"
)

func (e SourcePostgresTunnelMethod) ToPointer() *SourcePostgresTunnelMethod {
	return &e
}

func (e *SourcePostgresTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NO_TUNNEL":
		*e = SourcePostgresTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresTunnelMethod: %v", v)
	}
}

// SourcePostgresNoTunnel - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourcePostgresNoTunnel struct {
	// No ssh tunnel needed to connect to database
	tunnelMethod SourcePostgresTunnelMethod `const:"NO_TUNNEL" json:"tunnel_method"`
}

func (s SourcePostgresNoTunnel) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresNoTunnel) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresNoTunnel) GetTunnelMethod() SourcePostgresTunnelMethod {
	return SourcePostgresTunnelMethodNoTunnel
}

type SourcePostgresSSHTunnelMethodType string

const (
	SourcePostgresSSHTunnelMethodTypeNoTunnel               SourcePostgresSSHTunnelMethodType = "NoTunnel"
	SourcePostgresSSHTunnelMethodTypeSSHKeyAuthentication   SourcePostgresSSHTunnelMethodType = "SSHKeyAuthentication"
	SourcePostgresSSHTunnelMethodTypePasswordAuthentication SourcePostgresSSHTunnelMethodType = "PasswordAuthentication"
)

type SourcePostgresSSHTunnelMethod struct {
	NoTunnel               *SourcePostgresNoTunnel
	SSHKeyAuthentication   *SourcePostgresSSHKeyAuthentication
	PasswordAuthentication *SourcePostgresPasswordAuthentication

	Type SourcePostgresSSHTunnelMethodType
}

func CreateSourcePostgresSSHTunnelMethodNoTunnel(noTunnel SourcePostgresNoTunnel) SourcePostgresSSHTunnelMethod {
	typ := SourcePostgresSSHTunnelMethodTypeNoTunnel

	return SourcePostgresSSHTunnelMethod{
		NoTunnel: &noTunnel,
		Type:     typ,
	}
}

func CreateSourcePostgresSSHTunnelMethodSSHKeyAuthentication(sshKeyAuthentication SourcePostgresSSHKeyAuthentication) SourcePostgresSSHTunnelMethod {
	typ := SourcePostgresSSHTunnelMethodTypeSSHKeyAuthentication

	return SourcePostgresSSHTunnelMethod{
		SSHKeyAuthentication: &sshKeyAuthentication,
		Type:                 typ,
	}
}

func CreateSourcePostgresSSHTunnelMethodPasswordAuthentication(passwordAuthentication SourcePostgresPasswordAuthentication) SourcePostgresSSHTunnelMethod {
	typ := SourcePostgresSSHTunnelMethodTypePasswordAuthentication

	return SourcePostgresSSHTunnelMethod{
		PasswordAuthentication: &passwordAuthentication,
		Type:                   typ,
	}
}

func (u *SourcePostgresSSHTunnelMethod) UnmarshalJSON(data []byte) error {

	noTunnel := new(SourcePostgresNoTunnel)
	if err := utils.UnmarshalJSON(data, &noTunnel, "", true, true); err == nil {
		u.NoTunnel = noTunnel
		u.Type = SourcePostgresSSHTunnelMethodTypeNoTunnel
		return nil
	}

	sshKeyAuthentication := new(SourcePostgresSSHKeyAuthentication)
	if err := utils.UnmarshalJSON(data, &sshKeyAuthentication, "", true, true); err == nil {
		u.SSHKeyAuthentication = sshKeyAuthentication
		u.Type = SourcePostgresSSHTunnelMethodTypeSSHKeyAuthentication
		return nil
	}

	passwordAuthentication := new(SourcePostgresPasswordAuthentication)
	if err := utils.UnmarshalJSON(data, &passwordAuthentication, "", true, true); err == nil {
		u.PasswordAuthentication = passwordAuthentication
		u.Type = SourcePostgresSSHTunnelMethodTypePasswordAuthentication
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SourcePostgresSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.NoTunnel != nil {
		return utils.MarshalJSON(u.NoTunnel, "", true)
	}

	if u.SSHKeyAuthentication != nil {
		return utils.MarshalJSON(u.SSHKeyAuthentication, "", true)
	}

	if u.PasswordAuthentication != nil {
		return utils.MarshalJSON(u.PasswordAuthentication, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type SourcePostgres struct {
	// Name of the database.
	Database string `json:"database"`
	// Hostname of the database.
	Host string `json:"host"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (Eg. key1=value1&key2=value2&key3=value3). For more information read about <a href="https://jdbc.postgresql.org/documentation/head/connect.html">JDBC URL parameters</a>.
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// Password associated with the username.
	Password *string `json:"password,omitempty"`
	// Port of the database.
	Port *int64 `default:"5432" json:"port"`
	// Configures how data is extracted from the database.
	ReplicationMethod *SourcePostgresUpdateMethod `json:"replication_method,omitempty"`
	// The list of schemas (case sensitive) to sync from. Defaults to public.
	Schemas    []string               `json:"schemas,omitempty"`
	sourceType SourcePostgresPostgres `const:"postgres" json:"sourceType"`
	// SSL connection modes.
	//   Read more <a href="https://jdbc.postgresql.org/documentation/head/ssl-client.html"> in the docs</a>.
	SslMode *SourcePostgresSSLModes `json:"ssl_mode,omitempty"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod *SourcePostgresSSHTunnelMethod `json:"tunnel_method,omitempty"`
	// Username to access the database.
	Username string `json:"username"`
}

func (s SourcePostgres) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgres) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgres) GetDatabase() string {
	if o == nil {
		return ""
	}
	return o.Database
}

func (o *SourcePostgres) GetHost() string {
	if o == nil {
		return ""
	}
	return o.Host
}

func (o *SourcePostgres) GetJdbcURLParams() *string {
	if o == nil {
		return nil
	}
	return o.JdbcURLParams
}

func (o *SourcePostgres) GetPassword() *string {
	if o == nil {
		return nil
	}
	return o.Password
}

func (o *SourcePostgres) GetPort() *int64 {
	if o == nil {
		return nil
	}
	return o.Port
}

func (o *SourcePostgres) GetReplicationMethod() *SourcePostgresUpdateMethod {
	if o == nil {
		return nil
	}
	return o.ReplicationMethod
}

func (o *SourcePostgres) GetSchemas() []string {
	if o == nil {
		return nil
	}
	return o.Schemas
}

func (o *SourcePostgres) GetSourceType() SourcePostgresPostgres {
	return SourcePostgresPostgresPostgres
}

func (o *SourcePostgres) GetSslMode() *SourcePostgresSSLModes {
	if o == nil {
		return nil
	}
	return o.SslMode
}

func (o *SourcePostgres) GetTunnelMethod() *SourcePostgresSSHTunnelMethod {
	if o == nil {
		return nil
	}
	return o.TunnelMethod
}

func (o *SourcePostgres) GetUsername() string {
	if o == nil {
		return ""
	}
	return o.Username
}
