// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"airbyte/internal/sdk/pkg/utils"
	"encoding/json"
	"errors"
	"fmt"
)

type SourcePostgresUpdateMethodScanChangesWithUserDefinedCursorMethod string

const (
	SourcePostgresUpdateMethodScanChangesWithUserDefinedCursorMethodStandard SourcePostgresUpdateMethodScanChangesWithUserDefinedCursorMethod = "Standard"
)

func (e SourcePostgresUpdateMethodScanChangesWithUserDefinedCursorMethod) ToPointer() *SourcePostgresUpdateMethodScanChangesWithUserDefinedCursorMethod {
	return &e
}

func (e *SourcePostgresUpdateMethodScanChangesWithUserDefinedCursorMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Standard":
		*e = SourcePostgresUpdateMethodScanChangesWithUserDefinedCursorMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresUpdateMethodScanChangesWithUserDefinedCursorMethod: %v", v)
	}
}

// SourcePostgresUpdateMethodScanChangesWithUserDefinedCursor - Incrementally detects new inserts and updates using the <a href="https://docs.airbyte.com/understanding-airbyte/connections/incremental-append/#user-defined-cursor">cursor column</a> chosen when configuring a connection (e.g. created_at, updated_at).
type SourcePostgresUpdateMethodScanChangesWithUserDefinedCursor struct {
	method SourcePostgresUpdateMethodScanChangesWithUserDefinedCursorMethod `const:"Standard" json:"method"`
}

func (s SourcePostgresUpdateMethodScanChangesWithUserDefinedCursor) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresUpdateMethodScanChangesWithUserDefinedCursor) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresUpdateMethodScanChangesWithUserDefinedCursor) GetMethod() SourcePostgresUpdateMethodScanChangesWithUserDefinedCursorMethod {
	return SourcePostgresUpdateMethodScanChangesWithUserDefinedCursorMethodStandard
}

type SourcePostgresUpdateMethodDetectChangesWithXminSystemColumnMethod string

const (
	SourcePostgresUpdateMethodDetectChangesWithXminSystemColumnMethodXmin SourcePostgresUpdateMethodDetectChangesWithXminSystemColumnMethod = "Xmin"
)

func (e SourcePostgresUpdateMethodDetectChangesWithXminSystemColumnMethod) ToPointer() *SourcePostgresUpdateMethodDetectChangesWithXminSystemColumnMethod {
	return &e
}

func (e *SourcePostgresUpdateMethodDetectChangesWithXminSystemColumnMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Xmin":
		*e = SourcePostgresUpdateMethodDetectChangesWithXminSystemColumnMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresUpdateMethodDetectChangesWithXminSystemColumnMethod: %v", v)
	}
}

// SourcePostgresUpdateMethodDetectChangesWithXminSystemColumn - <i>Recommended</i> - Incrementally reads new inserts and updates via Postgres <a href="https://docs.airbyte.com/integrations/sources/postgres/#xmin">Xmin system column</a>. Only recommended for tables up to 500GB.
type SourcePostgresUpdateMethodDetectChangesWithXminSystemColumn struct {
	method SourcePostgresUpdateMethodDetectChangesWithXminSystemColumnMethod `const:"Xmin" json:"method"`
}

func (s SourcePostgresUpdateMethodDetectChangesWithXminSystemColumn) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresUpdateMethodDetectChangesWithXminSystemColumn) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresUpdateMethodDetectChangesWithXminSystemColumn) GetMethod() SourcePostgresUpdateMethodDetectChangesWithXminSystemColumnMethod {
	return SourcePostgresUpdateMethodDetectChangesWithXminSystemColumnMethodXmin
}

// SourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDCLSNCommitBehaviour - Determines when Airbtye should flush the LSN of processed WAL logs in the source database. `After loading Data in the destination` is default. If `While reading Data` is selected, in case of a downstream failure (while loading data into the destination), next sync would result in a full sync.
type SourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDCLSNCommitBehaviour string

const (
	SourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDCLSNCommitBehaviourWhileReadingData                 SourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDCLSNCommitBehaviour = "While reading Data"
	SourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDCLSNCommitBehaviourAfterLoadingDataInTheDestination SourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDCLSNCommitBehaviour = "After loading Data in the destination"
)

func (e SourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDCLSNCommitBehaviour) ToPointer() *SourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDCLSNCommitBehaviour {
	return &e
}

func (e *SourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDCLSNCommitBehaviour) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "While reading Data":
		fallthrough
	case "After loading Data in the destination":
		*e = SourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDCLSNCommitBehaviour(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDCLSNCommitBehaviour: %v", v)
	}
}

type SourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDCMethod string

const (
	SourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDCMethodCdc SourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDCMethod = "CDC"
)

func (e SourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDCMethod) ToPointer() *SourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDCMethod {
	return &e
}

func (e *SourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDCMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CDC":
		*e = SourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDCMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDCMethod: %v", v)
	}
}

// SourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDCPlugin - A logical decoding plugin installed on the PostgreSQL server.
type SourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDCPlugin string

const (
	SourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDCPluginPgoutput SourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDCPlugin = "pgoutput"
)

func (e SourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDCPlugin) ToPointer() *SourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDCPlugin {
	return &e
}

func (e *SourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDCPlugin) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "pgoutput":
		*e = SourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDCPlugin(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDCPlugin: %v", v)
	}
}

// SourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDC - <i>Recommended</i> - Incrementally reads new inserts, updates, and deletes using the Postgres <a href="https://docs.airbyte.com/integrations/sources/postgres/#cdc">write-ahead log (WAL)</a>. This needs to be configured on the source database itself. Recommended for tables of any size.
type SourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDC struct {
	AdditionalProperties interface{} `additionalProperties:"true" json:"-"`
	// The amount of time the connector will wait when it launches to determine if there is new data to sync or not. Defaults to 300 seconds. Valid range: 120 seconds to 1200 seconds. Read about <a href="https://docs.airbyte.com/integrations/sources/postgres#step-5-optional-set-up-initial-waiting-time">initial waiting time</a>.
	InitialWaitingSeconds *int64 `default:"300" json:"initial_waiting_seconds"`
	// Determines when Airbtye should flush the LSN of processed WAL logs in the source database. `After loading Data in the destination` is default. If `While reading Data` is selected, in case of a downstream failure (while loading data into the destination), next sync would result in a full sync.
	LsnCommitBehaviour *SourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDCLSNCommitBehaviour `default:"After loading Data in the destination" json:"lsn_commit_behaviour"`
	method             SourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDCMethod              `const:"CDC" json:"method"`
	// A logical decoding plugin installed on the PostgreSQL server.
	Plugin *SourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDCPlugin `default:"pgoutput" json:"plugin"`
	// A Postgres publication used for consuming changes. Read about <a href="https://docs.airbyte.com/integrations/sources/postgres#step-4-create-publications-and-replication-identities-for-tables">publications and replication identities</a>.
	Publication string `json:"publication"`
	// The size of the internal queue. This may interfere with memory consumption and efficiency of the connector, please be careful.
	QueueSize *int64 `default:"10000" json:"queue_size"`
	// A plugin logical replication slot. Read about <a href="https://docs.airbyte.com/integrations/sources/postgres#step-3-create-replication-slot">replication slots</a>.
	ReplicationSlot string `json:"replication_slot"`
}

func (s SourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDC) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDC) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDC) GetAdditionalProperties() interface{} {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *SourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDC) GetInitialWaitingSeconds() *int64 {
	if o == nil {
		return nil
	}
	return o.InitialWaitingSeconds
}

func (o *SourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDC) GetLsnCommitBehaviour() *SourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDCLSNCommitBehaviour {
	if o == nil {
		return nil
	}
	return o.LsnCommitBehaviour
}

func (o *SourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDC) GetMethod() SourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDCMethod {
	return SourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDCMethodCdc
}

func (o *SourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDC) GetPlugin() *SourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDCPlugin {
	if o == nil {
		return nil
	}
	return o.Plugin
}

func (o *SourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDC) GetPublication() string {
	if o == nil {
		return ""
	}
	return o.Publication
}

func (o *SourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDC) GetQueueSize() *int64 {
	if o == nil {
		return nil
	}
	return o.QueueSize
}

func (o *SourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDC) GetReplicationSlot() string {
	if o == nil {
		return ""
	}
	return o.ReplicationSlot
}

type SourcePostgresUpdateMethodType string

const (
	SourcePostgresUpdateMethodTypeSourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDC  SourcePostgresUpdateMethodType = "source-postgres_Update Method_Read Changes using Write-Ahead Log (CDC)"
	SourcePostgresUpdateMethodTypeSourcePostgresUpdateMethodDetectChangesWithXminSystemColumn SourcePostgresUpdateMethodType = "source-postgres_Update Method_Detect Changes with Xmin System Column"
	SourcePostgresUpdateMethodTypeSourcePostgresUpdateMethodScanChangesWithUserDefinedCursor  SourcePostgresUpdateMethodType = "source-postgres_Update Method_Scan Changes with User Defined Cursor"
)

type SourcePostgresUpdateMethod struct {
	SourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDC  *SourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDC
	SourcePostgresUpdateMethodDetectChangesWithXminSystemColumn *SourcePostgresUpdateMethodDetectChangesWithXminSystemColumn
	SourcePostgresUpdateMethodScanChangesWithUserDefinedCursor  *SourcePostgresUpdateMethodScanChangesWithUserDefinedCursor

	Type SourcePostgresUpdateMethodType
}

func CreateSourcePostgresUpdateMethodSourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDC(sourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDC SourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDC) SourcePostgresUpdateMethod {
	typ := SourcePostgresUpdateMethodTypeSourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDC

	return SourcePostgresUpdateMethod{
		SourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDC: &sourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDC,
		Type: typ,
	}
}

func CreateSourcePostgresUpdateMethodSourcePostgresUpdateMethodDetectChangesWithXminSystemColumn(sourcePostgresUpdateMethodDetectChangesWithXminSystemColumn SourcePostgresUpdateMethodDetectChangesWithXminSystemColumn) SourcePostgresUpdateMethod {
	typ := SourcePostgresUpdateMethodTypeSourcePostgresUpdateMethodDetectChangesWithXminSystemColumn

	return SourcePostgresUpdateMethod{
		SourcePostgresUpdateMethodDetectChangesWithXminSystemColumn: &sourcePostgresUpdateMethodDetectChangesWithXminSystemColumn,
		Type: typ,
	}
}

func CreateSourcePostgresUpdateMethodSourcePostgresUpdateMethodScanChangesWithUserDefinedCursor(sourcePostgresUpdateMethodScanChangesWithUserDefinedCursor SourcePostgresUpdateMethodScanChangesWithUserDefinedCursor) SourcePostgresUpdateMethod {
	typ := SourcePostgresUpdateMethodTypeSourcePostgresUpdateMethodScanChangesWithUserDefinedCursor

	return SourcePostgresUpdateMethod{
		SourcePostgresUpdateMethodScanChangesWithUserDefinedCursor: &sourcePostgresUpdateMethodScanChangesWithUserDefinedCursor,
		Type: typ,
	}
}

func (u *SourcePostgresUpdateMethod) UnmarshalJSON(data []byte) error {

	sourcePostgresUpdateMethodDetectChangesWithXminSystemColumn := new(SourcePostgresUpdateMethodDetectChangesWithXminSystemColumn)
	if err := utils.UnmarshalJSON(data, &sourcePostgresUpdateMethodDetectChangesWithXminSystemColumn, "", true, true); err == nil {
		u.SourcePostgresUpdateMethodDetectChangesWithXminSystemColumn = sourcePostgresUpdateMethodDetectChangesWithXminSystemColumn
		u.Type = SourcePostgresUpdateMethodTypeSourcePostgresUpdateMethodDetectChangesWithXminSystemColumn
		return nil
	}

	sourcePostgresUpdateMethodScanChangesWithUserDefinedCursor := new(SourcePostgresUpdateMethodScanChangesWithUserDefinedCursor)
	if err := utils.UnmarshalJSON(data, &sourcePostgresUpdateMethodScanChangesWithUserDefinedCursor, "", true, true); err == nil {
		u.SourcePostgresUpdateMethodScanChangesWithUserDefinedCursor = sourcePostgresUpdateMethodScanChangesWithUserDefinedCursor
		u.Type = SourcePostgresUpdateMethodTypeSourcePostgresUpdateMethodScanChangesWithUserDefinedCursor
		return nil
	}

	sourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDC := new(SourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDC)
	if err := utils.UnmarshalJSON(data, &sourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDC, "", true, true); err == nil {
		u.SourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDC = sourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDC
		u.Type = SourcePostgresUpdateMethodTypeSourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDC
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SourcePostgresUpdateMethod) MarshalJSON() ([]byte, error) {
	if u.SourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDC != nil {
		return utils.MarshalJSON(u.SourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDC, "", true)
	}

	if u.SourcePostgresUpdateMethodDetectChangesWithXminSystemColumn != nil {
		return utils.MarshalJSON(u.SourcePostgresUpdateMethodDetectChangesWithXminSystemColumn, "", true)
	}

	if u.SourcePostgresUpdateMethodScanChangesWithUserDefinedCursor != nil {
		return utils.MarshalJSON(u.SourcePostgresUpdateMethodScanChangesWithUserDefinedCursor, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type SourcePostgresPostgres string

const (
	SourcePostgresPostgresPostgres SourcePostgresPostgres = "postgres"
)

func (e SourcePostgresPostgres) ToPointer() *SourcePostgresPostgres {
	return &e
}

func (e *SourcePostgresPostgres) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "postgres":
		*e = SourcePostgresPostgres(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresPostgres: %v", v)
	}
}

type SourcePostgresSSLModesVerifyFullMode string

const (
	SourcePostgresSSLModesVerifyFullModeVerifyFull SourcePostgresSSLModesVerifyFullMode = "verify-full"
)

func (e SourcePostgresSSLModesVerifyFullMode) ToPointer() *SourcePostgresSSLModesVerifyFullMode {
	return &e
}

func (e *SourcePostgresSSLModesVerifyFullMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "verify-full":
		*e = SourcePostgresSSLModesVerifyFullMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresSSLModesVerifyFullMode: %v", v)
	}
}

// SourcePostgresSSLModesVerifyFull - This is the most secure mode. Always require encryption and verifies the identity of the source database server.
type SourcePostgresSSLModesVerifyFull struct {
	AdditionalProperties interface{} `additionalProperties:"true" json:"-"`
	// CA certificate
	CaCertificate string `json:"ca_certificate"`
	// Client certificate
	ClientCertificate *string `json:"client_certificate,omitempty"`
	// Client key
	ClientKey *string `json:"client_key,omitempty"`
	// Password for keystorage. If you do not add it - the password will be generated automatically.
	ClientKeyPassword *string                              `json:"client_key_password,omitempty"`
	mode              SourcePostgresSSLModesVerifyFullMode `const:"verify-full" json:"mode"`
}

func (s SourcePostgresSSLModesVerifyFull) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresSSLModesVerifyFull) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresSSLModesVerifyFull) GetAdditionalProperties() interface{} {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *SourcePostgresSSLModesVerifyFull) GetCaCertificate() string {
	if o == nil {
		return ""
	}
	return o.CaCertificate
}

func (o *SourcePostgresSSLModesVerifyFull) GetClientCertificate() *string {
	if o == nil {
		return nil
	}
	return o.ClientCertificate
}

func (o *SourcePostgresSSLModesVerifyFull) GetClientKey() *string {
	if o == nil {
		return nil
	}
	return o.ClientKey
}

func (o *SourcePostgresSSLModesVerifyFull) GetClientKeyPassword() *string {
	if o == nil {
		return nil
	}
	return o.ClientKeyPassword
}

func (o *SourcePostgresSSLModesVerifyFull) GetMode() SourcePostgresSSLModesVerifyFullMode {
	return SourcePostgresSSLModesVerifyFullModeVerifyFull
}

type SourcePostgresSSLModesVerifyCaMode string

const (
	SourcePostgresSSLModesVerifyCaModeVerifyCa SourcePostgresSSLModesVerifyCaMode = "verify-ca"
)

func (e SourcePostgresSSLModesVerifyCaMode) ToPointer() *SourcePostgresSSLModesVerifyCaMode {
	return &e
}

func (e *SourcePostgresSSLModesVerifyCaMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "verify-ca":
		*e = SourcePostgresSSLModesVerifyCaMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresSSLModesVerifyCaMode: %v", v)
	}
}

// SourcePostgresSSLModesVerifyCa - Always require encryption and verifies that the source database server has a valid SSL certificate.
type SourcePostgresSSLModesVerifyCa struct {
	AdditionalProperties interface{} `additionalProperties:"true" json:"-"`
	// CA certificate
	CaCertificate string `json:"ca_certificate"`
	// Client certificate
	ClientCertificate *string `json:"client_certificate,omitempty"`
	// Client key
	ClientKey *string `json:"client_key,omitempty"`
	// Password for keystorage. If you do not add it - the password will be generated automatically.
	ClientKeyPassword *string                            `json:"client_key_password,omitempty"`
	mode              SourcePostgresSSLModesVerifyCaMode `const:"verify-ca" json:"mode"`
}

func (s SourcePostgresSSLModesVerifyCa) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresSSLModesVerifyCa) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresSSLModesVerifyCa) GetAdditionalProperties() interface{} {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *SourcePostgresSSLModesVerifyCa) GetCaCertificate() string {
	if o == nil {
		return ""
	}
	return o.CaCertificate
}

func (o *SourcePostgresSSLModesVerifyCa) GetClientCertificate() *string {
	if o == nil {
		return nil
	}
	return o.ClientCertificate
}

func (o *SourcePostgresSSLModesVerifyCa) GetClientKey() *string {
	if o == nil {
		return nil
	}
	return o.ClientKey
}

func (o *SourcePostgresSSLModesVerifyCa) GetClientKeyPassword() *string {
	if o == nil {
		return nil
	}
	return o.ClientKeyPassword
}

func (o *SourcePostgresSSLModesVerifyCa) GetMode() SourcePostgresSSLModesVerifyCaMode {
	return SourcePostgresSSLModesVerifyCaModeVerifyCa
}

type SourcePostgresSSLModesRequireMode string

const (
	SourcePostgresSSLModesRequireModeRequire SourcePostgresSSLModesRequireMode = "require"
)

func (e SourcePostgresSSLModesRequireMode) ToPointer() *SourcePostgresSSLModesRequireMode {
	return &e
}

func (e *SourcePostgresSSLModesRequireMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "require":
		*e = SourcePostgresSSLModesRequireMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresSSLModesRequireMode: %v", v)
	}
}

// SourcePostgresSSLModesRequire - Always require encryption. If the source database server does not support encryption, connection will fail.
type SourcePostgresSSLModesRequire struct {
	AdditionalProperties interface{}                       `additionalProperties:"true" json:"-"`
	mode                 SourcePostgresSSLModesRequireMode `const:"require" json:"mode"`
}

func (s SourcePostgresSSLModesRequire) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresSSLModesRequire) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresSSLModesRequire) GetAdditionalProperties() interface{} {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *SourcePostgresSSLModesRequire) GetMode() SourcePostgresSSLModesRequireMode {
	return SourcePostgresSSLModesRequireModeRequire
}

type SourcePostgresSSLModesPreferMode string

const (
	SourcePostgresSSLModesPreferModePrefer SourcePostgresSSLModesPreferMode = "prefer"
)

func (e SourcePostgresSSLModesPreferMode) ToPointer() *SourcePostgresSSLModesPreferMode {
	return &e
}

func (e *SourcePostgresSSLModesPreferMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "prefer":
		*e = SourcePostgresSSLModesPreferMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresSSLModesPreferMode: %v", v)
	}
}

// SourcePostgresSSLModesPrefer - Allows unencrypted connection only if the source database does not support encryption.
type SourcePostgresSSLModesPrefer struct {
	AdditionalProperties interface{}                      `additionalProperties:"true" json:"-"`
	mode                 SourcePostgresSSLModesPreferMode `const:"prefer" json:"mode"`
}

func (s SourcePostgresSSLModesPrefer) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresSSLModesPrefer) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresSSLModesPrefer) GetAdditionalProperties() interface{} {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *SourcePostgresSSLModesPrefer) GetMode() SourcePostgresSSLModesPreferMode {
	return SourcePostgresSSLModesPreferModePrefer
}

type SourcePostgresSSLModesAllowMode string

const (
	SourcePostgresSSLModesAllowModeAllow SourcePostgresSSLModesAllowMode = "allow"
)

func (e SourcePostgresSSLModesAllowMode) ToPointer() *SourcePostgresSSLModesAllowMode {
	return &e
}

func (e *SourcePostgresSSLModesAllowMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "allow":
		*e = SourcePostgresSSLModesAllowMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresSSLModesAllowMode: %v", v)
	}
}

// SourcePostgresSSLModesAllow - Enables encryption only when required by the source database.
type SourcePostgresSSLModesAllow struct {
	AdditionalProperties interface{}                     `additionalProperties:"true" json:"-"`
	mode                 SourcePostgresSSLModesAllowMode `const:"allow" json:"mode"`
}

func (s SourcePostgresSSLModesAllow) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresSSLModesAllow) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresSSLModesAllow) GetAdditionalProperties() interface{} {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *SourcePostgresSSLModesAllow) GetMode() SourcePostgresSSLModesAllowMode {
	return SourcePostgresSSLModesAllowModeAllow
}

type SourcePostgresSSLModesDisableMode string

const (
	SourcePostgresSSLModesDisableModeDisable SourcePostgresSSLModesDisableMode = "disable"
)

func (e SourcePostgresSSLModesDisableMode) ToPointer() *SourcePostgresSSLModesDisableMode {
	return &e
}

func (e *SourcePostgresSSLModesDisableMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "disable":
		*e = SourcePostgresSSLModesDisableMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresSSLModesDisableMode: %v", v)
	}
}

// SourcePostgresSSLModesDisable - Disables encryption of communication between Airbyte and source database.
type SourcePostgresSSLModesDisable struct {
	AdditionalProperties interface{}                       `additionalProperties:"true" json:"-"`
	mode                 SourcePostgresSSLModesDisableMode `const:"disable" json:"mode"`
}

func (s SourcePostgresSSLModesDisable) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresSSLModesDisable) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresSSLModesDisable) GetAdditionalProperties() interface{} {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *SourcePostgresSSLModesDisable) GetMode() SourcePostgresSSLModesDisableMode {
	return SourcePostgresSSLModesDisableModeDisable
}

type SourcePostgresSSLModesType string

const (
	SourcePostgresSSLModesTypeSourcePostgresSSLModesDisable    SourcePostgresSSLModesType = "source-postgres_SSL Modes_disable"
	SourcePostgresSSLModesTypeSourcePostgresSSLModesAllow      SourcePostgresSSLModesType = "source-postgres_SSL Modes_allow"
	SourcePostgresSSLModesTypeSourcePostgresSSLModesPrefer     SourcePostgresSSLModesType = "source-postgres_SSL Modes_prefer"
	SourcePostgresSSLModesTypeSourcePostgresSSLModesRequire    SourcePostgresSSLModesType = "source-postgres_SSL Modes_require"
	SourcePostgresSSLModesTypeSourcePostgresSSLModesVerifyCa   SourcePostgresSSLModesType = "source-postgres_SSL Modes_verify-ca"
	SourcePostgresSSLModesTypeSourcePostgresSSLModesVerifyFull SourcePostgresSSLModesType = "source-postgres_SSL Modes_verify-full"
)

type SourcePostgresSSLModes struct {
	SourcePostgresSSLModesDisable    *SourcePostgresSSLModesDisable
	SourcePostgresSSLModesAllow      *SourcePostgresSSLModesAllow
	SourcePostgresSSLModesPrefer     *SourcePostgresSSLModesPrefer
	SourcePostgresSSLModesRequire    *SourcePostgresSSLModesRequire
	SourcePostgresSSLModesVerifyCa   *SourcePostgresSSLModesVerifyCa
	SourcePostgresSSLModesVerifyFull *SourcePostgresSSLModesVerifyFull

	Type SourcePostgresSSLModesType
}

func CreateSourcePostgresSSLModesSourcePostgresSSLModesDisable(sourcePostgresSSLModesDisable SourcePostgresSSLModesDisable) SourcePostgresSSLModes {
	typ := SourcePostgresSSLModesTypeSourcePostgresSSLModesDisable

	return SourcePostgresSSLModes{
		SourcePostgresSSLModesDisable: &sourcePostgresSSLModesDisable,
		Type:                          typ,
	}
}

func CreateSourcePostgresSSLModesSourcePostgresSSLModesAllow(sourcePostgresSSLModesAllow SourcePostgresSSLModesAllow) SourcePostgresSSLModes {
	typ := SourcePostgresSSLModesTypeSourcePostgresSSLModesAllow

	return SourcePostgresSSLModes{
		SourcePostgresSSLModesAllow: &sourcePostgresSSLModesAllow,
		Type:                        typ,
	}
}

func CreateSourcePostgresSSLModesSourcePostgresSSLModesPrefer(sourcePostgresSSLModesPrefer SourcePostgresSSLModesPrefer) SourcePostgresSSLModes {
	typ := SourcePostgresSSLModesTypeSourcePostgresSSLModesPrefer

	return SourcePostgresSSLModes{
		SourcePostgresSSLModesPrefer: &sourcePostgresSSLModesPrefer,
		Type:                         typ,
	}
}

func CreateSourcePostgresSSLModesSourcePostgresSSLModesRequire(sourcePostgresSSLModesRequire SourcePostgresSSLModesRequire) SourcePostgresSSLModes {
	typ := SourcePostgresSSLModesTypeSourcePostgresSSLModesRequire

	return SourcePostgresSSLModes{
		SourcePostgresSSLModesRequire: &sourcePostgresSSLModesRequire,
		Type:                          typ,
	}
}

func CreateSourcePostgresSSLModesSourcePostgresSSLModesVerifyCa(sourcePostgresSSLModesVerifyCa SourcePostgresSSLModesVerifyCa) SourcePostgresSSLModes {
	typ := SourcePostgresSSLModesTypeSourcePostgresSSLModesVerifyCa

	return SourcePostgresSSLModes{
		SourcePostgresSSLModesVerifyCa: &sourcePostgresSSLModesVerifyCa,
		Type:                           typ,
	}
}

func CreateSourcePostgresSSLModesSourcePostgresSSLModesVerifyFull(sourcePostgresSSLModesVerifyFull SourcePostgresSSLModesVerifyFull) SourcePostgresSSLModes {
	typ := SourcePostgresSSLModesTypeSourcePostgresSSLModesVerifyFull

	return SourcePostgresSSLModes{
		SourcePostgresSSLModesVerifyFull: &sourcePostgresSSLModesVerifyFull,
		Type:                             typ,
	}
}

func (u *SourcePostgresSSLModes) UnmarshalJSON(data []byte) error {

	sourcePostgresSSLModesDisable := new(SourcePostgresSSLModesDisable)
	if err := utils.UnmarshalJSON(data, &sourcePostgresSSLModesDisable, "", true, true); err == nil {
		u.SourcePostgresSSLModesDisable = sourcePostgresSSLModesDisable
		u.Type = SourcePostgresSSLModesTypeSourcePostgresSSLModesDisable
		return nil
	}

	sourcePostgresSSLModesAllow := new(SourcePostgresSSLModesAllow)
	if err := utils.UnmarshalJSON(data, &sourcePostgresSSLModesAllow, "", true, true); err == nil {
		u.SourcePostgresSSLModesAllow = sourcePostgresSSLModesAllow
		u.Type = SourcePostgresSSLModesTypeSourcePostgresSSLModesAllow
		return nil
	}

	sourcePostgresSSLModesPrefer := new(SourcePostgresSSLModesPrefer)
	if err := utils.UnmarshalJSON(data, &sourcePostgresSSLModesPrefer, "", true, true); err == nil {
		u.SourcePostgresSSLModesPrefer = sourcePostgresSSLModesPrefer
		u.Type = SourcePostgresSSLModesTypeSourcePostgresSSLModesPrefer
		return nil
	}

	sourcePostgresSSLModesRequire := new(SourcePostgresSSLModesRequire)
	if err := utils.UnmarshalJSON(data, &sourcePostgresSSLModesRequire, "", true, true); err == nil {
		u.SourcePostgresSSLModesRequire = sourcePostgresSSLModesRequire
		u.Type = SourcePostgresSSLModesTypeSourcePostgresSSLModesRequire
		return nil
	}

	sourcePostgresSSLModesVerifyCa := new(SourcePostgresSSLModesVerifyCa)
	if err := utils.UnmarshalJSON(data, &sourcePostgresSSLModesVerifyCa, "", true, true); err == nil {
		u.SourcePostgresSSLModesVerifyCa = sourcePostgresSSLModesVerifyCa
		u.Type = SourcePostgresSSLModesTypeSourcePostgresSSLModesVerifyCa
		return nil
	}

	sourcePostgresSSLModesVerifyFull := new(SourcePostgresSSLModesVerifyFull)
	if err := utils.UnmarshalJSON(data, &sourcePostgresSSLModesVerifyFull, "", true, true); err == nil {
		u.SourcePostgresSSLModesVerifyFull = sourcePostgresSSLModesVerifyFull
		u.Type = SourcePostgresSSLModesTypeSourcePostgresSSLModesVerifyFull
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SourcePostgresSSLModes) MarshalJSON() ([]byte, error) {
	if u.SourcePostgresSSLModesDisable != nil {
		return utils.MarshalJSON(u.SourcePostgresSSLModesDisable, "", true)
	}

	if u.SourcePostgresSSLModesAllow != nil {
		return utils.MarshalJSON(u.SourcePostgresSSLModesAllow, "", true)
	}

	if u.SourcePostgresSSLModesPrefer != nil {
		return utils.MarshalJSON(u.SourcePostgresSSLModesPrefer, "", true)
	}

	if u.SourcePostgresSSLModesRequire != nil {
		return utils.MarshalJSON(u.SourcePostgresSSLModesRequire, "", true)
	}

	if u.SourcePostgresSSLModesVerifyCa != nil {
		return utils.MarshalJSON(u.SourcePostgresSSLModesVerifyCa, "", true)
	}

	if u.SourcePostgresSSLModesVerifyFull != nil {
		return utils.MarshalJSON(u.SourcePostgresSSLModesVerifyFull, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

// SourcePostgresSSHTunnelMethodPasswordAuthenticationTunnelMethod - Connect through a jump server tunnel host using username and password authentication
type SourcePostgresSSHTunnelMethodPasswordAuthenticationTunnelMethod string

const (
	SourcePostgresSSHTunnelMethodPasswordAuthenticationTunnelMethodSSHPasswordAuth SourcePostgresSSHTunnelMethodPasswordAuthenticationTunnelMethod = "SSH_PASSWORD_AUTH"
)

func (e SourcePostgresSSHTunnelMethodPasswordAuthenticationTunnelMethod) ToPointer() *SourcePostgresSSHTunnelMethodPasswordAuthenticationTunnelMethod {
	return &e
}

func (e *SourcePostgresSSHTunnelMethodPasswordAuthenticationTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_PASSWORD_AUTH":
		*e = SourcePostgresSSHTunnelMethodPasswordAuthenticationTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresSSHTunnelMethodPasswordAuthenticationTunnelMethod: %v", v)
	}
}

// SourcePostgresSSHTunnelMethodPasswordAuthentication - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourcePostgresSSHTunnelMethodPasswordAuthentication struct {
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and password authentication
	tunnelMethod SourcePostgresSSHTunnelMethodPasswordAuthenticationTunnelMethod `const:"SSH_PASSWORD_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser string `json:"tunnel_user"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword string `json:"tunnel_user_password"`
}

func (s SourcePostgresSSHTunnelMethodPasswordAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresSSHTunnelMethodPasswordAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresSSHTunnelMethodPasswordAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *SourcePostgresSSHTunnelMethodPasswordAuthentication) GetTunnelMethod() SourcePostgresSSHTunnelMethodPasswordAuthenticationTunnelMethod {
	return SourcePostgresSSHTunnelMethodPasswordAuthenticationTunnelMethodSSHPasswordAuth
}

func (o *SourcePostgresSSHTunnelMethodPasswordAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *SourcePostgresSSHTunnelMethodPasswordAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

func (o *SourcePostgresSSHTunnelMethodPasswordAuthentication) GetTunnelUserPassword() string {
	if o == nil {
		return ""
	}
	return o.TunnelUserPassword
}

// SourcePostgresSSHTunnelMethodSSHKeyAuthenticationTunnelMethod - Connect through a jump server tunnel host using username and ssh key
type SourcePostgresSSHTunnelMethodSSHKeyAuthenticationTunnelMethod string

const (
	SourcePostgresSSHTunnelMethodSSHKeyAuthenticationTunnelMethodSSHKeyAuth SourcePostgresSSHTunnelMethodSSHKeyAuthenticationTunnelMethod = "SSH_KEY_AUTH"
)

func (e SourcePostgresSSHTunnelMethodSSHKeyAuthenticationTunnelMethod) ToPointer() *SourcePostgresSSHTunnelMethodSSHKeyAuthenticationTunnelMethod {
	return &e
}

func (e *SourcePostgresSSHTunnelMethodSSHKeyAuthenticationTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_KEY_AUTH":
		*e = SourcePostgresSSHTunnelMethodSSHKeyAuthenticationTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresSSHTunnelMethodSSHKeyAuthenticationTunnelMethod: %v", v)
	}
}

// SourcePostgresSSHTunnelMethodSSHKeyAuthentication - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourcePostgresSSHTunnelMethodSSHKeyAuthentication struct {
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey string `json:"ssh_key"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and ssh key
	tunnelMethod SourcePostgresSSHTunnelMethodSSHKeyAuthenticationTunnelMethod `const:"SSH_KEY_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host.
	TunnelUser string `json:"tunnel_user"`
}

func (s SourcePostgresSSHTunnelMethodSSHKeyAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresSSHTunnelMethodSSHKeyAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresSSHTunnelMethodSSHKeyAuthentication) GetSSHKey() string {
	if o == nil {
		return ""
	}
	return o.SSHKey
}

func (o *SourcePostgresSSHTunnelMethodSSHKeyAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *SourcePostgresSSHTunnelMethodSSHKeyAuthentication) GetTunnelMethod() SourcePostgresSSHTunnelMethodSSHKeyAuthenticationTunnelMethod {
	return SourcePostgresSSHTunnelMethodSSHKeyAuthenticationTunnelMethodSSHKeyAuth
}

func (o *SourcePostgresSSHTunnelMethodSSHKeyAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *SourcePostgresSSHTunnelMethodSSHKeyAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

// SourcePostgresSSHTunnelMethodNoTunnelTunnelMethod - No ssh tunnel needed to connect to database
type SourcePostgresSSHTunnelMethodNoTunnelTunnelMethod string

const (
	SourcePostgresSSHTunnelMethodNoTunnelTunnelMethodNoTunnel SourcePostgresSSHTunnelMethodNoTunnelTunnelMethod = "NO_TUNNEL"
)

func (e SourcePostgresSSHTunnelMethodNoTunnelTunnelMethod) ToPointer() *SourcePostgresSSHTunnelMethodNoTunnelTunnelMethod {
	return &e
}

func (e *SourcePostgresSSHTunnelMethodNoTunnelTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NO_TUNNEL":
		*e = SourcePostgresSSHTunnelMethodNoTunnelTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresSSHTunnelMethodNoTunnelTunnelMethod: %v", v)
	}
}

// SourcePostgresSSHTunnelMethodNoTunnel - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourcePostgresSSHTunnelMethodNoTunnel struct {
	// No ssh tunnel needed to connect to database
	tunnelMethod SourcePostgresSSHTunnelMethodNoTunnelTunnelMethod `const:"NO_TUNNEL" json:"tunnel_method"`
}

func (s SourcePostgresSSHTunnelMethodNoTunnel) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresSSHTunnelMethodNoTunnel) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresSSHTunnelMethodNoTunnel) GetTunnelMethod() SourcePostgresSSHTunnelMethodNoTunnelTunnelMethod {
	return SourcePostgresSSHTunnelMethodNoTunnelTunnelMethodNoTunnel
}

type SourcePostgresSSHTunnelMethodType string

const (
	SourcePostgresSSHTunnelMethodTypeSourcePostgresSSHTunnelMethodNoTunnel               SourcePostgresSSHTunnelMethodType = "source-postgres_SSH Tunnel Method_No Tunnel"
	SourcePostgresSSHTunnelMethodTypeSourcePostgresSSHTunnelMethodSSHKeyAuthentication   SourcePostgresSSHTunnelMethodType = "source-postgres_SSH Tunnel Method_SSH Key Authentication"
	SourcePostgresSSHTunnelMethodTypeSourcePostgresSSHTunnelMethodPasswordAuthentication SourcePostgresSSHTunnelMethodType = "source-postgres_SSH Tunnel Method_Password Authentication"
)

type SourcePostgresSSHTunnelMethod struct {
	SourcePostgresSSHTunnelMethodNoTunnel               *SourcePostgresSSHTunnelMethodNoTunnel
	SourcePostgresSSHTunnelMethodSSHKeyAuthentication   *SourcePostgresSSHTunnelMethodSSHKeyAuthentication
	SourcePostgresSSHTunnelMethodPasswordAuthentication *SourcePostgresSSHTunnelMethodPasswordAuthentication

	Type SourcePostgresSSHTunnelMethodType
}

func CreateSourcePostgresSSHTunnelMethodSourcePostgresSSHTunnelMethodNoTunnel(sourcePostgresSSHTunnelMethodNoTunnel SourcePostgresSSHTunnelMethodNoTunnel) SourcePostgresSSHTunnelMethod {
	typ := SourcePostgresSSHTunnelMethodTypeSourcePostgresSSHTunnelMethodNoTunnel

	return SourcePostgresSSHTunnelMethod{
		SourcePostgresSSHTunnelMethodNoTunnel: &sourcePostgresSSHTunnelMethodNoTunnel,
		Type:                                  typ,
	}
}

func CreateSourcePostgresSSHTunnelMethodSourcePostgresSSHTunnelMethodSSHKeyAuthentication(sourcePostgresSSHTunnelMethodSSHKeyAuthentication SourcePostgresSSHTunnelMethodSSHKeyAuthentication) SourcePostgresSSHTunnelMethod {
	typ := SourcePostgresSSHTunnelMethodTypeSourcePostgresSSHTunnelMethodSSHKeyAuthentication

	return SourcePostgresSSHTunnelMethod{
		SourcePostgresSSHTunnelMethodSSHKeyAuthentication: &sourcePostgresSSHTunnelMethodSSHKeyAuthentication,
		Type: typ,
	}
}

func CreateSourcePostgresSSHTunnelMethodSourcePostgresSSHTunnelMethodPasswordAuthentication(sourcePostgresSSHTunnelMethodPasswordAuthentication SourcePostgresSSHTunnelMethodPasswordAuthentication) SourcePostgresSSHTunnelMethod {
	typ := SourcePostgresSSHTunnelMethodTypeSourcePostgresSSHTunnelMethodPasswordAuthentication

	return SourcePostgresSSHTunnelMethod{
		SourcePostgresSSHTunnelMethodPasswordAuthentication: &sourcePostgresSSHTunnelMethodPasswordAuthentication,
		Type: typ,
	}
}

func (u *SourcePostgresSSHTunnelMethod) UnmarshalJSON(data []byte) error {

	sourcePostgresSSHTunnelMethodNoTunnel := new(SourcePostgresSSHTunnelMethodNoTunnel)
	if err := utils.UnmarshalJSON(data, &sourcePostgresSSHTunnelMethodNoTunnel, "", true, true); err == nil {
		u.SourcePostgresSSHTunnelMethodNoTunnel = sourcePostgresSSHTunnelMethodNoTunnel
		u.Type = SourcePostgresSSHTunnelMethodTypeSourcePostgresSSHTunnelMethodNoTunnel
		return nil
	}

	sourcePostgresSSHTunnelMethodSSHKeyAuthentication := new(SourcePostgresSSHTunnelMethodSSHKeyAuthentication)
	if err := utils.UnmarshalJSON(data, &sourcePostgresSSHTunnelMethodSSHKeyAuthentication, "", true, true); err == nil {
		u.SourcePostgresSSHTunnelMethodSSHKeyAuthentication = sourcePostgresSSHTunnelMethodSSHKeyAuthentication
		u.Type = SourcePostgresSSHTunnelMethodTypeSourcePostgresSSHTunnelMethodSSHKeyAuthentication
		return nil
	}

	sourcePostgresSSHTunnelMethodPasswordAuthentication := new(SourcePostgresSSHTunnelMethodPasswordAuthentication)
	if err := utils.UnmarshalJSON(data, &sourcePostgresSSHTunnelMethodPasswordAuthentication, "", true, true); err == nil {
		u.SourcePostgresSSHTunnelMethodPasswordAuthentication = sourcePostgresSSHTunnelMethodPasswordAuthentication
		u.Type = SourcePostgresSSHTunnelMethodTypeSourcePostgresSSHTunnelMethodPasswordAuthentication
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SourcePostgresSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.SourcePostgresSSHTunnelMethodNoTunnel != nil {
		return utils.MarshalJSON(u.SourcePostgresSSHTunnelMethodNoTunnel, "", true)
	}

	if u.SourcePostgresSSHTunnelMethodSSHKeyAuthentication != nil {
		return utils.MarshalJSON(u.SourcePostgresSSHTunnelMethodSSHKeyAuthentication, "", true)
	}

	if u.SourcePostgresSSHTunnelMethodPasswordAuthentication != nil {
		return utils.MarshalJSON(u.SourcePostgresSSHTunnelMethodPasswordAuthentication, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type SourcePostgres struct {
	// Name of the database.
	Database string `json:"database"`
	// Hostname of the database.
	Host string `json:"host"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (Eg. key1=value1&key2=value2&key3=value3). For more information read about <a href="https://jdbc.postgresql.org/documentation/head/connect.html">JDBC URL parameters</a>.
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// Password associated with the username.
	Password *string `json:"password,omitempty"`
	// Port of the database.
	Port *int64 `default:"5432" json:"port"`
	// Configures how data is extracted from the database.
	ReplicationMethod *SourcePostgresUpdateMethod `json:"replication_method,omitempty"`
	// The list of schemas (case sensitive) to sync from. Defaults to public.
	Schemas    []string               `json:"schemas,omitempty"`
	sourceType SourcePostgresPostgres `const:"postgres" json:"sourceType"`
	// SSL connection modes.
	//   Read more <a href="https://jdbc.postgresql.org/documentation/head/ssl-client.html"> in the docs</a>.
	SslMode *SourcePostgresSSLModes `json:"ssl_mode,omitempty"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod *SourcePostgresSSHTunnelMethod `json:"tunnel_method,omitempty"`
	// Username to access the database.
	Username string `json:"username"`
}

func (s SourcePostgres) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgres) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgres) GetDatabase() string {
	if o == nil {
		return ""
	}
	return o.Database
}

func (o *SourcePostgres) GetHost() string {
	if o == nil {
		return ""
	}
	return o.Host
}

func (o *SourcePostgres) GetJdbcURLParams() *string {
	if o == nil {
		return nil
	}
	return o.JdbcURLParams
}

func (o *SourcePostgres) GetPassword() *string {
	if o == nil {
		return nil
	}
	return o.Password
}

func (o *SourcePostgres) GetPort() *int64 {
	if o == nil {
		return nil
	}
	return o.Port
}

func (o *SourcePostgres) GetReplicationMethod() *SourcePostgresUpdateMethod {
	if o == nil {
		return nil
	}
	return o.ReplicationMethod
}

func (o *SourcePostgres) GetSchemas() []string {
	if o == nil {
		return nil
	}
	return o.Schemas
}

func (o *SourcePostgres) GetSourceType() SourcePostgresPostgres {
	return SourcePostgresPostgresPostgres
}

func (o *SourcePostgres) GetSslMode() *SourcePostgresSSLModes {
	if o == nil {
		return nil
	}
	return o.SslMode
}

func (o *SourcePostgres) GetTunnelMethod() *SourcePostgresSSHTunnelMethod {
	if o == nil {
		return nil
	}
	return o.TunnelMethod
}

func (o *SourcePostgres) GetUsername() string {
	if o == nil {
		return ""
	}
	return o.Username
}
