// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"airbyte/internal/sdk/pkg/utils"
	"encoding/json"
	"errors"
	"fmt"
)

type DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIPCompressionType string

const (
	DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIPCompressionTypeGzip DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIPCompressionType = "GZIP"
)

func (e DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIPCompressionType) ToPointer() *DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIPCompressionType {
	return &e
}

func (e *DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIPCompressionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "GZIP":
		*e = DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIPCompressionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIPCompressionType: %v", v)
	}
}

// DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP - Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").
type DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP struct {
	CompressionType *DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIPCompressionType `default:"GZIP" json:"compression_type"`
}

func (d DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP) GetCompressionType() *DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIPCompressionType {
	if o == nil {
		return nil
	}
	return o.CompressionType
}

type DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompressionCompressionType string

const (
	DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompressionCompressionTypeNoCompression DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompressionCompressionType = "No Compression"
)

func (e DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompressionCompressionType) ToPointer() *DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompressionCompressionType {
	return &e
}

func (e *DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompressionCompressionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "No Compression":
		*e = DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompressionCompressionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompressionCompressionType: %v", v)
	}
}

// DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression - Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").
type DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression struct {
	CompressionType *DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompressionCompressionType `default:"No Compression" json:"compression_type"`
}

func (d DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression) GetCompressionType() *DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompressionCompressionType {
	if o == nil {
		return nil
	}
	return o.CompressionType
}

type DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionType string

const (
	DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionTypeDestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionType = "destination-s3-glue-update_Output Format_JSON Lines: Newline-delimited JSON_Compression_No Compression"
	DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionTypeDestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP          DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionType = "destination-s3-glue-update_Output Format_JSON Lines: Newline-delimited JSON_Compression_GZIP"
)

type DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompression struct {
	DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression *DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression
	DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP          *DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP

	Type DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionType
}

func CreateDestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionDestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression(destinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression) DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompression {
	typ := DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionTypeDestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression

	return DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompression{
		DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression: &destinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression,
		Type: typ,
	}
}

func CreateDestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionDestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP(destinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP) DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompression {
	typ := DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionTypeDestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP

	return DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompression{
		DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP: &destinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP,
		Type: typ,
	}
}

func (u *DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompression) UnmarshalJSON(data []byte) error {

	destinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression := new(DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression)
	if err := utils.UnmarshalJSON(data, &destinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression, "", true, true); err == nil {
		u.DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression = destinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression
		u.Type = DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionTypeDestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression
		return nil
	}

	destinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP := new(DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP)
	if err := utils.UnmarshalJSON(data, &destinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP, "", true, true); err == nil {
		u.DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP = destinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP
		u.Type = DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionTypeDestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompression) MarshalJSON() ([]byte, error) {
	if u.DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression != nil {
		return utils.MarshalJSON(u.DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression, "", true)
	}

	if u.DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP != nil {
		return utils.MarshalJSON(u.DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

// DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONFlattening - Whether the input json data should be normalized (flattened) in the output JSON Lines. Please refer to docs for details.
type DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONFlattening string

const (
	DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONFlatteningNoFlattening        DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONFlattening = "No flattening"
	DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONFlatteningRootLevelFlattening DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONFlattening = "Root level flattening"
)

func (e DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONFlattening) ToPointer() *DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONFlattening {
	return &e
}

func (e *DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONFlattening) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "No flattening":
		fallthrough
	case "Root level flattening":
		*e = DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONFlattening(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONFlattening: %v", v)
	}
}

type DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONFormatType string

const (
	DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONFormatTypeJsonl DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONFormatType = "JSONL"
)

func (e DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONFormatType) ToPointer() *DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONFormatType {
	return &e
}

func (e *DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONFormatType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "JSONL":
		*e = DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONFormatType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONFormatType: %v", v)
	}
}

// DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSON - Format of the data output. See <a href="https://docs.airbyte.com/integrations/destinations/s3/#supported-output-schema">here</a> for more details
type DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSON struct {
	// Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").
	Compression *DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompression `json:"compression,omitempty"`
	// Whether the input json data should be normalized (flattened) in the output JSON Lines. Please refer to docs for details.
	Flattening *DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONFlattening `default:"Root level flattening" json:"flattening"`
	FormatType *DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONFormatType `default:"JSONL" json:"format_type"`
}

func (d DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSON) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSON) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSON) GetCompression() *DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompression {
	if o == nil {
		return nil
	}
	return o.Compression
}

func (o *DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSON) GetFlattening() *DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONFlattening {
	if o == nil {
		return nil
	}
	return o.Flattening
}

func (o *DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSON) GetFormatType() *DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSONFormatType {
	if o == nil {
		return nil
	}
	return o.FormatType
}

type DestinationS3GlueUpdateOutputFormatType string

const (
	DestinationS3GlueUpdateOutputFormatTypeDestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSON DestinationS3GlueUpdateOutputFormatType = "destination-s3-glue-update_Output Format_JSON Lines: Newline-delimited JSON"
)

type DestinationS3GlueUpdateOutputFormat struct {
	DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSON *DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSON

	Type DestinationS3GlueUpdateOutputFormatType
}

func CreateDestinationS3GlueUpdateOutputFormatDestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSON(destinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSON DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSON) DestinationS3GlueUpdateOutputFormat {
	typ := DestinationS3GlueUpdateOutputFormatTypeDestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSON

	return DestinationS3GlueUpdateOutputFormat{
		DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSON: &destinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSON,
		Type: typ,
	}
}

func (u *DestinationS3GlueUpdateOutputFormat) UnmarshalJSON(data []byte) error {

	destinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSON := new(DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSON)
	if err := utils.UnmarshalJSON(data, &destinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSON, "", true, true); err == nil {
		u.DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSON = destinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSON
		u.Type = DestinationS3GlueUpdateOutputFormatTypeDestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSON
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u DestinationS3GlueUpdateOutputFormat) MarshalJSON() ([]byte, error) {
	if u.DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSON != nil {
		return utils.MarshalJSON(u.DestinationS3GlueUpdateOutputFormatJSONLinesNewlineDelimitedJSON, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

// DestinationS3GlueUpdateSerializationLibrary - The library that your query engine will use for reading and writing data in your lake.
type DestinationS3GlueUpdateSerializationLibrary string

const (
	DestinationS3GlueUpdateSerializationLibraryOrgOpenxDataJsonserdeJSONSerDe     DestinationS3GlueUpdateSerializationLibrary = "org.openx.data.jsonserde.JsonSerDe"
	DestinationS3GlueUpdateSerializationLibraryOrgApacheHiveHcatalogDataJSONSerDe DestinationS3GlueUpdateSerializationLibrary = "org.apache.hive.hcatalog.data.JsonSerDe"
)

func (e DestinationS3GlueUpdateSerializationLibrary) ToPointer() *DestinationS3GlueUpdateSerializationLibrary {
	return &e
}

func (e *DestinationS3GlueUpdateSerializationLibrary) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "org.openx.data.jsonserde.JsonSerDe":
		fallthrough
	case "org.apache.hive.hcatalog.data.JsonSerDe":
		*e = DestinationS3GlueUpdateSerializationLibrary(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3GlueUpdateSerializationLibrary: %v", v)
	}
}

// DestinationS3GlueUpdateS3BucketRegion - The region of the S3 bucket. See <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-available-regions">here</a> for all region codes.
type DestinationS3GlueUpdateS3BucketRegion string

const (
	DestinationS3GlueUpdateS3BucketRegionUnknown      DestinationS3GlueUpdateS3BucketRegion = ""
	DestinationS3GlueUpdateS3BucketRegionUsEast1      DestinationS3GlueUpdateS3BucketRegion = "us-east-1"
	DestinationS3GlueUpdateS3BucketRegionUsEast2      DestinationS3GlueUpdateS3BucketRegion = "us-east-2"
	DestinationS3GlueUpdateS3BucketRegionUsWest1      DestinationS3GlueUpdateS3BucketRegion = "us-west-1"
	DestinationS3GlueUpdateS3BucketRegionUsWest2      DestinationS3GlueUpdateS3BucketRegion = "us-west-2"
	DestinationS3GlueUpdateS3BucketRegionAfSouth1     DestinationS3GlueUpdateS3BucketRegion = "af-south-1"
	DestinationS3GlueUpdateS3BucketRegionApEast1      DestinationS3GlueUpdateS3BucketRegion = "ap-east-1"
	DestinationS3GlueUpdateS3BucketRegionApSouth1     DestinationS3GlueUpdateS3BucketRegion = "ap-south-1"
	DestinationS3GlueUpdateS3BucketRegionApNortheast1 DestinationS3GlueUpdateS3BucketRegion = "ap-northeast-1"
	DestinationS3GlueUpdateS3BucketRegionApNortheast2 DestinationS3GlueUpdateS3BucketRegion = "ap-northeast-2"
	DestinationS3GlueUpdateS3BucketRegionApNortheast3 DestinationS3GlueUpdateS3BucketRegion = "ap-northeast-3"
	DestinationS3GlueUpdateS3BucketRegionApSoutheast1 DestinationS3GlueUpdateS3BucketRegion = "ap-southeast-1"
	DestinationS3GlueUpdateS3BucketRegionApSoutheast2 DestinationS3GlueUpdateS3BucketRegion = "ap-southeast-2"
	DestinationS3GlueUpdateS3BucketRegionCaCentral1   DestinationS3GlueUpdateS3BucketRegion = "ca-central-1"
	DestinationS3GlueUpdateS3BucketRegionCnNorth1     DestinationS3GlueUpdateS3BucketRegion = "cn-north-1"
	DestinationS3GlueUpdateS3BucketRegionCnNorthwest1 DestinationS3GlueUpdateS3BucketRegion = "cn-northwest-1"
	DestinationS3GlueUpdateS3BucketRegionEuCentral1   DestinationS3GlueUpdateS3BucketRegion = "eu-central-1"
	DestinationS3GlueUpdateS3BucketRegionEuNorth1     DestinationS3GlueUpdateS3BucketRegion = "eu-north-1"
	DestinationS3GlueUpdateS3BucketRegionEuSouth1     DestinationS3GlueUpdateS3BucketRegion = "eu-south-1"
	DestinationS3GlueUpdateS3BucketRegionEuWest1      DestinationS3GlueUpdateS3BucketRegion = "eu-west-1"
	DestinationS3GlueUpdateS3BucketRegionEuWest2      DestinationS3GlueUpdateS3BucketRegion = "eu-west-2"
	DestinationS3GlueUpdateS3BucketRegionEuWest3      DestinationS3GlueUpdateS3BucketRegion = "eu-west-3"
	DestinationS3GlueUpdateS3BucketRegionSaEast1      DestinationS3GlueUpdateS3BucketRegion = "sa-east-1"
	DestinationS3GlueUpdateS3BucketRegionMeSouth1     DestinationS3GlueUpdateS3BucketRegion = "me-south-1"
	DestinationS3GlueUpdateS3BucketRegionUsGovEast1   DestinationS3GlueUpdateS3BucketRegion = "us-gov-east-1"
	DestinationS3GlueUpdateS3BucketRegionUsGovWest1   DestinationS3GlueUpdateS3BucketRegion = "us-gov-west-1"
)

func (e DestinationS3GlueUpdateS3BucketRegion) ToPointer() *DestinationS3GlueUpdateS3BucketRegion {
	return &e
}

func (e *DestinationS3GlueUpdateS3BucketRegion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "":
		fallthrough
	case "us-east-1":
		fallthrough
	case "us-east-2":
		fallthrough
	case "us-west-1":
		fallthrough
	case "us-west-2":
		fallthrough
	case "af-south-1":
		fallthrough
	case "ap-east-1":
		fallthrough
	case "ap-south-1":
		fallthrough
	case "ap-northeast-1":
		fallthrough
	case "ap-northeast-2":
		fallthrough
	case "ap-northeast-3":
		fallthrough
	case "ap-southeast-1":
		fallthrough
	case "ap-southeast-2":
		fallthrough
	case "ca-central-1":
		fallthrough
	case "cn-north-1":
		fallthrough
	case "cn-northwest-1":
		fallthrough
	case "eu-central-1":
		fallthrough
	case "eu-north-1":
		fallthrough
	case "eu-south-1":
		fallthrough
	case "eu-west-1":
		fallthrough
	case "eu-west-2":
		fallthrough
	case "eu-west-3":
		fallthrough
	case "sa-east-1":
		fallthrough
	case "me-south-1":
		fallthrough
	case "us-gov-east-1":
		fallthrough
	case "us-gov-west-1":
		*e = DestinationS3GlueUpdateS3BucketRegion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3GlueUpdateS3BucketRegion: %v", v)
	}
}

type DestinationS3GlueUpdate struct {
	// The access key ID to access the S3 bucket. Airbyte requires Read and Write permissions to the given bucket. Read more <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">here</a>.
	AccessKeyID *string `json:"access_key_id,omitempty"`
	// The pattern allows you to set the file-name format for the S3 staging file(s)
	FileNamePattern *string `json:"file_name_pattern,omitempty"`
	// Format of the data output. See <a href="https://docs.airbyte.com/integrations/destinations/s3/#supported-output-schema">here</a> for more details
	Format DestinationS3GlueUpdateOutputFormat `json:"format"`
	// Name of the glue database for creating the tables, leave blank if no integration
	GlueDatabase string `json:"glue_database"`
	// The library that your query engine will use for reading and writing data in your lake.
	GlueSerializationLibrary *DestinationS3GlueUpdateSerializationLibrary `default:"org.openx.data.jsonserde.JsonSerDe" json:"glue_serialization_library"`
	// The name of the S3 bucket. Read more <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/create-bucket-overview.html">here</a>.
	S3BucketName string `json:"s3_bucket_name"`
	// Directory under the S3 bucket where data will be written. Read more <a href="https://docs.airbyte.com/integrations/destinations/s3#:~:text=to%20format%20the-,bucket%20path,-%3A">here</a>
	S3BucketPath string `json:"s3_bucket_path"`
	// The region of the S3 bucket. See <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-available-regions">here</a> for all region codes.
	S3BucketRegion *DestinationS3GlueUpdateS3BucketRegion `default:"" json:"s3_bucket_region"`
	// Your S3 endpoint url. Read more <a href="https://docs.aws.amazon.com/general/latest/gr/s3.html#:~:text=Service%20endpoints-,Amazon%20S3%20endpoints,-When%20you%20use">here</a>
	S3Endpoint *string `default:"" json:"s3_endpoint"`
	// Format string on how data will be organized inside the S3 bucket directory. Read more <a href="https://docs.airbyte.com/integrations/destinations/s3#:~:text=The%20full%20path%20of%20the%20output%20data%20with%20the%20default%20S3%20path%20format">here</a>
	S3PathFormat *string `json:"s3_path_format,omitempty"`
	// The corresponding secret to the access key ID. Read more <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">here</a>
	SecretAccessKey *string `json:"secret_access_key,omitempty"`
}

func (d DestinationS3GlueUpdate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationS3GlueUpdate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *DestinationS3GlueUpdate) GetAccessKeyID() *string {
	if o == nil {
		return nil
	}
	return o.AccessKeyID
}

func (o *DestinationS3GlueUpdate) GetFileNamePattern() *string {
	if o == nil {
		return nil
	}
	return o.FileNamePattern
}

func (o *DestinationS3GlueUpdate) GetFormat() DestinationS3GlueUpdateOutputFormat {
	if o == nil {
		return DestinationS3GlueUpdateOutputFormat{}
	}
	return o.Format
}

func (o *DestinationS3GlueUpdate) GetGlueDatabase() string {
	if o == nil {
		return ""
	}
	return o.GlueDatabase
}

func (o *DestinationS3GlueUpdate) GetGlueSerializationLibrary() *DestinationS3GlueUpdateSerializationLibrary {
	if o == nil {
		return nil
	}
	return o.GlueSerializationLibrary
}

func (o *DestinationS3GlueUpdate) GetS3BucketName() string {
	if o == nil {
		return ""
	}
	return o.S3BucketName
}

func (o *DestinationS3GlueUpdate) GetS3BucketPath() string {
	if o == nil {
		return ""
	}
	return o.S3BucketPath
}

func (o *DestinationS3GlueUpdate) GetS3BucketRegion() *DestinationS3GlueUpdateS3BucketRegion {
	if o == nil {
		return nil
	}
	return o.S3BucketRegion
}

func (o *DestinationS3GlueUpdate) GetS3Endpoint() *string {
	if o == nil {
		return nil
	}
	return o.S3Endpoint
}

func (o *DestinationS3GlueUpdate) GetS3PathFormat() *string {
	if o == nil {
		return nil
	}
	return o.S3PathFormat
}

func (o *DestinationS3GlueUpdate) GetSecretAccessKey() *string {
	if o == nil {
		return nil
	}
	return o.SecretAccessKey
}
