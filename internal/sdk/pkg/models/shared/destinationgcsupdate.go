// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
)

type DestinationGcsUpdateAuthenticationHMACKeyCredentialType string

const (
	DestinationGcsUpdateAuthenticationHMACKeyCredentialTypeHmacKey DestinationGcsUpdateAuthenticationHMACKeyCredentialType = "HMAC_KEY"
)

func (e DestinationGcsUpdateAuthenticationHMACKeyCredentialType) ToPointer() *DestinationGcsUpdateAuthenticationHMACKeyCredentialType {
	return &e
}

func (e *DestinationGcsUpdateAuthenticationHMACKeyCredentialType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "HMAC_KEY":
		*e = DestinationGcsUpdateAuthenticationHMACKeyCredentialType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsUpdateAuthenticationHMACKeyCredentialType: %v", v)
	}
}

// DestinationGcsUpdateAuthenticationHMACKey - An HMAC key is a type of credential and can be associated with a service account or a user account in Cloud Storage. Read more <a href="https://cloud.google.com/storage/docs/authentication/hmackeys">here</a>.
type DestinationGcsUpdateAuthenticationHMACKey struct {
	CredentialType DestinationGcsUpdateAuthenticationHMACKeyCredentialType `json:"credential_type"`
	// When linked to a service account, this ID is 61 characters long; when linked to a user account, it is 24 characters long. Read more <a href="https://cloud.google.com/storage/docs/authentication/hmackeys#overview">here</a>.
	HmacKeyAccessID string `json:"hmac_key_access_id"`
	// The corresponding secret for the access ID. It is a 40-character base-64 encoded string.  Read more <a href="https://cloud.google.com/storage/docs/authentication/hmackeys#secrets">here</a>.
	HmacKeySecret string `json:"hmac_key_secret"`
}

type DestinationGcsUpdateAuthenticationType string

const (
	DestinationGcsUpdateAuthenticationTypeDestinationGcsUpdateAuthenticationHMACKey DestinationGcsUpdateAuthenticationType = "destination-gcs-update_Authentication_HMAC Key"
)

type DestinationGcsUpdateAuthentication struct {
	DestinationGcsUpdateAuthenticationHMACKey *DestinationGcsUpdateAuthenticationHMACKey

	Type DestinationGcsUpdateAuthenticationType
}

func CreateDestinationGcsUpdateAuthenticationDestinationGcsUpdateAuthenticationHMACKey(destinationGcsUpdateAuthenticationHMACKey DestinationGcsUpdateAuthenticationHMACKey) DestinationGcsUpdateAuthentication {
	typ := DestinationGcsUpdateAuthenticationTypeDestinationGcsUpdateAuthenticationHMACKey

	return DestinationGcsUpdateAuthentication{
		DestinationGcsUpdateAuthenticationHMACKey: &destinationGcsUpdateAuthenticationHMACKey,
		Type: typ,
	}
}

func (u *DestinationGcsUpdateAuthentication) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	destinationGcsUpdateAuthenticationHMACKey := new(DestinationGcsUpdateAuthenticationHMACKey)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationGcsUpdateAuthenticationHMACKey); err == nil {
		u.DestinationGcsUpdateAuthenticationHMACKey = destinationGcsUpdateAuthenticationHMACKey
		u.Type = DestinationGcsUpdateAuthenticationTypeDestinationGcsUpdateAuthenticationHMACKey
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u DestinationGcsUpdateAuthentication) MarshalJSON() ([]byte, error) {
	if u.DestinationGcsUpdateAuthenticationHMACKey != nil {
		return json.Marshal(u.DestinationGcsUpdateAuthenticationHMACKey)
	}

	return nil, nil
}

// DestinationGcsUpdateOutputFormatParquetColumnarStorageCompressionCodec - The compression algorithm used to compress data pages.
type DestinationGcsUpdateOutputFormatParquetColumnarStorageCompressionCodec string

const (
	DestinationGcsUpdateOutputFormatParquetColumnarStorageCompressionCodecUncompressed DestinationGcsUpdateOutputFormatParquetColumnarStorageCompressionCodec = "UNCOMPRESSED"
	DestinationGcsUpdateOutputFormatParquetColumnarStorageCompressionCodecSnappy       DestinationGcsUpdateOutputFormatParquetColumnarStorageCompressionCodec = "SNAPPY"
	DestinationGcsUpdateOutputFormatParquetColumnarStorageCompressionCodecGzip         DestinationGcsUpdateOutputFormatParquetColumnarStorageCompressionCodec = "GZIP"
	DestinationGcsUpdateOutputFormatParquetColumnarStorageCompressionCodecLzo          DestinationGcsUpdateOutputFormatParquetColumnarStorageCompressionCodec = "LZO"
	DestinationGcsUpdateOutputFormatParquetColumnarStorageCompressionCodecBrotli       DestinationGcsUpdateOutputFormatParquetColumnarStorageCompressionCodec = "BROTLI"
	DestinationGcsUpdateOutputFormatParquetColumnarStorageCompressionCodecLz4          DestinationGcsUpdateOutputFormatParquetColumnarStorageCompressionCodec = "LZ4"
	DestinationGcsUpdateOutputFormatParquetColumnarStorageCompressionCodecZstd         DestinationGcsUpdateOutputFormatParquetColumnarStorageCompressionCodec = "ZSTD"
)

func (e DestinationGcsUpdateOutputFormatParquetColumnarStorageCompressionCodec) ToPointer() *DestinationGcsUpdateOutputFormatParquetColumnarStorageCompressionCodec {
	return &e
}

func (e *DestinationGcsUpdateOutputFormatParquetColumnarStorageCompressionCodec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "UNCOMPRESSED":
		fallthrough
	case "SNAPPY":
		fallthrough
	case "GZIP":
		fallthrough
	case "LZO":
		fallthrough
	case "BROTLI":
		fallthrough
	case "LZ4":
		fallthrough
	case "ZSTD":
		*e = DestinationGcsUpdateOutputFormatParquetColumnarStorageCompressionCodec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsUpdateOutputFormatParquetColumnarStorageCompressionCodec: %v", v)
	}
}

type DestinationGcsUpdateOutputFormatParquetColumnarStorageFormatType string

const (
	DestinationGcsUpdateOutputFormatParquetColumnarStorageFormatTypeParquet DestinationGcsUpdateOutputFormatParquetColumnarStorageFormatType = "Parquet"
)

func (e DestinationGcsUpdateOutputFormatParquetColumnarStorageFormatType) ToPointer() *DestinationGcsUpdateOutputFormatParquetColumnarStorageFormatType {
	return &e
}

func (e *DestinationGcsUpdateOutputFormatParquetColumnarStorageFormatType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Parquet":
		*e = DestinationGcsUpdateOutputFormatParquetColumnarStorageFormatType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsUpdateOutputFormatParquetColumnarStorageFormatType: %v", v)
	}
}

// DestinationGcsUpdateOutputFormatParquetColumnarStorage - Output data format. One of the following formats must be selected - <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-avro#advantages_of_avro">AVRO</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-parquet#parquet_schemas">PARQUET</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-csv#loading_csv_data_into_a_table">CSV</a> format, or <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-json#loading_json_data_into_a_new_table">JSONL</a> format.
type DestinationGcsUpdateOutputFormatParquetColumnarStorage struct {
	// This is the size of a row group being buffered in memory. It limits the memory usage when writing. Larger values will improve the IO when reading, but consume more memory when writing. Default: 128 MB.
	BlockSizeMb *int64 `json:"block_size_mb,omitempty"`
	// The compression algorithm used to compress data pages.
	CompressionCodec *DestinationGcsUpdateOutputFormatParquetColumnarStorageCompressionCodec `json:"compression_codec,omitempty"`
	// Default: true.
	DictionaryEncoding *bool `json:"dictionary_encoding,omitempty"`
	// There is one dictionary page per column per row group when dictionary encoding is used. The dictionary page size works like the page size but for dictionary. Default: 1024 KB.
	DictionaryPageSizeKb *int64                                                           `json:"dictionary_page_size_kb,omitempty"`
	FormatType           DestinationGcsUpdateOutputFormatParquetColumnarStorageFormatType `json:"format_type"`
	// Maximum size allowed as padding to align row groups. This is also the minimum size of a row group. Default: 8 MB.
	MaxPaddingSizeMb *int64 `json:"max_padding_size_mb,omitempty"`
	// The page size is for compression. A block is composed of pages. A page is the smallest unit that must be read fully to access a single record. If this value is too small, the compression will deteriorate. Default: 1024 KB.
	PageSizeKb *int64 `json:"page_size_kb,omitempty"`
}

type DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIPCompressionType string

const (
	DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIPCompressionTypeGzip DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIPCompressionType = "GZIP"
)

func (e DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIPCompressionType) ToPointer() *DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIPCompressionType {
	return &e
}

func (e *DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIPCompressionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "GZIP":
		*e = DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIPCompressionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIPCompressionType: %v", v)
	}
}

// DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP - Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").
type DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP struct {
	CompressionType *DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIPCompressionType `json:"compression_type,omitempty"`
}

type DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompressionCompressionType string

const (
	DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompressionCompressionTypeNoCompression DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompressionCompressionType = "No Compression"
)

func (e DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompressionCompressionType) ToPointer() *DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompressionCompressionType {
	return &e
}

func (e *DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompressionCompressionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "No Compression":
		*e = DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompressionCompressionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompressionCompressionType: %v", v)
	}
}

// DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression - Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").
type DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression struct {
	CompressionType *DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompressionCompressionType `json:"compression_type,omitempty"`
}

type DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionType string

const (
	DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionTypeDestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionType = "destination-gcs-update_Output Format_JSON Lines: newline-delimited JSON_Compression_No Compression"
	DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionTypeDestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP          DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionType = "destination-gcs-update_Output Format_JSON Lines: newline-delimited JSON_Compression_GZIP"
)

type DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompression struct {
	DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression *DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression
	DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP          *DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP

	Type DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionType
}

func CreateDestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionDestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression(destinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression) DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompression {
	typ := DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionTypeDestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression

	return DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompression{
		DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression: &destinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression,
		Type: typ,
	}
}

func CreateDestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionDestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP(destinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP) DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompression {
	typ := DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionTypeDestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP

	return DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompression{
		DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP: &destinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP,
		Type: typ,
	}
}

func (u *DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompression) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	destinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression := new(DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression); err == nil {
		u.DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression = destinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression
		u.Type = DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionTypeDestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression
		return nil
	}

	destinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP := new(DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP); err == nil {
		u.DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP = destinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP
		u.Type = DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionTypeDestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompression) MarshalJSON() ([]byte, error) {
	if u.DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression != nil {
		return json.Marshal(u.DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression)
	}

	if u.DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP != nil {
		return json.Marshal(u.DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP)
	}

	return nil, nil
}

type DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONFormatType string

const (
	DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONFormatTypeJsonl DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONFormatType = "JSONL"
)

func (e DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONFormatType) ToPointer() *DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONFormatType {
	return &e
}

func (e *DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONFormatType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "JSONL":
		*e = DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONFormatType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONFormatType: %v", v)
	}
}

// DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSON - Output data format. One of the following formats must be selected - <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-avro#advantages_of_avro">AVRO</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-parquet#parquet_schemas">PARQUET</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-csv#loading_csv_data_into_a_table">CSV</a> format, or <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-json#loading_json_data_into_a_new_table">JSONL</a> format.
type DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSON struct {
	// Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").
	Compression *DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONCompression `json:"compression,omitempty"`
	FormatType  DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSONFormatType   `json:"format_type"`
}

type DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionGZIPCompressionType string

const (
	DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionGZIPCompressionTypeGzip DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionGZIPCompressionType = "GZIP"
)

func (e DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionGZIPCompressionType) ToPointer() *DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionGZIPCompressionType {
	return &e
}

func (e *DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionGZIPCompressionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "GZIP":
		*e = DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionGZIPCompressionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionGZIPCompressionType: %v", v)
	}
}

// DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionGZIP - Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".csv.gz").
type DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionGZIP struct {
	CompressionType *DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionGZIPCompressionType `json:"compression_type,omitempty"`
}

type DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionNoCompressionCompressionType string

const (
	DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionNoCompressionCompressionTypeNoCompression DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionNoCompressionCompressionType = "No Compression"
)

func (e DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionNoCompressionCompressionType) ToPointer() *DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionNoCompressionCompressionType {
	return &e
}

func (e *DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionNoCompressionCompressionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "No Compression":
		*e = DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionNoCompressionCompressionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionNoCompressionCompressionType: %v", v)
	}
}

// DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionNoCompression - Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".csv.gz").
type DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionNoCompression struct {
	CompressionType *DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionNoCompressionCompressionType `json:"compression_type,omitempty"`
}

type DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionType string

const (
	DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionTypeDestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionNoCompression DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionType = "destination-gcs-update_Output Format_CSV: Comma-Separated Values_Compression_No Compression"
	DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionTypeDestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionGZIP          DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionType = "destination-gcs-update_Output Format_CSV: Comma-Separated Values_Compression_GZIP"
)

type DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompression struct {
	DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionNoCompression *DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionNoCompression
	DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionGZIP          *DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionGZIP

	Type DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionType
}

func CreateDestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionDestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionNoCompression(destinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionNoCompression DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionNoCompression) DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompression {
	typ := DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionTypeDestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionNoCompression

	return DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompression{
		DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionNoCompression: &destinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionNoCompression,
		Type: typ,
	}
}

func CreateDestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionDestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionGZIP(destinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionGZIP DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionGZIP) DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompression {
	typ := DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionTypeDestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionGZIP

	return DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompression{
		DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionGZIP: &destinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionGZIP,
		Type: typ,
	}
}

func (u *DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompression) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	destinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionNoCompression := new(DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionNoCompression)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionNoCompression); err == nil {
		u.DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionNoCompression = destinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionNoCompression
		u.Type = DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionTypeDestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionNoCompression
		return nil
	}

	destinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionGZIP := new(DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionGZIP)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionGZIP); err == nil {
		u.DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionGZIP = destinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionGZIP
		u.Type = DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionTypeDestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionGZIP
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompression) MarshalJSON() ([]byte, error) {
	if u.DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionNoCompression != nil {
		return json.Marshal(u.DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionNoCompression)
	}

	if u.DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionGZIP != nil {
		return json.Marshal(u.DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompressionGZIP)
	}

	return nil, nil
}

// DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesNormalization - Whether the input JSON data should be normalized (flattened) in the output CSV. Please refer to docs for details.
type DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesNormalization string

const (
	DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesNormalizationNoFlattening        DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesNormalization = "No flattening"
	DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesNormalizationRootLevelFlattening DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesNormalization = "Root level flattening"
)

func (e DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesNormalization) ToPointer() *DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesNormalization {
	return &e
}

func (e *DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesNormalization) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "No flattening":
		fallthrough
	case "Root level flattening":
		*e = DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesNormalization(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesNormalization: %v", v)
	}
}

type DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesFormatType string

const (
	DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesFormatTypeCsv DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesFormatType = "CSV"
)

func (e DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesFormatType) ToPointer() *DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesFormatType {
	return &e
}

func (e *DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesFormatType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CSV":
		*e = DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesFormatType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesFormatType: %v", v)
	}
}

// DestinationGcsUpdateOutputFormatCSVCommaSeparatedValues - Output data format. One of the following formats must be selected - <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-avro#advantages_of_avro">AVRO</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-parquet#parquet_schemas">PARQUET</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-csv#loading_csv_data_into_a_table">CSV</a> format, or <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-json#loading_json_data_into_a_new_table">JSONL</a> format.
type DestinationGcsUpdateOutputFormatCSVCommaSeparatedValues struct {
	// Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".csv.gz").
	Compression *DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesCompression `json:"compression,omitempty"`
	// Whether the input JSON data should be normalized (flattened) in the output CSV. Please refer to docs for details.
	Flattening *DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesNormalization `json:"flattening,omitempty"`
	FormatType DestinationGcsUpdateOutputFormatCSVCommaSeparatedValuesFormatType     `json:"format_type"`
}

type DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecSnappyCodec string

const (
	DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecSnappyCodecSnappy DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecSnappyCodec = "snappy"
)

func (e DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecSnappyCodec) ToPointer() *DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecSnappyCodec {
	return &e
}

func (e *DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecSnappyCodec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "snappy":
		*e = DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecSnappyCodec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecSnappyCodec: %v", v)
	}
}

// DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecSnappy - The compression algorithm used to compress data. Default to no compression.
type DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecSnappy struct {
	Codec DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecSnappyCodec `json:"codec"`
}

type DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecZstandardCodec string

const (
	DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecZstandardCodecZstandard DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecZstandardCodec = "zstandard"
)

func (e DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecZstandardCodec) ToPointer() *DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecZstandardCodec {
	return &e
}

func (e *DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecZstandardCodec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "zstandard":
		*e = DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecZstandardCodec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecZstandardCodec: %v", v)
	}
}

// DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecZstandard - The compression algorithm used to compress data. Default to no compression.
type DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecZstandard struct {
	Codec DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecZstandardCodec `json:"codec"`
	// Negative levels are 'fast' modes akin to lz4 or snappy, levels above 9 are generally for archival purposes, and levels above 18 use a lot of memory.
	CompressionLevel *int64 `json:"compression_level,omitempty"`
	// If true, include a checksum with each data block.
	IncludeChecksum *bool `json:"include_checksum,omitempty"`
}

type DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecXzCodec string

const (
	DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecXzCodecXz DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecXzCodec = "xz"
)

func (e DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecXzCodec) ToPointer() *DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecXzCodec {
	return &e
}

func (e *DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecXzCodec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "xz":
		*e = DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecXzCodec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecXzCodec: %v", v)
	}
}

// DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecXz - The compression algorithm used to compress data. Default to no compression.
type DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecXz struct {
	Codec DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecXzCodec `json:"codec"`
	// The presets 0-3 are fast presets with medium compression. The presets 4-6 are fairly slow presets with high compression. The default preset is 6. The presets 7-9 are like the preset 6 but use bigger dictionaries and have higher compressor and decompressor memory requirements. Unless the uncompressed size of the file exceeds 8 MiB, 16 MiB, or 32 MiB, it is waste of memory to use the presets 7, 8, or 9, respectively. Read more <a href="https://commons.apache.org/proper/commons-compress/apidocs/org/apache/commons/compress/compressors/xz/XZCompressorOutputStream.html#XZCompressorOutputStream-java.io.OutputStream-int-">here</a> for details.
	CompressionLevel *int64 `json:"compression_level,omitempty"`
}

type DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecBzip2Codec string

const (
	DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecBzip2CodecBzip2 DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecBzip2Codec = "bzip2"
)

func (e DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecBzip2Codec) ToPointer() *DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecBzip2Codec {
	return &e
}

func (e *DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecBzip2Codec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "bzip2":
		*e = DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecBzip2Codec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecBzip2Codec: %v", v)
	}
}

// DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecBzip2 - The compression algorithm used to compress data. Default to no compression.
type DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecBzip2 struct {
	Codec DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecBzip2Codec `json:"codec"`
}

type DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDeflateCodec string

const (
	DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDeflateCodecDeflate DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDeflateCodec = "Deflate"
)

func (e DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDeflateCodec) ToPointer() *DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDeflateCodec {
	return &e
}

func (e *DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDeflateCodec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Deflate":
		*e = DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDeflateCodec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDeflateCodec: %v", v)
	}
}

// DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDeflate - The compression algorithm used to compress data. Default to no compression.
type DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDeflate struct {
	Codec DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDeflateCodec `json:"codec"`
	// 0: no compression & fastest, 9: best compression & slowest.
	CompressionLevel *int64 `json:"compression_level,omitempty"`
}

type DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecNoCompressionCodec string

const (
	DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecNoCompressionCodecNoCompression DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecNoCompressionCodec = "no compression"
)

func (e DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecNoCompressionCodec) ToPointer() *DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecNoCompressionCodec {
	return &e
}

func (e *DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecNoCompressionCodec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "no compression":
		*e = DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecNoCompressionCodec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecNoCompressionCodec: %v", v)
	}
}

// DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecNoCompression - The compression algorithm used to compress data. Default to no compression.
type DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecNoCompression struct {
	Codec DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecNoCompressionCodec `json:"codec"`
}

type DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecType string

const (
	DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecNoCompression DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecType = "destination-gcs-update_Output Format_Avro: Apache Avro_Compression Codec_No Compression"
	DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDeflate       DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecType = "destination-gcs-update_Output Format_Avro: Apache Avro_Compression Codec_Deflate"
	DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecBzip2         DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecType = "destination-gcs-update_Output Format_Avro: Apache Avro_Compression Codec_bzip2"
	DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecXz            DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecType = "destination-gcs-update_Output Format_Avro: Apache Avro_Compression Codec_xz"
	DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecZstandard     DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecType = "destination-gcs-update_Output Format_Avro: Apache Avro_Compression Codec_zstandard"
	DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecSnappy        DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecType = "destination-gcs-update_Output Format_Avro: Apache Avro_Compression Codec_snappy"
)

type DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodec struct {
	DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecNoCompression *DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecNoCompression
	DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDeflate       *DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDeflate
	DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecBzip2         *DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecBzip2
	DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecXz            *DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecXz
	DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecZstandard     *DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecZstandard
	DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecSnappy        *DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecSnappy

	Type DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecType
}

func CreateDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecNoCompression(destinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecNoCompression DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecNoCompression) DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodec {
	typ := DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecNoCompression

	return DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodec{
		DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecNoCompression: &destinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecNoCompression,
		Type: typ,
	}
}

func CreateDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDeflate(destinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDeflate DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDeflate) DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodec {
	typ := DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDeflate

	return DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodec{
		DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDeflate: &destinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDeflate,
		Type: typ,
	}
}

func CreateDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecBzip2(destinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecBzip2 DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecBzip2) DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodec {
	typ := DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecBzip2

	return DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodec{
		DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecBzip2: &destinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecBzip2,
		Type: typ,
	}
}

func CreateDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecXz(destinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecXz DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecXz) DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodec {
	typ := DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecXz

	return DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodec{
		DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecXz: &destinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecXz,
		Type: typ,
	}
}

func CreateDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecZstandard(destinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecZstandard DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecZstandard) DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodec {
	typ := DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecZstandard

	return DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodec{
		DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecZstandard: &destinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecZstandard,
		Type: typ,
	}
}

func CreateDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecSnappy(destinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecSnappy DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecSnappy) DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodec {
	typ := DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecSnappy

	return DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodec{
		DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecSnappy: &destinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecSnappy,
		Type: typ,
	}
}

func (u *DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodec) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	destinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecNoCompression := new(DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecNoCompression)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecNoCompression); err == nil {
		u.DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecNoCompression = destinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecNoCompression
		u.Type = DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecNoCompression
		return nil
	}

	destinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecBzip2 := new(DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecBzip2)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecBzip2); err == nil {
		u.DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecBzip2 = destinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecBzip2
		u.Type = DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecBzip2
		return nil
	}

	destinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecSnappy := new(DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecSnappy)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecSnappy); err == nil {
		u.DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecSnappy = destinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecSnappy
		u.Type = DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecSnappy
		return nil
	}

	destinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDeflate := new(DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDeflate)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDeflate); err == nil {
		u.DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDeflate = destinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDeflate
		u.Type = DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDeflate
		return nil
	}

	destinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecXz := new(DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecXz)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecXz); err == nil {
		u.DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecXz = destinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecXz
		u.Type = DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecXz
		return nil
	}

	destinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecZstandard := new(DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecZstandard)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecZstandard); err == nil {
		u.DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecZstandard = destinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecZstandard
		u.Type = DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecTypeDestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecZstandard
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodec) MarshalJSON() ([]byte, error) {
	if u.DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecNoCompression != nil {
		return json.Marshal(u.DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecNoCompression)
	}

	if u.DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecBzip2 != nil {
		return json.Marshal(u.DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecBzip2)
	}

	if u.DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecSnappy != nil {
		return json.Marshal(u.DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecSnappy)
	}

	if u.DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDeflate != nil {
		return json.Marshal(u.DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecDeflate)
	}

	if u.DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecXz != nil {
		return json.Marshal(u.DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecXz)
	}

	if u.DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecZstandard != nil {
		return json.Marshal(u.DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodecZstandard)
	}

	return nil, nil
}

type DestinationGcsUpdateOutputFormatAvroApacheAvroFormatType string

const (
	DestinationGcsUpdateOutputFormatAvroApacheAvroFormatTypeAvro DestinationGcsUpdateOutputFormatAvroApacheAvroFormatType = "Avro"
)

func (e DestinationGcsUpdateOutputFormatAvroApacheAvroFormatType) ToPointer() *DestinationGcsUpdateOutputFormatAvroApacheAvroFormatType {
	return &e
}

func (e *DestinationGcsUpdateOutputFormatAvroApacheAvroFormatType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Avro":
		*e = DestinationGcsUpdateOutputFormatAvroApacheAvroFormatType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsUpdateOutputFormatAvroApacheAvroFormatType: %v", v)
	}
}

// DestinationGcsUpdateOutputFormatAvroApacheAvro - Output data format. One of the following formats must be selected - <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-avro#advantages_of_avro">AVRO</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-parquet#parquet_schemas">PARQUET</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-csv#loading_csv_data_into_a_table">CSV</a> format, or <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-json#loading_json_data_into_a_new_table">JSONL</a> format.
type DestinationGcsUpdateOutputFormatAvroApacheAvro struct {
	// The compression algorithm used to compress data. Default to no compression.
	CompressionCodec DestinationGcsUpdateOutputFormatAvroApacheAvroCompressionCodec `json:"compression_codec"`
	FormatType       DestinationGcsUpdateOutputFormatAvroApacheAvroFormatType       `json:"format_type"`
}

type DestinationGcsUpdateOutputFormatType string

const (
	DestinationGcsUpdateOutputFormatTypeDestinationGcsUpdateOutputFormatAvroApacheAvro                DestinationGcsUpdateOutputFormatType = "destination-gcs-update_Output Format_Avro: Apache Avro"
	DestinationGcsUpdateOutputFormatTypeDestinationGcsUpdateOutputFormatCSVCommaSeparatedValues       DestinationGcsUpdateOutputFormatType = "destination-gcs-update_Output Format_CSV: Comma-Separated Values"
	DestinationGcsUpdateOutputFormatTypeDestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSON DestinationGcsUpdateOutputFormatType = "destination-gcs-update_Output Format_JSON Lines: newline-delimited JSON"
	DestinationGcsUpdateOutputFormatTypeDestinationGcsUpdateOutputFormatParquetColumnarStorage        DestinationGcsUpdateOutputFormatType = "destination-gcs-update_Output Format_Parquet: Columnar Storage"
)

type DestinationGcsUpdateOutputFormat struct {
	DestinationGcsUpdateOutputFormatAvroApacheAvro                *DestinationGcsUpdateOutputFormatAvroApacheAvro
	DestinationGcsUpdateOutputFormatCSVCommaSeparatedValues       *DestinationGcsUpdateOutputFormatCSVCommaSeparatedValues
	DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSON *DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSON
	DestinationGcsUpdateOutputFormatParquetColumnarStorage        *DestinationGcsUpdateOutputFormatParquetColumnarStorage

	Type DestinationGcsUpdateOutputFormatType
}

func CreateDestinationGcsUpdateOutputFormatDestinationGcsUpdateOutputFormatAvroApacheAvro(destinationGcsUpdateOutputFormatAvroApacheAvro DestinationGcsUpdateOutputFormatAvroApacheAvro) DestinationGcsUpdateOutputFormat {
	typ := DestinationGcsUpdateOutputFormatTypeDestinationGcsUpdateOutputFormatAvroApacheAvro

	return DestinationGcsUpdateOutputFormat{
		DestinationGcsUpdateOutputFormatAvroApacheAvro: &destinationGcsUpdateOutputFormatAvroApacheAvro,
		Type: typ,
	}
}

func CreateDestinationGcsUpdateOutputFormatDestinationGcsUpdateOutputFormatCSVCommaSeparatedValues(destinationGcsUpdateOutputFormatCSVCommaSeparatedValues DestinationGcsUpdateOutputFormatCSVCommaSeparatedValues) DestinationGcsUpdateOutputFormat {
	typ := DestinationGcsUpdateOutputFormatTypeDestinationGcsUpdateOutputFormatCSVCommaSeparatedValues

	return DestinationGcsUpdateOutputFormat{
		DestinationGcsUpdateOutputFormatCSVCommaSeparatedValues: &destinationGcsUpdateOutputFormatCSVCommaSeparatedValues,
		Type: typ,
	}
}

func CreateDestinationGcsUpdateOutputFormatDestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSON(destinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSON DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSON) DestinationGcsUpdateOutputFormat {
	typ := DestinationGcsUpdateOutputFormatTypeDestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSON

	return DestinationGcsUpdateOutputFormat{
		DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSON: &destinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSON,
		Type: typ,
	}
}

func CreateDestinationGcsUpdateOutputFormatDestinationGcsUpdateOutputFormatParquetColumnarStorage(destinationGcsUpdateOutputFormatParquetColumnarStorage DestinationGcsUpdateOutputFormatParquetColumnarStorage) DestinationGcsUpdateOutputFormat {
	typ := DestinationGcsUpdateOutputFormatTypeDestinationGcsUpdateOutputFormatParquetColumnarStorage

	return DestinationGcsUpdateOutputFormat{
		DestinationGcsUpdateOutputFormatParquetColumnarStorage: &destinationGcsUpdateOutputFormatParquetColumnarStorage,
		Type: typ,
	}
}

func (u *DestinationGcsUpdateOutputFormat) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	destinationGcsUpdateOutputFormatAvroApacheAvro := new(DestinationGcsUpdateOutputFormatAvroApacheAvro)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationGcsUpdateOutputFormatAvroApacheAvro); err == nil {
		u.DestinationGcsUpdateOutputFormatAvroApacheAvro = destinationGcsUpdateOutputFormatAvroApacheAvro
		u.Type = DestinationGcsUpdateOutputFormatTypeDestinationGcsUpdateOutputFormatAvroApacheAvro
		return nil
	}

	destinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSON := new(DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSON)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSON); err == nil {
		u.DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSON = destinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSON
		u.Type = DestinationGcsUpdateOutputFormatTypeDestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSON
		return nil
	}

	destinationGcsUpdateOutputFormatCSVCommaSeparatedValues := new(DestinationGcsUpdateOutputFormatCSVCommaSeparatedValues)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationGcsUpdateOutputFormatCSVCommaSeparatedValues); err == nil {
		u.DestinationGcsUpdateOutputFormatCSVCommaSeparatedValues = destinationGcsUpdateOutputFormatCSVCommaSeparatedValues
		u.Type = DestinationGcsUpdateOutputFormatTypeDestinationGcsUpdateOutputFormatCSVCommaSeparatedValues
		return nil
	}

	destinationGcsUpdateOutputFormatParquetColumnarStorage := new(DestinationGcsUpdateOutputFormatParquetColumnarStorage)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationGcsUpdateOutputFormatParquetColumnarStorage); err == nil {
		u.DestinationGcsUpdateOutputFormatParquetColumnarStorage = destinationGcsUpdateOutputFormatParquetColumnarStorage
		u.Type = DestinationGcsUpdateOutputFormatTypeDestinationGcsUpdateOutputFormatParquetColumnarStorage
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u DestinationGcsUpdateOutputFormat) MarshalJSON() ([]byte, error) {
	if u.DestinationGcsUpdateOutputFormatAvroApacheAvro != nil {
		return json.Marshal(u.DestinationGcsUpdateOutputFormatAvroApacheAvro)
	}

	if u.DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSON != nil {
		return json.Marshal(u.DestinationGcsUpdateOutputFormatJSONLinesNewlineDelimitedJSON)
	}

	if u.DestinationGcsUpdateOutputFormatCSVCommaSeparatedValues != nil {
		return json.Marshal(u.DestinationGcsUpdateOutputFormatCSVCommaSeparatedValues)
	}

	if u.DestinationGcsUpdateOutputFormatParquetColumnarStorage != nil {
		return json.Marshal(u.DestinationGcsUpdateOutputFormatParquetColumnarStorage)
	}

	return nil, nil
}

// DestinationGCSUpdateGCSBucketRegion - Select a Region of the GCS Bucket. Read more <a href="https://cloud.google.com/storage/docs/locations">here</a>.
type DestinationGCSUpdateGCSBucketRegion string

const (
	DestinationGCSUpdateGCSBucketRegionNorthamericaNortheast1 DestinationGCSUpdateGCSBucketRegion = "northamerica-northeast1"
	DestinationGCSUpdateGCSBucketRegionNorthamericaNortheast2 DestinationGCSUpdateGCSBucketRegion = "northamerica-northeast2"
	DestinationGCSUpdateGCSBucketRegionUsCentral1             DestinationGCSUpdateGCSBucketRegion = "us-central1"
	DestinationGCSUpdateGCSBucketRegionUsEast1                DestinationGCSUpdateGCSBucketRegion = "us-east1"
	DestinationGCSUpdateGCSBucketRegionUsEast4                DestinationGCSUpdateGCSBucketRegion = "us-east4"
	DestinationGCSUpdateGCSBucketRegionUsWest1                DestinationGCSUpdateGCSBucketRegion = "us-west1"
	DestinationGCSUpdateGCSBucketRegionUsWest2                DestinationGCSUpdateGCSBucketRegion = "us-west2"
	DestinationGCSUpdateGCSBucketRegionUsWest3                DestinationGCSUpdateGCSBucketRegion = "us-west3"
	DestinationGCSUpdateGCSBucketRegionUsWest4                DestinationGCSUpdateGCSBucketRegion = "us-west4"
	DestinationGCSUpdateGCSBucketRegionSouthamericaEast1      DestinationGCSUpdateGCSBucketRegion = "southamerica-east1"
	DestinationGCSUpdateGCSBucketRegionSouthamericaWest1      DestinationGCSUpdateGCSBucketRegion = "southamerica-west1"
	DestinationGCSUpdateGCSBucketRegionEuropeCentral2         DestinationGCSUpdateGCSBucketRegion = "europe-central2"
	DestinationGCSUpdateGCSBucketRegionEuropeNorth1           DestinationGCSUpdateGCSBucketRegion = "europe-north1"
	DestinationGCSUpdateGCSBucketRegionEuropeWest1            DestinationGCSUpdateGCSBucketRegion = "europe-west1"
	DestinationGCSUpdateGCSBucketRegionEuropeWest2            DestinationGCSUpdateGCSBucketRegion = "europe-west2"
	DestinationGCSUpdateGCSBucketRegionEuropeWest3            DestinationGCSUpdateGCSBucketRegion = "europe-west3"
	DestinationGCSUpdateGCSBucketRegionEuropeWest4            DestinationGCSUpdateGCSBucketRegion = "europe-west4"
	DestinationGCSUpdateGCSBucketRegionEuropeWest6            DestinationGCSUpdateGCSBucketRegion = "europe-west6"
	DestinationGCSUpdateGCSBucketRegionAsiaEast1              DestinationGCSUpdateGCSBucketRegion = "asia-east1"
	DestinationGCSUpdateGCSBucketRegionAsiaEast2              DestinationGCSUpdateGCSBucketRegion = "asia-east2"
	DestinationGCSUpdateGCSBucketRegionAsiaNortheast1         DestinationGCSUpdateGCSBucketRegion = "asia-northeast1"
	DestinationGCSUpdateGCSBucketRegionAsiaNortheast2         DestinationGCSUpdateGCSBucketRegion = "asia-northeast2"
	DestinationGCSUpdateGCSBucketRegionAsiaNortheast3         DestinationGCSUpdateGCSBucketRegion = "asia-northeast3"
	DestinationGCSUpdateGCSBucketRegionAsiaSouth1             DestinationGCSUpdateGCSBucketRegion = "asia-south1"
	DestinationGCSUpdateGCSBucketRegionAsiaSouth2             DestinationGCSUpdateGCSBucketRegion = "asia-south2"
	DestinationGCSUpdateGCSBucketRegionAsiaSoutheast1         DestinationGCSUpdateGCSBucketRegion = "asia-southeast1"
	DestinationGCSUpdateGCSBucketRegionAsiaSoutheast2         DestinationGCSUpdateGCSBucketRegion = "asia-southeast2"
	DestinationGCSUpdateGCSBucketRegionAustraliaSoutheast1    DestinationGCSUpdateGCSBucketRegion = "australia-southeast1"
	DestinationGCSUpdateGCSBucketRegionAustraliaSoutheast2    DestinationGCSUpdateGCSBucketRegion = "australia-southeast2"
	DestinationGCSUpdateGCSBucketRegionAsia                   DestinationGCSUpdateGCSBucketRegion = "asia"
	DestinationGCSUpdateGCSBucketRegionEu                     DestinationGCSUpdateGCSBucketRegion = "eu"
	DestinationGCSUpdateGCSBucketRegionUs                     DestinationGCSUpdateGCSBucketRegion = "us"
	DestinationGCSUpdateGCSBucketRegionAsia1                  DestinationGCSUpdateGCSBucketRegion = "asia1"
	DestinationGCSUpdateGCSBucketRegionEur4                   DestinationGCSUpdateGCSBucketRegion = "eur4"
	DestinationGCSUpdateGCSBucketRegionNam4                   DestinationGCSUpdateGCSBucketRegion = "nam4"
)

func (e DestinationGCSUpdateGCSBucketRegion) ToPointer() *DestinationGCSUpdateGCSBucketRegion {
	return &e
}

func (e *DestinationGCSUpdateGCSBucketRegion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "northamerica-northeast1":
		fallthrough
	case "northamerica-northeast2":
		fallthrough
	case "us-central1":
		fallthrough
	case "us-east1":
		fallthrough
	case "us-east4":
		fallthrough
	case "us-west1":
		fallthrough
	case "us-west2":
		fallthrough
	case "us-west3":
		fallthrough
	case "us-west4":
		fallthrough
	case "southamerica-east1":
		fallthrough
	case "southamerica-west1":
		fallthrough
	case "europe-central2":
		fallthrough
	case "europe-north1":
		fallthrough
	case "europe-west1":
		fallthrough
	case "europe-west2":
		fallthrough
	case "europe-west3":
		fallthrough
	case "europe-west4":
		fallthrough
	case "europe-west6":
		fallthrough
	case "asia-east1":
		fallthrough
	case "asia-east2":
		fallthrough
	case "asia-northeast1":
		fallthrough
	case "asia-northeast2":
		fallthrough
	case "asia-northeast3":
		fallthrough
	case "asia-south1":
		fallthrough
	case "asia-south2":
		fallthrough
	case "asia-southeast1":
		fallthrough
	case "asia-southeast2":
		fallthrough
	case "australia-southeast1":
		fallthrough
	case "australia-southeast2":
		fallthrough
	case "asia":
		fallthrough
	case "eu":
		fallthrough
	case "us":
		fallthrough
	case "asia1":
		fallthrough
	case "eur4":
		fallthrough
	case "nam4":
		*e = DestinationGCSUpdateGCSBucketRegion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGCSUpdateGCSBucketRegion: %v", v)
	}
}

type DestinationGcsUpdate struct {
	// An HMAC key is a type of credential and can be associated with a service account or a user account in Cloud Storage. Read more <a href="https://cloud.google.com/storage/docs/authentication/hmackeys">here</a>.
	Credential DestinationGcsUpdateAuthentication `json:"credential"`
	// Output data format. One of the following formats must be selected - <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-avro#advantages_of_avro">AVRO</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-parquet#parquet_schemas">PARQUET</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-csv#loading_csv_data_into_a_table">CSV</a> format, or <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-json#loading_json_data_into_a_new_table">JSONL</a> format.
	Format DestinationGcsUpdateOutputFormat `json:"format"`
	// You can find the bucket name in the App Engine Admin console Application Settings page, under the label Google Cloud Storage Bucket. Read more <a href="https://cloud.google.com/storage/docs/naming-buckets">here</a>.
	GcsBucketName string `json:"gcs_bucket_name"`
	// GCS Bucket Path string Subdirectory under the above bucket to sync the data into.
	GcsBucketPath string `json:"gcs_bucket_path"`
	// Select a Region of the GCS Bucket. Read more <a href="https://cloud.google.com/storage/docs/locations">here</a>.
	GcsBucketRegion *DestinationGCSUpdateGCSBucketRegion `json:"gcs_bucket_region,omitempty"`
}
