// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"airbyte/internal/sdk/pkg/utils"
	"encoding/json"
	"fmt"
	"time"
)

type SourceStripeStripe string

const (
	SourceStripeStripeStripe SourceStripeStripe = "stripe"
)

func (e SourceStripeStripe) ToPointer() *SourceStripeStripe {
	return &e
}

func (e *SourceStripeStripe) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "stripe":
		*e = SourceStripeStripe(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceStripeStripe: %v", v)
	}
}

type SourceStripe struct {
	// Your Stripe account ID (starts with 'acct_', find yours <a href="https://dashboard.stripe.com/settings/account">here</a>).
	AccountID string `json:"account_id"`
	// Stripe API key (usually starts with 'sk_live_'; find yours <a href="https://dashboard.stripe.com/apikeys">here</a>).
	ClientSecret string `json:"client_secret"`
	// When set, the connector will always re-export data from the past N days, where N is the value set here. This is useful if your data is frequently updated after creation. Applies only to streams that do not support event-based incremental syncs: CheckoutSessionLineItems,  Events, SetupAttempts, ShippingRates, BalanceTransactions, Files, FileLinks. More info <a href="https://docs.airbyte.com/integrations/sources/stripe#requirements">here</a>
	LookbackWindowDays *int64 `default:"0" json:"lookback_window_days"`
	// The time increment used by the connector when requesting data from the Stripe API. The bigger the value is, the less requests will be made and faster the sync will be. On the other hand, the more seldom the state is persisted.
	SliceRange *int64             `default:"365" json:"slice_range"`
	sourceType SourceStripeStripe `const:"stripe" json:"sourceType"`
	// UTC date and time in the format 2017-01-25T00:00:00Z. Only data generated after this date will be replicated.
	StartDate *time.Time `default:"2017-01-25T00:00:00Z" json:"start_date"`
}

func (s SourceStripe) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceStripe) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *SourceStripe) GetAccountID() string {
	if o == nil {
		return ""
	}
	return o.AccountID
}

func (o *SourceStripe) GetClientSecret() string {
	if o == nil {
		return ""
	}
	return o.ClientSecret
}

func (o *SourceStripe) GetLookbackWindowDays() *int64 {
	if o == nil {
		return nil
	}
	return o.LookbackWindowDays
}

func (o *SourceStripe) GetSliceRange() *int64 {
	if o == nil {
		return nil
	}
	return o.SliceRange
}

func (o *SourceStripe) GetSourceType() SourceStripeStripe {
	return SourceStripeStripeStripe
}

func (o *SourceStripe) GetStartDate() *time.Time {
	if o == nil {
		return nil
	}
	return o.StartDate
}
