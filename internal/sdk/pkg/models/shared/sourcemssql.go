// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/pkg/utils"
)

type SourceMssqlSchemasMethod string

const (
	SourceMssqlSchemasMethodStandard SourceMssqlSchemasMethod = "STANDARD"
)

func (e SourceMssqlSchemasMethod) ToPointer() *SourceMssqlSchemasMethod {
	return &e
}

func (e *SourceMssqlSchemasMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "STANDARD":
		*e = SourceMssqlSchemasMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMssqlSchemasMethod: %v", v)
	}
}

// SourceMssqlScanChangesWithUserDefinedCursor - Incrementally detects new inserts and updates using the <a href="https://docs.airbyte.com/understanding-airbyte/connections/incremental-append/#user-defined-cursor">cursor column</a> chosen when configuring a connection (e.g. created_at, updated_at).
type SourceMssqlScanChangesWithUserDefinedCursor struct {
	method SourceMssqlSchemasMethod `const:"STANDARD" json:"method"`
}

func (s SourceMssqlScanChangesWithUserDefinedCursor) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMssqlScanChangesWithUserDefinedCursor) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceMssqlScanChangesWithUserDefinedCursor) GetMethod() SourceMssqlSchemasMethod {
	return SourceMssqlSchemasMethodStandard
}

// SourceMssqlDataToSync - What data should be synced under the CDC. "Existing and New" will read existing data as a snapshot, and sync new changes through CDC. "New Changes Only" will skip the initial snapshot, and only sync new changes through CDC.
type SourceMssqlDataToSync string

const (
	SourceMssqlDataToSyncExistingAndNew SourceMssqlDataToSync = "Existing and New"
	SourceMssqlDataToSyncNewChangesOnly SourceMssqlDataToSync = "New Changes Only"
)

func (e SourceMssqlDataToSync) ToPointer() *SourceMssqlDataToSync {
	return &e
}

func (e *SourceMssqlDataToSync) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Existing and New":
		fallthrough
	case "New Changes Only":
		*e = SourceMssqlDataToSync(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMssqlDataToSync: %v", v)
	}
}

type SourceMssqlMethod string

const (
	SourceMssqlMethodCdc SourceMssqlMethod = "CDC"
)

func (e SourceMssqlMethod) ToPointer() *SourceMssqlMethod {
	return &e
}

func (e *SourceMssqlMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CDC":
		*e = SourceMssqlMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMssqlMethod: %v", v)
	}
}

// SourceMssqlInitialSnapshotIsolationLevel - Existing data in the database are synced through an initial snapshot. This parameter controls the isolation level that will be used during the initial snapshotting. If you choose the "Snapshot" level, you must enable the <a href="https://docs.microsoft.com/en-us/dotnet/framework/data/adonet/sql/snapshot-isolation-in-sql-server">snapshot isolation mode</a> on the database.
type SourceMssqlInitialSnapshotIsolationLevel string

const (
	SourceMssqlInitialSnapshotIsolationLevelSnapshot      SourceMssqlInitialSnapshotIsolationLevel = "Snapshot"
	SourceMssqlInitialSnapshotIsolationLevelReadCommitted SourceMssqlInitialSnapshotIsolationLevel = "Read Committed"
)

func (e SourceMssqlInitialSnapshotIsolationLevel) ToPointer() *SourceMssqlInitialSnapshotIsolationLevel {
	return &e
}

func (e *SourceMssqlInitialSnapshotIsolationLevel) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Snapshot":
		fallthrough
	case "Read Committed":
		*e = SourceMssqlInitialSnapshotIsolationLevel(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMssqlInitialSnapshotIsolationLevel: %v", v)
	}
}

// SourceMssqlReadChangesUsingChangeDataCaptureCDC - <i>Recommended</i> - Incrementally reads new inserts, updates, and deletes using the SQL Server's <a href="https://docs.airbyte.com/integrations/sources/mssql/#change-data-capture-cdc">change data capture feature</a>. This must be enabled on your database.
type SourceMssqlReadChangesUsingChangeDataCaptureCDC struct {
	// What data should be synced under the CDC. "Existing and New" will read existing data as a snapshot, and sync new changes through CDC. "New Changes Only" will skip the initial snapshot, and only sync new changes through CDC.
	DataToSync *SourceMssqlDataToSync `default:"Existing and New" json:"data_to_sync"`
	// The amount of time the connector will wait when it launches to determine if there is new data to sync or not. Defaults to 300 seconds. Valid range: 120 seconds to 1200 seconds. Read about <a href="https://docs.airbyte.com/integrations/sources/mysql/#change-data-capture-cdc">initial waiting time</a>.
	InitialWaitingSeconds *int64            `default:"300" json:"initial_waiting_seconds"`
	method                SourceMssqlMethod `const:"CDC" json:"method"`
	// Existing data in the database are synced through an initial snapshot. This parameter controls the isolation level that will be used during the initial snapshotting. If you choose the "Snapshot" level, you must enable the <a href="https://docs.microsoft.com/en-us/dotnet/framework/data/adonet/sql/snapshot-isolation-in-sql-server">snapshot isolation mode</a> on the database.
	SnapshotIsolation *SourceMssqlInitialSnapshotIsolationLevel `default:"Snapshot" json:"snapshot_isolation"`
}

func (s SourceMssqlReadChangesUsingChangeDataCaptureCDC) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMssqlReadChangesUsingChangeDataCaptureCDC) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceMssqlReadChangesUsingChangeDataCaptureCDC) GetDataToSync() *SourceMssqlDataToSync {
	if o == nil {
		return nil
	}
	return o.DataToSync
}

func (o *SourceMssqlReadChangesUsingChangeDataCaptureCDC) GetInitialWaitingSeconds() *int64 {
	if o == nil {
		return nil
	}
	return o.InitialWaitingSeconds
}

func (o *SourceMssqlReadChangesUsingChangeDataCaptureCDC) GetMethod() SourceMssqlMethod {
	return SourceMssqlMethodCdc
}

func (o *SourceMssqlReadChangesUsingChangeDataCaptureCDC) GetSnapshotIsolation() *SourceMssqlInitialSnapshotIsolationLevel {
	if o == nil {
		return nil
	}
	return o.SnapshotIsolation
}

type SourceMssqlUpdateMethodType string

const (
	SourceMssqlUpdateMethodTypeReadChangesUsingChangeDataCaptureCDC SourceMssqlUpdateMethodType = "ReadChangesUsingChangeDataCaptureCDC"
	SourceMssqlUpdateMethodTypeScanChangesWithUserDefinedCursor     SourceMssqlUpdateMethodType = "ScanChangesWithUserDefinedCursor"
)

type SourceMssqlUpdateMethod struct {
	ReadChangesUsingChangeDataCaptureCDC *SourceMssqlReadChangesUsingChangeDataCaptureCDC
	ScanChangesWithUserDefinedCursor     *SourceMssqlScanChangesWithUserDefinedCursor

	Type SourceMssqlUpdateMethodType
}

func CreateSourceMssqlUpdateMethodReadChangesUsingChangeDataCaptureCDC(readChangesUsingChangeDataCaptureCDC SourceMssqlReadChangesUsingChangeDataCaptureCDC) SourceMssqlUpdateMethod {
	typ := SourceMssqlUpdateMethodTypeReadChangesUsingChangeDataCaptureCDC

	return SourceMssqlUpdateMethod{
		ReadChangesUsingChangeDataCaptureCDC: &readChangesUsingChangeDataCaptureCDC,
		Type:                                 typ,
	}
}

func CreateSourceMssqlUpdateMethodScanChangesWithUserDefinedCursor(scanChangesWithUserDefinedCursor SourceMssqlScanChangesWithUserDefinedCursor) SourceMssqlUpdateMethod {
	typ := SourceMssqlUpdateMethodTypeScanChangesWithUserDefinedCursor

	return SourceMssqlUpdateMethod{
		ScanChangesWithUserDefinedCursor: &scanChangesWithUserDefinedCursor,
		Type:                             typ,
	}
}

func (u *SourceMssqlUpdateMethod) UnmarshalJSON(data []byte) error {

	scanChangesWithUserDefinedCursor := new(SourceMssqlScanChangesWithUserDefinedCursor)
	if err := utils.UnmarshalJSON(data, &scanChangesWithUserDefinedCursor, "", true, true); err == nil {
		u.ScanChangesWithUserDefinedCursor = scanChangesWithUserDefinedCursor
		u.Type = SourceMssqlUpdateMethodTypeScanChangesWithUserDefinedCursor
		return nil
	}

	readChangesUsingChangeDataCaptureCDC := new(SourceMssqlReadChangesUsingChangeDataCaptureCDC)
	if err := utils.UnmarshalJSON(data, &readChangesUsingChangeDataCaptureCDC, "", true, true); err == nil {
		u.ReadChangesUsingChangeDataCaptureCDC = readChangesUsingChangeDataCaptureCDC
		u.Type = SourceMssqlUpdateMethodTypeReadChangesUsingChangeDataCaptureCDC
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SourceMssqlUpdateMethod) MarshalJSON() ([]byte, error) {
	if u.ReadChangesUsingChangeDataCaptureCDC != nil {
		return utils.MarshalJSON(u.ReadChangesUsingChangeDataCaptureCDC, "", true)
	}

	if u.ScanChangesWithUserDefinedCursor != nil {
		return utils.MarshalJSON(u.ScanChangesWithUserDefinedCursor, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type SourceMssqlMssql string

const (
	SourceMssqlMssqlMssql SourceMssqlMssql = "mssql"
)

func (e SourceMssqlMssql) ToPointer() *SourceMssqlMssql {
	return &e
}

func (e *SourceMssqlMssql) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "mssql":
		*e = SourceMssqlMssql(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMssqlMssql: %v", v)
	}
}

type SourceMssqlSchemasSslMethodSslMethod string

const (
	SourceMssqlSchemasSslMethodSslMethodEncryptedVerifyCertificate SourceMssqlSchemasSslMethodSslMethod = "encrypted_verify_certificate"
)

func (e SourceMssqlSchemasSslMethodSslMethod) ToPointer() *SourceMssqlSchemasSslMethodSslMethod {
	return &e
}

func (e *SourceMssqlSchemasSslMethodSslMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "encrypted_verify_certificate":
		*e = SourceMssqlSchemasSslMethodSslMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMssqlSchemasSslMethodSslMethod: %v", v)
	}
}

// SourceMssqlEncryptedVerifyCertificate - Verify and use the certificate provided by the server.
type SourceMssqlEncryptedVerifyCertificate struct {
	// Specifies the host name of the server. The value of this property must match the subject property of the certificate.
	HostNameInCertificate *string                              `json:"hostNameInCertificate,omitempty"`
	sslMethod             SourceMssqlSchemasSslMethodSslMethod `const:"encrypted_verify_certificate" json:"ssl_method"`
}

func (s SourceMssqlEncryptedVerifyCertificate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMssqlEncryptedVerifyCertificate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceMssqlEncryptedVerifyCertificate) GetHostNameInCertificate() *string {
	if o == nil {
		return nil
	}
	return o.HostNameInCertificate
}

func (o *SourceMssqlEncryptedVerifyCertificate) GetSslMethod() SourceMssqlSchemasSslMethodSslMethod {
	return SourceMssqlSchemasSslMethodSslMethodEncryptedVerifyCertificate
}

type SourceMssqlSchemasSslMethod string

const (
	SourceMssqlSchemasSslMethodEncryptedTrustServerCertificate SourceMssqlSchemasSslMethod = "encrypted_trust_server_certificate"
)

func (e SourceMssqlSchemasSslMethod) ToPointer() *SourceMssqlSchemasSslMethod {
	return &e
}

func (e *SourceMssqlSchemasSslMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "encrypted_trust_server_certificate":
		*e = SourceMssqlSchemasSslMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMssqlSchemasSslMethod: %v", v)
	}
}

// SourceMssqlEncryptedTrustServerCertificate - Use the certificate provided by the server without verification. (For testing purposes only!)
type SourceMssqlEncryptedTrustServerCertificate struct {
	sslMethod SourceMssqlSchemasSslMethod `const:"encrypted_trust_server_certificate" json:"ssl_method"`
}

func (s SourceMssqlEncryptedTrustServerCertificate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMssqlEncryptedTrustServerCertificate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceMssqlEncryptedTrustServerCertificate) GetSslMethod() SourceMssqlSchemasSslMethod {
	return SourceMssqlSchemasSslMethodEncryptedTrustServerCertificate
}

type SourceMssqlSSLMethodType string

const (
	SourceMssqlSSLMethodTypeEncryptedTrustServerCertificate SourceMssqlSSLMethodType = "EncryptedTrustServerCertificate"
	SourceMssqlSSLMethodTypeEncryptedVerifyCertificate      SourceMssqlSSLMethodType = "EncryptedVerifyCertificate"
)

type SourceMssqlSSLMethod struct {
	EncryptedTrustServerCertificate *SourceMssqlEncryptedTrustServerCertificate
	EncryptedVerifyCertificate      *SourceMssqlEncryptedVerifyCertificate

	Type SourceMssqlSSLMethodType
}

func CreateSourceMssqlSSLMethodEncryptedTrustServerCertificate(encryptedTrustServerCertificate SourceMssqlEncryptedTrustServerCertificate) SourceMssqlSSLMethod {
	typ := SourceMssqlSSLMethodTypeEncryptedTrustServerCertificate

	return SourceMssqlSSLMethod{
		EncryptedTrustServerCertificate: &encryptedTrustServerCertificate,
		Type:                            typ,
	}
}

func CreateSourceMssqlSSLMethodEncryptedVerifyCertificate(encryptedVerifyCertificate SourceMssqlEncryptedVerifyCertificate) SourceMssqlSSLMethod {
	typ := SourceMssqlSSLMethodTypeEncryptedVerifyCertificate

	return SourceMssqlSSLMethod{
		EncryptedVerifyCertificate: &encryptedVerifyCertificate,
		Type:                       typ,
	}
}

func (u *SourceMssqlSSLMethod) UnmarshalJSON(data []byte) error {

	encryptedTrustServerCertificate := new(SourceMssqlEncryptedTrustServerCertificate)
	if err := utils.UnmarshalJSON(data, &encryptedTrustServerCertificate, "", true, true); err == nil {
		u.EncryptedTrustServerCertificate = encryptedTrustServerCertificate
		u.Type = SourceMssqlSSLMethodTypeEncryptedTrustServerCertificate
		return nil
	}

	encryptedVerifyCertificate := new(SourceMssqlEncryptedVerifyCertificate)
	if err := utils.UnmarshalJSON(data, &encryptedVerifyCertificate, "", true, true); err == nil {
		u.EncryptedVerifyCertificate = encryptedVerifyCertificate
		u.Type = SourceMssqlSSLMethodTypeEncryptedVerifyCertificate
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SourceMssqlSSLMethod) MarshalJSON() ([]byte, error) {
	if u.EncryptedTrustServerCertificate != nil {
		return utils.MarshalJSON(u.EncryptedTrustServerCertificate, "", true)
	}

	if u.EncryptedVerifyCertificate != nil {
		return utils.MarshalJSON(u.EncryptedVerifyCertificate, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

// SourceMssqlSchemasTunnelMethodTunnelMethod - Connect through a jump server tunnel host using username and password authentication
type SourceMssqlSchemasTunnelMethodTunnelMethod string

const (
	SourceMssqlSchemasTunnelMethodTunnelMethodSSHPasswordAuth SourceMssqlSchemasTunnelMethodTunnelMethod = "SSH_PASSWORD_AUTH"
)

func (e SourceMssqlSchemasTunnelMethodTunnelMethod) ToPointer() *SourceMssqlSchemasTunnelMethodTunnelMethod {
	return &e
}

func (e *SourceMssqlSchemasTunnelMethodTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_PASSWORD_AUTH":
		*e = SourceMssqlSchemasTunnelMethodTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMssqlSchemasTunnelMethodTunnelMethod: %v", v)
	}
}

// SourceMssqlPasswordAuthentication - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceMssqlPasswordAuthentication struct {
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and password authentication
	tunnelMethod SourceMssqlSchemasTunnelMethodTunnelMethod `const:"SSH_PASSWORD_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser string `json:"tunnel_user"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword string `json:"tunnel_user_password"`
}

func (s SourceMssqlPasswordAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMssqlPasswordAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceMssqlPasswordAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *SourceMssqlPasswordAuthentication) GetTunnelMethod() SourceMssqlSchemasTunnelMethodTunnelMethod {
	return SourceMssqlSchemasTunnelMethodTunnelMethodSSHPasswordAuth
}

func (o *SourceMssqlPasswordAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *SourceMssqlPasswordAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

func (o *SourceMssqlPasswordAuthentication) GetTunnelUserPassword() string {
	if o == nil {
		return ""
	}
	return o.TunnelUserPassword
}

// SourceMssqlSchemasTunnelMethod - Connect through a jump server tunnel host using username and ssh key
type SourceMssqlSchemasTunnelMethod string

const (
	SourceMssqlSchemasTunnelMethodSSHKeyAuth SourceMssqlSchemasTunnelMethod = "SSH_KEY_AUTH"
)

func (e SourceMssqlSchemasTunnelMethod) ToPointer() *SourceMssqlSchemasTunnelMethod {
	return &e
}

func (e *SourceMssqlSchemasTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_KEY_AUTH":
		*e = SourceMssqlSchemasTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMssqlSchemasTunnelMethod: %v", v)
	}
}

// SourceMssqlSSHKeyAuthentication - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceMssqlSSHKeyAuthentication struct {
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey string `json:"ssh_key"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and ssh key
	tunnelMethod SourceMssqlSchemasTunnelMethod `const:"SSH_KEY_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host.
	TunnelUser string `json:"tunnel_user"`
}

func (s SourceMssqlSSHKeyAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMssqlSSHKeyAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceMssqlSSHKeyAuthentication) GetSSHKey() string {
	if o == nil {
		return ""
	}
	return o.SSHKey
}

func (o *SourceMssqlSSHKeyAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *SourceMssqlSSHKeyAuthentication) GetTunnelMethod() SourceMssqlSchemasTunnelMethod {
	return SourceMssqlSchemasTunnelMethodSSHKeyAuth
}

func (o *SourceMssqlSSHKeyAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *SourceMssqlSSHKeyAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

// SourceMssqlTunnelMethod - No ssh tunnel needed to connect to database
type SourceMssqlTunnelMethod string

const (
	SourceMssqlTunnelMethodNoTunnel SourceMssqlTunnelMethod = "NO_TUNNEL"
)

func (e SourceMssqlTunnelMethod) ToPointer() *SourceMssqlTunnelMethod {
	return &e
}

func (e *SourceMssqlTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NO_TUNNEL":
		*e = SourceMssqlTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMssqlTunnelMethod: %v", v)
	}
}

// SourceMssqlNoTunnel - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceMssqlNoTunnel struct {
	// No ssh tunnel needed to connect to database
	tunnelMethod SourceMssqlTunnelMethod `const:"NO_TUNNEL" json:"tunnel_method"`
}

func (s SourceMssqlNoTunnel) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMssqlNoTunnel) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceMssqlNoTunnel) GetTunnelMethod() SourceMssqlTunnelMethod {
	return SourceMssqlTunnelMethodNoTunnel
}

type SourceMssqlSSHTunnelMethodType string

const (
	SourceMssqlSSHTunnelMethodTypeNoTunnel               SourceMssqlSSHTunnelMethodType = "NoTunnel"
	SourceMssqlSSHTunnelMethodTypeSSHKeyAuthentication   SourceMssqlSSHTunnelMethodType = "SSHKeyAuthentication"
	SourceMssqlSSHTunnelMethodTypePasswordAuthentication SourceMssqlSSHTunnelMethodType = "PasswordAuthentication"
)

type SourceMssqlSSHTunnelMethod struct {
	NoTunnel               *SourceMssqlNoTunnel
	SSHKeyAuthentication   *SourceMssqlSSHKeyAuthentication
	PasswordAuthentication *SourceMssqlPasswordAuthentication

	Type SourceMssqlSSHTunnelMethodType
}

func CreateSourceMssqlSSHTunnelMethodNoTunnel(noTunnel SourceMssqlNoTunnel) SourceMssqlSSHTunnelMethod {
	typ := SourceMssqlSSHTunnelMethodTypeNoTunnel

	return SourceMssqlSSHTunnelMethod{
		NoTunnel: &noTunnel,
		Type:     typ,
	}
}

func CreateSourceMssqlSSHTunnelMethodSSHKeyAuthentication(sshKeyAuthentication SourceMssqlSSHKeyAuthentication) SourceMssqlSSHTunnelMethod {
	typ := SourceMssqlSSHTunnelMethodTypeSSHKeyAuthentication

	return SourceMssqlSSHTunnelMethod{
		SSHKeyAuthentication: &sshKeyAuthentication,
		Type:                 typ,
	}
}

func CreateSourceMssqlSSHTunnelMethodPasswordAuthentication(passwordAuthentication SourceMssqlPasswordAuthentication) SourceMssqlSSHTunnelMethod {
	typ := SourceMssqlSSHTunnelMethodTypePasswordAuthentication

	return SourceMssqlSSHTunnelMethod{
		PasswordAuthentication: &passwordAuthentication,
		Type:                   typ,
	}
}

func (u *SourceMssqlSSHTunnelMethod) UnmarshalJSON(data []byte) error {

	noTunnel := new(SourceMssqlNoTunnel)
	if err := utils.UnmarshalJSON(data, &noTunnel, "", true, true); err == nil {
		u.NoTunnel = noTunnel
		u.Type = SourceMssqlSSHTunnelMethodTypeNoTunnel
		return nil
	}

	sshKeyAuthentication := new(SourceMssqlSSHKeyAuthentication)
	if err := utils.UnmarshalJSON(data, &sshKeyAuthentication, "", true, true); err == nil {
		u.SSHKeyAuthentication = sshKeyAuthentication
		u.Type = SourceMssqlSSHTunnelMethodTypeSSHKeyAuthentication
		return nil
	}

	passwordAuthentication := new(SourceMssqlPasswordAuthentication)
	if err := utils.UnmarshalJSON(data, &passwordAuthentication, "", true, true); err == nil {
		u.PasswordAuthentication = passwordAuthentication
		u.Type = SourceMssqlSSHTunnelMethodTypePasswordAuthentication
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SourceMssqlSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.NoTunnel != nil {
		return utils.MarshalJSON(u.NoTunnel, "", true)
	}

	if u.SSHKeyAuthentication != nil {
		return utils.MarshalJSON(u.SSHKeyAuthentication, "", true)
	}

	if u.PasswordAuthentication != nil {
		return utils.MarshalJSON(u.PasswordAuthentication, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type SourceMssql struct {
	// The name of the database.
	Database string `json:"database"`
	// The hostname of the database.
	Host string `json:"host"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// The password associated with the username.
	Password *string `json:"password,omitempty"`
	// The port of the database.
	Port int64 `json:"port"`
	// Configures how data is extracted from the database.
	ReplicationMethod *SourceMssqlUpdateMethod `json:"replication_method,omitempty"`
	// The list of schemas to sync from. Defaults to user. Case sensitive.
	Schemas    []string         `json:"schemas,omitempty"`
	sourceType SourceMssqlMssql `const:"mssql" json:"sourceType"`
	// The encryption method which is used when communicating with the database.
	SslMethod *SourceMssqlSSLMethod `json:"ssl_method,omitempty"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod *SourceMssqlSSHTunnelMethod `json:"tunnel_method,omitempty"`
	// The username which is used to access the database.
	Username string `json:"username"`
}

func (s SourceMssql) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMssql) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *SourceMssql) GetDatabase() string {
	if o == nil {
		return ""
	}
	return o.Database
}

func (o *SourceMssql) GetHost() string {
	if o == nil {
		return ""
	}
	return o.Host
}

func (o *SourceMssql) GetJdbcURLParams() *string {
	if o == nil {
		return nil
	}
	return o.JdbcURLParams
}

func (o *SourceMssql) GetPassword() *string {
	if o == nil {
		return nil
	}
	return o.Password
}

func (o *SourceMssql) GetPort() int64 {
	if o == nil {
		return 0
	}
	return o.Port
}

func (o *SourceMssql) GetReplicationMethod() *SourceMssqlUpdateMethod {
	if o == nil {
		return nil
	}
	return o.ReplicationMethod
}

func (o *SourceMssql) GetSchemas() []string {
	if o == nil {
		return nil
	}
	return o.Schemas
}

func (o *SourceMssql) GetSourceType() SourceMssqlMssql {
	return SourceMssqlMssqlMssql
}

func (o *SourceMssql) GetSslMethod() *SourceMssqlSSLMethod {
	if o == nil {
		return nil
	}
	return o.SslMethod
}

func (o *SourceMssql) GetTunnelMethod() *SourceMssqlSSHTunnelMethod {
	if o == nil {
		return nil
	}
	return o.TunnelMethod
}

func (o *SourceMssql) GetUsername() string {
	if o == nil {
		return ""
	}
	return o.Username
}
