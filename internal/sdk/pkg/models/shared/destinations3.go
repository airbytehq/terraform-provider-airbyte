// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
)

type DestinationS3S3 string

const (
	DestinationS3S3S3 DestinationS3S3 = "s3"
)

func (e DestinationS3S3) ToPointer() *DestinationS3S3 {
	return &e
}

func (e *DestinationS3S3) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "s3":
		*e = DestinationS3S3(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3S3: %v", v)
	}
}

// DestinationS3OutputFormatParquetColumnarStorageCompressionCodec - The compression algorithm used to compress data pages.
type DestinationS3OutputFormatParquetColumnarStorageCompressionCodec string

const (
	DestinationS3OutputFormatParquetColumnarStorageCompressionCodecUncompressed DestinationS3OutputFormatParquetColumnarStorageCompressionCodec = "UNCOMPRESSED"
	DestinationS3OutputFormatParquetColumnarStorageCompressionCodecSnappy       DestinationS3OutputFormatParquetColumnarStorageCompressionCodec = "SNAPPY"
	DestinationS3OutputFormatParquetColumnarStorageCompressionCodecGzip         DestinationS3OutputFormatParquetColumnarStorageCompressionCodec = "GZIP"
	DestinationS3OutputFormatParquetColumnarStorageCompressionCodecLzo          DestinationS3OutputFormatParquetColumnarStorageCompressionCodec = "LZO"
	DestinationS3OutputFormatParquetColumnarStorageCompressionCodecBrotli       DestinationS3OutputFormatParquetColumnarStorageCompressionCodec = "BROTLI"
	DestinationS3OutputFormatParquetColumnarStorageCompressionCodecLz4          DestinationS3OutputFormatParquetColumnarStorageCompressionCodec = "LZ4"
	DestinationS3OutputFormatParquetColumnarStorageCompressionCodecZstd         DestinationS3OutputFormatParquetColumnarStorageCompressionCodec = "ZSTD"
)

func (e DestinationS3OutputFormatParquetColumnarStorageCompressionCodec) ToPointer() *DestinationS3OutputFormatParquetColumnarStorageCompressionCodec {
	return &e
}

func (e *DestinationS3OutputFormatParquetColumnarStorageCompressionCodec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "UNCOMPRESSED":
		fallthrough
	case "SNAPPY":
		fallthrough
	case "GZIP":
		fallthrough
	case "LZO":
		fallthrough
	case "BROTLI":
		fallthrough
	case "LZ4":
		fallthrough
	case "ZSTD":
		*e = DestinationS3OutputFormatParquetColumnarStorageCompressionCodec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3OutputFormatParquetColumnarStorageCompressionCodec: %v", v)
	}
}

type DestinationS3OutputFormatParquetColumnarStorageFormatType string

const (
	DestinationS3OutputFormatParquetColumnarStorageFormatTypeParquet DestinationS3OutputFormatParquetColumnarStorageFormatType = "Parquet"
)

func (e DestinationS3OutputFormatParquetColumnarStorageFormatType) ToPointer() *DestinationS3OutputFormatParquetColumnarStorageFormatType {
	return &e
}

func (e *DestinationS3OutputFormatParquetColumnarStorageFormatType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Parquet":
		*e = DestinationS3OutputFormatParquetColumnarStorageFormatType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3OutputFormatParquetColumnarStorageFormatType: %v", v)
	}
}

// DestinationS3OutputFormatParquetColumnarStorage - Format of the data output. See <a href="https://docs.airbyte.com/integrations/destinations/s3/#supported-output-schema">here</a> for more details
type DestinationS3OutputFormatParquetColumnarStorage struct {
	// This is the size of a row group being buffered in memory. It limits the memory usage when writing. Larger values will improve the IO when reading, but consume more memory when writing. Default: 128 MB.
	BlockSizeMb *int64 `json:"block_size_mb,omitempty"`
	// The compression algorithm used to compress data pages.
	CompressionCodec *DestinationS3OutputFormatParquetColumnarStorageCompressionCodec `json:"compression_codec,omitempty"`
	// Default: true.
	DictionaryEncoding *bool `json:"dictionary_encoding,omitempty"`
	// There is one dictionary page per column per row group when dictionary encoding is used. The dictionary page size works like the page size but for dictionary. Default: 1024 KB.
	DictionaryPageSizeKb *int64                                                    `json:"dictionary_page_size_kb,omitempty"`
	FormatType           DestinationS3OutputFormatParquetColumnarStorageFormatType `json:"format_type"`
	// Maximum size allowed as padding to align row groups. This is also the minimum size of a row group. Default: 8 MB.
	MaxPaddingSizeMb *int64 `json:"max_padding_size_mb,omitempty"`
	// The page size is for compression. A block is composed of pages. A page is the smallest unit that must be read fully to access a single record. If this value is too small, the compression will deteriorate. Default: 1024 KB.
	PageSizeKb *int64 `json:"page_size_kb,omitempty"`
}

type DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIPCompressionType string

const (
	DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIPCompressionTypeGzip DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIPCompressionType = "GZIP"
)

func (e DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIPCompressionType) ToPointer() *DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIPCompressionType {
	return &e
}

func (e *DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIPCompressionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "GZIP":
		*e = DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIPCompressionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIPCompressionType: %v", v)
	}
}

// DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP - Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").
type DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP struct {
	CompressionType *DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIPCompressionType `json:"compression_type,omitempty"`
}

type DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompressionCompressionType string

const (
	DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompressionCompressionTypeNoCompression DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompressionCompressionType = "No Compression"
)

func (e DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompressionCompressionType) ToPointer() *DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompressionCompressionType {
	return &e
}

func (e *DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompressionCompressionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "No Compression":
		*e = DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompressionCompressionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompressionCompressionType: %v", v)
	}
}

// DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression - Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").
type DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression struct {
	CompressionType *DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompressionCompressionType `json:"compression_type,omitempty"`
}

type DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionType string

const (
	DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionTypeDestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionType = "destination-s3_Output Format_JSON Lines: Newline-delimited JSON_Compression_No Compression"
	DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionTypeDestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP          DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionType = "destination-s3_Output Format_JSON Lines: Newline-delimited JSON_Compression_GZIP"
)

type DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompression struct {
	DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression *DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression
	DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP          *DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP

	Type DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionType
}

func CreateDestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionDestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression(destinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression) DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompression {
	typ := DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionTypeDestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression

	return DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompression{
		DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression: &destinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression,
		Type: typ,
	}
}

func CreateDestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionDestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP(destinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP) DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompression {
	typ := DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionTypeDestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP

	return DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompression{
		DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP: &destinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP,
		Type: typ,
	}
}

func (u *DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompression) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	destinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression := new(DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression); err == nil {
		u.DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression = destinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression
		u.Type = DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionTypeDestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression
		return nil
	}

	destinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP := new(DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP); err == nil {
		u.DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP = destinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP
		u.Type = DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionTypeDestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompression) MarshalJSON() ([]byte, error) {
	if u.DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression != nil {
		return json.Marshal(u.DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionNoCompression)
	}

	if u.DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP != nil {
		return json.Marshal(u.DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompressionGZIP)
	}

	return nil, nil
}

// DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONFlattening - Whether the input json data should be normalized (flattened) in the output JSON Lines. Please refer to docs for details.
type DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONFlattening string

const (
	DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONFlatteningNoFlattening        DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONFlattening = "No flattening"
	DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONFlatteningRootLevelFlattening DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONFlattening = "Root level flattening"
)

func (e DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONFlattening) ToPointer() *DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONFlattening {
	return &e
}

func (e *DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONFlattening) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "No flattening":
		fallthrough
	case "Root level flattening":
		*e = DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONFlattening(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONFlattening: %v", v)
	}
}

type DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONFormatType string

const (
	DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONFormatTypeJsonl DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONFormatType = "JSONL"
)

func (e DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONFormatType) ToPointer() *DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONFormatType {
	return &e
}

func (e *DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONFormatType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "JSONL":
		*e = DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONFormatType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONFormatType: %v", v)
	}
}

// DestinationS3OutputFormatJSONLinesNewlineDelimitedJSON - Format of the data output. See <a href="https://docs.airbyte.com/integrations/destinations/s3/#supported-output-schema">here</a> for more details
type DestinationS3OutputFormatJSONLinesNewlineDelimitedJSON struct {
	// Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").
	Compression *DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONCompression `json:"compression,omitempty"`
	// Whether the input json data should be normalized (flattened) in the output JSON Lines. Please refer to docs for details.
	Flattening *DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONFlattening `json:"flattening,omitempty"`
	FormatType DestinationS3OutputFormatJSONLinesNewlineDelimitedJSONFormatType  `json:"format_type"`
}

type DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionGZIPCompressionType string

const (
	DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionGZIPCompressionTypeGzip DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionGZIPCompressionType = "GZIP"
)

func (e DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionGZIPCompressionType) ToPointer() *DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionGZIPCompressionType {
	return &e
}

func (e *DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionGZIPCompressionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "GZIP":
		*e = DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionGZIPCompressionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionGZIPCompressionType: %v", v)
	}
}

// DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionGZIP - Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".csv.gz").
type DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionGZIP struct {
	CompressionType *DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionGZIPCompressionType `json:"compression_type,omitempty"`
}

type DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionNoCompressionCompressionType string

const (
	DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionNoCompressionCompressionTypeNoCompression DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionNoCompressionCompressionType = "No Compression"
)

func (e DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionNoCompressionCompressionType) ToPointer() *DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionNoCompressionCompressionType {
	return &e
}

func (e *DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionNoCompressionCompressionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "No Compression":
		*e = DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionNoCompressionCompressionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionNoCompressionCompressionType: %v", v)
	}
}

// DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionNoCompression - Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".csv.gz").
type DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionNoCompression struct {
	CompressionType *DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionNoCompressionCompressionType `json:"compression_type,omitempty"`
}

type DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionType string

const (
	DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionTypeDestinationS3OutputFormatCSVCommaSeparatedValuesCompressionNoCompression DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionType = "destination-s3_Output Format_CSV: Comma-Separated Values_Compression_No Compression"
	DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionTypeDestinationS3OutputFormatCSVCommaSeparatedValuesCompressionGZIP          DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionType = "destination-s3_Output Format_CSV: Comma-Separated Values_Compression_GZIP"
)

type DestinationS3OutputFormatCSVCommaSeparatedValuesCompression struct {
	DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionNoCompression *DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionNoCompression
	DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionGZIP          *DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionGZIP

	Type DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionType
}

func CreateDestinationS3OutputFormatCSVCommaSeparatedValuesCompressionDestinationS3OutputFormatCSVCommaSeparatedValuesCompressionNoCompression(destinationS3OutputFormatCSVCommaSeparatedValuesCompressionNoCompression DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionNoCompression) DestinationS3OutputFormatCSVCommaSeparatedValuesCompression {
	typ := DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionTypeDestinationS3OutputFormatCSVCommaSeparatedValuesCompressionNoCompression

	return DestinationS3OutputFormatCSVCommaSeparatedValuesCompression{
		DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionNoCompression: &destinationS3OutputFormatCSVCommaSeparatedValuesCompressionNoCompression,
		Type: typ,
	}
}

func CreateDestinationS3OutputFormatCSVCommaSeparatedValuesCompressionDestinationS3OutputFormatCSVCommaSeparatedValuesCompressionGZIP(destinationS3OutputFormatCSVCommaSeparatedValuesCompressionGZIP DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionGZIP) DestinationS3OutputFormatCSVCommaSeparatedValuesCompression {
	typ := DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionTypeDestinationS3OutputFormatCSVCommaSeparatedValuesCompressionGZIP

	return DestinationS3OutputFormatCSVCommaSeparatedValuesCompression{
		DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionGZIP: &destinationS3OutputFormatCSVCommaSeparatedValuesCompressionGZIP,
		Type: typ,
	}
}

func (u *DestinationS3OutputFormatCSVCommaSeparatedValuesCompression) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	destinationS3OutputFormatCSVCommaSeparatedValuesCompressionNoCompression := new(DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionNoCompression)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationS3OutputFormatCSVCommaSeparatedValuesCompressionNoCompression); err == nil {
		u.DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionNoCompression = destinationS3OutputFormatCSVCommaSeparatedValuesCompressionNoCompression
		u.Type = DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionTypeDestinationS3OutputFormatCSVCommaSeparatedValuesCompressionNoCompression
		return nil
	}

	destinationS3OutputFormatCSVCommaSeparatedValuesCompressionGZIP := new(DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionGZIP)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationS3OutputFormatCSVCommaSeparatedValuesCompressionGZIP); err == nil {
		u.DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionGZIP = destinationS3OutputFormatCSVCommaSeparatedValuesCompressionGZIP
		u.Type = DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionTypeDestinationS3OutputFormatCSVCommaSeparatedValuesCompressionGZIP
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u DestinationS3OutputFormatCSVCommaSeparatedValuesCompression) MarshalJSON() ([]byte, error) {
	if u.DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionNoCompression != nil {
		return json.Marshal(u.DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionNoCompression)
	}

	if u.DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionGZIP != nil {
		return json.Marshal(u.DestinationS3OutputFormatCSVCommaSeparatedValuesCompressionGZIP)
	}

	return nil, nil
}

// DestinationS3OutputFormatCSVCommaSeparatedValuesFlattening - Whether the input json data should be normalized (flattened) in the output CSV. Please refer to docs for details.
type DestinationS3OutputFormatCSVCommaSeparatedValuesFlattening string

const (
	DestinationS3OutputFormatCSVCommaSeparatedValuesFlatteningNoFlattening        DestinationS3OutputFormatCSVCommaSeparatedValuesFlattening = "No flattening"
	DestinationS3OutputFormatCSVCommaSeparatedValuesFlatteningRootLevelFlattening DestinationS3OutputFormatCSVCommaSeparatedValuesFlattening = "Root level flattening"
)

func (e DestinationS3OutputFormatCSVCommaSeparatedValuesFlattening) ToPointer() *DestinationS3OutputFormatCSVCommaSeparatedValuesFlattening {
	return &e
}

func (e *DestinationS3OutputFormatCSVCommaSeparatedValuesFlattening) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "No flattening":
		fallthrough
	case "Root level flattening":
		*e = DestinationS3OutputFormatCSVCommaSeparatedValuesFlattening(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3OutputFormatCSVCommaSeparatedValuesFlattening: %v", v)
	}
}

type DestinationS3OutputFormatCSVCommaSeparatedValuesFormatType string

const (
	DestinationS3OutputFormatCSVCommaSeparatedValuesFormatTypeCsv DestinationS3OutputFormatCSVCommaSeparatedValuesFormatType = "CSV"
)

func (e DestinationS3OutputFormatCSVCommaSeparatedValuesFormatType) ToPointer() *DestinationS3OutputFormatCSVCommaSeparatedValuesFormatType {
	return &e
}

func (e *DestinationS3OutputFormatCSVCommaSeparatedValuesFormatType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CSV":
		*e = DestinationS3OutputFormatCSVCommaSeparatedValuesFormatType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3OutputFormatCSVCommaSeparatedValuesFormatType: %v", v)
	}
}

// DestinationS3OutputFormatCSVCommaSeparatedValues - Format of the data output. See <a href="https://docs.airbyte.com/integrations/destinations/s3/#supported-output-schema">here</a> for more details
type DestinationS3OutputFormatCSVCommaSeparatedValues struct {
	// Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".csv.gz").
	Compression *DestinationS3OutputFormatCSVCommaSeparatedValuesCompression `json:"compression,omitempty"`
	// Whether the input json data should be normalized (flattened) in the output CSV. Please refer to docs for details.
	Flattening DestinationS3OutputFormatCSVCommaSeparatedValuesFlattening `json:"flattening"`
	FormatType DestinationS3OutputFormatCSVCommaSeparatedValuesFormatType `json:"format_type"`
}

type DestinationS3OutputFormatAvroApacheAvroCompressionCodecSnappyCodec string

const (
	DestinationS3OutputFormatAvroApacheAvroCompressionCodecSnappyCodecSnappy DestinationS3OutputFormatAvroApacheAvroCompressionCodecSnappyCodec = "snappy"
)

func (e DestinationS3OutputFormatAvroApacheAvroCompressionCodecSnappyCodec) ToPointer() *DestinationS3OutputFormatAvroApacheAvroCompressionCodecSnappyCodec {
	return &e
}

func (e *DestinationS3OutputFormatAvroApacheAvroCompressionCodecSnappyCodec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "snappy":
		*e = DestinationS3OutputFormatAvroApacheAvroCompressionCodecSnappyCodec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3OutputFormatAvroApacheAvroCompressionCodecSnappyCodec: %v", v)
	}
}

// DestinationS3OutputFormatAvroApacheAvroCompressionCodecSnappy - The compression algorithm used to compress data. Default to no compression.
type DestinationS3OutputFormatAvroApacheAvroCompressionCodecSnappy struct {
	Codec DestinationS3OutputFormatAvroApacheAvroCompressionCodecSnappyCodec `json:"codec"`
}

type DestinationS3OutputFormatAvroApacheAvroCompressionCodecZstandardCodec string

const (
	DestinationS3OutputFormatAvroApacheAvroCompressionCodecZstandardCodecZstandard DestinationS3OutputFormatAvroApacheAvroCompressionCodecZstandardCodec = "zstandard"
)

func (e DestinationS3OutputFormatAvroApacheAvroCompressionCodecZstandardCodec) ToPointer() *DestinationS3OutputFormatAvroApacheAvroCompressionCodecZstandardCodec {
	return &e
}

func (e *DestinationS3OutputFormatAvroApacheAvroCompressionCodecZstandardCodec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "zstandard":
		*e = DestinationS3OutputFormatAvroApacheAvroCompressionCodecZstandardCodec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3OutputFormatAvroApacheAvroCompressionCodecZstandardCodec: %v", v)
	}
}

// DestinationS3OutputFormatAvroApacheAvroCompressionCodecZstandard - The compression algorithm used to compress data. Default to no compression.
type DestinationS3OutputFormatAvroApacheAvroCompressionCodecZstandard struct {
	Codec DestinationS3OutputFormatAvroApacheAvroCompressionCodecZstandardCodec `json:"codec"`
	// Negative levels are 'fast' modes akin to lz4 or snappy, levels above 9 are generally for archival purposes, and levels above 18 use a lot of memory.
	CompressionLevel int64 `json:"compression_level"`
	// If true, include a checksum with each data block.
	IncludeChecksum *bool `json:"include_checksum,omitempty"`
}

type DestinationS3OutputFormatAvroApacheAvroCompressionCodecXzCodec string

const (
	DestinationS3OutputFormatAvroApacheAvroCompressionCodecXzCodecXz DestinationS3OutputFormatAvroApacheAvroCompressionCodecXzCodec = "xz"
)

func (e DestinationS3OutputFormatAvroApacheAvroCompressionCodecXzCodec) ToPointer() *DestinationS3OutputFormatAvroApacheAvroCompressionCodecXzCodec {
	return &e
}

func (e *DestinationS3OutputFormatAvroApacheAvroCompressionCodecXzCodec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "xz":
		*e = DestinationS3OutputFormatAvroApacheAvroCompressionCodecXzCodec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3OutputFormatAvroApacheAvroCompressionCodecXzCodec: %v", v)
	}
}

// DestinationS3OutputFormatAvroApacheAvroCompressionCodecXz - The compression algorithm used to compress data. Default to no compression.
type DestinationS3OutputFormatAvroApacheAvroCompressionCodecXz struct {
	Codec DestinationS3OutputFormatAvroApacheAvroCompressionCodecXzCodec `json:"codec"`
	// See <a href="https://commons.apache.org/proper/commons-compress/apidocs/org/apache/commons/compress/compressors/xz/XZCompressorOutputStream.html#XZCompressorOutputStream-java.io.OutputStream-int-">here</a> for details.
	CompressionLevel int64 `json:"compression_level"`
}

type DestinationS3OutputFormatAvroApacheAvroCompressionCodecBzip2Codec string

const (
	DestinationS3OutputFormatAvroApacheAvroCompressionCodecBzip2CodecBzip2 DestinationS3OutputFormatAvroApacheAvroCompressionCodecBzip2Codec = "bzip2"
)

func (e DestinationS3OutputFormatAvroApacheAvroCompressionCodecBzip2Codec) ToPointer() *DestinationS3OutputFormatAvroApacheAvroCompressionCodecBzip2Codec {
	return &e
}

func (e *DestinationS3OutputFormatAvroApacheAvroCompressionCodecBzip2Codec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "bzip2":
		*e = DestinationS3OutputFormatAvroApacheAvroCompressionCodecBzip2Codec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3OutputFormatAvroApacheAvroCompressionCodecBzip2Codec: %v", v)
	}
}

// DestinationS3OutputFormatAvroApacheAvroCompressionCodecBzip2 - The compression algorithm used to compress data. Default to no compression.
type DestinationS3OutputFormatAvroApacheAvroCompressionCodecBzip2 struct {
	Codec DestinationS3OutputFormatAvroApacheAvroCompressionCodecBzip2Codec `json:"codec"`
}

type DestinationS3OutputFormatAvroApacheAvroCompressionCodecDeflateCodec string

const (
	DestinationS3OutputFormatAvroApacheAvroCompressionCodecDeflateCodecDeflate DestinationS3OutputFormatAvroApacheAvroCompressionCodecDeflateCodec = "Deflate"
)

func (e DestinationS3OutputFormatAvroApacheAvroCompressionCodecDeflateCodec) ToPointer() *DestinationS3OutputFormatAvroApacheAvroCompressionCodecDeflateCodec {
	return &e
}

func (e *DestinationS3OutputFormatAvroApacheAvroCompressionCodecDeflateCodec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Deflate":
		*e = DestinationS3OutputFormatAvroApacheAvroCompressionCodecDeflateCodec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3OutputFormatAvroApacheAvroCompressionCodecDeflateCodec: %v", v)
	}
}

// DestinationS3OutputFormatAvroApacheAvroCompressionCodecDeflate - The compression algorithm used to compress data. Default to no compression.
type DestinationS3OutputFormatAvroApacheAvroCompressionCodecDeflate struct {
	Codec DestinationS3OutputFormatAvroApacheAvroCompressionCodecDeflateCodec `json:"codec"`
	// 0: no compression & fastest, 9: best compression & slowest.
	CompressionLevel int64 `json:"compression_level"`
}

type DestinationS3OutputFormatAvroApacheAvroCompressionCodecNoCompressionCodec string

const (
	DestinationS3OutputFormatAvroApacheAvroCompressionCodecNoCompressionCodecNoCompression DestinationS3OutputFormatAvroApacheAvroCompressionCodecNoCompressionCodec = "no compression"
)

func (e DestinationS3OutputFormatAvroApacheAvroCompressionCodecNoCompressionCodec) ToPointer() *DestinationS3OutputFormatAvroApacheAvroCompressionCodecNoCompressionCodec {
	return &e
}

func (e *DestinationS3OutputFormatAvroApacheAvroCompressionCodecNoCompressionCodec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "no compression":
		*e = DestinationS3OutputFormatAvroApacheAvroCompressionCodecNoCompressionCodec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3OutputFormatAvroApacheAvroCompressionCodecNoCompressionCodec: %v", v)
	}
}

// DestinationS3OutputFormatAvroApacheAvroCompressionCodecNoCompression - The compression algorithm used to compress data. Default to no compression.
type DestinationS3OutputFormatAvroApacheAvroCompressionCodecNoCompression struct {
	Codec DestinationS3OutputFormatAvroApacheAvroCompressionCodecNoCompressionCodec `json:"codec"`
}

type DestinationS3OutputFormatAvroApacheAvroCompressionCodecType string

const (
	DestinationS3OutputFormatAvroApacheAvroCompressionCodecTypeDestinationS3OutputFormatAvroApacheAvroCompressionCodecNoCompression DestinationS3OutputFormatAvroApacheAvroCompressionCodecType = "destination-s3_Output Format_Avro: Apache Avro_Compression Codec_No Compression"
	DestinationS3OutputFormatAvroApacheAvroCompressionCodecTypeDestinationS3OutputFormatAvroApacheAvroCompressionCodecDeflate       DestinationS3OutputFormatAvroApacheAvroCompressionCodecType = "destination-s3_Output Format_Avro: Apache Avro_Compression Codec_Deflate"
	DestinationS3OutputFormatAvroApacheAvroCompressionCodecTypeDestinationS3OutputFormatAvroApacheAvroCompressionCodecBzip2         DestinationS3OutputFormatAvroApacheAvroCompressionCodecType = "destination-s3_Output Format_Avro: Apache Avro_Compression Codec_bzip2"
	DestinationS3OutputFormatAvroApacheAvroCompressionCodecTypeDestinationS3OutputFormatAvroApacheAvroCompressionCodecXz            DestinationS3OutputFormatAvroApacheAvroCompressionCodecType = "destination-s3_Output Format_Avro: Apache Avro_Compression Codec_xz"
	DestinationS3OutputFormatAvroApacheAvroCompressionCodecTypeDestinationS3OutputFormatAvroApacheAvroCompressionCodecZstandard     DestinationS3OutputFormatAvroApacheAvroCompressionCodecType = "destination-s3_Output Format_Avro: Apache Avro_Compression Codec_zstandard"
	DestinationS3OutputFormatAvroApacheAvroCompressionCodecTypeDestinationS3OutputFormatAvroApacheAvroCompressionCodecSnappy        DestinationS3OutputFormatAvroApacheAvroCompressionCodecType = "destination-s3_Output Format_Avro: Apache Avro_Compression Codec_snappy"
)

type DestinationS3OutputFormatAvroApacheAvroCompressionCodec struct {
	DestinationS3OutputFormatAvroApacheAvroCompressionCodecNoCompression *DestinationS3OutputFormatAvroApacheAvroCompressionCodecNoCompression
	DestinationS3OutputFormatAvroApacheAvroCompressionCodecDeflate       *DestinationS3OutputFormatAvroApacheAvroCompressionCodecDeflate
	DestinationS3OutputFormatAvroApacheAvroCompressionCodecBzip2         *DestinationS3OutputFormatAvroApacheAvroCompressionCodecBzip2
	DestinationS3OutputFormatAvroApacheAvroCompressionCodecXz            *DestinationS3OutputFormatAvroApacheAvroCompressionCodecXz
	DestinationS3OutputFormatAvroApacheAvroCompressionCodecZstandard     *DestinationS3OutputFormatAvroApacheAvroCompressionCodecZstandard
	DestinationS3OutputFormatAvroApacheAvroCompressionCodecSnappy        *DestinationS3OutputFormatAvroApacheAvroCompressionCodecSnappy

	Type DestinationS3OutputFormatAvroApacheAvroCompressionCodecType
}

func CreateDestinationS3OutputFormatAvroApacheAvroCompressionCodecDestinationS3OutputFormatAvroApacheAvroCompressionCodecNoCompression(destinationS3OutputFormatAvroApacheAvroCompressionCodecNoCompression DestinationS3OutputFormatAvroApacheAvroCompressionCodecNoCompression) DestinationS3OutputFormatAvroApacheAvroCompressionCodec {
	typ := DestinationS3OutputFormatAvroApacheAvroCompressionCodecTypeDestinationS3OutputFormatAvroApacheAvroCompressionCodecNoCompression

	return DestinationS3OutputFormatAvroApacheAvroCompressionCodec{
		DestinationS3OutputFormatAvroApacheAvroCompressionCodecNoCompression: &destinationS3OutputFormatAvroApacheAvroCompressionCodecNoCompression,
		Type: typ,
	}
}

func CreateDestinationS3OutputFormatAvroApacheAvroCompressionCodecDestinationS3OutputFormatAvroApacheAvroCompressionCodecDeflate(destinationS3OutputFormatAvroApacheAvroCompressionCodecDeflate DestinationS3OutputFormatAvroApacheAvroCompressionCodecDeflate) DestinationS3OutputFormatAvroApacheAvroCompressionCodec {
	typ := DestinationS3OutputFormatAvroApacheAvroCompressionCodecTypeDestinationS3OutputFormatAvroApacheAvroCompressionCodecDeflate

	return DestinationS3OutputFormatAvroApacheAvroCompressionCodec{
		DestinationS3OutputFormatAvroApacheAvroCompressionCodecDeflate: &destinationS3OutputFormatAvroApacheAvroCompressionCodecDeflate,
		Type: typ,
	}
}

func CreateDestinationS3OutputFormatAvroApacheAvroCompressionCodecDestinationS3OutputFormatAvroApacheAvroCompressionCodecBzip2(destinationS3OutputFormatAvroApacheAvroCompressionCodecBzip2 DestinationS3OutputFormatAvroApacheAvroCompressionCodecBzip2) DestinationS3OutputFormatAvroApacheAvroCompressionCodec {
	typ := DestinationS3OutputFormatAvroApacheAvroCompressionCodecTypeDestinationS3OutputFormatAvroApacheAvroCompressionCodecBzip2

	return DestinationS3OutputFormatAvroApacheAvroCompressionCodec{
		DestinationS3OutputFormatAvroApacheAvroCompressionCodecBzip2: &destinationS3OutputFormatAvroApacheAvroCompressionCodecBzip2,
		Type: typ,
	}
}

func CreateDestinationS3OutputFormatAvroApacheAvroCompressionCodecDestinationS3OutputFormatAvroApacheAvroCompressionCodecXz(destinationS3OutputFormatAvroApacheAvroCompressionCodecXz DestinationS3OutputFormatAvroApacheAvroCompressionCodecXz) DestinationS3OutputFormatAvroApacheAvroCompressionCodec {
	typ := DestinationS3OutputFormatAvroApacheAvroCompressionCodecTypeDestinationS3OutputFormatAvroApacheAvroCompressionCodecXz

	return DestinationS3OutputFormatAvroApacheAvroCompressionCodec{
		DestinationS3OutputFormatAvroApacheAvroCompressionCodecXz: &destinationS3OutputFormatAvroApacheAvroCompressionCodecXz,
		Type: typ,
	}
}

func CreateDestinationS3OutputFormatAvroApacheAvroCompressionCodecDestinationS3OutputFormatAvroApacheAvroCompressionCodecZstandard(destinationS3OutputFormatAvroApacheAvroCompressionCodecZstandard DestinationS3OutputFormatAvroApacheAvroCompressionCodecZstandard) DestinationS3OutputFormatAvroApacheAvroCompressionCodec {
	typ := DestinationS3OutputFormatAvroApacheAvroCompressionCodecTypeDestinationS3OutputFormatAvroApacheAvroCompressionCodecZstandard

	return DestinationS3OutputFormatAvroApacheAvroCompressionCodec{
		DestinationS3OutputFormatAvroApacheAvroCompressionCodecZstandard: &destinationS3OutputFormatAvroApacheAvroCompressionCodecZstandard,
		Type: typ,
	}
}

func CreateDestinationS3OutputFormatAvroApacheAvroCompressionCodecDestinationS3OutputFormatAvroApacheAvroCompressionCodecSnappy(destinationS3OutputFormatAvroApacheAvroCompressionCodecSnappy DestinationS3OutputFormatAvroApacheAvroCompressionCodecSnappy) DestinationS3OutputFormatAvroApacheAvroCompressionCodec {
	typ := DestinationS3OutputFormatAvroApacheAvroCompressionCodecTypeDestinationS3OutputFormatAvroApacheAvroCompressionCodecSnappy

	return DestinationS3OutputFormatAvroApacheAvroCompressionCodec{
		DestinationS3OutputFormatAvroApacheAvroCompressionCodecSnappy: &destinationS3OutputFormatAvroApacheAvroCompressionCodecSnappy,
		Type: typ,
	}
}

func (u *DestinationS3OutputFormatAvroApacheAvroCompressionCodec) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	destinationS3OutputFormatAvroApacheAvroCompressionCodecNoCompression := new(DestinationS3OutputFormatAvroApacheAvroCompressionCodecNoCompression)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationS3OutputFormatAvroApacheAvroCompressionCodecNoCompression); err == nil {
		u.DestinationS3OutputFormatAvroApacheAvroCompressionCodecNoCompression = destinationS3OutputFormatAvroApacheAvroCompressionCodecNoCompression
		u.Type = DestinationS3OutputFormatAvroApacheAvroCompressionCodecTypeDestinationS3OutputFormatAvroApacheAvroCompressionCodecNoCompression
		return nil
	}

	destinationS3OutputFormatAvroApacheAvroCompressionCodecBzip2 := new(DestinationS3OutputFormatAvroApacheAvroCompressionCodecBzip2)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationS3OutputFormatAvroApacheAvroCompressionCodecBzip2); err == nil {
		u.DestinationS3OutputFormatAvroApacheAvroCompressionCodecBzip2 = destinationS3OutputFormatAvroApacheAvroCompressionCodecBzip2
		u.Type = DestinationS3OutputFormatAvroApacheAvroCompressionCodecTypeDestinationS3OutputFormatAvroApacheAvroCompressionCodecBzip2
		return nil
	}

	destinationS3OutputFormatAvroApacheAvroCompressionCodecSnappy := new(DestinationS3OutputFormatAvroApacheAvroCompressionCodecSnappy)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationS3OutputFormatAvroApacheAvroCompressionCodecSnappy); err == nil {
		u.DestinationS3OutputFormatAvroApacheAvroCompressionCodecSnappy = destinationS3OutputFormatAvroApacheAvroCompressionCodecSnappy
		u.Type = DestinationS3OutputFormatAvroApacheAvroCompressionCodecTypeDestinationS3OutputFormatAvroApacheAvroCompressionCodecSnappy
		return nil
	}

	destinationS3OutputFormatAvroApacheAvroCompressionCodecDeflate := new(DestinationS3OutputFormatAvroApacheAvroCompressionCodecDeflate)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationS3OutputFormatAvroApacheAvroCompressionCodecDeflate); err == nil {
		u.DestinationS3OutputFormatAvroApacheAvroCompressionCodecDeflate = destinationS3OutputFormatAvroApacheAvroCompressionCodecDeflate
		u.Type = DestinationS3OutputFormatAvroApacheAvroCompressionCodecTypeDestinationS3OutputFormatAvroApacheAvroCompressionCodecDeflate
		return nil
	}

	destinationS3OutputFormatAvroApacheAvroCompressionCodecXz := new(DestinationS3OutputFormatAvroApacheAvroCompressionCodecXz)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationS3OutputFormatAvroApacheAvroCompressionCodecXz); err == nil {
		u.DestinationS3OutputFormatAvroApacheAvroCompressionCodecXz = destinationS3OutputFormatAvroApacheAvroCompressionCodecXz
		u.Type = DestinationS3OutputFormatAvroApacheAvroCompressionCodecTypeDestinationS3OutputFormatAvroApacheAvroCompressionCodecXz
		return nil
	}

	destinationS3OutputFormatAvroApacheAvroCompressionCodecZstandard := new(DestinationS3OutputFormatAvroApacheAvroCompressionCodecZstandard)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationS3OutputFormatAvroApacheAvroCompressionCodecZstandard); err == nil {
		u.DestinationS3OutputFormatAvroApacheAvroCompressionCodecZstandard = destinationS3OutputFormatAvroApacheAvroCompressionCodecZstandard
		u.Type = DestinationS3OutputFormatAvroApacheAvroCompressionCodecTypeDestinationS3OutputFormatAvroApacheAvroCompressionCodecZstandard
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u DestinationS3OutputFormatAvroApacheAvroCompressionCodec) MarshalJSON() ([]byte, error) {
	if u.DestinationS3OutputFormatAvroApacheAvroCompressionCodecNoCompression != nil {
		return json.Marshal(u.DestinationS3OutputFormatAvroApacheAvroCompressionCodecNoCompression)
	}

	if u.DestinationS3OutputFormatAvroApacheAvroCompressionCodecBzip2 != nil {
		return json.Marshal(u.DestinationS3OutputFormatAvroApacheAvroCompressionCodecBzip2)
	}

	if u.DestinationS3OutputFormatAvroApacheAvroCompressionCodecSnappy != nil {
		return json.Marshal(u.DestinationS3OutputFormatAvroApacheAvroCompressionCodecSnappy)
	}

	if u.DestinationS3OutputFormatAvroApacheAvroCompressionCodecDeflate != nil {
		return json.Marshal(u.DestinationS3OutputFormatAvroApacheAvroCompressionCodecDeflate)
	}

	if u.DestinationS3OutputFormatAvroApacheAvroCompressionCodecXz != nil {
		return json.Marshal(u.DestinationS3OutputFormatAvroApacheAvroCompressionCodecXz)
	}

	if u.DestinationS3OutputFormatAvroApacheAvroCompressionCodecZstandard != nil {
		return json.Marshal(u.DestinationS3OutputFormatAvroApacheAvroCompressionCodecZstandard)
	}

	return nil, nil
}

type DestinationS3OutputFormatAvroApacheAvroFormatType string

const (
	DestinationS3OutputFormatAvroApacheAvroFormatTypeAvro DestinationS3OutputFormatAvroApacheAvroFormatType = "Avro"
)

func (e DestinationS3OutputFormatAvroApacheAvroFormatType) ToPointer() *DestinationS3OutputFormatAvroApacheAvroFormatType {
	return &e
}

func (e *DestinationS3OutputFormatAvroApacheAvroFormatType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Avro":
		*e = DestinationS3OutputFormatAvroApacheAvroFormatType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3OutputFormatAvroApacheAvroFormatType: %v", v)
	}
}

// DestinationS3OutputFormatAvroApacheAvro - Format of the data output. See <a href="https://docs.airbyte.com/integrations/destinations/s3/#supported-output-schema">here</a> for more details
type DestinationS3OutputFormatAvroApacheAvro struct {
	// The compression algorithm used to compress data. Default to no compression.
	CompressionCodec DestinationS3OutputFormatAvroApacheAvroCompressionCodec `json:"compression_codec"`
	FormatType       DestinationS3OutputFormatAvroApacheAvroFormatType       `json:"format_type"`
}

type DestinationS3OutputFormatType string

const (
	DestinationS3OutputFormatTypeDestinationS3OutputFormatAvroApacheAvro                DestinationS3OutputFormatType = "destination-s3_Output Format_Avro: Apache Avro"
	DestinationS3OutputFormatTypeDestinationS3OutputFormatCSVCommaSeparatedValues       DestinationS3OutputFormatType = "destination-s3_Output Format_CSV: Comma-Separated Values"
	DestinationS3OutputFormatTypeDestinationS3OutputFormatJSONLinesNewlineDelimitedJSON DestinationS3OutputFormatType = "destination-s3_Output Format_JSON Lines: Newline-delimited JSON"
	DestinationS3OutputFormatTypeDestinationS3OutputFormatParquetColumnarStorage        DestinationS3OutputFormatType = "destination-s3_Output Format_Parquet: Columnar Storage"
)

type DestinationS3OutputFormat struct {
	DestinationS3OutputFormatAvroApacheAvro                *DestinationS3OutputFormatAvroApacheAvro
	DestinationS3OutputFormatCSVCommaSeparatedValues       *DestinationS3OutputFormatCSVCommaSeparatedValues
	DestinationS3OutputFormatJSONLinesNewlineDelimitedJSON *DestinationS3OutputFormatJSONLinesNewlineDelimitedJSON
	DestinationS3OutputFormatParquetColumnarStorage        *DestinationS3OutputFormatParquetColumnarStorage

	Type DestinationS3OutputFormatType
}

func CreateDestinationS3OutputFormatDestinationS3OutputFormatAvroApacheAvro(destinationS3OutputFormatAvroApacheAvro DestinationS3OutputFormatAvroApacheAvro) DestinationS3OutputFormat {
	typ := DestinationS3OutputFormatTypeDestinationS3OutputFormatAvroApacheAvro

	return DestinationS3OutputFormat{
		DestinationS3OutputFormatAvroApacheAvro: &destinationS3OutputFormatAvroApacheAvro,
		Type:                                    typ,
	}
}

func CreateDestinationS3OutputFormatDestinationS3OutputFormatCSVCommaSeparatedValues(destinationS3OutputFormatCSVCommaSeparatedValues DestinationS3OutputFormatCSVCommaSeparatedValues) DestinationS3OutputFormat {
	typ := DestinationS3OutputFormatTypeDestinationS3OutputFormatCSVCommaSeparatedValues

	return DestinationS3OutputFormat{
		DestinationS3OutputFormatCSVCommaSeparatedValues: &destinationS3OutputFormatCSVCommaSeparatedValues,
		Type: typ,
	}
}

func CreateDestinationS3OutputFormatDestinationS3OutputFormatJSONLinesNewlineDelimitedJSON(destinationS3OutputFormatJSONLinesNewlineDelimitedJSON DestinationS3OutputFormatJSONLinesNewlineDelimitedJSON) DestinationS3OutputFormat {
	typ := DestinationS3OutputFormatTypeDestinationS3OutputFormatJSONLinesNewlineDelimitedJSON

	return DestinationS3OutputFormat{
		DestinationS3OutputFormatJSONLinesNewlineDelimitedJSON: &destinationS3OutputFormatJSONLinesNewlineDelimitedJSON,
		Type: typ,
	}
}

func CreateDestinationS3OutputFormatDestinationS3OutputFormatParquetColumnarStorage(destinationS3OutputFormatParquetColumnarStorage DestinationS3OutputFormatParquetColumnarStorage) DestinationS3OutputFormat {
	typ := DestinationS3OutputFormatTypeDestinationS3OutputFormatParquetColumnarStorage

	return DestinationS3OutputFormat{
		DestinationS3OutputFormatParquetColumnarStorage: &destinationS3OutputFormatParquetColumnarStorage,
		Type: typ,
	}
}

func (u *DestinationS3OutputFormat) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	destinationS3OutputFormatAvroApacheAvro := new(DestinationS3OutputFormatAvroApacheAvro)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationS3OutputFormatAvroApacheAvro); err == nil {
		u.DestinationS3OutputFormatAvroApacheAvro = destinationS3OutputFormatAvroApacheAvro
		u.Type = DestinationS3OutputFormatTypeDestinationS3OutputFormatAvroApacheAvro
		return nil
	}

	destinationS3OutputFormatCSVCommaSeparatedValues := new(DestinationS3OutputFormatCSVCommaSeparatedValues)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationS3OutputFormatCSVCommaSeparatedValues); err == nil {
		u.DestinationS3OutputFormatCSVCommaSeparatedValues = destinationS3OutputFormatCSVCommaSeparatedValues
		u.Type = DestinationS3OutputFormatTypeDestinationS3OutputFormatCSVCommaSeparatedValues
		return nil
	}

	destinationS3OutputFormatJSONLinesNewlineDelimitedJSON := new(DestinationS3OutputFormatJSONLinesNewlineDelimitedJSON)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationS3OutputFormatJSONLinesNewlineDelimitedJSON); err == nil {
		u.DestinationS3OutputFormatJSONLinesNewlineDelimitedJSON = destinationS3OutputFormatJSONLinesNewlineDelimitedJSON
		u.Type = DestinationS3OutputFormatTypeDestinationS3OutputFormatJSONLinesNewlineDelimitedJSON
		return nil
	}

	destinationS3OutputFormatParquetColumnarStorage := new(DestinationS3OutputFormatParquetColumnarStorage)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&destinationS3OutputFormatParquetColumnarStorage); err == nil {
		u.DestinationS3OutputFormatParquetColumnarStorage = destinationS3OutputFormatParquetColumnarStorage
		u.Type = DestinationS3OutputFormatTypeDestinationS3OutputFormatParquetColumnarStorage
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u DestinationS3OutputFormat) MarshalJSON() ([]byte, error) {
	if u.DestinationS3OutputFormatAvroApacheAvro != nil {
		return json.Marshal(u.DestinationS3OutputFormatAvroApacheAvro)
	}

	if u.DestinationS3OutputFormatCSVCommaSeparatedValues != nil {
		return json.Marshal(u.DestinationS3OutputFormatCSVCommaSeparatedValues)
	}

	if u.DestinationS3OutputFormatJSONLinesNewlineDelimitedJSON != nil {
		return json.Marshal(u.DestinationS3OutputFormatJSONLinesNewlineDelimitedJSON)
	}

	if u.DestinationS3OutputFormatParquetColumnarStorage != nil {
		return json.Marshal(u.DestinationS3OutputFormatParquetColumnarStorage)
	}

	return nil, nil
}

// DestinationS3S3BucketRegion - The region of the S3 bucket. See <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-available-regions">here</a> for all region codes.
type DestinationS3S3BucketRegion string

const (
	DestinationS3S3BucketRegionUnknown      DestinationS3S3BucketRegion = ""
	DestinationS3S3BucketRegionUsEast1      DestinationS3S3BucketRegion = "us-east-1"
	DestinationS3S3BucketRegionUsEast2      DestinationS3S3BucketRegion = "us-east-2"
	DestinationS3S3BucketRegionUsWest1      DestinationS3S3BucketRegion = "us-west-1"
	DestinationS3S3BucketRegionUsWest2      DestinationS3S3BucketRegion = "us-west-2"
	DestinationS3S3BucketRegionAfSouth1     DestinationS3S3BucketRegion = "af-south-1"
	DestinationS3S3BucketRegionApEast1      DestinationS3S3BucketRegion = "ap-east-1"
	DestinationS3S3BucketRegionApSouth1     DestinationS3S3BucketRegion = "ap-south-1"
	DestinationS3S3BucketRegionApNortheast1 DestinationS3S3BucketRegion = "ap-northeast-1"
	DestinationS3S3BucketRegionApNortheast2 DestinationS3S3BucketRegion = "ap-northeast-2"
	DestinationS3S3BucketRegionApNortheast3 DestinationS3S3BucketRegion = "ap-northeast-3"
	DestinationS3S3BucketRegionApSoutheast1 DestinationS3S3BucketRegion = "ap-southeast-1"
	DestinationS3S3BucketRegionApSoutheast2 DestinationS3S3BucketRegion = "ap-southeast-2"
	DestinationS3S3BucketRegionCaCentral1   DestinationS3S3BucketRegion = "ca-central-1"
	DestinationS3S3BucketRegionCnNorth1     DestinationS3S3BucketRegion = "cn-north-1"
	DestinationS3S3BucketRegionCnNorthwest1 DestinationS3S3BucketRegion = "cn-northwest-1"
	DestinationS3S3BucketRegionEuCentral1   DestinationS3S3BucketRegion = "eu-central-1"
	DestinationS3S3BucketRegionEuNorth1     DestinationS3S3BucketRegion = "eu-north-1"
	DestinationS3S3BucketRegionEuSouth1     DestinationS3S3BucketRegion = "eu-south-1"
	DestinationS3S3BucketRegionEuWest1      DestinationS3S3BucketRegion = "eu-west-1"
	DestinationS3S3BucketRegionEuWest2      DestinationS3S3BucketRegion = "eu-west-2"
	DestinationS3S3BucketRegionEuWest3      DestinationS3S3BucketRegion = "eu-west-3"
	DestinationS3S3BucketRegionSaEast1      DestinationS3S3BucketRegion = "sa-east-1"
	DestinationS3S3BucketRegionMeSouth1     DestinationS3S3BucketRegion = "me-south-1"
	DestinationS3S3BucketRegionUsGovEast1   DestinationS3S3BucketRegion = "us-gov-east-1"
	DestinationS3S3BucketRegionUsGovWest1   DestinationS3S3BucketRegion = "us-gov-west-1"
)

func (e DestinationS3S3BucketRegion) ToPointer() *DestinationS3S3BucketRegion {
	return &e
}

func (e *DestinationS3S3BucketRegion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "":
		fallthrough
	case "us-east-1":
		fallthrough
	case "us-east-2":
		fallthrough
	case "us-west-1":
		fallthrough
	case "us-west-2":
		fallthrough
	case "af-south-1":
		fallthrough
	case "ap-east-1":
		fallthrough
	case "ap-south-1":
		fallthrough
	case "ap-northeast-1":
		fallthrough
	case "ap-northeast-2":
		fallthrough
	case "ap-northeast-3":
		fallthrough
	case "ap-southeast-1":
		fallthrough
	case "ap-southeast-2":
		fallthrough
	case "ca-central-1":
		fallthrough
	case "cn-north-1":
		fallthrough
	case "cn-northwest-1":
		fallthrough
	case "eu-central-1":
		fallthrough
	case "eu-north-1":
		fallthrough
	case "eu-south-1":
		fallthrough
	case "eu-west-1":
		fallthrough
	case "eu-west-2":
		fallthrough
	case "eu-west-3":
		fallthrough
	case "sa-east-1":
		fallthrough
	case "me-south-1":
		fallthrough
	case "us-gov-east-1":
		fallthrough
	case "us-gov-west-1":
		*e = DestinationS3S3BucketRegion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3S3BucketRegion: %v", v)
	}
}

type DestinationS3 struct {
	// The access key ID to access the S3 bucket. Airbyte requires Read and Write permissions to the given bucket. Read more <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">here</a>.
	AccessKeyID     *string         `json:"access_key_id,omitempty"`
	DestinationType DestinationS3S3 `json:"destinationType"`
	// The pattern allows you to set the file-name format for the S3 staging file(s)
	FileNamePattern *string `json:"file_name_pattern,omitempty"`
	// Format of the data output. See <a href="https://docs.airbyte.com/integrations/destinations/s3/#supported-output-schema">here</a> for more details
	Format DestinationS3OutputFormat `json:"format"`
	// The name of the S3 bucket. Read more <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/create-bucket-overview.html">here</a>.
	S3BucketName string `json:"s3_bucket_name"`
	// Directory under the S3 bucket where data will be written. Read more <a href="https://docs.airbyte.com/integrations/destinations/s3#:~:text=to%20format%20the-,bucket%20path,-%3A">here</a>
	S3BucketPath string `json:"s3_bucket_path"`
	// The region of the S3 bucket. See <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-available-regions">here</a> for all region codes.
	S3BucketRegion DestinationS3S3BucketRegion `json:"s3_bucket_region"`
	// Your S3 endpoint url. Read more <a href="https://docs.aws.amazon.com/general/latest/gr/s3.html#:~:text=Service%20endpoints-,Amazon%20S3%20endpoints,-When%20you%20use">here</a>
	S3Endpoint *string `json:"s3_endpoint,omitempty"`
	// Format string on how data will be organized inside the S3 bucket directory. Read more <a href="https://docs.airbyte.com/integrations/destinations/s3#:~:text=The%20full%20path%20of%20the%20output%20data%20with%20the%20default%20S3%20path%20format">here</a>
	S3PathFormat *string `json:"s3_path_format,omitempty"`
	// The corresponding secret to the access key ID. Read more <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">here</a>
	SecretAccessKey *string `json:"secret_access_key,omitempty"`
}
