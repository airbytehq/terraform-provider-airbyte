// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/pkg/utils"
)

type SourceMysqlSchemasMethod string

const (
	SourceMysqlSchemasMethodStandard SourceMysqlSchemasMethod = "STANDARD"
)

func (e SourceMysqlSchemasMethod) ToPointer() *SourceMysqlSchemasMethod {
	return &e
}

func (e *SourceMysqlSchemasMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "STANDARD":
		*e = SourceMysqlSchemasMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlSchemasMethod: %v", v)
	}
}

// SourceMysqlScanChangesWithUserDefinedCursor - Incrementally detects new inserts and updates using the <a href="https://docs.airbyte.com/understanding-airbyte/connections/incremental-append/#user-defined-cursor">cursor column</a> chosen when configuring a connection (e.g. created_at, updated_at).
type SourceMysqlScanChangesWithUserDefinedCursor struct {
	method SourceMysqlSchemasMethod `const:"STANDARD" json:"method"`
}

func (s SourceMysqlScanChangesWithUserDefinedCursor) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMysqlScanChangesWithUserDefinedCursor) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceMysqlScanChangesWithUserDefinedCursor) GetMethod() SourceMysqlSchemasMethod {
	return SourceMysqlSchemasMethodStandard
}

type SourceMysqlMethod string

const (
	SourceMysqlMethodCdc SourceMysqlMethod = "CDC"
)

func (e SourceMysqlMethod) ToPointer() *SourceMysqlMethod {
	return &e
}

func (e *SourceMysqlMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CDC":
		*e = SourceMysqlMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlMethod: %v", v)
	}
}

// SourceMysqlReadChangesUsingBinaryLogCDC - <i>Recommended</i> - Incrementally reads new inserts, updates, and deletes using the MySQL <a href="https://docs.airbyte.com/integrations/sources/mysql/#change-data-capture-cdc">binary log</a>. This must be enabled on your database.
type SourceMysqlReadChangesUsingBinaryLogCDC struct {
	// The amount of time the connector will wait when it launches to determine if there is new data to sync or not. Defaults to 300 seconds. Valid range: 120 seconds to 1200 seconds. Read about <a href="https://docs.airbyte.com/integrations/sources/mysql/#change-data-capture-cdc">initial waiting time</a>.
	InitialWaitingSeconds *int64            `default:"300" json:"initial_waiting_seconds"`
	method                SourceMysqlMethod `const:"CDC" json:"method"`
	// Enter the configured MySQL server timezone. This should only be done if the configured timezone in your MySQL instance does not conform to IANNA standard.
	ServerTimeZone *string `json:"server_time_zone,omitempty"`
}

func (s SourceMysqlReadChangesUsingBinaryLogCDC) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMysqlReadChangesUsingBinaryLogCDC) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceMysqlReadChangesUsingBinaryLogCDC) GetInitialWaitingSeconds() *int64 {
	if o == nil {
		return nil
	}
	return o.InitialWaitingSeconds
}

func (o *SourceMysqlReadChangesUsingBinaryLogCDC) GetMethod() SourceMysqlMethod {
	return SourceMysqlMethodCdc
}

func (o *SourceMysqlReadChangesUsingBinaryLogCDC) GetServerTimeZone() *string {
	if o == nil {
		return nil
	}
	return o.ServerTimeZone
}

type SourceMysqlUpdateMethodType string

const (
	SourceMysqlUpdateMethodTypeReadChangesUsingBinaryLogCDC     SourceMysqlUpdateMethodType = "ReadChangesUsingBinaryLogCDC"
	SourceMysqlUpdateMethodTypeScanChangesWithUserDefinedCursor SourceMysqlUpdateMethodType = "ScanChangesWithUserDefinedCursor"
)

type SourceMysqlUpdateMethod struct {
	ReadChangesUsingBinaryLogCDC     *SourceMysqlReadChangesUsingBinaryLogCDC
	ScanChangesWithUserDefinedCursor *SourceMysqlScanChangesWithUserDefinedCursor

	Type SourceMysqlUpdateMethodType
}

func CreateSourceMysqlUpdateMethodReadChangesUsingBinaryLogCDC(readChangesUsingBinaryLogCDC SourceMysqlReadChangesUsingBinaryLogCDC) SourceMysqlUpdateMethod {
	typ := SourceMysqlUpdateMethodTypeReadChangesUsingBinaryLogCDC

	return SourceMysqlUpdateMethod{
		ReadChangesUsingBinaryLogCDC: &readChangesUsingBinaryLogCDC,
		Type:                         typ,
	}
}

func CreateSourceMysqlUpdateMethodScanChangesWithUserDefinedCursor(scanChangesWithUserDefinedCursor SourceMysqlScanChangesWithUserDefinedCursor) SourceMysqlUpdateMethod {
	typ := SourceMysqlUpdateMethodTypeScanChangesWithUserDefinedCursor

	return SourceMysqlUpdateMethod{
		ScanChangesWithUserDefinedCursor: &scanChangesWithUserDefinedCursor,
		Type:                             typ,
	}
}

func (u *SourceMysqlUpdateMethod) UnmarshalJSON(data []byte) error {

	scanChangesWithUserDefinedCursor := new(SourceMysqlScanChangesWithUserDefinedCursor)
	if err := utils.UnmarshalJSON(data, &scanChangesWithUserDefinedCursor, "", true, true); err == nil {
		u.ScanChangesWithUserDefinedCursor = scanChangesWithUserDefinedCursor
		u.Type = SourceMysqlUpdateMethodTypeScanChangesWithUserDefinedCursor
		return nil
	}

	readChangesUsingBinaryLogCDC := new(SourceMysqlReadChangesUsingBinaryLogCDC)
	if err := utils.UnmarshalJSON(data, &readChangesUsingBinaryLogCDC, "", true, true); err == nil {
		u.ReadChangesUsingBinaryLogCDC = readChangesUsingBinaryLogCDC
		u.Type = SourceMysqlUpdateMethodTypeReadChangesUsingBinaryLogCDC
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SourceMysqlUpdateMethod) MarshalJSON() ([]byte, error) {
	if u.ReadChangesUsingBinaryLogCDC != nil {
		return utils.MarshalJSON(u.ReadChangesUsingBinaryLogCDC, "", true)
	}

	if u.ScanChangesWithUserDefinedCursor != nil {
		return utils.MarshalJSON(u.ScanChangesWithUserDefinedCursor, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type SourceMysqlMysql string

const (
	SourceMysqlMysqlMysql SourceMysqlMysql = "mysql"
)

func (e SourceMysqlMysql) ToPointer() *SourceMysqlMysql {
	return &e
}

func (e *SourceMysqlMysql) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "mysql":
		*e = SourceMysqlMysql(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlMysql: %v", v)
	}
}

type SourceMysqlSchemasSSLModeSSLModesMode string

const (
	SourceMysqlSchemasSSLModeSSLModesModeVerifyIdentity SourceMysqlSchemasSSLModeSSLModesMode = "verify_identity"
)

func (e SourceMysqlSchemasSSLModeSSLModesMode) ToPointer() *SourceMysqlSchemasSSLModeSSLModesMode {
	return &e
}

func (e *SourceMysqlSchemasSSLModeSSLModesMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "verify_identity":
		*e = SourceMysqlSchemasSSLModeSSLModesMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlSchemasSSLModeSSLModesMode: %v", v)
	}
}

// SourceMysqlVerifyIdentity - Always connect with SSL. Verify both CA and Hostname.
type SourceMysqlVerifyIdentity struct {
	// CA certificate
	CaCertificate string `json:"ca_certificate"`
	// Client certificate (this is not a required field, but if you want to use it, you will need to add the <b>Client key</b> as well)
	ClientCertificate *string `json:"client_certificate,omitempty"`
	// Client key (this is not a required field, but if you want to use it, you will need to add the <b>Client certificate</b> as well)
	ClientKey *string `json:"client_key,omitempty"`
	// Password for keystorage. This field is optional. If you do not add it - the password will be generated automatically.
	ClientKeyPassword *string                               `json:"client_key_password,omitempty"`
	mode              SourceMysqlSchemasSSLModeSSLModesMode `const:"verify_identity" json:"mode"`
}

func (s SourceMysqlVerifyIdentity) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMysqlVerifyIdentity) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceMysqlVerifyIdentity) GetCaCertificate() string {
	if o == nil {
		return ""
	}
	return o.CaCertificate
}

func (o *SourceMysqlVerifyIdentity) GetClientCertificate() *string {
	if o == nil {
		return nil
	}
	return o.ClientCertificate
}

func (o *SourceMysqlVerifyIdentity) GetClientKey() *string {
	if o == nil {
		return nil
	}
	return o.ClientKey
}

func (o *SourceMysqlVerifyIdentity) GetClientKeyPassword() *string {
	if o == nil {
		return nil
	}
	return o.ClientKeyPassword
}

func (o *SourceMysqlVerifyIdentity) GetMode() SourceMysqlSchemasSSLModeSSLModesMode {
	return SourceMysqlSchemasSSLModeSSLModesModeVerifyIdentity
}

type SourceMysqlSchemasSslModeMode string

const (
	SourceMysqlSchemasSslModeModeVerifyCa SourceMysqlSchemasSslModeMode = "verify_ca"
)

func (e SourceMysqlSchemasSslModeMode) ToPointer() *SourceMysqlSchemasSslModeMode {
	return &e
}

func (e *SourceMysqlSchemasSslModeMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "verify_ca":
		*e = SourceMysqlSchemasSslModeMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlSchemasSslModeMode: %v", v)
	}
}

// SourceMysqlVerifyCA - Always connect with SSL. Verifies CA, but allows connection even if Hostname does not match.
type SourceMysqlVerifyCA struct {
	// CA certificate
	CaCertificate string `json:"ca_certificate"`
	// Client certificate (this is not a required field, but if you want to use it, you will need to add the <b>Client key</b> as well)
	ClientCertificate *string `json:"client_certificate,omitempty"`
	// Client key (this is not a required field, but if you want to use it, you will need to add the <b>Client certificate</b> as well)
	ClientKey *string `json:"client_key,omitempty"`
	// Password for keystorage. This field is optional. If you do not add it - the password will be generated automatically.
	ClientKeyPassword *string                       `json:"client_key_password,omitempty"`
	mode              SourceMysqlSchemasSslModeMode `const:"verify_ca" json:"mode"`
}

func (s SourceMysqlVerifyCA) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMysqlVerifyCA) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceMysqlVerifyCA) GetCaCertificate() string {
	if o == nil {
		return ""
	}
	return o.CaCertificate
}

func (o *SourceMysqlVerifyCA) GetClientCertificate() *string {
	if o == nil {
		return nil
	}
	return o.ClientCertificate
}

func (o *SourceMysqlVerifyCA) GetClientKey() *string {
	if o == nil {
		return nil
	}
	return o.ClientKey
}

func (o *SourceMysqlVerifyCA) GetClientKeyPassword() *string {
	if o == nil {
		return nil
	}
	return o.ClientKeyPassword
}

func (o *SourceMysqlVerifyCA) GetMode() SourceMysqlSchemasSslModeMode {
	return SourceMysqlSchemasSslModeModeVerifyCa
}

type SourceMysqlSchemasMode string

const (
	SourceMysqlSchemasModeRequired SourceMysqlSchemasMode = "required"
)

func (e SourceMysqlSchemasMode) ToPointer() *SourceMysqlSchemasMode {
	return &e
}

func (e *SourceMysqlSchemasMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "required":
		*e = SourceMysqlSchemasMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlSchemasMode: %v", v)
	}
}

// SourceMysqlRequired - Always connect with SSL. If the MySQL server doesnâ€™t support SSL, the connection will not be established. Certificate Authority (CA) and Hostname are not verified.
type SourceMysqlRequired struct {
	mode SourceMysqlSchemasMode `const:"required" json:"mode"`
}

func (s SourceMysqlRequired) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMysqlRequired) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceMysqlRequired) GetMode() SourceMysqlSchemasMode {
	return SourceMysqlSchemasModeRequired
}

type SourceMysqlMode string

const (
	SourceMysqlModePreferred SourceMysqlMode = "preferred"
)

func (e SourceMysqlMode) ToPointer() *SourceMysqlMode {
	return &e
}

func (e *SourceMysqlMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "preferred":
		*e = SourceMysqlMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlMode: %v", v)
	}
}

// SourceMysqlPreferred - Automatically attempt SSL connection. If the MySQL server does not support SSL, continue with a regular connection.
type SourceMysqlPreferred struct {
	mode SourceMysqlMode `const:"preferred" json:"mode"`
}

func (s SourceMysqlPreferred) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMysqlPreferred) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceMysqlPreferred) GetMode() SourceMysqlMode {
	return SourceMysqlModePreferred
}

type SourceMysqlSSLModesType string

const (
	SourceMysqlSSLModesTypePreferred      SourceMysqlSSLModesType = "Preferred"
	SourceMysqlSSLModesTypeRequired       SourceMysqlSSLModesType = "Required"
	SourceMysqlSSLModesTypeVerifyCA       SourceMysqlSSLModesType = "VerifyCA"
	SourceMysqlSSLModesTypeVerifyIdentity SourceMysqlSSLModesType = "VerifyIdentity"
)

type SourceMysqlSSLModes struct {
	Preferred      *SourceMysqlPreferred
	Required       *SourceMysqlRequired
	VerifyCA       *SourceMysqlVerifyCA
	VerifyIdentity *SourceMysqlVerifyIdentity

	Type SourceMysqlSSLModesType
}

func CreateSourceMysqlSSLModesPreferred(preferred SourceMysqlPreferred) SourceMysqlSSLModes {
	typ := SourceMysqlSSLModesTypePreferred

	return SourceMysqlSSLModes{
		Preferred: &preferred,
		Type:      typ,
	}
}

func CreateSourceMysqlSSLModesRequired(required SourceMysqlRequired) SourceMysqlSSLModes {
	typ := SourceMysqlSSLModesTypeRequired

	return SourceMysqlSSLModes{
		Required: &required,
		Type:     typ,
	}
}

func CreateSourceMysqlSSLModesVerifyCA(verifyCA SourceMysqlVerifyCA) SourceMysqlSSLModes {
	typ := SourceMysqlSSLModesTypeVerifyCA

	return SourceMysqlSSLModes{
		VerifyCA: &verifyCA,
		Type:     typ,
	}
}

func CreateSourceMysqlSSLModesVerifyIdentity(verifyIdentity SourceMysqlVerifyIdentity) SourceMysqlSSLModes {
	typ := SourceMysqlSSLModesTypeVerifyIdentity

	return SourceMysqlSSLModes{
		VerifyIdentity: &verifyIdentity,
		Type:           typ,
	}
}

func (u *SourceMysqlSSLModes) UnmarshalJSON(data []byte) error {

	preferred := new(SourceMysqlPreferred)
	if err := utils.UnmarshalJSON(data, &preferred, "", true, true); err == nil {
		u.Preferred = preferred
		u.Type = SourceMysqlSSLModesTypePreferred
		return nil
	}

	required := new(SourceMysqlRequired)
	if err := utils.UnmarshalJSON(data, &required, "", true, true); err == nil {
		u.Required = required
		u.Type = SourceMysqlSSLModesTypeRequired
		return nil
	}

	verifyCA := new(SourceMysqlVerifyCA)
	if err := utils.UnmarshalJSON(data, &verifyCA, "", true, true); err == nil {
		u.VerifyCA = verifyCA
		u.Type = SourceMysqlSSLModesTypeVerifyCA
		return nil
	}

	verifyIdentity := new(SourceMysqlVerifyIdentity)
	if err := utils.UnmarshalJSON(data, &verifyIdentity, "", true, true); err == nil {
		u.VerifyIdentity = verifyIdentity
		u.Type = SourceMysqlSSLModesTypeVerifyIdentity
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SourceMysqlSSLModes) MarshalJSON() ([]byte, error) {
	if u.Preferred != nil {
		return utils.MarshalJSON(u.Preferred, "", true)
	}

	if u.Required != nil {
		return utils.MarshalJSON(u.Required, "", true)
	}

	if u.VerifyCA != nil {
		return utils.MarshalJSON(u.VerifyCA, "", true)
	}

	if u.VerifyIdentity != nil {
		return utils.MarshalJSON(u.VerifyIdentity, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

// SourceMysqlSchemasTunnelMethodTunnelMethod - Connect through a jump server tunnel host using username and password authentication
type SourceMysqlSchemasTunnelMethodTunnelMethod string

const (
	SourceMysqlSchemasTunnelMethodTunnelMethodSSHPasswordAuth SourceMysqlSchemasTunnelMethodTunnelMethod = "SSH_PASSWORD_AUTH"
)

func (e SourceMysqlSchemasTunnelMethodTunnelMethod) ToPointer() *SourceMysqlSchemasTunnelMethodTunnelMethod {
	return &e
}

func (e *SourceMysqlSchemasTunnelMethodTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_PASSWORD_AUTH":
		*e = SourceMysqlSchemasTunnelMethodTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlSchemasTunnelMethodTunnelMethod: %v", v)
	}
}

// SourceMysqlPasswordAuthentication - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceMysqlPasswordAuthentication struct {
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and password authentication
	tunnelMethod SourceMysqlSchemasTunnelMethodTunnelMethod `const:"SSH_PASSWORD_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser string `json:"tunnel_user"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword string `json:"tunnel_user_password"`
}

func (s SourceMysqlPasswordAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMysqlPasswordAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceMysqlPasswordAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *SourceMysqlPasswordAuthentication) GetTunnelMethod() SourceMysqlSchemasTunnelMethodTunnelMethod {
	return SourceMysqlSchemasTunnelMethodTunnelMethodSSHPasswordAuth
}

func (o *SourceMysqlPasswordAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *SourceMysqlPasswordAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

func (o *SourceMysqlPasswordAuthentication) GetTunnelUserPassword() string {
	if o == nil {
		return ""
	}
	return o.TunnelUserPassword
}

// SourceMysqlSchemasTunnelMethod - Connect through a jump server tunnel host using username and ssh key
type SourceMysqlSchemasTunnelMethod string

const (
	SourceMysqlSchemasTunnelMethodSSHKeyAuth SourceMysqlSchemasTunnelMethod = "SSH_KEY_AUTH"
)

func (e SourceMysqlSchemasTunnelMethod) ToPointer() *SourceMysqlSchemasTunnelMethod {
	return &e
}

func (e *SourceMysqlSchemasTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_KEY_AUTH":
		*e = SourceMysqlSchemasTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlSchemasTunnelMethod: %v", v)
	}
}

// SourceMysqlSSHKeyAuthentication - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceMysqlSSHKeyAuthentication struct {
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey string `json:"ssh_key"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and ssh key
	tunnelMethod SourceMysqlSchemasTunnelMethod `const:"SSH_KEY_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host.
	TunnelUser string `json:"tunnel_user"`
}

func (s SourceMysqlSSHKeyAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMysqlSSHKeyAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceMysqlSSHKeyAuthentication) GetSSHKey() string {
	if o == nil {
		return ""
	}
	return o.SSHKey
}

func (o *SourceMysqlSSHKeyAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *SourceMysqlSSHKeyAuthentication) GetTunnelMethod() SourceMysqlSchemasTunnelMethod {
	return SourceMysqlSchemasTunnelMethodSSHKeyAuth
}

func (o *SourceMysqlSSHKeyAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *SourceMysqlSSHKeyAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

// SourceMysqlTunnelMethod - No ssh tunnel needed to connect to database
type SourceMysqlTunnelMethod string

const (
	SourceMysqlTunnelMethodNoTunnel SourceMysqlTunnelMethod = "NO_TUNNEL"
)

func (e SourceMysqlTunnelMethod) ToPointer() *SourceMysqlTunnelMethod {
	return &e
}

func (e *SourceMysqlTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NO_TUNNEL":
		*e = SourceMysqlTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlTunnelMethod: %v", v)
	}
}

// SourceMysqlNoTunnel - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceMysqlNoTunnel struct {
	// No ssh tunnel needed to connect to database
	tunnelMethod SourceMysqlTunnelMethod `const:"NO_TUNNEL" json:"tunnel_method"`
}

func (s SourceMysqlNoTunnel) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMysqlNoTunnel) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceMysqlNoTunnel) GetTunnelMethod() SourceMysqlTunnelMethod {
	return SourceMysqlTunnelMethodNoTunnel
}

type SourceMysqlSSHTunnelMethodType string

const (
	SourceMysqlSSHTunnelMethodTypeNoTunnel               SourceMysqlSSHTunnelMethodType = "NoTunnel"
	SourceMysqlSSHTunnelMethodTypeSSHKeyAuthentication   SourceMysqlSSHTunnelMethodType = "SSHKeyAuthentication"
	SourceMysqlSSHTunnelMethodTypePasswordAuthentication SourceMysqlSSHTunnelMethodType = "PasswordAuthentication"
)

type SourceMysqlSSHTunnelMethod struct {
	NoTunnel               *SourceMysqlNoTunnel
	SSHKeyAuthentication   *SourceMysqlSSHKeyAuthentication
	PasswordAuthentication *SourceMysqlPasswordAuthentication

	Type SourceMysqlSSHTunnelMethodType
}

func CreateSourceMysqlSSHTunnelMethodNoTunnel(noTunnel SourceMysqlNoTunnel) SourceMysqlSSHTunnelMethod {
	typ := SourceMysqlSSHTunnelMethodTypeNoTunnel

	return SourceMysqlSSHTunnelMethod{
		NoTunnel: &noTunnel,
		Type:     typ,
	}
}

func CreateSourceMysqlSSHTunnelMethodSSHKeyAuthentication(sshKeyAuthentication SourceMysqlSSHKeyAuthentication) SourceMysqlSSHTunnelMethod {
	typ := SourceMysqlSSHTunnelMethodTypeSSHKeyAuthentication

	return SourceMysqlSSHTunnelMethod{
		SSHKeyAuthentication: &sshKeyAuthentication,
		Type:                 typ,
	}
}

func CreateSourceMysqlSSHTunnelMethodPasswordAuthentication(passwordAuthentication SourceMysqlPasswordAuthentication) SourceMysqlSSHTunnelMethod {
	typ := SourceMysqlSSHTunnelMethodTypePasswordAuthentication

	return SourceMysqlSSHTunnelMethod{
		PasswordAuthentication: &passwordAuthentication,
		Type:                   typ,
	}
}

func (u *SourceMysqlSSHTunnelMethod) UnmarshalJSON(data []byte) error {

	noTunnel := new(SourceMysqlNoTunnel)
	if err := utils.UnmarshalJSON(data, &noTunnel, "", true, true); err == nil {
		u.NoTunnel = noTunnel
		u.Type = SourceMysqlSSHTunnelMethodTypeNoTunnel
		return nil
	}

	sshKeyAuthentication := new(SourceMysqlSSHKeyAuthentication)
	if err := utils.UnmarshalJSON(data, &sshKeyAuthentication, "", true, true); err == nil {
		u.SSHKeyAuthentication = sshKeyAuthentication
		u.Type = SourceMysqlSSHTunnelMethodTypeSSHKeyAuthentication
		return nil
	}

	passwordAuthentication := new(SourceMysqlPasswordAuthentication)
	if err := utils.UnmarshalJSON(data, &passwordAuthentication, "", true, true); err == nil {
		u.PasswordAuthentication = passwordAuthentication
		u.Type = SourceMysqlSSHTunnelMethodTypePasswordAuthentication
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SourceMysqlSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.NoTunnel != nil {
		return utils.MarshalJSON(u.NoTunnel, "", true)
	}

	if u.SSHKeyAuthentication != nil {
		return utils.MarshalJSON(u.SSHKeyAuthentication, "", true)
	}

	if u.PasswordAuthentication != nil {
		return utils.MarshalJSON(u.PasswordAuthentication, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type SourceMysql struct {
	// The database name.
	Database string `json:"database"`
	// The host name of the database.
	Host string `json:"host"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3). For more information read about <a href="https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-reference-jdbc-url-format.html">JDBC URL parameters</a>.
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// The password associated with the username.
	Password *string `json:"password,omitempty"`
	// The port to connect to.
	Port *int64 `default:"3306" json:"port"`
	// Configures how data is extracted from the database.
	ReplicationMethod SourceMysqlUpdateMethod `json:"replication_method"`
	sourceType        SourceMysqlMysql        `const:"mysql" json:"sourceType"`
	// SSL connection modes. Read more <a href="https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-reference-using-ssl.html"> in the docs</a>.
	SslMode *SourceMysqlSSLModes `json:"ssl_mode,omitempty"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod *SourceMysqlSSHTunnelMethod `json:"tunnel_method,omitempty"`
	// The username which is used to access the database.
	Username string `json:"username"`
}

func (s SourceMysql) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMysql) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *SourceMysql) GetDatabase() string {
	if o == nil {
		return ""
	}
	return o.Database
}

func (o *SourceMysql) GetHost() string {
	if o == nil {
		return ""
	}
	return o.Host
}

func (o *SourceMysql) GetJdbcURLParams() *string {
	if o == nil {
		return nil
	}
	return o.JdbcURLParams
}

func (o *SourceMysql) GetPassword() *string {
	if o == nil {
		return nil
	}
	return o.Password
}

func (o *SourceMysql) GetPort() *int64 {
	if o == nil {
		return nil
	}
	return o.Port
}

func (o *SourceMysql) GetReplicationMethod() SourceMysqlUpdateMethod {
	if o == nil {
		return SourceMysqlUpdateMethod{}
	}
	return o.ReplicationMethod
}

func (o *SourceMysql) GetSourceType() SourceMysqlMysql {
	return SourceMysqlMysqlMysql
}

func (o *SourceMysql) GetSslMode() *SourceMysqlSSLModes {
	if o == nil {
		return nil
	}
	return o.SslMode
}

func (o *SourceMysql) GetTunnelMethod() *SourceMysqlSSHTunnelMethod {
	if o == nil {
		return nil
	}
	return o.TunnelMethod
}

func (o *SourceMysql) GetUsername() string {
	if o == nil {
		return ""
	}
	return o.Username
}
