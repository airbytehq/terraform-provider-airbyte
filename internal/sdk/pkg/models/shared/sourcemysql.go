// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
)

type SourceMysqlReplicationMethodLogicalReplicationCDCMethodEnum string

const (
	SourceMysqlReplicationMethodLogicalReplicationCDCMethodEnumCdc SourceMysqlReplicationMethodLogicalReplicationCDCMethodEnum = "CDC"
)

func (e SourceMysqlReplicationMethodLogicalReplicationCDCMethodEnum) ToPointer() *SourceMysqlReplicationMethodLogicalReplicationCDCMethodEnum {
	return &e
}

func (e *SourceMysqlReplicationMethodLogicalReplicationCDCMethodEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CDC":
		*e = SourceMysqlReplicationMethodLogicalReplicationCDCMethodEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlReplicationMethodLogicalReplicationCDCMethodEnum: %v", v)
	}
}

// SourceMysqlReplicationMethodLogicalReplicationCDC - CDC uses the Binlog to detect inserts, updates, and deletes. This needs to be configured on the source database itself.
type SourceMysqlReplicationMethodLogicalReplicationCDC struct {
	// The amount of time the connector will wait when it launches to determine if there is new data to sync or not. Defaults to 300 seconds. Valid range: 120 seconds to 1200 seconds. Read about <a href="https://docs.airbyte.com/integrations/sources/mysql/#change-data-capture-cdc">initial waiting time</a>.
	InitialWaitingSeconds *int64                                                      `json:"initial_waiting_seconds,omitempty"`
	Method                SourceMysqlReplicationMethodLogicalReplicationCDCMethodEnum `json:"method"`
	// Enter the configured MySQL server timezone. This should only be done if the configured timezone in your MySQL instance does not conform to IANNA standard.
	ServerTimeZone *string `json:"server_time_zone,omitempty"`
}

type SourceMysqlReplicationMethodStandardMethodEnum string

const (
	SourceMysqlReplicationMethodStandardMethodEnumStandard SourceMysqlReplicationMethodStandardMethodEnum = "STANDARD"
)

func (e SourceMysqlReplicationMethodStandardMethodEnum) ToPointer() *SourceMysqlReplicationMethodStandardMethodEnum {
	return &e
}

func (e *SourceMysqlReplicationMethodStandardMethodEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "STANDARD":
		*e = SourceMysqlReplicationMethodStandardMethodEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlReplicationMethodStandardMethodEnum: %v", v)
	}
}

// SourceMysqlReplicationMethodStandard - Standard replication requires no setup on the DB side but will not be able to represent deletions incrementally.
type SourceMysqlReplicationMethodStandard struct {
	Method SourceMysqlReplicationMethodStandardMethodEnum `json:"method"`
}

type SourceMysqlReplicationMethodType string

const (
	SourceMysqlReplicationMethodTypeSourceMysqlReplicationMethodStandard              SourceMysqlReplicationMethodType = "source-mysql_Replication Method_Standard"
	SourceMysqlReplicationMethodTypeSourceMysqlReplicationMethodLogicalReplicationCDC SourceMysqlReplicationMethodType = "source-mysql_Replication Method_Logical Replication (CDC)"
)

type SourceMysqlReplicationMethod struct {
	SourceMysqlReplicationMethodStandard              *SourceMysqlReplicationMethodStandard
	SourceMysqlReplicationMethodLogicalReplicationCDC *SourceMysqlReplicationMethodLogicalReplicationCDC

	Type SourceMysqlReplicationMethodType
}

func CreateSourceMysqlReplicationMethodSourceMysqlReplicationMethodStandard(sourceMysqlReplicationMethodStandard SourceMysqlReplicationMethodStandard) SourceMysqlReplicationMethod {
	typ := SourceMysqlReplicationMethodTypeSourceMysqlReplicationMethodStandard

	return SourceMysqlReplicationMethod{
		SourceMysqlReplicationMethodStandard: &sourceMysqlReplicationMethodStandard,
		Type:                                 typ,
	}
}

func CreateSourceMysqlReplicationMethodSourceMysqlReplicationMethodLogicalReplicationCDC(sourceMysqlReplicationMethodLogicalReplicationCDC SourceMysqlReplicationMethodLogicalReplicationCDC) SourceMysqlReplicationMethod {
	typ := SourceMysqlReplicationMethodTypeSourceMysqlReplicationMethodLogicalReplicationCDC

	return SourceMysqlReplicationMethod{
		SourceMysqlReplicationMethodLogicalReplicationCDC: &sourceMysqlReplicationMethodLogicalReplicationCDC,
		Type: typ,
	}
}

func (u *SourceMysqlReplicationMethod) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	sourceMysqlReplicationMethodStandard := new(SourceMysqlReplicationMethodStandard)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sourceMysqlReplicationMethodStandard); err == nil {
		u.SourceMysqlReplicationMethodStandard = sourceMysqlReplicationMethodStandard
		u.Type = SourceMysqlReplicationMethodTypeSourceMysqlReplicationMethodStandard
		return nil
	}

	sourceMysqlReplicationMethodLogicalReplicationCDC := new(SourceMysqlReplicationMethodLogicalReplicationCDC)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sourceMysqlReplicationMethodLogicalReplicationCDC); err == nil {
		u.SourceMysqlReplicationMethodLogicalReplicationCDC = sourceMysqlReplicationMethodLogicalReplicationCDC
		u.Type = SourceMysqlReplicationMethodTypeSourceMysqlReplicationMethodLogicalReplicationCDC
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SourceMysqlReplicationMethod) MarshalJSON() ([]byte, error) {
	if u.SourceMysqlReplicationMethodStandard != nil {
		return json.Marshal(u.SourceMysqlReplicationMethodStandard)
	}

	if u.SourceMysqlReplicationMethodLogicalReplicationCDC != nil {
		return json.Marshal(u.SourceMysqlReplicationMethodLogicalReplicationCDC)
	}

	return nil, nil
}

type SourceMysqlMysqlEnum string

const (
	SourceMysqlMysqlEnumMysql SourceMysqlMysqlEnum = "mysql"
)

func (e SourceMysqlMysqlEnum) ToPointer() *SourceMysqlMysqlEnum {
	return &e
}

func (e *SourceMysqlMysqlEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "mysql":
		*e = SourceMysqlMysqlEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlMysqlEnum: %v", v)
	}
}

type SourceMysqlSSLModesVerifyIdentityModeEnum string

const (
	SourceMysqlSSLModesVerifyIdentityModeEnumVerifyIdentity SourceMysqlSSLModesVerifyIdentityModeEnum = "verify_identity"
)

func (e SourceMysqlSSLModesVerifyIdentityModeEnum) ToPointer() *SourceMysqlSSLModesVerifyIdentityModeEnum {
	return &e
}

func (e *SourceMysqlSSLModesVerifyIdentityModeEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "verify_identity":
		*e = SourceMysqlSSLModesVerifyIdentityModeEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlSSLModesVerifyIdentityModeEnum: %v", v)
	}
}

// SourceMysqlSSLModesVerifyIdentity - Always connect with SSL. Verify both CA and Hostname.
type SourceMysqlSSLModesVerifyIdentity struct {
	// CA certificate
	CaCertificate string `json:"ca_certificate"`
	// Client certificate (this is not a required field, but if you want to use it, you will need to add the <b>Client key</b> as well)
	ClientCertificate *string `json:"client_certificate,omitempty"`
	// Client key (this is not a required field, but if you want to use it, you will need to add the <b>Client certificate</b> as well)
	ClientKey *string `json:"client_key,omitempty"`
	// Password for keystorage. This field is optional. If you do not add it - the password will be generated automatically.
	ClientKeyPassword *string                                   `json:"client_key_password,omitempty"`
	Mode              SourceMysqlSSLModesVerifyIdentityModeEnum `json:"mode"`
}

type SourceMysqlSSLModesVerifyCAModeEnum string

const (
	SourceMysqlSSLModesVerifyCAModeEnumVerifyCa SourceMysqlSSLModesVerifyCAModeEnum = "verify_ca"
)

func (e SourceMysqlSSLModesVerifyCAModeEnum) ToPointer() *SourceMysqlSSLModesVerifyCAModeEnum {
	return &e
}

func (e *SourceMysqlSSLModesVerifyCAModeEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "verify_ca":
		*e = SourceMysqlSSLModesVerifyCAModeEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlSSLModesVerifyCAModeEnum: %v", v)
	}
}

// SourceMysqlSSLModesVerifyCA - Always connect with SSL. Verifies CA, but allows connection even if Hostname does not match.
type SourceMysqlSSLModesVerifyCA struct {
	// CA certificate
	CaCertificate string `json:"ca_certificate"`
	// Client certificate (this is not a required field, but if you want to use it, you will need to add the <b>Client key</b> as well)
	ClientCertificate *string `json:"client_certificate,omitempty"`
	// Client key (this is not a required field, but if you want to use it, you will need to add the <b>Client certificate</b> as well)
	ClientKey *string `json:"client_key,omitempty"`
	// Password for keystorage. This field is optional. If you do not add it - the password will be generated automatically.
	ClientKeyPassword *string                             `json:"client_key_password,omitempty"`
	Mode              SourceMysqlSSLModesVerifyCAModeEnum `json:"mode"`
}

type SourceMysqlSSLModesRequiredModeEnum string

const (
	SourceMysqlSSLModesRequiredModeEnumRequired SourceMysqlSSLModesRequiredModeEnum = "required"
)

func (e SourceMysqlSSLModesRequiredModeEnum) ToPointer() *SourceMysqlSSLModesRequiredModeEnum {
	return &e
}

func (e *SourceMysqlSSLModesRequiredModeEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "required":
		*e = SourceMysqlSSLModesRequiredModeEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlSSLModesRequiredModeEnum: %v", v)
	}
}

// SourceMysqlSSLModesRequired - Always connect with SSL. If the MySQL server doesnâ€™t support SSL, the connection will not be established. Certificate Authority (CA) and Hostname are not verified.
type SourceMysqlSSLModesRequired struct {
	Mode SourceMysqlSSLModesRequiredModeEnum `json:"mode"`
}

type SourceMysqlSSLModesPreferredModeEnum string

const (
	SourceMysqlSSLModesPreferredModeEnumPreferred SourceMysqlSSLModesPreferredModeEnum = "preferred"
)

func (e SourceMysqlSSLModesPreferredModeEnum) ToPointer() *SourceMysqlSSLModesPreferredModeEnum {
	return &e
}

func (e *SourceMysqlSSLModesPreferredModeEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "preferred":
		*e = SourceMysqlSSLModesPreferredModeEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlSSLModesPreferredModeEnum: %v", v)
	}
}

// SourceMysqlSSLModesPreferred - Automatically attempt SSL connection. If the MySQL server does not support SSL, continue with a regular connection.
type SourceMysqlSSLModesPreferred struct {
	Mode SourceMysqlSSLModesPreferredModeEnum `json:"mode"`
}

type SourceMysqlSSLModesType string

const (
	SourceMysqlSSLModesTypeSourceMysqlSSLModesPreferred      SourceMysqlSSLModesType = "source-mysql_SSL modes_preferred"
	SourceMysqlSSLModesTypeSourceMysqlSSLModesRequired       SourceMysqlSSLModesType = "source-mysql_SSL modes_required"
	SourceMysqlSSLModesTypeSourceMysqlSSLModesVerifyCA       SourceMysqlSSLModesType = "source-mysql_SSL modes_Verify CA"
	SourceMysqlSSLModesTypeSourceMysqlSSLModesVerifyIdentity SourceMysqlSSLModesType = "source-mysql_SSL modes_Verify Identity"
)

type SourceMysqlSSLModes struct {
	SourceMysqlSSLModesPreferred      *SourceMysqlSSLModesPreferred
	SourceMysqlSSLModesRequired       *SourceMysqlSSLModesRequired
	SourceMysqlSSLModesVerifyCA       *SourceMysqlSSLModesVerifyCA
	SourceMysqlSSLModesVerifyIdentity *SourceMysqlSSLModesVerifyIdentity

	Type SourceMysqlSSLModesType
}

func CreateSourceMysqlSSLModesSourceMysqlSSLModesPreferred(sourceMysqlSSLModesPreferred SourceMysqlSSLModesPreferred) SourceMysqlSSLModes {
	typ := SourceMysqlSSLModesTypeSourceMysqlSSLModesPreferred

	return SourceMysqlSSLModes{
		SourceMysqlSSLModesPreferred: &sourceMysqlSSLModesPreferred,
		Type:                         typ,
	}
}

func CreateSourceMysqlSSLModesSourceMysqlSSLModesRequired(sourceMysqlSSLModesRequired SourceMysqlSSLModesRequired) SourceMysqlSSLModes {
	typ := SourceMysqlSSLModesTypeSourceMysqlSSLModesRequired

	return SourceMysqlSSLModes{
		SourceMysqlSSLModesRequired: &sourceMysqlSSLModesRequired,
		Type:                        typ,
	}
}

func CreateSourceMysqlSSLModesSourceMysqlSSLModesVerifyCA(sourceMysqlSSLModesVerifyCA SourceMysqlSSLModesVerifyCA) SourceMysqlSSLModes {
	typ := SourceMysqlSSLModesTypeSourceMysqlSSLModesVerifyCA

	return SourceMysqlSSLModes{
		SourceMysqlSSLModesVerifyCA: &sourceMysqlSSLModesVerifyCA,
		Type:                        typ,
	}
}

func CreateSourceMysqlSSLModesSourceMysqlSSLModesVerifyIdentity(sourceMysqlSSLModesVerifyIdentity SourceMysqlSSLModesVerifyIdentity) SourceMysqlSSLModes {
	typ := SourceMysqlSSLModesTypeSourceMysqlSSLModesVerifyIdentity

	return SourceMysqlSSLModes{
		SourceMysqlSSLModesVerifyIdentity: &sourceMysqlSSLModesVerifyIdentity,
		Type:                              typ,
	}
}

func (u *SourceMysqlSSLModes) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	sourceMysqlSSLModesPreferred := new(SourceMysqlSSLModesPreferred)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sourceMysqlSSLModesPreferred); err == nil {
		u.SourceMysqlSSLModesPreferred = sourceMysqlSSLModesPreferred
		u.Type = SourceMysqlSSLModesTypeSourceMysqlSSLModesPreferred
		return nil
	}

	sourceMysqlSSLModesRequired := new(SourceMysqlSSLModesRequired)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sourceMysqlSSLModesRequired); err == nil {
		u.SourceMysqlSSLModesRequired = sourceMysqlSSLModesRequired
		u.Type = SourceMysqlSSLModesTypeSourceMysqlSSLModesRequired
		return nil
	}

	sourceMysqlSSLModesVerifyCA := new(SourceMysqlSSLModesVerifyCA)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sourceMysqlSSLModesVerifyCA); err == nil {
		u.SourceMysqlSSLModesVerifyCA = sourceMysqlSSLModesVerifyCA
		u.Type = SourceMysqlSSLModesTypeSourceMysqlSSLModesVerifyCA
		return nil
	}

	sourceMysqlSSLModesVerifyIdentity := new(SourceMysqlSSLModesVerifyIdentity)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sourceMysqlSSLModesVerifyIdentity); err == nil {
		u.SourceMysqlSSLModesVerifyIdentity = sourceMysqlSSLModesVerifyIdentity
		u.Type = SourceMysqlSSLModesTypeSourceMysqlSSLModesVerifyIdentity
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SourceMysqlSSLModes) MarshalJSON() ([]byte, error) {
	if u.SourceMysqlSSLModesPreferred != nil {
		return json.Marshal(u.SourceMysqlSSLModesPreferred)
	}

	if u.SourceMysqlSSLModesRequired != nil {
		return json.Marshal(u.SourceMysqlSSLModesRequired)
	}

	if u.SourceMysqlSSLModesVerifyCA != nil {
		return json.Marshal(u.SourceMysqlSSLModesVerifyCA)
	}

	if u.SourceMysqlSSLModesVerifyIdentity != nil {
		return json.Marshal(u.SourceMysqlSSLModesVerifyIdentity)
	}

	return nil, nil
}

// SourceMysqlSSHTunnelMethodPasswordAuthenticationTunnelMethodEnum - Connect through a jump server tunnel host using username and password authentication
type SourceMysqlSSHTunnelMethodPasswordAuthenticationTunnelMethodEnum string

const (
	SourceMysqlSSHTunnelMethodPasswordAuthenticationTunnelMethodEnumSSHPasswordAuth SourceMysqlSSHTunnelMethodPasswordAuthenticationTunnelMethodEnum = "SSH_PASSWORD_AUTH"
)

func (e SourceMysqlSSHTunnelMethodPasswordAuthenticationTunnelMethodEnum) ToPointer() *SourceMysqlSSHTunnelMethodPasswordAuthenticationTunnelMethodEnum {
	return &e
}

func (e *SourceMysqlSSHTunnelMethodPasswordAuthenticationTunnelMethodEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_PASSWORD_AUTH":
		*e = SourceMysqlSSHTunnelMethodPasswordAuthenticationTunnelMethodEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlSSHTunnelMethodPasswordAuthenticationTunnelMethodEnum: %v", v)
	}
}

// SourceMysqlSSHTunnelMethodPasswordAuthentication - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceMysqlSSHTunnelMethodPasswordAuthentication struct {
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and password authentication
	TunnelMethod SourceMysqlSSHTunnelMethodPasswordAuthenticationTunnelMethodEnum `json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort int64 `json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser string `json:"tunnel_user"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword string `json:"tunnel_user_password"`
}

// SourceMysqlSSHTunnelMethodSSHKeyAuthenticationTunnelMethodEnum - Connect through a jump server tunnel host using username and ssh key
type SourceMysqlSSHTunnelMethodSSHKeyAuthenticationTunnelMethodEnum string

const (
	SourceMysqlSSHTunnelMethodSSHKeyAuthenticationTunnelMethodEnumSSHKeyAuth SourceMysqlSSHTunnelMethodSSHKeyAuthenticationTunnelMethodEnum = "SSH_KEY_AUTH"
)

func (e SourceMysqlSSHTunnelMethodSSHKeyAuthenticationTunnelMethodEnum) ToPointer() *SourceMysqlSSHTunnelMethodSSHKeyAuthenticationTunnelMethodEnum {
	return &e
}

func (e *SourceMysqlSSHTunnelMethodSSHKeyAuthenticationTunnelMethodEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_KEY_AUTH":
		*e = SourceMysqlSSHTunnelMethodSSHKeyAuthenticationTunnelMethodEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlSSHTunnelMethodSSHKeyAuthenticationTunnelMethodEnum: %v", v)
	}
}

// SourceMysqlSSHTunnelMethodSSHKeyAuthentication - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceMysqlSSHTunnelMethodSSHKeyAuthentication struct {
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey string `json:"ssh_key"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and ssh key
	TunnelMethod SourceMysqlSSHTunnelMethodSSHKeyAuthenticationTunnelMethodEnum `json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort int64 `json:"tunnel_port"`
	// OS-level username for logging into the jump server host.
	TunnelUser string `json:"tunnel_user"`
}

// SourceMysqlSSHTunnelMethodNoTunnelTunnelMethodEnum - No ssh tunnel needed to connect to database
type SourceMysqlSSHTunnelMethodNoTunnelTunnelMethodEnum string

const (
	SourceMysqlSSHTunnelMethodNoTunnelTunnelMethodEnumNoTunnel SourceMysqlSSHTunnelMethodNoTunnelTunnelMethodEnum = "NO_TUNNEL"
)

func (e SourceMysqlSSHTunnelMethodNoTunnelTunnelMethodEnum) ToPointer() *SourceMysqlSSHTunnelMethodNoTunnelTunnelMethodEnum {
	return &e
}

func (e *SourceMysqlSSHTunnelMethodNoTunnelTunnelMethodEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NO_TUNNEL":
		*e = SourceMysqlSSHTunnelMethodNoTunnelTunnelMethodEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlSSHTunnelMethodNoTunnelTunnelMethodEnum: %v", v)
	}
}

// SourceMysqlSSHTunnelMethodNoTunnel - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceMysqlSSHTunnelMethodNoTunnel struct {
	// No ssh tunnel needed to connect to database
	TunnelMethod SourceMysqlSSHTunnelMethodNoTunnelTunnelMethodEnum `json:"tunnel_method"`
}

type SourceMysqlSSHTunnelMethodType string

const (
	SourceMysqlSSHTunnelMethodTypeSourceMysqlSSHTunnelMethodNoTunnel               SourceMysqlSSHTunnelMethodType = "source-mysql_SSH Tunnel Method_No Tunnel"
	SourceMysqlSSHTunnelMethodTypeSourceMysqlSSHTunnelMethodSSHKeyAuthentication   SourceMysqlSSHTunnelMethodType = "source-mysql_SSH Tunnel Method_SSH Key Authentication"
	SourceMysqlSSHTunnelMethodTypeSourceMysqlSSHTunnelMethodPasswordAuthentication SourceMysqlSSHTunnelMethodType = "source-mysql_SSH Tunnel Method_Password Authentication"
)

type SourceMysqlSSHTunnelMethod struct {
	SourceMysqlSSHTunnelMethodNoTunnel               *SourceMysqlSSHTunnelMethodNoTunnel
	SourceMysqlSSHTunnelMethodSSHKeyAuthentication   *SourceMysqlSSHTunnelMethodSSHKeyAuthentication
	SourceMysqlSSHTunnelMethodPasswordAuthentication *SourceMysqlSSHTunnelMethodPasswordAuthentication

	Type SourceMysqlSSHTunnelMethodType
}

func CreateSourceMysqlSSHTunnelMethodSourceMysqlSSHTunnelMethodNoTunnel(sourceMysqlSSHTunnelMethodNoTunnel SourceMysqlSSHTunnelMethodNoTunnel) SourceMysqlSSHTunnelMethod {
	typ := SourceMysqlSSHTunnelMethodTypeSourceMysqlSSHTunnelMethodNoTunnel

	return SourceMysqlSSHTunnelMethod{
		SourceMysqlSSHTunnelMethodNoTunnel: &sourceMysqlSSHTunnelMethodNoTunnel,
		Type:                               typ,
	}
}

func CreateSourceMysqlSSHTunnelMethodSourceMysqlSSHTunnelMethodSSHKeyAuthentication(sourceMysqlSSHTunnelMethodSSHKeyAuthentication SourceMysqlSSHTunnelMethodSSHKeyAuthentication) SourceMysqlSSHTunnelMethod {
	typ := SourceMysqlSSHTunnelMethodTypeSourceMysqlSSHTunnelMethodSSHKeyAuthentication

	return SourceMysqlSSHTunnelMethod{
		SourceMysqlSSHTunnelMethodSSHKeyAuthentication: &sourceMysqlSSHTunnelMethodSSHKeyAuthentication,
		Type: typ,
	}
}

func CreateSourceMysqlSSHTunnelMethodSourceMysqlSSHTunnelMethodPasswordAuthentication(sourceMysqlSSHTunnelMethodPasswordAuthentication SourceMysqlSSHTunnelMethodPasswordAuthentication) SourceMysqlSSHTunnelMethod {
	typ := SourceMysqlSSHTunnelMethodTypeSourceMysqlSSHTunnelMethodPasswordAuthentication

	return SourceMysqlSSHTunnelMethod{
		SourceMysqlSSHTunnelMethodPasswordAuthentication: &sourceMysqlSSHTunnelMethodPasswordAuthentication,
		Type: typ,
	}
}

func (u *SourceMysqlSSHTunnelMethod) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	sourceMysqlSSHTunnelMethodNoTunnel := new(SourceMysqlSSHTunnelMethodNoTunnel)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sourceMysqlSSHTunnelMethodNoTunnel); err == nil {
		u.SourceMysqlSSHTunnelMethodNoTunnel = sourceMysqlSSHTunnelMethodNoTunnel
		u.Type = SourceMysqlSSHTunnelMethodTypeSourceMysqlSSHTunnelMethodNoTunnel
		return nil
	}

	sourceMysqlSSHTunnelMethodSSHKeyAuthentication := new(SourceMysqlSSHTunnelMethodSSHKeyAuthentication)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sourceMysqlSSHTunnelMethodSSHKeyAuthentication); err == nil {
		u.SourceMysqlSSHTunnelMethodSSHKeyAuthentication = sourceMysqlSSHTunnelMethodSSHKeyAuthentication
		u.Type = SourceMysqlSSHTunnelMethodTypeSourceMysqlSSHTunnelMethodSSHKeyAuthentication
		return nil
	}

	sourceMysqlSSHTunnelMethodPasswordAuthentication := new(SourceMysqlSSHTunnelMethodPasswordAuthentication)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sourceMysqlSSHTunnelMethodPasswordAuthentication); err == nil {
		u.SourceMysqlSSHTunnelMethodPasswordAuthentication = sourceMysqlSSHTunnelMethodPasswordAuthentication
		u.Type = SourceMysqlSSHTunnelMethodTypeSourceMysqlSSHTunnelMethodPasswordAuthentication
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SourceMysqlSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.SourceMysqlSSHTunnelMethodNoTunnel != nil {
		return json.Marshal(u.SourceMysqlSSHTunnelMethodNoTunnel)
	}

	if u.SourceMysqlSSHTunnelMethodSSHKeyAuthentication != nil {
		return json.Marshal(u.SourceMysqlSSHTunnelMethodSSHKeyAuthentication)
	}

	if u.SourceMysqlSSHTunnelMethodPasswordAuthentication != nil {
		return json.Marshal(u.SourceMysqlSSHTunnelMethodPasswordAuthentication)
	}

	return nil, nil
}

type SourceMysql struct {
	// The database name.
	Database string `json:"database"`
	// The host name of the database.
	Host string `json:"host"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3). For more information read about <a href="https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-reference-jdbc-url-format.html">JDBC URL parameters</a>.
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// The password associated with the username.
	Password *string `json:"password,omitempty"`
	// The port to connect to.
	Port int64 `json:"port"`
	// Replication method to use for extracting data from the database.
	ReplicationMethod SourceMysqlReplicationMethod `json:"replication_method"`
	SourceType        SourceMysqlMysqlEnum         `json:"sourceType"`
	// SSL connection modes. Read more <a href="https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-reference-using-ssl.html"> in the docs</a>.
	SslMode *SourceMysqlSSLModes `json:"ssl_mode,omitempty"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod *SourceMysqlSSHTunnelMethod `json:"tunnel_method,omitempty"`
	// The username which is used to access the database.
	Username string `json:"username"`
}
