// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
)

type SourceMysqlReplicationMethodLogicalReplicationCDCMethod string

const (
	SourceMysqlReplicationMethodLogicalReplicationCDCMethodCdc SourceMysqlReplicationMethodLogicalReplicationCDCMethod = "CDC"
)

func (e SourceMysqlReplicationMethodLogicalReplicationCDCMethod) ToPointer() *SourceMysqlReplicationMethodLogicalReplicationCDCMethod {
	return &e
}

func (e *SourceMysqlReplicationMethodLogicalReplicationCDCMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CDC":
		*e = SourceMysqlReplicationMethodLogicalReplicationCDCMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlReplicationMethodLogicalReplicationCDCMethod: %v", v)
	}
}

// SourceMysqlReplicationMethodLogicalReplicationCDC - CDC uses the Binlog to detect inserts, updates, and deletes. This needs to be configured on the source database itself.
type SourceMysqlReplicationMethodLogicalReplicationCDC struct {
	// The amount of time the connector will wait when it launches to determine if there is new data to sync or not. Defaults to 300 seconds. Valid range: 120 seconds to 1200 seconds. Read about <a href="https://docs.airbyte.com/integrations/sources/mysql/#change-data-capture-cdc">initial waiting time</a>.
	InitialWaitingSeconds *int64                                                  `json:"initial_waiting_seconds,omitempty"`
	Method                SourceMysqlReplicationMethodLogicalReplicationCDCMethod `json:"method"`
	// Enter the configured MySQL server timezone. This should only be done if the configured timezone in your MySQL instance does not conform to IANNA standard.
	ServerTimeZone *string `json:"server_time_zone,omitempty"`
}

type SourceMysqlReplicationMethodStandardMethod string

const (
	SourceMysqlReplicationMethodStandardMethodStandard SourceMysqlReplicationMethodStandardMethod = "STANDARD"
)

func (e SourceMysqlReplicationMethodStandardMethod) ToPointer() *SourceMysqlReplicationMethodStandardMethod {
	return &e
}

func (e *SourceMysqlReplicationMethodStandardMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "STANDARD":
		*e = SourceMysqlReplicationMethodStandardMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlReplicationMethodStandardMethod: %v", v)
	}
}

// SourceMysqlReplicationMethodStandard - Standard replication requires no setup on the DB side but will not be able to represent deletions incrementally.
type SourceMysqlReplicationMethodStandard struct {
	Method SourceMysqlReplicationMethodStandardMethod `json:"method"`
}

type SourceMysqlReplicationMethodType string

const (
	SourceMysqlReplicationMethodTypeSourceMysqlReplicationMethodStandard              SourceMysqlReplicationMethodType = "source-mysql_Replication Method_Standard"
	SourceMysqlReplicationMethodTypeSourceMysqlReplicationMethodLogicalReplicationCDC SourceMysqlReplicationMethodType = "source-mysql_Replication Method_Logical Replication (CDC)"
)

type SourceMysqlReplicationMethod struct {
	SourceMysqlReplicationMethodStandard              *SourceMysqlReplicationMethodStandard
	SourceMysqlReplicationMethodLogicalReplicationCDC *SourceMysqlReplicationMethodLogicalReplicationCDC

	Type SourceMysqlReplicationMethodType
}

func CreateSourceMysqlReplicationMethodSourceMysqlReplicationMethodStandard(sourceMysqlReplicationMethodStandard SourceMysqlReplicationMethodStandard) SourceMysqlReplicationMethod {
	typ := SourceMysqlReplicationMethodTypeSourceMysqlReplicationMethodStandard

	return SourceMysqlReplicationMethod{
		SourceMysqlReplicationMethodStandard: &sourceMysqlReplicationMethodStandard,
		Type:                                 typ,
	}
}

func CreateSourceMysqlReplicationMethodSourceMysqlReplicationMethodLogicalReplicationCDC(sourceMysqlReplicationMethodLogicalReplicationCDC SourceMysqlReplicationMethodLogicalReplicationCDC) SourceMysqlReplicationMethod {
	typ := SourceMysqlReplicationMethodTypeSourceMysqlReplicationMethodLogicalReplicationCDC

	return SourceMysqlReplicationMethod{
		SourceMysqlReplicationMethodLogicalReplicationCDC: &sourceMysqlReplicationMethodLogicalReplicationCDC,
		Type: typ,
	}
}

func (u *SourceMysqlReplicationMethod) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	sourceMysqlReplicationMethodStandard := new(SourceMysqlReplicationMethodStandard)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sourceMysqlReplicationMethodStandard); err == nil {
		u.SourceMysqlReplicationMethodStandard = sourceMysqlReplicationMethodStandard
		u.Type = SourceMysqlReplicationMethodTypeSourceMysqlReplicationMethodStandard
		return nil
	}

	sourceMysqlReplicationMethodLogicalReplicationCDC := new(SourceMysqlReplicationMethodLogicalReplicationCDC)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sourceMysqlReplicationMethodLogicalReplicationCDC); err == nil {
		u.SourceMysqlReplicationMethodLogicalReplicationCDC = sourceMysqlReplicationMethodLogicalReplicationCDC
		u.Type = SourceMysqlReplicationMethodTypeSourceMysqlReplicationMethodLogicalReplicationCDC
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SourceMysqlReplicationMethod) MarshalJSON() ([]byte, error) {
	if u.SourceMysqlReplicationMethodStandard != nil {
		return json.Marshal(u.SourceMysqlReplicationMethodStandard)
	}

	if u.SourceMysqlReplicationMethodLogicalReplicationCDC != nil {
		return json.Marshal(u.SourceMysqlReplicationMethodLogicalReplicationCDC)
	}

	return nil, nil
}

type SourceMysqlMysql string

const (
	SourceMysqlMysqlMysql SourceMysqlMysql = "mysql"
)

func (e SourceMysqlMysql) ToPointer() *SourceMysqlMysql {
	return &e
}

func (e *SourceMysqlMysql) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "mysql":
		*e = SourceMysqlMysql(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlMysql: %v", v)
	}
}

type SourceMysqlSSLModesVerifyIdentityMode string

const (
	SourceMysqlSSLModesVerifyIdentityModeVerifyIdentity SourceMysqlSSLModesVerifyIdentityMode = "verify_identity"
)

func (e SourceMysqlSSLModesVerifyIdentityMode) ToPointer() *SourceMysqlSSLModesVerifyIdentityMode {
	return &e
}

func (e *SourceMysqlSSLModesVerifyIdentityMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "verify_identity":
		*e = SourceMysqlSSLModesVerifyIdentityMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlSSLModesVerifyIdentityMode: %v", v)
	}
}

// SourceMysqlSSLModesVerifyIdentity - Always connect with SSL. Verify both CA and Hostname.
type SourceMysqlSSLModesVerifyIdentity struct {
	// CA certificate
	CaCertificate string `json:"ca_certificate"`
	// Client certificate (this is not a required field, but if you want to use it, you will need to add the <b>Client key</b> as well)
	ClientCertificate *string `json:"client_certificate,omitempty"`
	// Client key (this is not a required field, but if you want to use it, you will need to add the <b>Client certificate</b> as well)
	ClientKey *string `json:"client_key,omitempty"`
	// Password for keystorage. This field is optional. If you do not add it - the password will be generated automatically.
	ClientKeyPassword *string                               `json:"client_key_password,omitempty"`
	Mode              SourceMysqlSSLModesVerifyIdentityMode `json:"mode"`
}

type SourceMysqlSSLModesVerifyCAMode string

const (
	SourceMysqlSSLModesVerifyCAModeVerifyCa SourceMysqlSSLModesVerifyCAMode = "verify_ca"
)

func (e SourceMysqlSSLModesVerifyCAMode) ToPointer() *SourceMysqlSSLModesVerifyCAMode {
	return &e
}

func (e *SourceMysqlSSLModesVerifyCAMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "verify_ca":
		*e = SourceMysqlSSLModesVerifyCAMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlSSLModesVerifyCAMode: %v", v)
	}
}

// SourceMysqlSSLModesVerifyCA - Always connect with SSL. Verifies CA, but allows connection even if Hostname does not match.
type SourceMysqlSSLModesVerifyCA struct {
	// CA certificate
	CaCertificate string `json:"ca_certificate"`
	// Client certificate (this is not a required field, but if you want to use it, you will need to add the <b>Client key</b> as well)
	ClientCertificate *string `json:"client_certificate,omitempty"`
	// Client key (this is not a required field, but if you want to use it, you will need to add the <b>Client certificate</b> as well)
	ClientKey *string `json:"client_key,omitempty"`
	// Password for keystorage. This field is optional. If you do not add it - the password will be generated automatically.
	ClientKeyPassword *string                         `json:"client_key_password,omitempty"`
	Mode              SourceMysqlSSLModesVerifyCAMode `json:"mode"`
}

type SourceMysqlSSLModesRequiredMode string

const (
	SourceMysqlSSLModesRequiredModeRequired SourceMysqlSSLModesRequiredMode = "required"
)

func (e SourceMysqlSSLModesRequiredMode) ToPointer() *SourceMysqlSSLModesRequiredMode {
	return &e
}

func (e *SourceMysqlSSLModesRequiredMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "required":
		*e = SourceMysqlSSLModesRequiredMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlSSLModesRequiredMode: %v", v)
	}
}

// SourceMysqlSSLModesRequired - Always connect with SSL. If the MySQL server doesnâ€™t support SSL, the connection will not be established. Certificate Authority (CA) and Hostname are not verified.
type SourceMysqlSSLModesRequired struct {
	Mode SourceMysqlSSLModesRequiredMode `json:"mode"`
}

type SourceMysqlSSLModesPreferredMode string

const (
	SourceMysqlSSLModesPreferredModePreferred SourceMysqlSSLModesPreferredMode = "preferred"
)

func (e SourceMysqlSSLModesPreferredMode) ToPointer() *SourceMysqlSSLModesPreferredMode {
	return &e
}

func (e *SourceMysqlSSLModesPreferredMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "preferred":
		*e = SourceMysqlSSLModesPreferredMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlSSLModesPreferredMode: %v", v)
	}
}

// SourceMysqlSSLModesPreferred - Automatically attempt SSL connection. If the MySQL server does not support SSL, continue with a regular connection.
type SourceMysqlSSLModesPreferred struct {
	Mode SourceMysqlSSLModesPreferredMode `json:"mode"`
}

type SourceMysqlSSLModesType string

const (
	SourceMysqlSSLModesTypeSourceMysqlSSLModesPreferred      SourceMysqlSSLModesType = "source-mysql_SSL modes_preferred"
	SourceMysqlSSLModesTypeSourceMysqlSSLModesRequired       SourceMysqlSSLModesType = "source-mysql_SSL modes_required"
	SourceMysqlSSLModesTypeSourceMysqlSSLModesVerifyCA       SourceMysqlSSLModesType = "source-mysql_SSL modes_Verify CA"
	SourceMysqlSSLModesTypeSourceMysqlSSLModesVerifyIdentity SourceMysqlSSLModesType = "source-mysql_SSL modes_Verify Identity"
)

type SourceMysqlSSLModes struct {
	SourceMysqlSSLModesPreferred      *SourceMysqlSSLModesPreferred
	SourceMysqlSSLModesRequired       *SourceMysqlSSLModesRequired
	SourceMysqlSSLModesVerifyCA       *SourceMysqlSSLModesVerifyCA
	SourceMysqlSSLModesVerifyIdentity *SourceMysqlSSLModesVerifyIdentity

	Type SourceMysqlSSLModesType
}

func CreateSourceMysqlSSLModesSourceMysqlSSLModesPreferred(sourceMysqlSSLModesPreferred SourceMysqlSSLModesPreferred) SourceMysqlSSLModes {
	typ := SourceMysqlSSLModesTypeSourceMysqlSSLModesPreferred

	return SourceMysqlSSLModes{
		SourceMysqlSSLModesPreferred: &sourceMysqlSSLModesPreferred,
		Type:                         typ,
	}
}

func CreateSourceMysqlSSLModesSourceMysqlSSLModesRequired(sourceMysqlSSLModesRequired SourceMysqlSSLModesRequired) SourceMysqlSSLModes {
	typ := SourceMysqlSSLModesTypeSourceMysqlSSLModesRequired

	return SourceMysqlSSLModes{
		SourceMysqlSSLModesRequired: &sourceMysqlSSLModesRequired,
		Type:                        typ,
	}
}

func CreateSourceMysqlSSLModesSourceMysqlSSLModesVerifyCA(sourceMysqlSSLModesVerifyCA SourceMysqlSSLModesVerifyCA) SourceMysqlSSLModes {
	typ := SourceMysqlSSLModesTypeSourceMysqlSSLModesVerifyCA

	return SourceMysqlSSLModes{
		SourceMysqlSSLModesVerifyCA: &sourceMysqlSSLModesVerifyCA,
		Type:                        typ,
	}
}

func CreateSourceMysqlSSLModesSourceMysqlSSLModesVerifyIdentity(sourceMysqlSSLModesVerifyIdentity SourceMysqlSSLModesVerifyIdentity) SourceMysqlSSLModes {
	typ := SourceMysqlSSLModesTypeSourceMysqlSSLModesVerifyIdentity

	return SourceMysqlSSLModes{
		SourceMysqlSSLModesVerifyIdentity: &sourceMysqlSSLModesVerifyIdentity,
		Type:                              typ,
	}
}

func (u *SourceMysqlSSLModes) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	sourceMysqlSSLModesPreferred := new(SourceMysqlSSLModesPreferred)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sourceMysqlSSLModesPreferred); err == nil {
		u.SourceMysqlSSLModesPreferred = sourceMysqlSSLModesPreferred
		u.Type = SourceMysqlSSLModesTypeSourceMysqlSSLModesPreferred
		return nil
	}

	sourceMysqlSSLModesRequired := new(SourceMysqlSSLModesRequired)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sourceMysqlSSLModesRequired); err == nil {
		u.SourceMysqlSSLModesRequired = sourceMysqlSSLModesRequired
		u.Type = SourceMysqlSSLModesTypeSourceMysqlSSLModesRequired
		return nil
	}

	sourceMysqlSSLModesVerifyCA := new(SourceMysqlSSLModesVerifyCA)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sourceMysqlSSLModesVerifyCA); err == nil {
		u.SourceMysqlSSLModesVerifyCA = sourceMysqlSSLModesVerifyCA
		u.Type = SourceMysqlSSLModesTypeSourceMysqlSSLModesVerifyCA
		return nil
	}

	sourceMysqlSSLModesVerifyIdentity := new(SourceMysqlSSLModesVerifyIdentity)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sourceMysqlSSLModesVerifyIdentity); err == nil {
		u.SourceMysqlSSLModesVerifyIdentity = sourceMysqlSSLModesVerifyIdentity
		u.Type = SourceMysqlSSLModesTypeSourceMysqlSSLModesVerifyIdentity
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SourceMysqlSSLModes) MarshalJSON() ([]byte, error) {
	if u.SourceMysqlSSLModesPreferred != nil {
		return json.Marshal(u.SourceMysqlSSLModesPreferred)
	}

	if u.SourceMysqlSSLModesRequired != nil {
		return json.Marshal(u.SourceMysqlSSLModesRequired)
	}

	if u.SourceMysqlSSLModesVerifyCA != nil {
		return json.Marshal(u.SourceMysqlSSLModesVerifyCA)
	}

	if u.SourceMysqlSSLModesVerifyIdentity != nil {
		return json.Marshal(u.SourceMysqlSSLModesVerifyIdentity)
	}

	return nil, nil
}

// SourceMysqlSSHTunnelMethodPasswordAuthenticationTunnelMethod - Connect through a jump server tunnel host using username and password authentication
type SourceMysqlSSHTunnelMethodPasswordAuthenticationTunnelMethod string

const (
	SourceMysqlSSHTunnelMethodPasswordAuthenticationTunnelMethodSSHPasswordAuth SourceMysqlSSHTunnelMethodPasswordAuthenticationTunnelMethod = "SSH_PASSWORD_AUTH"
)

func (e SourceMysqlSSHTunnelMethodPasswordAuthenticationTunnelMethod) ToPointer() *SourceMysqlSSHTunnelMethodPasswordAuthenticationTunnelMethod {
	return &e
}

func (e *SourceMysqlSSHTunnelMethodPasswordAuthenticationTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_PASSWORD_AUTH":
		*e = SourceMysqlSSHTunnelMethodPasswordAuthenticationTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlSSHTunnelMethodPasswordAuthenticationTunnelMethod: %v", v)
	}
}

// SourceMysqlSSHTunnelMethodPasswordAuthentication - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceMysqlSSHTunnelMethodPasswordAuthentication struct {
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and password authentication
	TunnelMethod SourceMysqlSSHTunnelMethodPasswordAuthenticationTunnelMethod `json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort int64 `json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser string `json:"tunnel_user"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword string `json:"tunnel_user_password"`
}

// SourceMysqlSSHTunnelMethodSSHKeyAuthenticationTunnelMethod - Connect through a jump server tunnel host using username and ssh key
type SourceMysqlSSHTunnelMethodSSHKeyAuthenticationTunnelMethod string

const (
	SourceMysqlSSHTunnelMethodSSHKeyAuthenticationTunnelMethodSSHKeyAuth SourceMysqlSSHTunnelMethodSSHKeyAuthenticationTunnelMethod = "SSH_KEY_AUTH"
)

func (e SourceMysqlSSHTunnelMethodSSHKeyAuthenticationTunnelMethod) ToPointer() *SourceMysqlSSHTunnelMethodSSHKeyAuthenticationTunnelMethod {
	return &e
}

func (e *SourceMysqlSSHTunnelMethodSSHKeyAuthenticationTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_KEY_AUTH":
		*e = SourceMysqlSSHTunnelMethodSSHKeyAuthenticationTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlSSHTunnelMethodSSHKeyAuthenticationTunnelMethod: %v", v)
	}
}

// SourceMysqlSSHTunnelMethodSSHKeyAuthentication - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceMysqlSSHTunnelMethodSSHKeyAuthentication struct {
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey string `json:"ssh_key"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and ssh key
	TunnelMethod SourceMysqlSSHTunnelMethodSSHKeyAuthenticationTunnelMethod `json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort int64 `json:"tunnel_port"`
	// OS-level username for logging into the jump server host.
	TunnelUser string `json:"tunnel_user"`
}

// SourceMysqlSSHTunnelMethodNoTunnelTunnelMethod - No ssh tunnel needed to connect to database
type SourceMysqlSSHTunnelMethodNoTunnelTunnelMethod string

const (
	SourceMysqlSSHTunnelMethodNoTunnelTunnelMethodNoTunnel SourceMysqlSSHTunnelMethodNoTunnelTunnelMethod = "NO_TUNNEL"
)

func (e SourceMysqlSSHTunnelMethodNoTunnelTunnelMethod) ToPointer() *SourceMysqlSSHTunnelMethodNoTunnelTunnelMethod {
	return &e
}

func (e *SourceMysqlSSHTunnelMethodNoTunnelTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NO_TUNNEL":
		*e = SourceMysqlSSHTunnelMethodNoTunnelTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlSSHTunnelMethodNoTunnelTunnelMethod: %v", v)
	}
}

// SourceMysqlSSHTunnelMethodNoTunnel - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceMysqlSSHTunnelMethodNoTunnel struct {
	// No ssh tunnel needed to connect to database
	TunnelMethod SourceMysqlSSHTunnelMethodNoTunnelTunnelMethod `json:"tunnel_method"`
}

type SourceMysqlSSHTunnelMethodType string

const (
	SourceMysqlSSHTunnelMethodTypeSourceMysqlSSHTunnelMethodNoTunnel               SourceMysqlSSHTunnelMethodType = "source-mysql_SSH Tunnel Method_No Tunnel"
	SourceMysqlSSHTunnelMethodTypeSourceMysqlSSHTunnelMethodSSHKeyAuthentication   SourceMysqlSSHTunnelMethodType = "source-mysql_SSH Tunnel Method_SSH Key Authentication"
	SourceMysqlSSHTunnelMethodTypeSourceMysqlSSHTunnelMethodPasswordAuthentication SourceMysqlSSHTunnelMethodType = "source-mysql_SSH Tunnel Method_Password Authentication"
)

type SourceMysqlSSHTunnelMethod struct {
	SourceMysqlSSHTunnelMethodNoTunnel               *SourceMysqlSSHTunnelMethodNoTunnel
	SourceMysqlSSHTunnelMethodSSHKeyAuthentication   *SourceMysqlSSHTunnelMethodSSHKeyAuthentication
	SourceMysqlSSHTunnelMethodPasswordAuthentication *SourceMysqlSSHTunnelMethodPasswordAuthentication

	Type SourceMysqlSSHTunnelMethodType
}

func CreateSourceMysqlSSHTunnelMethodSourceMysqlSSHTunnelMethodNoTunnel(sourceMysqlSSHTunnelMethodNoTunnel SourceMysqlSSHTunnelMethodNoTunnel) SourceMysqlSSHTunnelMethod {
	typ := SourceMysqlSSHTunnelMethodTypeSourceMysqlSSHTunnelMethodNoTunnel

	return SourceMysqlSSHTunnelMethod{
		SourceMysqlSSHTunnelMethodNoTunnel: &sourceMysqlSSHTunnelMethodNoTunnel,
		Type:                               typ,
	}
}

func CreateSourceMysqlSSHTunnelMethodSourceMysqlSSHTunnelMethodSSHKeyAuthentication(sourceMysqlSSHTunnelMethodSSHKeyAuthentication SourceMysqlSSHTunnelMethodSSHKeyAuthentication) SourceMysqlSSHTunnelMethod {
	typ := SourceMysqlSSHTunnelMethodTypeSourceMysqlSSHTunnelMethodSSHKeyAuthentication

	return SourceMysqlSSHTunnelMethod{
		SourceMysqlSSHTunnelMethodSSHKeyAuthentication: &sourceMysqlSSHTunnelMethodSSHKeyAuthentication,
		Type: typ,
	}
}

func CreateSourceMysqlSSHTunnelMethodSourceMysqlSSHTunnelMethodPasswordAuthentication(sourceMysqlSSHTunnelMethodPasswordAuthentication SourceMysqlSSHTunnelMethodPasswordAuthentication) SourceMysqlSSHTunnelMethod {
	typ := SourceMysqlSSHTunnelMethodTypeSourceMysqlSSHTunnelMethodPasswordAuthentication

	return SourceMysqlSSHTunnelMethod{
		SourceMysqlSSHTunnelMethodPasswordAuthentication: &sourceMysqlSSHTunnelMethodPasswordAuthentication,
		Type: typ,
	}
}

func (u *SourceMysqlSSHTunnelMethod) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	sourceMysqlSSHTunnelMethodNoTunnel := new(SourceMysqlSSHTunnelMethodNoTunnel)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sourceMysqlSSHTunnelMethodNoTunnel); err == nil {
		u.SourceMysqlSSHTunnelMethodNoTunnel = sourceMysqlSSHTunnelMethodNoTunnel
		u.Type = SourceMysqlSSHTunnelMethodTypeSourceMysqlSSHTunnelMethodNoTunnel
		return nil
	}

	sourceMysqlSSHTunnelMethodSSHKeyAuthentication := new(SourceMysqlSSHTunnelMethodSSHKeyAuthentication)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sourceMysqlSSHTunnelMethodSSHKeyAuthentication); err == nil {
		u.SourceMysqlSSHTunnelMethodSSHKeyAuthentication = sourceMysqlSSHTunnelMethodSSHKeyAuthentication
		u.Type = SourceMysqlSSHTunnelMethodTypeSourceMysqlSSHTunnelMethodSSHKeyAuthentication
		return nil
	}

	sourceMysqlSSHTunnelMethodPasswordAuthentication := new(SourceMysqlSSHTunnelMethodPasswordAuthentication)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sourceMysqlSSHTunnelMethodPasswordAuthentication); err == nil {
		u.SourceMysqlSSHTunnelMethodPasswordAuthentication = sourceMysqlSSHTunnelMethodPasswordAuthentication
		u.Type = SourceMysqlSSHTunnelMethodTypeSourceMysqlSSHTunnelMethodPasswordAuthentication
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SourceMysqlSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.SourceMysqlSSHTunnelMethodNoTunnel != nil {
		return json.Marshal(u.SourceMysqlSSHTunnelMethodNoTunnel)
	}

	if u.SourceMysqlSSHTunnelMethodSSHKeyAuthentication != nil {
		return json.Marshal(u.SourceMysqlSSHTunnelMethodSSHKeyAuthentication)
	}

	if u.SourceMysqlSSHTunnelMethodPasswordAuthentication != nil {
		return json.Marshal(u.SourceMysqlSSHTunnelMethodPasswordAuthentication)
	}

	return nil, nil
}

type SourceMysql struct {
	// The database name.
	Database string `json:"database"`
	// The host name of the database.
	Host string `json:"host"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3). For more information read about <a href="https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-reference-jdbc-url-format.html">JDBC URL parameters</a>.
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// The password associated with the username.
	Password *string `json:"password,omitempty"`
	// The port to connect to.
	Port int64 `json:"port"`
	// Replication method to use for extracting data from the database.
	ReplicationMethod SourceMysqlReplicationMethod `json:"replication_method"`
	SourceType        SourceMysqlMysql             `json:"sourceType"`
	// SSL connection modes. Read more <a href="https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-reference-using-ssl.html"> in the docs</a>.
	SslMode *SourceMysqlSSLModes `json:"ssl_mode,omitempty"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod *SourceMysqlSSHTunnelMethod `json:"tunnel_method,omitempty"`
	// The username which is used to access the database.
	Username string `json:"username"`
}
