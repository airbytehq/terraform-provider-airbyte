// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"airbyte/internal/sdk/pkg/utils"
	"encoding/json"
	"errors"
	"fmt"
)

type SourceMysqlUpdateMethodScanChangesWithUserDefinedCursorMethod string

const (
	SourceMysqlUpdateMethodScanChangesWithUserDefinedCursorMethodStandard SourceMysqlUpdateMethodScanChangesWithUserDefinedCursorMethod = "STANDARD"
)

func (e SourceMysqlUpdateMethodScanChangesWithUserDefinedCursorMethod) ToPointer() *SourceMysqlUpdateMethodScanChangesWithUserDefinedCursorMethod {
	return &e
}

func (e *SourceMysqlUpdateMethodScanChangesWithUserDefinedCursorMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "STANDARD":
		*e = SourceMysqlUpdateMethodScanChangesWithUserDefinedCursorMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlUpdateMethodScanChangesWithUserDefinedCursorMethod: %v", v)
	}
}

// SourceMysqlUpdateMethodScanChangesWithUserDefinedCursor - Incrementally detects new inserts and updates using the <a href="https://docs.airbyte.com/understanding-airbyte/connections/incremental-append/#user-defined-cursor">cursor column</a> chosen when configuring a connection (e.g. created_at, updated_at).
type SourceMysqlUpdateMethodScanChangesWithUserDefinedCursor struct {
	method SourceMysqlUpdateMethodScanChangesWithUserDefinedCursorMethod `const:"STANDARD" json:"method"`
}

func (s SourceMysqlUpdateMethodScanChangesWithUserDefinedCursor) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMysqlUpdateMethodScanChangesWithUserDefinedCursor) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceMysqlUpdateMethodScanChangesWithUserDefinedCursor) GetMethod() SourceMysqlUpdateMethodScanChangesWithUserDefinedCursorMethod {
	return SourceMysqlUpdateMethodScanChangesWithUserDefinedCursorMethodStandard
}

type SourceMysqlUpdateMethodReadChangesUsingBinaryLogCDCMethod string

const (
	SourceMysqlUpdateMethodReadChangesUsingBinaryLogCDCMethodCdc SourceMysqlUpdateMethodReadChangesUsingBinaryLogCDCMethod = "CDC"
)

func (e SourceMysqlUpdateMethodReadChangesUsingBinaryLogCDCMethod) ToPointer() *SourceMysqlUpdateMethodReadChangesUsingBinaryLogCDCMethod {
	return &e
}

func (e *SourceMysqlUpdateMethodReadChangesUsingBinaryLogCDCMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CDC":
		*e = SourceMysqlUpdateMethodReadChangesUsingBinaryLogCDCMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlUpdateMethodReadChangesUsingBinaryLogCDCMethod: %v", v)
	}
}

// SourceMysqlUpdateMethodReadChangesUsingBinaryLogCDC - <i>Recommended</i> - Incrementally reads new inserts, updates, and deletes using the MySQL <a href="https://docs.airbyte.com/integrations/sources/mysql/#change-data-capture-cdc">binary log</a>. This must be enabled on your database.
type SourceMysqlUpdateMethodReadChangesUsingBinaryLogCDC struct {
	// The amount of time the connector will wait when it launches to determine if there is new data to sync or not. Defaults to 300 seconds. Valid range: 120 seconds to 1200 seconds. Read about <a href="https://docs.airbyte.com/integrations/sources/mysql/#change-data-capture-cdc">initial waiting time</a>.
	InitialWaitingSeconds *int64                                                    `default:"300" json:"initial_waiting_seconds"`
	method                SourceMysqlUpdateMethodReadChangesUsingBinaryLogCDCMethod `const:"CDC" json:"method"`
	// Enter the configured MySQL server timezone. This should only be done if the configured timezone in your MySQL instance does not conform to IANNA standard.
	ServerTimeZone *string `json:"server_time_zone,omitempty"`
}

func (s SourceMysqlUpdateMethodReadChangesUsingBinaryLogCDC) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMysqlUpdateMethodReadChangesUsingBinaryLogCDC) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceMysqlUpdateMethodReadChangesUsingBinaryLogCDC) GetInitialWaitingSeconds() *int64 {
	if o == nil {
		return nil
	}
	return o.InitialWaitingSeconds
}

func (o *SourceMysqlUpdateMethodReadChangesUsingBinaryLogCDC) GetMethod() SourceMysqlUpdateMethodReadChangesUsingBinaryLogCDCMethod {
	return SourceMysqlUpdateMethodReadChangesUsingBinaryLogCDCMethodCdc
}

func (o *SourceMysqlUpdateMethodReadChangesUsingBinaryLogCDC) GetServerTimeZone() *string {
	if o == nil {
		return nil
	}
	return o.ServerTimeZone
}

type SourceMysqlUpdateMethodType string

const (
	SourceMysqlUpdateMethodTypeSourceMysqlUpdateMethodReadChangesUsingBinaryLogCDC     SourceMysqlUpdateMethodType = "source-mysql_Update Method_Read Changes using Binary Log (CDC)"
	SourceMysqlUpdateMethodTypeSourceMysqlUpdateMethodScanChangesWithUserDefinedCursor SourceMysqlUpdateMethodType = "source-mysql_Update Method_Scan Changes with User Defined Cursor"
)

type SourceMysqlUpdateMethod struct {
	SourceMysqlUpdateMethodReadChangesUsingBinaryLogCDC     *SourceMysqlUpdateMethodReadChangesUsingBinaryLogCDC
	SourceMysqlUpdateMethodScanChangesWithUserDefinedCursor *SourceMysqlUpdateMethodScanChangesWithUserDefinedCursor

	Type SourceMysqlUpdateMethodType
}

func CreateSourceMysqlUpdateMethodSourceMysqlUpdateMethodReadChangesUsingBinaryLogCDC(sourceMysqlUpdateMethodReadChangesUsingBinaryLogCDC SourceMysqlUpdateMethodReadChangesUsingBinaryLogCDC) SourceMysqlUpdateMethod {
	typ := SourceMysqlUpdateMethodTypeSourceMysqlUpdateMethodReadChangesUsingBinaryLogCDC

	return SourceMysqlUpdateMethod{
		SourceMysqlUpdateMethodReadChangesUsingBinaryLogCDC: &sourceMysqlUpdateMethodReadChangesUsingBinaryLogCDC,
		Type: typ,
	}
}

func CreateSourceMysqlUpdateMethodSourceMysqlUpdateMethodScanChangesWithUserDefinedCursor(sourceMysqlUpdateMethodScanChangesWithUserDefinedCursor SourceMysqlUpdateMethodScanChangesWithUserDefinedCursor) SourceMysqlUpdateMethod {
	typ := SourceMysqlUpdateMethodTypeSourceMysqlUpdateMethodScanChangesWithUserDefinedCursor

	return SourceMysqlUpdateMethod{
		SourceMysqlUpdateMethodScanChangesWithUserDefinedCursor: &sourceMysqlUpdateMethodScanChangesWithUserDefinedCursor,
		Type: typ,
	}
}

func (u *SourceMysqlUpdateMethod) UnmarshalJSON(data []byte) error {

	sourceMysqlUpdateMethodScanChangesWithUserDefinedCursor := new(SourceMysqlUpdateMethodScanChangesWithUserDefinedCursor)
	if err := utils.UnmarshalJSON(data, &sourceMysqlUpdateMethodScanChangesWithUserDefinedCursor, "", true, true); err == nil {
		u.SourceMysqlUpdateMethodScanChangesWithUserDefinedCursor = sourceMysqlUpdateMethodScanChangesWithUserDefinedCursor
		u.Type = SourceMysqlUpdateMethodTypeSourceMysqlUpdateMethodScanChangesWithUserDefinedCursor
		return nil
	}

	sourceMysqlUpdateMethodReadChangesUsingBinaryLogCDC := new(SourceMysqlUpdateMethodReadChangesUsingBinaryLogCDC)
	if err := utils.UnmarshalJSON(data, &sourceMysqlUpdateMethodReadChangesUsingBinaryLogCDC, "", true, true); err == nil {
		u.SourceMysqlUpdateMethodReadChangesUsingBinaryLogCDC = sourceMysqlUpdateMethodReadChangesUsingBinaryLogCDC
		u.Type = SourceMysqlUpdateMethodTypeSourceMysqlUpdateMethodReadChangesUsingBinaryLogCDC
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SourceMysqlUpdateMethod) MarshalJSON() ([]byte, error) {
	if u.SourceMysqlUpdateMethodReadChangesUsingBinaryLogCDC != nil {
		return utils.MarshalJSON(u.SourceMysqlUpdateMethodReadChangesUsingBinaryLogCDC, "", true)
	}

	if u.SourceMysqlUpdateMethodScanChangesWithUserDefinedCursor != nil {
		return utils.MarshalJSON(u.SourceMysqlUpdateMethodScanChangesWithUserDefinedCursor, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type SourceMysqlMysql string

const (
	SourceMysqlMysqlMysql SourceMysqlMysql = "mysql"
)

func (e SourceMysqlMysql) ToPointer() *SourceMysqlMysql {
	return &e
}

func (e *SourceMysqlMysql) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "mysql":
		*e = SourceMysqlMysql(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlMysql: %v", v)
	}
}

type SourceMysqlSSLModesVerifyIdentityMode string

const (
	SourceMysqlSSLModesVerifyIdentityModeVerifyIdentity SourceMysqlSSLModesVerifyIdentityMode = "verify_identity"
)

func (e SourceMysqlSSLModesVerifyIdentityMode) ToPointer() *SourceMysqlSSLModesVerifyIdentityMode {
	return &e
}

func (e *SourceMysqlSSLModesVerifyIdentityMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "verify_identity":
		*e = SourceMysqlSSLModesVerifyIdentityMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlSSLModesVerifyIdentityMode: %v", v)
	}
}

// SourceMysqlSSLModesVerifyIdentity - Always connect with SSL. Verify both CA and Hostname.
type SourceMysqlSSLModesVerifyIdentity struct {
	// CA certificate
	CaCertificate string `json:"ca_certificate"`
	// Client certificate (this is not a required field, but if you want to use it, you will need to add the <b>Client key</b> as well)
	ClientCertificate *string `json:"client_certificate,omitempty"`
	// Client key (this is not a required field, but if you want to use it, you will need to add the <b>Client certificate</b> as well)
	ClientKey *string `json:"client_key,omitempty"`
	// Password for keystorage. This field is optional. If you do not add it - the password will be generated automatically.
	ClientKeyPassword *string                               `json:"client_key_password,omitempty"`
	mode              SourceMysqlSSLModesVerifyIdentityMode `const:"verify_identity" json:"mode"`
}

func (s SourceMysqlSSLModesVerifyIdentity) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMysqlSSLModesVerifyIdentity) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceMysqlSSLModesVerifyIdentity) GetCaCertificate() string {
	if o == nil {
		return ""
	}
	return o.CaCertificate
}

func (o *SourceMysqlSSLModesVerifyIdentity) GetClientCertificate() *string {
	if o == nil {
		return nil
	}
	return o.ClientCertificate
}

func (o *SourceMysqlSSLModesVerifyIdentity) GetClientKey() *string {
	if o == nil {
		return nil
	}
	return o.ClientKey
}

func (o *SourceMysqlSSLModesVerifyIdentity) GetClientKeyPassword() *string {
	if o == nil {
		return nil
	}
	return o.ClientKeyPassword
}

func (o *SourceMysqlSSLModesVerifyIdentity) GetMode() SourceMysqlSSLModesVerifyIdentityMode {
	return SourceMysqlSSLModesVerifyIdentityModeVerifyIdentity
}

type SourceMysqlSSLModesVerifyCAMode string

const (
	SourceMysqlSSLModesVerifyCAModeVerifyCa SourceMysqlSSLModesVerifyCAMode = "verify_ca"
)

func (e SourceMysqlSSLModesVerifyCAMode) ToPointer() *SourceMysqlSSLModesVerifyCAMode {
	return &e
}

func (e *SourceMysqlSSLModesVerifyCAMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "verify_ca":
		*e = SourceMysqlSSLModesVerifyCAMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlSSLModesVerifyCAMode: %v", v)
	}
}

// SourceMysqlSSLModesVerifyCA - Always connect with SSL. Verifies CA, but allows connection even if Hostname does not match.
type SourceMysqlSSLModesVerifyCA struct {
	// CA certificate
	CaCertificate string `json:"ca_certificate"`
	// Client certificate (this is not a required field, but if you want to use it, you will need to add the <b>Client key</b> as well)
	ClientCertificate *string `json:"client_certificate,omitempty"`
	// Client key (this is not a required field, but if you want to use it, you will need to add the <b>Client certificate</b> as well)
	ClientKey *string `json:"client_key,omitempty"`
	// Password for keystorage. This field is optional. If you do not add it - the password will be generated automatically.
	ClientKeyPassword *string                         `json:"client_key_password,omitempty"`
	mode              SourceMysqlSSLModesVerifyCAMode `const:"verify_ca" json:"mode"`
}

func (s SourceMysqlSSLModesVerifyCA) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMysqlSSLModesVerifyCA) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceMysqlSSLModesVerifyCA) GetCaCertificate() string {
	if o == nil {
		return ""
	}
	return o.CaCertificate
}

func (o *SourceMysqlSSLModesVerifyCA) GetClientCertificate() *string {
	if o == nil {
		return nil
	}
	return o.ClientCertificate
}

func (o *SourceMysqlSSLModesVerifyCA) GetClientKey() *string {
	if o == nil {
		return nil
	}
	return o.ClientKey
}

func (o *SourceMysqlSSLModesVerifyCA) GetClientKeyPassword() *string {
	if o == nil {
		return nil
	}
	return o.ClientKeyPassword
}

func (o *SourceMysqlSSLModesVerifyCA) GetMode() SourceMysqlSSLModesVerifyCAMode {
	return SourceMysqlSSLModesVerifyCAModeVerifyCa
}

type SourceMysqlSSLModesRequiredMode string

const (
	SourceMysqlSSLModesRequiredModeRequired SourceMysqlSSLModesRequiredMode = "required"
)

func (e SourceMysqlSSLModesRequiredMode) ToPointer() *SourceMysqlSSLModesRequiredMode {
	return &e
}

func (e *SourceMysqlSSLModesRequiredMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "required":
		*e = SourceMysqlSSLModesRequiredMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlSSLModesRequiredMode: %v", v)
	}
}

// SourceMysqlSSLModesRequired - Always connect with SSL. If the MySQL server doesn’t support SSL, the connection will not be established. Certificate Authority (CA) and Hostname are not verified.
type SourceMysqlSSLModesRequired struct {
	mode SourceMysqlSSLModesRequiredMode `const:"required" json:"mode"`
}

func (s SourceMysqlSSLModesRequired) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMysqlSSLModesRequired) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceMysqlSSLModesRequired) GetMode() SourceMysqlSSLModesRequiredMode {
	return SourceMysqlSSLModesRequiredModeRequired
}

type SourceMysqlSSLModesPreferredMode string

const (
	SourceMysqlSSLModesPreferredModePreferred SourceMysqlSSLModesPreferredMode = "preferred"
)

func (e SourceMysqlSSLModesPreferredMode) ToPointer() *SourceMysqlSSLModesPreferredMode {
	return &e
}

func (e *SourceMysqlSSLModesPreferredMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "preferred":
		*e = SourceMysqlSSLModesPreferredMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlSSLModesPreferredMode: %v", v)
	}
}

// SourceMysqlSSLModesPreferred - Automatically attempt SSL connection. If the MySQL server does not support SSL, continue with a regular connection.
type SourceMysqlSSLModesPreferred struct {
	mode SourceMysqlSSLModesPreferredMode `const:"preferred" json:"mode"`
}

func (s SourceMysqlSSLModesPreferred) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMysqlSSLModesPreferred) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceMysqlSSLModesPreferred) GetMode() SourceMysqlSSLModesPreferredMode {
	return SourceMysqlSSLModesPreferredModePreferred
}

type SourceMysqlSSLModesType string

const (
	SourceMysqlSSLModesTypeSourceMysqlSSLModesPreferred      SourceMysqlSSLModesType = "source-mysql_SSL modes_preferred"
	SourceMysqlSSLModesTypeSourceMysqlSSLModesRequired       SourceMysqlSSLModesType = "source-mysql_SSL modes_required"
	SourceMysqlSSLModesTypeSourceMysqlSSLModesVerifyCA       SourceMysqlSSLModesType = "source-mysql_SSL modes_Verify CA"
	SourceMysqlSSLModesTypeSourceMysqlSSLModesVerifyIdentity SourceMysqlSSLModesType = "source-mysql_SSL modes_Verify Identity"
)

type SourceMysqlSSLModes struct {
	SourceMysqlSSLModesPreferred      *SourceMysqlSSLModesPreferred
	SourceMysqlSSLModesRequired       *SourceMysqlSSLModesRequired
	SourceMysqlSSLModesVerifyCA       *SourceMysqlSSLModesVerifyCA
	SourceMysqlSSLModesVerifyIdentity *SourceMysqlSSLModesVerifyIdentity

	Type SourceMysqlSSLModesType
}

func CreateSourceMysqlSSLModesSourceMysqlSSLModesPreferred(sourceMysqlSSLModesPreferred SourceMysqlSSLModesPreferred) SourceMysqlSSLModes {
	typ := SourceMysqlSSLModesTypeSourceMysqlSSLModesPreferred

	return SourceMysqlSSLModes{
		SourceMysqlSSLModesPreferred: &sourceMysqlSSLModesPreferred,
		Type:                         typ,
	}
}

func CreateSourceMysqlSSLModesSourceMysqlSSLModesRequired(sourceMysqlSSLModesRequired SourceMysqlSSLModesRequired) SourceMysqlSSLModes {
	typ := SourceMysqlSSLModesTypeSourceMysqlSSLModesRequired

	return SourceMysqlSSLModes{
		SourceMysqlSSLModesRequired: &sourceMysqlSSLModesRequired,
		Type:                        typ,
	}
}

func CreateSourceMysqlSSLModesSourceMysqlSSLModesVerifyCA(sourceMysqlSSLModesVerifyCA SourceMysqlSSLModesVerifyCA) SourceMysqlSSLModes {
	typ := SourceMysqlSSLModesTypeSourceMysqlSSLModesVerifyCA

	return SourceMysqlSSLModes{
		SourceMysqlSSLModesVerifyCA: &sourceMysqlSSLModesVerifyCA,
		Type:                        typ,
	}
}

func CreateSourceMysqlSSLModesSourceMysqlSSLModesVerifyIdentity(sourceMysqlSSLModesVerifyIdentity SourceMysqlSSLModesVerifyIdentity) SourceMysqlSSLModes {
	typ := SourceMysqlSSLModesTypeSourceMysqlSSLModesVerifyIdentity

	return SourceMysqlSSLModes{
		SourceMysqlSSLModesVerifyIdentity: &sourceMysqlSSLModesVerifyIdentity,
		Type:                              typ,
	}
}

func (u *SourceMysqlSSLModes) UnmarshalJSON(data []byte) error {

	sourceMysqlSSLModesPreferred := new(SourceMysqlSSLModesPreferred)
	if err := utils.UnmarshalJSON(data, &sourceMysqlSSLModesPreferred, "", true, true); err == nil {
		u.SourceMysqlSSLModesPreferred = sourceMysqlSSLModesPreferred
		u.Type = SourceMysqlSSLModesTypeSourceMysqlSSLModesPreferred
		return nil
	}

	sourceMysqlSSLModesRequired := new(SourceMysqlSSLModesRequired)
	if err := utils.UnmarshalJSON(data, &sourceMysqlSSLModesRequired, "", true, true); err == nil {
		u.SourceMysqlSSLModesRequired = sourceMysqlSSLModesRequired
		u.Type = SourceMysqlSSLModesTypeSourceMysqlSSLModesRequired
		return nil
	}

	sourceMysqlSSLModesVerifyCA := new(SourceMysqlSSLModesVerifyCA)
	if err := utils.UnmarshalJSON(data, &sourceMysqlSSLModesVerifyCA, "", true, true); err == nil {
		u.SourceMysqlSSLModesVerifyCA = sourceMysqlSSLModesVerifyCA
		u.Type = SourceMysqlSSLModesTypeSourceMysqlSSLModesVerifyCA
		return nil
	}

	sourceMysqlSSLModesVerifyIdentity := new(SourceMysqlSSLModesVerifyIdentity)
	if err := utils.UnmarshalJSON(data, &sourceMysqlSSLModesVerifyIdentity, "", true, true); err == nil {
		u.SourceMysqlSSLModesVerifyIdentity = sourceMysqlSSLModesVerifyIdentity
		u.Type = SourceMysqlSSLModesTypeSourceMysqlSSLModesVerifyIdentity
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SourceMysqlSSLModes) MarshalJSON() ([]byte, error) {
	if u.SourceMysqlSSLModesPreferred != nil {
		return utils.MarshalJSON(u.SourceMysqlSSLModesPreferred, "", true)
	}

	if u.SourceMysqlSSLModesRequired != nil {
		return utils.MarshalJSON(u.SourceMysqlSSLModesRequired, "", true)
	}

	if u.SourceMysqlSSLModesVerifyCA != nil {
		return utils.MarshalJSON(u.SourceMysqlSSLModesVerifyCA, "", true)
	}

	if u.SourceMysqlSSLModesVerifyIdentity != nil {
		return utils.MarshalJSON(u.SourceMysqlSSLModesVerifyIdentity, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

// SourceMysqlSSHTunnelMethodPasswordAuthenticationTunnelMethod - Connect through a jump server tunnel host using username and password authentication
type SourceMysqlSSHTunnelMethodPasswordAuthenticationTunnelMethod string

const (
	SourceMysqlSSHTunnelMethodPasswordAuthenticationTunnelMethodSSHPasswordAuth SourceMysqlSSHTunnelMethodPasswordAuthenticationTunnelMethod = "SSH_PASSWORD_AUTH"
)

func (e SourceMysqlSSHTunnelMethodPasswordAuthenticationTunnelMethod) ToPointer() *SourceMysqlSSHTunnelMethodPasswordAuthenticationTunnelMethod {
	return &e
}

func (e *SourceMysqlSSHTunnelMethodPasswordAuthenticationTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_PASSWORD_AUTH":
		*e = SourceMysqlSSHTunnelMethodPasswordAuthenticationTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlSSHTunnelMethodPasswordAuthenticationTunnelMethod: %v", v)
	}
}

// SourceMysqlSSHTunnelMethodPasswordAuthentication - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceMysqlSSHTunnelMethodPasswordAuthentication struct {
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and password authentication
	tunnelMethod SourceMysqlSSHTunnelMethodPasswordAuthenticationTunnelMethod `const:"SSH_PASSWORD_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser string `json:"tunnel_user"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword string `json:"tunnel_user_password"`
}

func (s SourceMysqlSSHTunnelMethodPasswordAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMysqlSSHTunnelMethodPasswordAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceMysqlSSHTunnelMethodPasswordAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *SourceMysqlSSHTunnelMethodPasswordAuthentication) GetTunnelMethod() SourceMysqlSSHTunnelMethodPasswordAuthenticationTunnelMethod {
	return SourceMysqlSSHTunnelMethodPasswordAuthenticationTunnelMethodSSHPasswordAuth
}

func (o *SourceMysqlSSHTunnelMethodPasswordAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *SourceMysqlSSHTunnelMethodPasswordAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

func (o *SourceMysqlSSHTunnelMethodPasswordAuthentication) GetTunnelUserPassword() string {
	if o == nil {
		return ""
	}
	return o.TunnelUserPassword
}

// SourceMysqlSSHTunnelMethodSSHKeyAuthenticationTunnelMethod - Connect through a jump server tunnel host using username and ssh key
type SourceMysqlSSHTunnelMethodSSHKeyAuthenticationTunnelMethod string

const (
	SourceMysqlSSHTunnelMethodSSHKeyAuthenticationTunnelMethodSSHKeyAuth SourceMysqlSSHTunnelMethodSSHKeyAuthenticationTunnelMethod = "SSH_KEY_AUTH"
)

func (e SourceMysqlSSHTunnelMethodSSHKeyAuthenticationTunnelMethod) ToPointer() *SourceMysqlSSHTunnelMethodSSHKeyAuthenticationTunnelMethod {
	return &e
}

func (e *SourceMysqlSSHTunnelMethodSSHKeyAuthenticationTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_KEY_AUTH":
		*e = SourceMysqlSSHTunnelMethodSSHKeyAuthenticationTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlSSHTunnelMethodSSHKeyAuthenticationTunnelMethod: %v", v)
	}
}

// SourceMysqlSSHTunnelMethodSSHKeyAuthentication - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceMysqlSSHTunnelMethodSSHKeyAuthentication struct {
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey string `json:"ssh_key"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and ssh key
	tunnelMethod SourceMysqlSSHTunnelMethodSSHKeyAuthenticationTunnelMethod `const:"SSH_KEY_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host.
	TunnelUser string `json:"tunnel_user"`
}

func (s SourceMysqlSSHTunnelMethodSSHKeyAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMysqlSSHTunnelMethodSSHKeyAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceMysqlSSHTunnelMethodSSHKeyAuthentication) GetSSHKey() string {
	if o == nil {
		return ""
	}
	return o.SSHKey
}

func (o *SourceMysqlSSHTunnelMethodSSHKeyAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *SourceMysqlSSHTunnelMethodSSHKeyAuthentication) GetTunnelMethod() SourceMysqlSSHTunnelMethodSSHKeyAuthenticationTunnelMethod {
	return SourceMysqlSSHTunnelMethodSSHKeyAuthenticationTunnelMethodSSHKeyAuth
}

func (o *SourceMysqlSSHTunnelMethodSSHKeyAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *SourceMysqlSSHTunnelMethodSSHKeyAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

// SourceMysqlSSHTunnelMethodNoTunnelTunnelMethod - No ssh tunnel needed to connect to database
type SourceMysqlSSHTunnelMethodNoTunnelTunnelMethod string

const (
	SourceMysqlSSHTunnelMethodNoTunnelTunnelMethodNoTunnel SourceMysqlSSHTunnelMethodNoTunnelTunnelMethod = "NO_TUNNEL"
)

func (e SourceMysqlSSHTunnelMethodNoTunnelTunnelMethod) ToPointer() *SourceMysqlSSHTunnelMethodNoTunnelTunnelMethod {
	return &e
}

func (e *SourceMysqlSSHTunnelMethodNoTunnelTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NO_TUNNEL":
		*e = SourceMysqlSSHTunnelMethodNoTunnelTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlSSHTunnelMethodNoTunnelTunnelMethod: %v", v)
	}
}

// SourceMysqlSSHTunnelMethodNoTunnel - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceMysqlSSHTunnelMethodNoTunnel struct {
	// No ssh tunnel needed to connect to database
	tunnelMethod SourceMysqlSSHTunnelMethodNoTunnelTunnelMethod `const:"NO_TUNNEL" json:"tunnel_method"`
}

func (s SourceMysqlSSHTunnelMethodNoTunnel) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMysqlSSHTunnelMethodNoTunnel) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceMysqlSSHTunnelMethodNoTunnel) GetTunnelMethod() SourceMysqlSSHTunnelMethodNoTunnelTunnelMethod {
	return SourceMysqlSSHTunnelMethodNoTunnelTunnelMethodNoTunnel
}

type SourceMysqlSSHTunnelMethodType string

const (
	SourceMysqlSSHTunnelMethodTypeSourceMysqlSSHTunnelMethodNoTunnel               SourceMysqlSSHTunnelMethodType = "source-mysql_SSH Tunnel Method_No Tunnel"
	SourceMysqlSSHTunnelMethodTypeSourceMysqlSSHTunnelMethodSSHKeyAuthentication   SourceMysqlSSHTunnelMethodType = "source-mysql_SSH Tunnel Method_SSH Key Authentication"
	SourceMysqlSSHTunnelMethodTypeSourceMysqlSSHTunnelMethodPasswordAuthentication SourceMysqlSSHTunnelMethodType = "source-mysql_SSH Tunnel Method_Password Authentication"
)

type SourceMysqlSSHTunnelMethod struct {
	SourceMysqlSSHTunnelMethodNoTunnel               *SourceMysqlSSHTunnelMethodNoTunnel
	SourceMysqlSSHTunnelMethodSSHKeyAuthentication   *SourceMysqlSSHTunnelMethodSSHKeyAuthentication
	SourceMysqlSSHTunnelMethodPasswordAuthentication *SourceMysqlSSHTunnelMethodPasswordAuthentication

	Type SourceMysqlSSHTunnelMethodType
}

func CreateSourceMysqlSSHTunnelMethodSourceMysqlSSHTunnelMethodNoTunnel(sourceMysqlSSHTunnelMethodNoTunnel SourceMysqlSSHTunnelMethodNoTunnel) SourceMysqlSSHTunnelMethod {
	typ := SourceMysqlSSHTunnelMethodTypeSourceMysqlSSHTunnelMethodNoTunnel

	return SourceMysqlSSHTunnelMethod{
		SourceMysqlSSHTunnelMethodNoTunnel: &sourceMysqlSSHTunnelMethodNoTunnel,
		Type:                               typ,
	}
}

func CreateSourceMysqlSSHTunnelMethodSourceMysqlSSHTunnelMethodSSHKeyAuthentication(sourceMysqlSSHTunnelMethodSSHKeyAuthentication SourceMysqlSSHTunnelMethodSSHKeyAuthentication) SourceMysqlSSHTunnelMethod {
	typ := SourceMysqlSSHTunnelMethodTypeSourceMysqlSSHTunnelMethodSSHKeyAuthentication

	return SourceMysqlSSHTunnelMethod{
		SourceMysqlSSHTunnelMethodSSHKeyAuthentication: &sourceMysqlSSHTunnelMethodSSHKeyAuthentication,
		Type: typ,
	}
}

func CreateSourceMysqlSSHTunnelMethodSourceMysqlSSHTunnelMethodPasswordAuthentication(sourceMysqlSSHTunnelMethodPasswordAuthentication SourceMysqlSSHTunnelMethodPasswordAuthentication) SourceMysqlSSHTunnelMethod {
	typ := SourceMysqlSSHTunnelMethodTypeSourceMysqlSSHTunnelMethodPasswordAuthentication

	return SourceMysqlSSHTunnelMethod{
		SourceMysqlSSHTunnelMethodPasswordAuthentication: &sourceMysqlSSHTunnelMethodPasswordAuthentication,
		Type: typ,
	}
}

func (u *SourceMysqlSSHTunnelMethod) UnmarshalJSON(data []byte) error {

	sourceMysqlSSHTunnelMethodNoTunnel := new(SourceMysqlSSHTunnelMethodNoTunnel)
	if err := utils.UnmarshalJSON(data, &sourceMysqlSSHTunnelMethodNoTunnel, "", true, true); err == nil {
		u.SourceMysqlSSHTunnelMethodNoTunnel = sourceMysqlSSHTunnelMethodNoTunnel
		u.Type = SourceMysqlSSHTunnelMethodTypeSourceMysqlSSHTunnelMethodNoTunnel
		return nil
	}

	sourceMysqlSSHTunnelMethodSSHKeyAuthentication := new(SourceMysqlSSHTunnelMethodSSHKeyAuthentication)
	if err := utils.UnmarshalJSON(data, &sourceMysqlSSHTunnelMethodSSHKeyAuthentication, "", true, true); err == nil {
		u.SourceMysqlSSHTunnelMethodSSHKeyAuthentication = sourceMysqlSSHTunnelMethodSSHKeyAuthentication
		u.Type = SourceMysqlSSHTunnelMethodTypeSourceMysqlSSHTunnelMethodSSHKeyAuthentication
		return nil
	}

	sourceMysqlSSHTunnelMethodPasswordAuthentication := new(SourceMysqlSSHTunnelMethodPasswordAuthentication)
	if err := utils.UnmarshalJSON(data, &sourceMysqlSSHTunnelMethodPasswordAuthentication, "", true, true); err == nil {
		u.SourceMysqlSSHTunnelMethodPasswordAuthentication = sourceMysqlSSHTunnelMethodPasswordAuthentication
		u.Type = SourceMysqlSSHTunnelMethodTypeSourceMysqlSSHTunnelMethodPasswordAuthentication
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SourceMysqlSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.SourceMysqlSSHTunnelMethodNoTunnel != nil {
		return utils.MarshalJSON(u.SourceMysqlSSHTunnelMethodNoTunnel, "", true)
	}

	if u.SourceMysqlSSHTunnelMethodSSHKeyAuthentication != nil {
		return utils.MarshalJSON(u.SourceMysqlSSHTunnelMethodSSHKeyAuthentication, "", true)
	}

	if u.SourceMysqlSSHTunnelMethodPasswordAuthentication != nil {
		return utils.MarshalJSON(u.SourceMysqlSSHTunnelMethodPasswordAuthentication, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type SourceMysql struct {
	// The database name.
	Database string `json:"database"`
	// The host name of the database.
	Host string `json:"host"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3). For more information read about <a href="https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-reference-jdbc-url-format.html">JDBC URL parameters</a>.
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// The password associated with the username.
	Password *string `json:"password,omitempty"`
	// The port to connect to.
	Port *int64 `default:"3306" json:"port"`
	// Configures how data is extracted from the database.
	ReplicationMethod SourceMysqlUpdateMethod `json:"replication_method"`
	sourceType        SourceMysqlMysql        `const:"mysql" json:"sourceType"`
	// SSL connection modes. Read more <a href="https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-reference-using-ssl.html"> in the docs</a>.
	SslMode *SourceMysqlSSLModes `json:"ssl_mode,omitempty"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod *SourceMysqlSSHTunnelMethod `json:"tunnel_method,omitempty"`
	// The username which is used to access the database.
	Username string `json:"username"`
}

func (s SourceMysql) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMysql) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *SourceMysql) GetDatabase() string {
	if o == nil {
		return ""
	}
	return o.Database
}

func (o *SourceMysql) GetHost() string {
	if o == nil {
		return ""
	}
	return o.Host
}

func (o *SourceMysql) GetJdbcURLParams() *string {
	if o == nil {
		return nil
	}
	return o.JdbcURLParams
}

func (o *SourceMysql) GetPassword() *string {
	if o == nil {
		return nil
	}
	return o.Password
}

func (o *SourceMysql) GetPort() *int64 {
	if o == nil {
		return nil
	}
	return o.Port
}

func (o *SourceMysql) GetReplicationMethod() SourceMysqlUpdateMethod {
	if o == nil {
		return SourceMysqlUpdateMethod{}
	}
	return o.ReplicationMethod
}

func (o *SourceMysql) GetSourceType() SourceMysqlMysql {
	return SourceMysqlMysqlMysql
}

func (o *SourceMysql) GetSslMode() *SourceMysqlSSLModes {
	if o == nil {
		return nil
	}
	return o.SslMode
}

func (o *SourceMysql) GetTunnelMethod() *SourceMysqlSSHTunnelMethod {
	if o == nil {
		return nil
	}
	return o.TunnelMethod
}

func (o *SourceMysql) GetUsername() string {
	if o == nil {
		return ""
	}
	return o.Username
}
