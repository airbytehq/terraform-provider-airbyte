// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package utils

import (
	"encoding/json"
	"reflect"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// makeCandidates unmarshals payload into each type and returns candidates
func makeCandidates(t *testing.T, payload string, types ...any) []UnionCandidate {
	t.Helper()
	candidates := make([]UnionCandidate, len(types))
	for i, typ := range types {
		val := reflect.New(reflect.TypeOf(typ)).Interface()
		require.NoError(t, UnmarshalJSON([]byte(payload), val, "", false, nil))
		candidates[i] = UnionCandidate{Type: typ, Value: reflect.ValueOf(val).Elem().Interface()}
	}
	return candidates
}

func TestPickBestUnionCandidate_SelectsTypeWithMoreMatchedFields(t *testing.T) {
	type A struct {
		Foo string `json:"foo"`
	}
	type B struct {
		Foo string `json:"foo"`
		Bar string `json:"bar"`
	}

	payload := `{"foo": "", "bar": ""}`
	candidates := makeCandidates(t, payload, A{}, B{})
	result := PickBestUnionCandidate(candidates, []byte(payload))

	require.NotNil(t, result)
	assert.IsType(t, B{}, result.Type)
}

func TestPickBestUnionCandidate_EmptyCandidates(t *testing.T) {
	result := PickBestUnionCandidate([]UnionCandidate{}, []byte(`{"foo": "test"}`))
	assert.Nil(t, result)
}

func TestPickBestUnionCandidate_PrefersFewerUnmatchedFields(t *testing.T) {
	type A struct {
		Foo string `json:"foo"`
		Bar string `json:"bar"` // not in payload
	}
	type B struct {
		Foo string `json:"foo"`
	}

	payload := `{"foo": "test"}`
	candidates := makeCandidates(t, payload, A{}, B{})
	result := PickBestUnionCandidate(candidates, []byte(payload))

	require.NotNil(t, result)
	assert.IsType(t, B{}, result.Type) // fewer unmatched fields
}

func TestPickBestUnionCandidate_NestedStructs(t *testing.T) {
	type InnerA struct {
		Value string `json:"value"`
	}
	type InnerB struct {
		Value string `json:"value"`
		Extra string `json:"extra"`
	}
	type A struct {
		Nested InnerA `json:"nested"`
	}
	type B struct {
		Nested InnerB `json:"nested"`
	}

	payload := `{"nested": {"value": "test", "extra": "data"}}`
	candidates := makeCandidates(t, payload, A{}, B{})
	result := PickBestUnionCandidate(candidates, []byte(payload))

	require.NotNil(t, result)
	assert.IsType(t, B{}, result.Type)
}

func TestPickBestUnionCandidate_ArrayFields(t *testing.T) {
	type ItemA struct {
		Name string `json:"name"`
	}
	type ItemB struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	}
	type A = []ItemA
	type B = []ItemB

	payload := `[{"name": "a", "value": "1"}, {"name": "b", "value": "2"}]`
	candidates := makeCandidates(t, payload, A{}, B{})
	result := PickBestUnionCandidate(candidates, []byte(payload))

	require.NotNil(t, result)
	assert.IsType(t, B{}, result.Type)
}

func TestPickBestUnionCandidate_PreservesOrderOnTie(t *testing.T) {
	type A struct {
		Foo string `json:"foo"`
	}
	type B struct {
		Foo string `json:"foo"`
	}

	payload := `{"foo": "test"}`
	candidates := makeCandidates(t, payload, A{}, B{})
	result := PickBestUnionCandidate(candidates, []byte(payload))

	require.NotNil(t, result)
	assert.IsType(t, A{}, result.Type) // first wins on tie
}

func TestPickBestUnionCandidate_OptionalPointerFields(t *testing.T) {
	type A struct {
		Foo *string `json:"foo"`
	}
	type B struct {
		Foo *string `json:"foo"`
		Bar *string `json:"bar"`
	}

	payload := `{"foo": "test", "bar": "value"}`
	candidates := makeCandidates(t, payload, A{}, B{})
	result := PickBestUnionCandidate(candidates, []byte(payload))

	require.NotNil(t, result)
	assert.IsType(t, B{}, result.Type)
}

func TestPickBestUnionCandidate_OptionalPointerStructs(t *testing.T) {
	type InnerA struct {
		Name string `json:"name"`
	}
	type InnerB struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	}
	type A struct {
		Nested *InnerA `json:"nested"`
	}
	type B struct {
		Nested *InnerB `json:"nested"`
	}

	payload := `{"nested": {"name": "test", "value": "data"}}`
	candidates := makeCandidates(t, payload, A{}, B{})
	result := PickBestUnionCandidate(candidates, []byte(payload))

	require.NotNil(t, result)
	assert.IsType(t, B{}, result.Type)
}

func TestPickBestUnionCandidate_NullPointerField(t *testing.T) {
	type A struct {
		Bar *string `json:"bar"`
	}
	type B struct {
		Foo *string `json:"foo"`
	}

	payload := `{"foo": null}`
	candidates := makeCandidates(t, payload, A{}, B{})
	result := PickBestUnionCandidate(candidates, []byte(payload))

	require.NotNil(t, result)
	assert.IsType(t, B{}, result.Type)
}

func TestPickBestUnionCandidate_NullNestedPointerField(t *testing.T) {
	type InnerA struct {
		Bar *string `json:"bar"`
	}
	type InnerB struct {
		Bar *bool `json:"bar"`
	}
	type A struct {
		Foo InnerA `json:"foo"`
	}
	type B struct {
		Foo InnerB `json:"foo"`
	}

	payload := `{"foo": {"bar": null}}`
	candidates := makeCandidates(t, payload, A{}, B{})
	result := PickBestUnionCandidate(candidates, []byte(payload))

	require.NotNil(t, result)
	assert.IsType(t, A{}, result.Type) // first wins on tie
}

func TestPickBestUnionCandidate_NullNonPointerField(t *testing.T) {
	type A struct {
		Foo string `json:"foo"`
	}
	type B struct {
		Foo string `json:"foo"`
		Bar string `json:"bar"`
	}

	payload := `{"foo": "", "bar": null}`
	candidates := makeCandidates(t, payload, A{}, B{})
	result := PickBestUnionCandidate(candidates, []byte(payload))

	require.NotNil(t, result)
	assert.IsType(t, B{}, result.Type)
}

func TestPickBestUnionCandidate_NullNestedFieldDifferentStructs(t *testing.T) {
	type InnerA struct {
		Bar string `json:"bar"`
	}
	type InnerB struct {
		Baz *string `json:"baz"`
	}
	type A struct {
		Foo InnerA `json:"foo"`
	}
	type B struct {
		Foo InnerB `json:"foo"`
	}

	payload := `{"foo": {"baz": null}}`
	candidates := makeCandidates(t, payload, A{}, B{})
	result := PickBestUnionCandidate(candidates, []byte(payload))

	require.NotNil(t, result)
	assert.IsType(t, B{}, result.Type)
}

func TestPickBestUnionCandidate_NullNestedFieldBothPresent(t *testing.T) {
	type InnerA struct {
		Bar *string `json:"bar"`
	}
	type InnerB struct {
		Baz *string `json:"baz"`
	}
	type A struct {
		Foo InnerA `json:"foo"`
	}
	type B struct {
		Foo InnerB `json:"foo"`
	}

	payload := `{"foo": {"bar": null, "baz": null}}`
	candidates := makeCandidates(t, payload, A{}, B{})
	result := PickBestUnionCandidate(candidates, []byte(payload))

	require.NotNil(t, result)
	assert.IsType(t, A{}, result.Type) // first wins on tie
}

// EnumA represents an enum with values 1 or 2
type EnumA int

func (e *EnumA) IsExact() bool {
	return *e == 1 || *e == 2
}

func (e *EnumA) UnmarshalJSON(data []byte) error {
	var v int
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	*e = EnumA(v)
	return nil
}

// EnumB represents an enum with values 3 or 4
type EnumB int

func (e *EnumB) IsExact() bool {
	return *e == 3 || *e == 4
}

func (e *EnumB) UnmarshalJSON(data []byte) error {
	var v int
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	*e = EnumB(v)
	return nil
}

func TestPickBestUnionCandidate_EnumDiscrimination(t *testing.T) {
	type A struct {
		Val EnumA `json:"a"`
	}
	type B struct {
		Val EnumB `json:"a"`
	}

	payload := `{"a": 4}`
	candidates := makeCandidates(t, payload, A{}, B{})
	result := PickBestUnionCandidate(candidates, []byte(payload))

	require.NotNil(t, result)
	assert.IsType(t, B{}, result.Type)
}

func TestPickBestUnionCandidate_ThreeWayFieldDiscrimination(t *testing.T) {
	type A struct {
		FieldA string `json:"a"`
		FieldB string `json:"b"`
	}
	type B struct {
		FieldA string `json:"a"`
		FieldC string `json:"c"`
	}
	type C struct {
		FieldB string `json:"b"`
		FieldC string `json:"c"`
	}

	payload := `{"b": "", "c": ""}`
	candidates := makeCandidates(t, payload, A{}, B{}, C{})
	result := PickBestUnionCandidate(candidates, []byte(payload))

	require.NotNil(t, result)
	assert.IsType(t, C{}, result.Type)
}

func TestPickBestUnionCandidate_ConstFieldDiscrimination(t *testing.T) {
	type A struct {
		ConstA string `json:"a" const:"x"`
		ConstB string `json:"b" const:"1"`
	}
	type B struct {
		ConstA string `json:"a" const:"x"`
		ConstC string `json:"c" const:"1"`
	}
	type C struct {
		ConstB string `json:"b" const:"1"`
		ConstC string `json:"c" const:"1"`
	}

	payload := `{"b": "1", "c": "1"}`
	candidates := makeCandidates(t, payload, A{}, B{}, C{})
	result := PickBestUnionCandidate(candidates, []byte(payload))

	require.NotNil(t, result)
	assert.IsType(t, C{}, result.Type)
}

func TestPickBestUnionCandidate_NullPayload(t *testing.T) {
	type A struct {
		Foo string `json:"foo"`
	}
	type B *string // nullable type

	payload := `null`

	candidates := makeCandidates(t, payload, A{}, B(nil))
	result := PickBestUnionCandidate(candidates, []byte(payload))

	require.NotNil(t, result)
	_, isB := result.Type.(B)
	assert.True(t, isB, "expected B (nullable type) to win for null payload")
}

func TestPickBestUnionCandidate_PrimitiveStringTypes(t *testing.T) {
	// When both types are strings, first wins on tie
	type A = string
	type B = string

	payload := `"asdf"`

	candidates := makeCandidates(t, payload, A(""), B(""))
	result := PickBestUnionCandidate(candidates, []byte(payload))

	require.NotNil(t, result)
	_, isA := result.Type.(A)
	assert.True(t, isA, "expected A (first type) to win on tie")
}

func TestPickBestUnionCandidate_NullPointerPrimitives(t *testing.T) {
	// A: *string, B: *float64
	// payload: null
	// Both can be null, first wins
	type A = *string
	type B = *float64

	payload := `null`

	candidates := makeCandidates(t, payload, A(nil), B(nil))
	result := PickBestUnionCandidate(candidates, []byte(payload))

	require.NotNil(t, result)
	_, isA := result.Type.(A)
	assert.True(t, isA, "expected A (*string) to win for null payload (first wins on tie)")
}

func TestPickBestUnionCandidate_NullPointersMatchOverMissingFields(t *testing.T) {
	// A: { a: string }
	// B: { b: *string, c: *string }
	// payload: { "b": null, "c": null }
	// B wins because it has 2 matched fields, A has 0
	type A struct {
		A string `json:"a"`
	}
	type B struct {
		B *string `json:"b"`
		C *string `json:"c"`
	}

	payload := `{"b": null, "c": null}`
	candidates := makeCandidates(t, payload, A{}, B{})
	result := PickBestUnionCandidate(candidates, []byte(payload))

	require.NotNil(t, result)
	assert.IsType(t, B{}, result.Type)
}

func TestPickBestUnionCandidate_MapOfStructs(t *testing.T) {
	// A: map[string]{ a: string }
	// B: map[string]{ b: string }
	// payload: { "x": null, "y": null, "z": { "b": "b" } }
	// B wins because it has a matched field in the nested struct
	type InnerA struct {
		A string `json:"a"`
	}
	type InnerB struct {
		B string `json:"b"`
	}
	type A = map[string]*InnerA
	type B = map[string]*InnerB

	payload := `{"x": null, "y": null, "z": {"b": "b"}}`

	candidates := makeCandidates(t, payload, A(nil), B(nil))
	result := PickBestUnionCandidate(candidates, []byte(payload))

	require.NotNil(t, result)
	_, isB := result.Type.(B)
	assert.True(t, isB, "expected B (map with matching struct field) to win")
}

func TestPickBestUnionCandidate_NullPointerStructVsString(t *testing.T) {
	// A: *{foo: string}, B: *string
	// payload: null
	type Inner struct {
		Foo string `json:"foo"`
	}
	type A = *Inner
	type B = *string

	payload := `null`

	candidates := makeCandidates(t, payload, A(nil), B(nil))
	result := PickBestUnionCandidate(candidates, []byte(payload))

	require.NotNil(t, result)
	_, isA := result.Type.(A)
	assert.True(t, isA, "expected A (*struct) to win for null payload (first wins on tie)")
}

func TestPickBestUnionCandidate_MapWithNestedStructsVsSimpleField(t *testing.T) {
	// A: { a: string }
	// B: { b: map[string]{ id: string, name: string } }
	// payload: { "a": "", "b": { "foo": { "id": "", "name": "" } } }
	// B should win because it has more matched fields (id, name in nested struct)
	type Inner struct {
		ID   string `json:"id"`
		Name string `json:"name"`
	}
	type A struct {
		A string `json:"a"`
	}
	type B struct {
		B map[string]Inner `json:"b"`
	}

	payload := `{"a": "", "b": {"foo": {"id": "", "name": ""}}}`
	candidates := makeCandidates(t, payload, A{}, B{})
	result := PickBestUnionCandidate(candidates, []byte(payload))

	require.NotNil(t, result)
	assert.IsType(t, B{}, result.Type)
}

func TestPickBestUnionCandidate_AdditionalPropertiesWins(t *testing.T) {
	type A struct {
		A string `json:"a"`
	}
	type B struct {
		B                    string            `json:"b"`
		AdditionalProperties map[string]string `additionalProperties:"true"`
	}

	payload := `{"a": "", "b": "", "c": ""}`
	candidates := makeCandidates(t, payload, A{}, B{})
	result := PickBestUnionCandidate(candidates, []byte(payload))

	require.NotNil(t, result)
	assert.IsType(t, B{}, result.Type)
}

func TestPickBestUnionCandidate_StructVsMapOfStrings(t *testing.T) {
	// A: map[string]string
	// B: { id: string }
	// payload: { "id": "", "foo": "" }
	// B should win because struct fields are more specific than map
	type A = map[string]string
	type B struct {
		ID string `json:"id"`
	}

	payload := `{"id": "", "foo": ""}`

	candidates := makeCandidates(t, payload, A(nil), B{})
	result := PickBestUnionCandidate(candidates, []byte(payload))

	require.NotNil(t, result)
	assert.IsType(t, A{}, result.Type)
}

func TestPickBestUnionCandidate_AdditionalPropertiesVsExactField(t *testing.T) {
	// A: { id: *string, additionalProperties: true }
	// B: { foo: string }
	// payload: { "foo": "" }
	// B should win because it has an exact field match, while A only matches via additionalProperties
	type A struct {
		ID                   *string           `json:"id"`
		AdditionalProperties map[string]string `additionalProperties:"true"`
	}
	type B struct {
		Foo string `json:"foo"`
	}

	payload := `{"foo": ""}`
	candidates := makeCandidates(t, payload, A{}, B{})
	result := PickBestUnionCandidate(candidates, []byte(payload))

	require.NotNil(t, result)
	assert.IsType(t, B{}, result.Type)
}

func TestPickBestUnionCandidate_ArrayOfNullableStructs(t *testing.T) {
	// A: Array<{ foo: *string } | null>
	// B: Array<{ bar: *string } | null>
	// payload: [null, null, { "bar": "" }]
	// B should win because it has a matching field in the non-null element
	type ItemA struct {
		Foo *string `json:"foo"`
	}
	type ItemB struct {
		Bar *string `json:"bar"`
	}
	type A = []*ItemA
	type B = []*ItemB

	payload := `[null, null, {"bar": ""}]`
	candidates := makeCandidates(t, payload, A{}, B{})
	result := PickBestUnionCandidate(candidates, []byte(payload))

	require.NotNil(t, result)
	assert.IsType(t, B{}, result.Type)
}

func TestPickBestUnionCandidate_AnyFieldType(t *testing.T) {
	// A: { a: string }
	// B: { b: any }
	// payload: { "b": "asdf" }
	// B should win because it has a matching field
	type A struct {
		A string `json:"a"`
	}
	type B struct {
		B any `json:"b"`
	}

	payload := `{"b": "asdf"}`
	candidates := makeCandidates(t, payload, A{}, B{})
	result := PickBestUnionCandidate(candidates, []byte(payload))

	require.NotNil(t, result)
	assert.IsType(t, B{}, result.Type)
}
