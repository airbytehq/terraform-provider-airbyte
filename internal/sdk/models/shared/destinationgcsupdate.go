// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

type DestinationGcsUpdateCredentialType string

const (
	DestinationGcsUpdateCredentialTypeHmacKey DestinationGcsUpdateCredentialType = "HMAC_KEY"
)

func (e DestinationGcsUpdateCredentialType) ToPointer() *DestinationGcsUpdateCredentialType {
	return &e
}
func (e *DestinationGcsUpdateCredentialType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "HMAC_KEY":
		*e = DestinationGcsUpdateCredentialType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsUpdateCredentialType: %v", v)
	}
}

type DestinationGcsUpdateHMACKey struct {
	CredentialType *DestinationGcsUpdateCredentialType `default:"HMAC_KEY" json:"credential_type"`
	// When linked to a service account, this ID is 61 characters long; when linked to a user account, it is 24 characters long. Read more <a href="https://cloud.google.com/storage/docs/authentication/hmackeys#overview">here</a>.
	HmacKeyAccessID *string `json:"hmac_key_access_id,omitempty"`
	// The corresponding secret for the access ID. It is a 40-character base-64 encoded string.  Read more <a href="https://cloud.google.com/storage/docs/authentication/hmackeys#secrets">here</a>.
	HmacKeySecret *string `json:"hmac_key_secret,omitempty"`
}

func (d DestinationGcsUpdateHMACKey) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsUpdateHMACKey) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationGcsUpdateHMACKey) GetCredentialType() *DestinationGcsUpdateCredentialType {
	if d == nil {
		return nil
	}
	return d.CredentialType
}

func (d *DestinationGcsUpdateHMACKey) GetHmacKeyAccessID() *string {
	if d == nil {
		return nil
	}
	return d.HmacKeyAccessID
}

func (d *DestinationGcsUpdateHMACKey) GetHmacKeySecret() *string {
	if d == nil {
		return nil
	}
	return d.HmacKeySecret
}

type DestinationGcsUpdateAuthenticationType string

const (
	DestinationGcsUpdateAuthenticationTypeDestinationGcsUpdateHMACKey DestinationGcsUpdateAuthenticationType = "destination-gcs-update_HMAC Key"
)

// DestinationGcsUpdateAuthentication - An HMAC key is a type of credential and can be associated with a service account or a user account in Cloud Storage. Read more <a href="https://cloud.google.com/storage/docs/authentication/hmackeys">here</a>.
type DestinationGcsUpdateAuthentication struct {
	DestinationGcsUpdateHMACKey *DestinationGcsUpdateHMACKey `queryParam:"inline" union:"member"`

	Type DestinationGcsUpdateAuthenticationType
}

func CreateDestinationGcsUpdateAuthenticationDestinationGcsUpdateHMACKey(destinationGcsUpdateHMACKey DestinationGcsUpdateHMACKey) DestinationGcsUpdateAuthentication {
	typ := DestinationGcsUpdateAuthenticationTypeDestinationGcsUpdateHMACKey

	return DestinationGcsUpdateAuthentication{
		DestinationGcsUpdateHMACKey: &destinationGcsUpdateHMACKey,
		Type:                        typ,
	}
}

func (u *DestinationGcsUpdateAuthentication) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var destinationGcsUpdateHMACKey DestinationGcsUpdateHMACKey = DestinationGcsUpdateHMACKey{}
	if err := utils.UnmarshalJSON(data, &destinationGcsUpdateHMACKey, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationGcsUpdateAuthenticationTypeDestinationGcsUpdateHMACKey,
			Value: &destinationGcsUpdateHMACKey,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationGcsUpdateAuthentication", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationGcsUpdateAuthentication", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(DestinationGcsUpdateAuthenticationType)
	switch best.Type {
	case DestinationGcsUpdateAuthenticationTypeDestinationGcsUpdateHMACKey:
		u.DestinationGcsUpdateHMACKey = best.Value.(*DestinationGcsUpdateHMACKey)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationGcsUpdateAuthentication", string(data))
}

func (u DestinationGcsUpdateAuthentication) MarshalJSON() ([]byte, error) {
	if u.DestinationGcsUpdateHMACKey != nil {
		return utils.MarshalJSON(u.DestinationGcsUpdateHMACKey, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationGcsUpdateAuthentication: all fields are null")
}

// DestinationGcsUpdateSchemasCompressionCodec - The compression algorithm used to compress data pages.
type DestinationGcsUpdateSchemasCompressionCodec string

const (
	DestinationGcsUpdateSchemasCompressionCodecUncompressed DestinationGcsUpdateSchemasCompressionCodec = "UNCOMPRESSED"
	DestinationGcsUpdateSchemasCompressionCodecSnappy       DestinationGcsUpdateSchemasCompressionCodec = "SNAPPY"
	DestinationGcsUpdateSchemasCompressionCodecGzip         DestinationGcsUpdateSchemasCompressionCodec = "GZIP"
	DestinationGcsUpdateSchemasCompressionCodecLzo          DestinationGcsUpdateSchemasCompressionCodec = "LZO"
	DestinationGcsUpdateSchemasCompressionCodecBrotli       DestinationGcsUpdateSchemasCompressionCodec = "BROTLI"
	DestinationGcsUpdateSchemasCompressionCodecLz4          DestinationGcsUpdateSchemasCompressionCodec = "LZ4"
	DestinationGcsUpdateSchemasCompressionCodecZstd         DestinationGcsUpdateSchemasCompressionCodec = "ZSTD"
)

func (e DestinationGcsUpdateSchemasCompressionCodec) ToPointer() *DestinationGcsUpdateSchemasCompressionCodec {
	return &e
}
func (e *DestinationGcsUpdateSchemasCompressionCodec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "UNCOMPRESSED":
		fallthrough
	case "SNAPPY":
		fallthrough
	case "GZIP":
		fallthrough
	case "LZO":
		fallthrough
	case "BROTLI":
		fallthrough
	case "LZ4":
		fallthrough
	case "ZSTD":
		*e = DestinationGcsUpdateSchemasCompressionCodec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsUpdateSchemasCompressionCodec: %v", v)
	}
}

type DestinationGcsUpdateSchemasFormatOutputFormatFormatType string

const (
	DestinationGcsUpdateSchemasFormatOutputFormatFormatTypeParquet DestinationGcsUpdateSchemasFormatOutputFormatFormatType = "Parquet"
)

func (e DestinationGcsUpdateSchemasFormatOutputFormatFormatType) ToPointer() *DestinationGcsUpdateSchemasFormatOutputFormatFormatType {
	return &e
}
func (e *DestinationGcsUpdateSchemasFormatOutputFormatFormatType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Parquet":
		*e = DestinationGcsUpdateSchemasFormatOutputFormatFormatType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsUpdateSchemasFormatOutputFormatFormatType: %v", v)
	}
}

type DestinationGcsUpdateParquetColumnarStorage struct {
	// This is the size of a row group being buffered in memory. It limits the memory usage when writing. Larger values will improve the IO when reading, but consume more memory when writing. Default: 128 MB.
	BlockSizeMb *int64 `default:"128" json:"block_size_mb"`
	// The compression algorithm used to compress data pages.
	CompressionCodec *DestinationGcsUpdateSchemasCompressionCodec `default:"UNCOMPRESSED" json:"compression_codec"`
	// Default: true.
	DictionaryEncoding *bool `default:"true" json:"dictionary_encoding"`
	// There is one dictionary page per column per row group when dictionary encoding is used. The dictionary page size works like the page size but for dictionary. Default: 1024 KB.
	DictionaryPageSizeKb *int64                                                   `default:"1024" json:"dictionary_page_size_kb"`
	FormatType           *DestinationGcsUpdateSchemasFormatOutputFormatFormatType `default:"Parquet" json:"format_type"`
	// Maximum size allowed as padding to align row groups. This is also the minimum size of a row group. Default: 8 MB.
	MaxPaddingSizeMb *int64 `default:"8" json:"max_padding_size_mb"`
	// The page size is for compression. A block is composed of pages. A page is the smallest unit that must be read fully to access a single record. If this value is too small, the compression will deteriorate. Default: 1024 KB.
	PageSizeKb *int64 `default:"1024" json:"page_size_kb"`
}

func (d DestinationGcsUpdateParquetColumnarStorage) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsUpdateParquetColumnarStorage) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationGcsUpdateParquetColumnarStorage) GetBlockSizeMb() *int64 {
	if d == nil {
		return nil
	}
	return d.BlockSizeMb
}

func (d *DestinationGcsUpdateParquetColumnarStorage) GetCompressionCodec() *DestinationGcsUpdateSchemasCompressionCodec {
	if d == nil {
		return nil
	}
	return d.CompressionCodec
}

func (d *DestinationGcsUpdateParquetColumnarStorage) GetDictionaryEncoding() *bool {
	if d == nil {
		return nil
	}
	return d.DictionaryEncoding
}

func (d *DestinationGcsUpdateParquetColumnarStorage) GetDictionaryPageSizeKb() *int64 {
	if d == nil {
		return nil
	}
	return d.DictionaryPageSizeKb
}

func (d *DestinationGcsUpdateParquetColumnarStorage) GetFormatType() *DestinationGcsUpdateSchemasFormatOutputFormatFormatType {
	if d == nil {
		return nil
	}
	return d.FormatType
}

func (d *DestinationGcsUpdateParquetColumnarStorage) GetMaxPaddingSizeMb() *int64 {
	if d == nil {
		return nil
	}
	return d.MaxPaddingSizeMb
}

func (d *DestinationGcsUpdateParquetColumnarStorage) GetPageSizeKb() *int64 {
	if d == nil {
		return nil
	}
	return d.PageSizeKb
}

type DestinationGcsUpdateSchemasFormatOutputFormatCompressionType string

const (
	DestinationGcsUpdateSchemasFormatOutputFormatCompressionTypeGzip DestinationGcsUpdateSchemasFormatOutputFormatCompressionType = "GZIP"
)

func (e DestinationGcsUpdateSchemasFormatOutputFormatCompressionType) ToPointer() *DestinationGcsUpdateSchemasFormatOutputFormatCompressionType {
	return &e
}
func (e *DestinationGcsUpdateSchemasFormatOutputFormatCompressionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "GZIP":
		*e = DestinationGcsUpdateSchemasFormatOutputFormatCompressionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsUpdateSchemasFormatOutputFormatCompressionType: %v", v)
	}
}

type DestinationGcsUpdateSchemasGZIP struct {
	CompressionType *DestinationGcsUpdateSchemasFormatOutputFormatCompressionType `default:"GZIP" json:"compression_type"`
}

func (d DestinationGcsUpdateSchemasGZIP) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsUpdateSchemasGZIP) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationGcsUpdateSchemasGZIP) GetCompressionType() *DestinationGcsUpdateSchemasFormatOutputFormatCompressionType {
	if d == nil {
		return nil
	}
	return d.CompressionType
}

type DestinationGcsUpdateSchemasFormatCompressionType string

const (
	DestinationGcsUpdateSchemasFormatCompressionTypeNoCompression DestinationGcsUpdateSchemasFormatCompressionType = "No Compression"
)

func (e DestinationGcsUpdateSchemasFormatCompressionType) ToPointer() *DestinationGcsUpdateSchemasFormatCompressionType {
	return &e
}
func (e *DestinationGcsUpdateSchemasFormatCompressionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "No Compression":
		*e = DestinationGcsUpdateSchemasFormatCompressionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsUpdateSchemasFormatCompressionType: %v", v)
	}
}

type DestinationGcsUpdateSchemasFormatNoCompression struct {
	CompressionType *DestinationGcsUpdateSchemasFormatCompressionType `default:"No Compression" json:"compression_type"`
}

func (d DestinationGcsUpdateSchemasFormatNoCompression) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsUpdateSchemasFormatNoCompression) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationGcsUpdateSchemasFormatNoCompression) GetCompressionType() *DestinationGcsUpdateSchemasFormatCompressionType {
	if d == nil {
		return nil
	}
	return d.CompressionType
}

type DestinationGcsUpdateSchemasCompressionUnionType string

const (
	DestinationGcsUpdateSchemasCompressionUnionTypeDestinationGcsUpdateSchemasFormatNoCompression DestinationGcsUpdateSchemasCompressionUnionType = "destination-gcs-update_Schemas_format_No Compression"
	DestinationGcsUpdateSchemasCompressionUnionTypeDestinationGcsUpdateSchemasGZIP                DestinationGcsUpdateSchemasCompressionUnionType = "destination-gcs-update_Schemas_GZIP"
)

// DestinationGcsUpdateSchemasCompression - Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").
type DestinationGcsUpdateSchemasCompression struct {
	DestinationGcsUpdateSchemasFormatNoCompression *DestinationGcsUpdateSchemasFormatNoCompression `queryParam:"inline" union:"member"`
	DestinationGcsUpdateSchemasGZIP                *DestinationGcsUpdateSchemasGZIP                `queryParam:"inline" union:"member"`

	Type DestinationGcsUpdateSchemasCompressionUnionType
}

func CreateDestinationGcsUpdateSchemasCompressionDestinationGcsUpdateSchemasFormatNoCompression(destinationGcsUpdateSchemasFormatNoCompression DestinationGcsUpdateSchemasFormatNoCompression) DestinationGcsUpdateSchemasCompression {
	typ := DestinationGcsUpdateSchemasCompressionUnionTypeDestinationGcsUpdateSchemasFormatNoCompression

	return DestinationGcsUpdateSchemasCompression{
		DestinationGcsUpdateSchemasFormatNoCompression: &destinationGcsUpdateSchemasFormatNoCompression,
		Type: typ,
	}
}

func CreateDestinationGcsUpdateSchemasCompressionDestinationGcsUpdateSchemasGZIP(destinationGcsUpdateSchemasGZIP DestinationGcsUpdateSchemasGZIP) DestinationGcsUpdateSchemasCompression {
	typ := DestinationGcsUpdateSchemasCompressionUnionTypeDestinationGcsUpdateSchemasGZIP

	return DestinationGcsUpdateSchemasCompression{
		DestinationGcsUpdateSchemasGZIP: &destinationGcsUpdateSchemasGZIP,
		Type:                            typ,
	}
}

func (u *DestinationGcsUpdateSchemasCompression) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var destinationGcsUpdateSchemasFormatNoCompression DestinationGcsUpdateSchemasFormatNoCompression = DestinationGcsUpdateSchemasFormatNoCompression{}
	if err := utils.UnmarshalJSON(data, &destinationGcsUpdateSchemasFormatNoCompression, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationGcsUpdateSchemasCompressionUnionTypeDestinationGcsUpdateSchemasFormatNoCompression,
			Value: &destinationGcsUpdateSchemasFormatNoCompression,
		})
	}

	var destinationGcsUpdateSchemasGZIP DestinationGcsUpdateSchemasGZIP = DestinationGcsUpdateSchemasGZIP{}
	if err := utils.UnmarshalJSON(data, &destinationGcsUpdateSchemasGZIP, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationGcsUpdateSchemasCompressionUnionTypeDestinationGcsUpdateSchemasGZIP,
			Value: &destinationGcsUpdateSchemasGZIP,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationGcsUpdateSchemasCompression", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationGcsUpdateSchemasCompression", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(DestinationGcsUpdateSchemasCompressionUnionType)
	switch best.Type {
	case DestinationGcsUpdateSchemasCompressionUnionTypeDestinationGcsUpdateSchemasFormatNoCompression:
		u.DestinationGcsUpdateSchemasFormatNoCompression = best.Value.(*DestinationGcsUpdateSchemasFormatNoCompression)
		return nil
	case DestinationGcsUpdateSchemasCompressionUnionTypeDestinationGcsUpdateSchemasGZIP:
		u.DestinationGcsUpdateSchemasGZIP = best.Value.(*DestinationGcsUpdateSchemasGZIP)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationGcsUpdateSchemasCompression", string(data))
}

func (u DestinationGcsUpdateSchemasCompression) MarshalJSON() ([]byte, error) {
	if u.DestinationGcsUpdateSchemasFormatNoCompression != nil {
		return utils.MarshalJSON(u.DestinationGcsUpdateSchemasFormatNoCompression, "", true)
	}

	if u.DestinationGcsUpdateSchemasGZIP != nil {
		return utils.MarshalJSON(u.DestinationGcsUpdateSchemasGZIP, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationGcsUpdateSchemasCompression: all fields are null")
}

type DestinationGcsUpdateSchemasFormatFormatType string

const (
	DestinationGcsUpdateSchemasFormatFormatTypeJsonl DestinationGcsUpdateSchemasFormatFormatType = "JSONL"
)

func (e DestinationGcsUpdateSchemasFormatFormatType) ToPointer() *DestinationGcsUpdateSchemasFormatFormatType {
	return &e
}
func (e *DestinationGcsUpdateSchemasFormatFormatType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "JSONL":
		*e = DestinationGcsUpdateSchemasFormatFormatType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsUpdateSchemasFormatFormatType: %v", v)
	}
}

type DestinationGcsUpdateJSONLinesNewlineDelimitedJSON struct {
	// Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").
	Compression *DestinationGcsUpdateSchemasCompression      `json:"compression,omitempty"`
	FormatType  *DestinationGcsUpdateSchemasFormatFormatType `default:"JSONL" json:"format_type"`
}

func (d DestinationGcsUpdateJSONLinesNewlineDelimitedJSON) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsUpdateJSONLinesNewlineDelimitedJSON) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationGcsUpdateJSONLinesNewlineDelimitedJSON) GetCompression() *DestinationGcsUpdateSchemasCompression {
	if d == nil {
		return nil
	}
	return d.Compression
}

func (d *DestinationGcsUpdateJSONLinesNewlineDelimitedJSON) GetFormatType() *DestinationGcsUpdateSchemasFormatFormatType {
	if d == nil {
		return nil
	}
	return d.FormatType
}

type DestinationGcsUpdateSchemasCompressionType string

const (
	DestinationGcsUpdateSchemasCompressionTypeGzip DestinationGcsUpdateSchemasCompressionType = "GZIP"
)

func (e DestinationGcsUpdateSchemasCompressionType) ToPointer() *DestinationGcsUpdateSchemasCompressionType {
	return &e
}
func (e *DestinationGcsUpdateSchemasCompressionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "GZIP":
		*e = DestinationGcsUpdateSchemasCompressionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsUpdateSchemasCompressionType: %v", v)
	}
}

type DestinationGcsUpdateGZIP struct {
	CompressionType *DestinationGcsUpdateSchemasCompressionType `default:"GZIP" json:"compression_type"`
}

func (d DestinationGcsUpdateGZIP) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsUpdateGZIP) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationGcsUpdateGZIP) GetCompressionType() *DestinationGcsUpdateSchemasCompressionType {
	if d == nil {
		return nil
	}
	return d.CompressionType
}

type DestinationGcsUpdateCompressionType string

const (
	DestinationGcsUpdateCompressionTypeNoCompression DestinationGcsUpdateCompressionType = "No Compression"
)

func (e DestinationGcsUpdateCompressionType) ToPointer() *DestinationGcsUpdateCompressionType {
	return &e
}
func (e *DestinationGcsUpdateCompressionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "No Compression":
		*e = DestinationGcsUpdateCompressionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsUpdateCompressionType: %v", v)
	}
}

type DestinationGcsUpdateSchemasNoCompression struct {
	CompressionType *DestinationGcsUpdateCompressionType `default:"No Compression" json:"compression_type"`
}

func (d DestinationGcsUpdateSchemasNoCompression) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsUpdateSchemasNoCompression) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationGcsUpdateSchemasNoCompression) GetCompressionType() *DestinationGcsUpdateCompressionType {
	if d == nil {
		return nil
	}
	return d.CompressionType
}

type DestinationGcsUpdateCompressionUnionType string

const (
	DestinationGcsUpdateCompressionUnionTypeDestinationGcsUpdateSchemasNoCompression DestinationGcsUpdateCompressionUnionType = "destination-gcs-update_Schemas_No Compression"
	DestinationGcsUpdateCompressionUnionTypeDestinationGcsUpdateGZIP                 DestinationGcsUpdateCompressionUnionType = "destination-gcs-update_GZIP"
)

// DestinationGcsUpdateCompression - Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".csv.gz").
type DestinationGcsUpdateCompression struct {
	DestinationGcsUpdateSchemasNoCompression *DestinationGcsUpdateSchemasNoCompression `queryParam:"inline" union:"member"`
	DestinationGcsUpdateGZIP                 *DestinationGcsUpdateGZIP                 `queryParam:"inline" union:"member"`

	Type DestinationGcsUpdateCompressionUnionType
}

func CreateDestinationGcsUpdateCompressionDestinationGcsUpdateSchemasNoCompression(destinationGcsUpdateSchemasNoCompression DestinationGcsUpdateSchemasNoCompression) DestinationGcsUpdateCompression {
	typ := DestinationGcsUpdateCompressionUnionTypeDestinationGcsUpdateSchemasNoCompression

	return DestinationGcsUpdateCompression{
		DestinationGcsUpdateSchemasNoCompression: &destinationGcsUpdateSchemasNoCompression,
		Type:                                     typ,
	}
}

func CreateDestinationGcsUpdateCompressionDestinationGcsUpdateGZIP(destinationGcsUpdateGZIP DestinationGcsUpdateGZIP) DestinationGcsUpdateCompression {
	typ := DestinationGcsUpdateCompressionUnionTypeDestinationGcsUpdateGZIP

	return DestinationGcsUpdateCompression{
		DestinationGcsUpdateGZIP: &destinationGcsUpdateGZIP,
		Type:                     typ,
	}
}

func (u *DestinationGcsUpdateCompression) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var destinationGcsUpdateSchemasNoCompression DestinationGcsUpdateSchemasNoCompression = DestinationGcsUpdateSchemasNoCompression{}
	if err := utils.UnmarshalJSON(data, &destinationGcsUpdateSchemasNoCompression, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationGcsUpdateCompressionUnionTypeDestinationGcsUpdateSchemasNoCompression,
			Value: &destinationGcsUpdateSchemasNoCompression,
		})
	}

	var destinationGcsUpdateGZIP DestinationGcsUpdateGZIP = DestinationGcsUpdateGZIP{}
	if err := utils.UnmarshalJSON(data, &destinationGcsUpdateGZIP, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationGcsUpdateCompressionUnionTypeDestinationGcsUpdateGZIP,
			Value: &destinationGcsUpdateGZIP,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationGcsUpdateCompression", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationGcsUpdateCompression", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(DestinationGcsUpdateCompressionUnionType)
	switch best.Type {
	case DestinationGcsUpdateCompressionUnionTypeDestinationGcsUpdateSchemasNoCompression:
		u.DestinationGcsUpdateSchemasNoCompression = best.Value.(*DestinationGcsUpdateSchemasNoCompression)
		return nil
	case DestinationGcsUpdateCompressionUnionTypeDestinationGcsUpdateGZIP:
		u.DestinationGcsUpdateGZIP = best.Value.(*DestinationGcsUpdateGZIP)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationGcsUpdateCompression", string(data))
}

func (u DestinationGcsUpdateCompression) MarshalJSON() ([]byte, error) {
	if u.DestinationGcsUpdateSchemasNoCompression != nil {
		return utils.MarshalJSON(u.DestinationGcsUpdateSchemasNoCompression, "", true)
	}

	if u.DestinationGcsUpdateGZIP != nil {
		return utils.MarshalJSON(u.DestinationGcsUpdateGZIP, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationGcsUpdateCompression: all fields are null")
}

// DestinationGcsUpdateNormalization - Whether the input JSON data should be normalized (flattened) in the output CSV. Please refer to docs for details.
type DestinationGcsUpdateNormalization string

const (
	DestinationGcsUpdateNormalizationNoFlattening        DestinationGcsUpdateNormalization = "No flattening"
	DestinationGcsUpdateNormalizationRootLevelFlattening DestinationGcsUpdateNormalization = "Root level flattening"
)

func (e DestinationGcsUpdateNormalization) ToPointer() *DestinationGcsUpdateNormalization {
	return &e
}
func (e *DestinationGcsUpdateNormalization) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "No flattening":
		fallthrough
	case "Root level flattening":
		*e = DestinationGcsUpdateNormalization(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsUpdateNormalization: %v", v)
	}
}

type DestinationGcsUpdateSchemasFormatType string

const (
	DestinationGcsUpdateSchemasFormatTypeCsv DestinationGcsUpdateSchemasFormatType = "CSV"
)

func (e DestinationGcsUpdateSchemasFormatType) ToPointer() *DestinationGcsUpdateSchemasFormatType {
	return &e
}
func (e *DestinationGcsUpdateSchemasFormatType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CSV":
		*e = DestinationGcsUpdateSchemasFormatType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsUpdateSchemasFormatType: %v", v)
	}
}

type DestinationGcsUpdateCSVCommaSeparatedValues struct {
	// Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".csv.gz").
	Compression *DestinationGcsUpdateCompression `json:"compression,omitempty"`
	// Whether the input JSON data should be normalized (flattened) in the output CSV. Please refer to docs for details.
	Flattening *DestinationGcsUpdateNormalization     `default:"No flattening" json:"flattening"`
	FormatType *DestinationGcsUpdateSchemasFormatType `default:"CSV" json:"format_type"`
}

func (d DestinationGcsUpdateCSVCommaSeparatedValues) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsUpdateCSVCommaSeparatedValues) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationGcsUpdateCSVCommaSeparatedValues) GetCompression() *DestinationGcsUpdateCompression {
	if d == nil {
		return nil
	}
	return d.Compression
}

func (d *DestinationGcsUpdateCSVCommaSeparatedValues) GetFlattening() *DestinationGcsUpdateNormalization {
	if d == nil {
		return nil
	}
	return d.Flattening
}

func (d *DestinationGcsUpdateCSVCommaSeparatedValues) GetFormatType() *DestinationGcsUpdateSchemasFormatType {
	if d == nil {
		return nil
	}
	return d.FormatType
}

type DestinationGcsUpdateSchemasFormatOutputFormat1CompressionCodecCodec string

const (
	DestinationGcsUpdateSchemasFormatOutputFormat1CompressionCodecCodecSnappy DestinationGcsUpdateSchemasFormatOutputFormat1CompressionCodecCodec = "snappy"
)

func (e DestinationGcsUpdateSchemasFormatOutputFormat1CompressionCodecCodec) ToPointer() *DestinationGcsUpdateSchemasFormatOutputFormat1CompressionCodecCodec {
	return &e
}
func (e *DestinationGcsUpdateSchemasFormatOutputFormat1CompressionCodecCodec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "snappy":
		*e = DestinationGcsUpdateSchemasFormatOutputFormat1CompressionCodecCodec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsUpdateSchemasFormatOutputFormat1CompressionCodecCodec: %v", v)
	}
}

type DestinationGcsUpdateSnappy struct {
	Codec *DestinationGcsUpdateSchemasFormatOutputFormat1CompressionCodecCodec `default:"snappy" json:"codec"`
}

func (d DestinationGcsUpdateSnappy) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsUpdateSnappy) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationGcsUpdateSnappy) GetCodec() *DestinationGcsUpdateSchemasFormatOutputFormat1CompressionCodecCodec {
	if d == nil {
		return nil
	}
	return d.Codec
}

type DestinationGcsUpdateSchemasFormatOutputFormat1Codec string

const (
	DestinationGcsUpdateSchemasFormatOutputFormat1CodecZstandard DestinationGcsUpdateSchemasFormatOutputFormat1Codec = "zstandard"
)

func (e DestinationGcsUpdateSchemasFormatOutputFormat1Codec) ToPointer() *DestinationGcsUpdateSchemasFormatOutputFormat1Codec {
	return &e
}
func (e *DestinationGcsUpdateSchemasFormatOutputFormat1Codec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "zstandard":
		*e = DestinationGcsUpdateSchemasFormatOutputFormat1Codec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsUpdateSchemasFormatOutputFormat1Codec: %v", v)
	}
}

type DestinationGcsUpdateZstandard struct {
	Codec *DestinationGcsUpdateSchemasFormatOutputFormat1Codec `default:"zstandard" json:"codec"`
	// Negative levels are 'fast' modes akin to lz4 or snappy, levels above 9 are generally for archival purposes, and levels above 18 use a lot of memory.
	CompressionLevel *int64 `default:"3" json:"compression_level"`
	// If true, include a checksum with each data block.
	IncludeChecksum *bool `default:"false" json:"include_checksum"`
}

func (d DestinationGcsUpdateZstandard) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsUpdateZstandard) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationGcsUpdateZstandard) GetCodec() *DestinationGcsUpdateSchemasFormatOutputFormat1Codec {
	if d == nil {
		return nil
	}
	return d.Codec
}

func (d *DestinationGcsUpdateZstandard) GetCompressionLevel() *int64 {
	if d == nil {
		return nil
	}
	return d.CompressionLevel
}

func (d *DestinationGcsUpdateZstandard) GetIncludeChecksum() *bool {
	if d == nil {
		return nil
	}
	return d.IncludeChecksum
}

type DestinationGcsUpdateSchemasFormatOutputFormatCodec string

const (
	DestinationGcsUpdateSchemasFormatOutputFormatCodecXz DestinationGcsUpdateSchemasFormatOutputFormatCodec = "xz"
)

func (e DestinationGcsUpdateSchemasFormatOutputFormatCodec) ToPointer() *DestinationGcsUpdateSchemasFormatOutputFormatCodec {
	return &e
}
func (e *DestinationGcsUpdateSchemasFormatOutputFormatCodec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "xz":
		*e = DestinationGcsUpdateSchemasFormatOutputFormatCodec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsUpdateSchemasFormatOutputFormatCodec: %v", v)
	}
}

type DestinationGcsUpdateXz struct {
	Codec *DestinationGcsUpdateSchemasFormatOutputFormatCodec `default:"xz" json:"codec"`
	// The presets 0-3 are fast presets with medium compression. The presets 4-6 are fairly slow presets with high compression. The default preset is 6. The presets 7-9 are like the preset 6 but use bigger dictionaries and have higher compressor and decompressor memory requirements. Unless the uncompressed size of the file exceeds 8 MiB, 16 MiB, or 32 MiB, it is waste of memory to use the presets 7, 8, or 9, respectively. Read more <a href="https://commons.apache.org/proper/commons-compress/apidocs/org/apache/commons/compress/compressors/xz/XZCompressorOutputStream.html#XZCompressorOutputStream-java.io.OutputStream-int-">here</a> for details.
	CompressionLevel *int64 `default:"6" json:"compression_level"`
}

func (d DestinationGcsUpdateXz) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsUpdateXz) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationGcsUpdateXz) GetCodec() *DestinationGcsUpdateSchemasFormatOutputFormatCodec {
	if d == nil {
		return nil
	}
	return d.Codec
}

func (d *DestinationGcsUpdateXz) GetCompressionLevel() *int64 {
	if d == nil {
		return nil
	}
	return d.CompressionLevel
}

type DestinationGcsUpdateSchemasFormatCodec string

const (
	DestinationGcsUpdateSchemasFormatCodecBzip2 DestinationGcsUpdateSchemasFormatCodec = "bzip2"
)

func (e DestinationGcsUpdateSchemasFormatCodec) ToPointer() *DestinationGcsUpdateSchemasFormatCodec {
	return &e
}
func (e *DestinationGcsUpdateSchemasFormatCodec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "bzip2":
		*e = DestinationGcsUpdateSchemasFormatCodec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsUpdateSchemasFormatCodec: %v", v)
	}
}

type DestinationGcsUpdateBzip2 struct {
	Codec *DestinationGcsUpdateSchemasFormatCodec `default:"bzip2" json:"codec"`
}

func (d DestinationGcsUpdateBzip2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsUpdateBzip2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationGcsUpdateBzip2) GetCodec() *DestinationGcsUpdateSchemasFormatCodec {
	if d == nil {
		return nil
	}
	return d.Codec
}

type DestinationGcsUpdateSchemasCodec string

const (
	DestinationGcsUpdateSchemasCodecDeflate DestinationGcsUpdateSchemasCodec = "Deflate"
)

func (e DestinationGcsUpdateSchemasCodec) ToPointer() *DestinationGcsUpdateSchemasCodec {
	return &e
}
func (e *DestinationGcsUpdateSchemasCodec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Deflate":
		*e = DestinationGcsUpdateSchemasCodec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsUpdateSchemasCodec: %v", v)
	}
}

type DestinationGcsUpdateDeflate struct {
	Codec *DestinationGcsUpdateSchemasCodec `default:"Deflate" json:"codec"`
	// 0: no compression & fastest, 9: best compression & slowest.
	CompressionLevel *int64 `default:"0" json:"compression_level"`
}

func (d DestinationGcsUpdateDeflate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsUpdateDeflate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationGcsUpdateDeflate) GetCodec() *DestinationGcsUpdateSchemasCodec {
	if d == nil {
		return nil
	}
	return d.Codec
}

func (d *DestinationGcsUpdateDeflate) GetCompressionLevel() *int64 {
	if d == nil {
		return nil
	}
	return d.CompressionLevel
}

type DestinationGcsUpdateCodec string

const (
	DestinationGcsUpdateCodecNoCompression DestinationGcsUpdateCodec = "no compression"
)

func (e DestinationGcsUpdateCodec) ToPointer() *DestinationGcsUpdateCodec {
	return &e
}
func (e *DestinationGcsUpdateCodec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "no compression":
		*e = DestinationGcsUpdateCodec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsUpdateCodec: %v", v)
	}
}

type DestinationGcsUpdateNoCompression struct {
	Codec *DestinationGcsUpdateCodec `default:"no compression" json:"codec"`
}

func (d DestinationGcsUpdateNoCompression) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsUpdateNoCompression) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationGcsUpdateNoCompression) GetCodec() *DestinationGcsUpdateCodec {
	if d == nil {
		return nil
	}
	return d.Codec
}

type DestinationGcsUpdateCompressionCodecType string

const (
	DestinationGcsUpdateCompressionCodecTypeDestinationGcsUpdateNoCompression DestinationGcsUpdateCompressionCodecType = "destination-gcs-update_No Compression"
	DestinationGcsUpdateCompressionCodecTypeDestinationGcsUpdateDeflate       DestinationGcsUpdateCompressionCodecType = "destination-gcs-update_Deflate"
	DestinationGcsUpdateCompressionCodecTypeDestinationGcsUpdateBzip2         DestinationGcsUpdateCompressionCodecType = "destination-gcs-update_bzip2"
	DestinationGcsUpdateCompressionCodecTypeDestinationGcsUpdateXz            DestinationGcsUpdateCompressionCodecType = "destination-gcs-update_xz"
	DestinationGcsUpdateCompressionCodecTypeDestinationGcsUpdateZstandard     DestinationGcsUpdateCompressionCodecType = "destination-gcs-update_zstandard"
	DestinationGcsUpdateCompressionCodecTypeDestinationGcsUpdateSnappy        DestinationGcsUpdateCompressionCodecType = "destination-gcs-update_snappy"
)

// DestinationGcsUpdateCompressionCodec - The compression algorithm used to compress data. Default to no compression.
type DestinationGcsUpdateCompressionCodec struct {
	DestinationGcsUpdateNoCompression *DestinationGcsUpdateNoCompression `queryParam:"inline" union:"member"`
	DestinationGcsUpdateDeflate       *DestinationGcsUpdateDeflate       `queryParam:"inline" union:"member"`
	DestinationGcsUpdateBzip2         *DestinationGcsUpdateBzip2         `queryParam:"inline" union:"member"`
	DestinationGcsUpdateXz            *DestinationGcsUpdateXz            `queryParam:"inline" union:"member"`
	DestinationGcsUpdateZstandard     *DestinationGcsUpdateZstandard     `queryParam:"inline" union:"member"`
	DestinationGcsUpdateSnappy        *DestinationGcsUpdateSnappy        `queryParam:"inline" union:"member"`

	Type DestinationGcsUpdateCompressionCodecType
}

func CreateDestinationGcsUpdateCompressionCodecDestinationGcsUpdateNoCompression(destinationGcsUpdateNoCompression DestinationGcsUpdateNoCompression) DestinationGcsUpdateCompressionCodec {
	typ := DestinationGcsUpdateCompressionCodecTypeDestinationGcsUpdateNoCompression

	return DestinationGcsUpdateCompressionCodec{
		DestinationGcsUpdateNoCompression: &destinationGcsUpdateNoCompression,
		Type:                              typ,
	}
}

func CreateDestinationGcsUpdateCompressionCodecDestinationGcsUpdateDeflate(destinationGcsUpdateDeflate DestinationGcsUpdateDeflate) DestinationGcsUpdateCompressionCodec {
	typ := DestinationGcsUpdateCompressionCodecTypeDestinationGcsUpdateDeflate

	return DestinationGcsUpdateCompressionCodec{
		DestinationGcsUpdateDeflate: &destinationGcsUpdateDeflate,
		Type:                        typ,
	}
}

func CreateDestinationGcsUpdateCompressionCodecDestinationGcsUpdateBzip2(destinationGcsUpdateBzip2 DestinationGcsUpdateBzip2) DestinationGcsUpdateCompressionCodec {
	typ := DestinationGcsUpdateCompressionCodecTypeDestinationGcsUpdateBzip2

	return DestinationGcsUpdateCompressionCodec{
		DestinationGcsUpdateBzip2: &destinationGcsUpdateBzip2,
		Type:                      typ,
	}
}

func CreateDestinationGcsUpdateCompressionCodecDestinationGcsUpdateXz(destinationGcsUpdateXz DestinationGcsUpdateXz) DestinationGcsUpdateCompressionCodec {
	typ := DestinationGcsUpdateCompressionCodecTypeDestinationGcsUpdateXz

	return DestinationGcsUpdateCompressionCodec{
		DestinationGcsUpdateXz: &destinationGcsUpdateXz,
		Type:                   typ,
	}
}

func CreateDestinationGcsUpdateCompressionCodecDestinationGcsUpdateZstandard(destinationGcsUpdateZstandard DestinationGcsUpdateZstandard) DestinationGcsUpdateCompressionCodec {
	typ := DestinationGcsUpdateCompressionCodecTypeDestinationGcsUpdateZstandard

	return DestinationGcsUpdateCompressionCodec{
		DestinationGcsUpdateZstandard: &destinationGcsUpdateZstandard,
		Type:                          typ,
	}
}

func CreateDestinationGcsUpdateCompressionCodecDestinationGcsUpdateSnappy(destinationGcsUpdateSnappy DestinationGcsUpdateSnappy) DestinationGcsUpdateCompressionCodec {
	typ := DestinationGcsUpdateCompressionCodecTypeDestinationGcsUpdateSnappy

	return DestinationGcsUpdateCompressionCodec{
		DestinationGcsUpdateSnappy: &destinationGcsUpdateSnappy,
		Type:                       typ,
	}
}

func (u *DestinationGcsUpdateCompressionCodec) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var destinationGcsUpdateNoCompression DestinationGcsUpdateNoCompression = DestinationGcsUpdateNoCompression{}
	if err := utils.UnmarshalJSON(data, &destinationGcsUpdateNoCompression, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationGcsUpdateCompressionCodecTypeDestinationGcsUpdateNoCompression,
			Value: &destinationGcsUpdateNoCompression,
		})
	}

	var destinationGcsUpdateDeflate DestinationGcsUpdateDeflate = DestinationGcsUpdateDeflate{}
	if err := utils.UnmarshalJSON(data, &destinationGcsUpdateDeflate, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationGcsUpdateCompressionCodecTypeDestinationGcsUpdateDeflate,
			Value: &destinationGcsUpdateDeflate,
		})
	}

	var destinationGcsUpdateBzip2 DestinationGcsUpdateBzip2 = DestinationGcsUpdateBzip2{}
	if err := utils.UnmarshalJSON(data, &destinationGcsUpdateBzip2, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationGcsUpdateCompressionCodecTypeDestinationGcsUpdateBzip2,
			Value: &destinationGcsUpdateBzip2,
		})
	}

	var destinationGcsUpdateXz DestinationGcsUpdateXz = DestinationGcsUpdateXz{}
	if err := utils.UnmarshalJSON(data, &destinationGcsUpdateXz, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationGcsUpdateCompressionCodecTypeDestinationGcsUpdateXz,
			Value: &destinationGcsUpdateXz,
		})
	}

	var destinationGcsUpdateZstandard DestinationGcsUpdateZstandard = DestinationGcsUpdateZstandard{}
	if err := utils.UnmarshalJSON(data, &destinationGcsUpdateZstandard, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationGcsUpdateCompressionCodecTypeDestinationGcsUpdateZstandard,
			Value: &destinationGcsUpdateZstandard,
		})
	}

	var destinationGcsUpdateSnappy DestinationGcsUpdateSnappy = DestinationGcsUpdateSnappy{}
	if err := utils.UnmarshalJSON(data, &destinationGcsUpdateSnappy, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationGcsUpdateCompressionCodecTypeDestinationGcsUpdateSnappy,
			Value: &destinationGcsUpdateSnappy,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationGcsUpdateCompressionCodec", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationGcsUpdateCompressionCodec", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(DestinationGcsUpdateCompressionCodecType)
	switch best.Type {
	case DestinationGcsUpdateCompressionCodecTypeDestinationGcsUpdateNoCompression:
		u.DestinationGcsUpdateNoCompression = best.Value.(*DestinationGcsUpdateNoCompression)
		return nil
	case DestinationGcsUpdateCompressionCodecTypeDestinationGcsUpdateDeflate:
		u.DestinationGcsUpdateDeflate = best.Value.(*DestinationGcsUpdateDeflate)
		return nil
	case DestinationGcsUpdateCompressionCodecTypeDestinationGcsUpdateBzip2:
		u.DestinationGcsUpdateBzip2 = best.Value.(*DestinationGcsUpdateBzip2)
		return nil
	case DestinationGcsUpdateCompressionCodecTypeDestinationGcsUpdateXz:
		u.DestinationGcsUpdateXz = best.Value.(*DestinationGcsUpdateXz)
		return nil
	case DestinationGcsUpdateCompressionCodecTypeDestinationGcsUpdateZstandard:
		u.DestinationGcsUpdateZstandard = best.Value.(*DestinationGcsUpdateZstandard)
		return nil
	case DestinationGcsUpdateCompressionCodecTypeDestinationGcsUpdateSnappy:
		u.DestinationGcsUpdateSnappy = best.Value.(*DestinationGcsUpdateSnappy)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationGcsUpdateCompressionCodec", string(data))
}

func (u DestinationGcsUpdateCompressionCodec) MarshalJSON() ([]byte, error) {
	if u.DestinationGcsUpdateNoCompression != nil {
		return utils.MarshalJSON(u.DestinationGcsUpdateNoCompression, "", true)
	}

	if u.DestinationGcsUpdateDeflate != nil {
		return utils.MarshalJSON(u.DestinationGcsUpdateDeflate, "", true)
	}

	if u.DestinationGcsUpdateBzip2 != nil {
		return utils.MarshalJSON(u.DestinationGcsUpdateBzip2, "", true)
	}

	if u.DestinationGcsUpdateXz != nil {
		return utils.MarshalJSON(u.DestinationGcsUpdateXz, "", true)
	}

	if u.DestinationGcsUpdateZstandard != nil {
		return utils.MarshalJSON(u.DestinationGcsUpdateZstandard, "", true)
	}

	if u.DestinationGcsUpdateSnappy != nil {
		return utils.MarshalJSON(u.DestinationGcsUpdateSnappy, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationGcsUpdateCompressionCodec: all fields are null")
}

type DestinationGcsUpdateFormatType string

const (
	DestinationGcsUpdateFormatTypeAvro DestinationGcsUpdateFormatType = "Avro"
)

func (e DestinationGcsUpdateFormatType) ToPointer() *DestinationGcsUpdateFormatType {
	return &e
}
func (e *DestinationGcsUpdateFormatType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Avro":
		*e = DestinationGcsUpdateFormatType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsUpdateFormatType: %v", v)
	}
}

type DestinationGcsUpdateAvroApacheAvro struct {
	// The compression algorithm used to compress data. Default to no compression.
	CompressionCodec *DestinationGcsUpdateCompressionCodec `json:"compression_codec,omitempty"`
	FormatType       *DestinationGcsUpdateFormatType       `default:"Avro" json:"format_type"`
}

func (d DestinationGcsUpdateAvroApacheAvro) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsUpdateAvroApacheAvro) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationGcsUpdateAvroApacheAvro) GetCompressionCodec() *DestinationGcsUpdateCompressionCodec {
	if d == nil {
		return nil
	}
	return d.CompressionCodec
}

func (d *DestinationGcsUpdateAvroApacheAvro) GetFormatType() *DestinationGcsUpdateFormatType {
	if d == nil {
		return nil
	}
	return d.FormatType
}

type DestinationGcsUpdateOutputFormatType string

const (
	DestinationGcsUpdateOutputFormatTypeDestinationGcsUpdateAvroApacheAvro                DestinationGcsUpdateOutputFormatType = "destination-gcs-update_Avro: Apache Avro"
	DestinationGcsUpdateOutputFormatTypeDestinationGcsUpdateCSVCommaSeparatedValues       DestinationGcsUpdateOutputFormatType = "destination-gcs-update_CSV: Comma-Separated Values"
	DestinationGcsUpdateOutputFormatTypeDestinationGcsUpdateJSONLinesNewlineDelimitedJSON DestinationGcsUpdateOutputFormatType = "destination-gcs-update_JSON Lines: newline-delimited JSON"
	DestinationGcsUpdateOutputFormatTypeDestinationGcsUpdateParquetColumnarStorage        DestinationGcsUpdateOutputFormatType = "destination-gcs-update_Parquet: Columnar Storage"
)

// DestinationGcsUpdateOutputFormat - Output data format. One of the following formats must be selected - <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-avro#advantages_of_avro">AVRO</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-parquet#parquet_schemas">PARQUET</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-csv#loading_csv_data_into_a_table">CSV</a> format, or <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-json#loading_json_data_into_a_new_table">JSONL</a> format.
type DestinationGcsUpdateOutputFormat struct {
	DestinationGcsUpdateAvroApacheAvro                *DestinationGcsUpdateAvroApacheAvro                `queryParam:"inline" union:"member"`
	DestinationGcsUpdateCSVCommaSeparatedValues       *DestinationGcsUpdateCSVCommaSeparatedValues       `queryParam:"inline" union:"member"`
	DestinationGcsUpdateJSONLinesNewlineDelimitedJSON *DestinationGcsUpdateJSONLinesNewlineDelimitedJSON `queryParam:"inline" union:"member"`
	DestinationGcsUpdateParquetColumnarStorage        *DestinationGcsUpdateParquetColumnarStorage        `queryParam:"inline" union:"member"`

	Type DestinationGcsUpdateOutputFormatType
}

func CreateDestinationGcsUpdateOutputFormatDestinationGcsUpdateAvroApacheAvro(destinationGcsUpdateAvroApacheAvro DestinationGcsUpdateAvroApacheAvro) DestinationGcsUpdateOutputFormat {
	typ := DestinationGcsUpdateOutputFormatTypeDestinationGcsUpdateAvroApacheAvro

	return DestinationGcsUpdateOutputFormat{
		DestinationGcsUpdateAvroApacheAvro: &destinationGcsUpdateAvroApacheAvro,
		Type:                               typ,
	}
}

func CreateDestinationGcsUpdateOutputFormatDestinationGcsUpdateCSVCommaSeparatedValues(destinationGcsUpdateCSVCommaSeparatedValues DestinationGcsUpdateCSVCommaSeparatedValues) DestinationGcsUpdateOutputFormat {
	typ := DestinationGcsUpdateOutputFormatTypeDestinationGcsUpdateCSVCommaSeparatedValues

	return DestinationGcsUpdateOutputFormat{
		DestinationGcsUpdateCSVCommaSeparatedValues: &destinationGcsUpdateCSVCommaSeparatedValues,
		Type: typ,
	}
}

func CreateDestinationGcsUpdateOutputFormatDestinationGcsUpdateJSONLinesNewlineDelimitedJSON(destinationGcsUpdateJSONLinesNewlineDelimitedJSON DestinationGcsUpdateJSONLinesNewlineDelimitedJSON) DestinationGcsUpdateOutputFormat {
	typ := DestinationGcsUpdateOutputFormatTypeDestinationGcsUpdateJSONLinesNewlineDelimitedJSON

	return DestinationGcsUpdateOutputFormat{
		DestinationGcsUpdateJSONLinesNewlineDelimitedJSON: &destinationGcsUpdateJSONLinesNewlineDelimitedJSON,
		Type: typ,
	}
}

func CreateDestinationGcsUpdateOutputFormatDestinationGcsUpdateParquetColumnarStorage(destinationGcsUpdateParquetColumnarStorage DestinationGcsUpdateParquetColumnarStorage) DestinationGcsUpdateOutputFormat {
	typ := DestinationGcsUpdateOutputFormatTypeDestinationGcsUpdateParquetColumnarStorage

	return DestinationGcsUpdateOutputFormat{
		DestinationGcsUpdateParquetColumnarStorage: &destinationGcsUpdateParquetColumnarStorage,
		Type: typ,
	}
}

func (u *DestinationGcsUpdateOutputFormat) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var destinationGcsUpdateAvroApacheAvro DestinationGcsUpdateAvroApacheAvro = DestinationGcsUpdateAvroApacheAvro{}
	if err := utils.UnmarshalJSON(data, &destinationGcsUpdateAvroApacheAvro, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationGcsUpdateOutputFormatTypeDestinationGcsUpdateAvroApacheAvro,
			Value: &destinationGcsUpdateAvroApacheAvro,
		})
	}

	var destinationGcsUpdateCSVCommaSeparatedValues DestinationGcsUpdateCSVCommaSeparatedValues = DestinationGcsUpdateCSVCommaSeparatedValues{}
	if err := utils.UnmarshalJSON(data, &destinationGcsUpdateCSVCommaSeparatedValues, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationGcsUpdateOutputFormatTypeDestinationGcsUpdateCSVCommaSeparatedValues,
			Value: &destinationGcsUpdateCSVCommaSeparatedValues,
		})
	}

	var destinationGcsUpdateJSONLinesNewlineDelimitedJSON DestinationGcsUpdateJSONLinesNewlineDelimitedJSON = DestinationGcsUpdateJSONLinesNewlineDelimitedJSON{}
	if err := utils.UnmarshalJSON(data, &destinationGcsUpdateJSONLinesNewlineDelimitedJSON, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationGcsUpdateOutputFormatTypeDestinationGcsUpdateJSONLinesNewlineDelimitedJSON,
			Value: &destinationGcsUpdateJSONLinesNewlineDelimitedJSON,
		})
	}

	var destinationGcsUpdateParquetColumnarStorage DestinationGcsUpdateParquetColumnarStorage = DestinationGcsUpdateParquetColumnarStorage{}
	if err := utils.UnmarshalJSON(data, &destinationGcsUpdateParquetColumnarStorage, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationGcsUpdateOutputFormatTypeDestinationGcsUpdateParquetColumnarStorage,
			Value: &destinationGcsUpdateParquetColumnarStorage,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationGcsUpdateOutputFormat", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationGcsUpdateOutputFormat", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(DestinationGcsUpdateOutputFormatType)
	switch best.Type {
	case DestinationGcsUpdateOutputFormatTypeDestinationGcsUpdateAvroApacheAvro:
		u.DestinationGcsUpdateAvroApacheAvro = best.Value.(*DestinationGcsUpdateAvroApacheAvro)
		return nil
	case DestinationGcsUpdateOutputFormatTypeDestinationGcsUpdateCSVCommaSeparatedValues:
		u.DestinationGcsUpdateCSVCommaSeparatedValues = best.Value.(*DestinationGcsUpdateCSVCommaSeparatedValues)
		return nil
	case DestinationGcsUpdateOutputFormatTypeDestinationGcsUpdateJSONLinesNewlineDelimitedJSON:
		u.DestinationGcsUpdateJSONLinesNewlineDelimitedJSON = best.Value.(*DestinationGcsUpdateJSONLinesNewlineDelimitedJSON)
		return nil
	case DestinationGcsUpdateOutputFormatTypeDestinationGcsUpdateParquetColumnarStorage:
		u.DestinationGcsUpdateParquetColumnarStorage = best.Value.(*DestinationGcsUpdateParquetColumnarStorage)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationGcsUpdateOutputFormat", string(data))
}

func (u DestinationGcsUpdateOutputFormat) MarshalJSON() ([]byte, error) {
	if u.DestinationGcsUpdateAvroApacheAvro != nil {
		return utils.MarshalJSON(u.DestinationGcsUpdateAvroApacheAvro, "", true)
	}

	if u.DestinationGcsUpdateCSVCommaSeparatedValues != nil {
		return utils.MarshalJSON(u.DestinationGcsUpdateCSVCommaSeparatedValues, "", true)
	}

	if u.DestinationGcsUpdateJSONLinesNewlineDelimitedJSON != nil {
		return utils.MarshalJSON(u.DestinationGcsUpdateJSONLinesNewlineDelimitedJSON, "", true)
	}

	if u.DestinationGcsUpdateParquetColumnarStorage != nil {
		return utils.MarshalJSON(u.DestinationGcsUpdateParquetColumnarStorage, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationGcsUpdateOutputFormat: all fields are null")
}

// DestinationGCSUpdateGCSBucketRegion - Select a Region of the GCS Bucket. Read more <a href="https://cloud.google.com/storage/docs/locations">here</a>.
type DestinationGCSUpdateGCSBucketRegion string

const (
	DestinationGCSUpdateGCSBucketRegionNorthamericaNortheast1 DestinationGCSUpdateGCSBucketRegion = "northamerica-northeast1"
	DestinationGCSUpdateGCSBucketRegionNorthamericaNortheast2 DestinationGCSUpdateGCSBucketRegion = "northamerica-northeast2"
	DestinationGCSUpdateGCSBucketRegionUsCentral1             DestinationGCSUpdateGCSBucketRegion = "us-central1"
	DestinationGCSUpdateGCSBucketRegionUsEast1                DestinationGCSUpdateGCSBucketRegion = "us-east1"
	DestinationGCSUpdateGCSBucketRegionUsEast4                DestinationGCSUpdateGCSBucketRegion = "us-east4"
	DestinationGCSUpdateGCSBucketRegionUsWest1                DestinationGCSUpdateGCSBucketRegion = "us-west1"
	DestinationGCSUpdateGCSBucketRegionUsWest2                DestinationGCSUpdateGCSBucketRegion = "us-west2"
	DestinationGCSUpdateGCSBucketRegionUsWest3                DestinationGCSUpdateGCSBucketRegion = "us-west3"
	DestinationGCSUpdateGCSBucketRegionUsWest4                DestinationGCSUpdateGCSBucketRegion = "us-west4"
	DestinationGCSUpdateGCSBucketRegionSouthamericaEast1      DestinationGCSUpdateGCSBucketRegion = "southamerica-east1"
	DestinationGCSUpdateGCSBucketRegionSouthamericaWest1      DestinationGCSUpdateGCSBucketRegion = "southamerica-west1"
	DestinationGCSUpdateGCSBucketRegionEuropeCentral2         DestinationGCSUpdateGCSBucketRegion = "europe-central2"
	DestinationGCSUpdateGCSBucketRegionEuropeNorth1           DestinationGCSUpdateGCSBucketRegion = "europe-north1"
	DestinationGCSUpdateGCSBucketRegionEuropeWest1            DestinationGCSUpdateGCSBucketRegion = "europe-west1"
	DestinationGCSUpdateGCSBucketRegionEuropeWest2            DestinationGCSUpdateGCSBucketRegion = "europe-west2"
	DestinationGCSUpdateGCSBucketRegionEuropeWest3            DestinationGCSUpdateGCSBucketRegion = "europe-west3"
	DestinationGCSUpdateGCSBucketRegionEuropeWest4            DestinationGCSUpdateGCSBucketRegion = "europe-west4"
	DestinationGCSUpdateGCSBucketRegionEuropeWest6            DestinationGCSUpdateGCSBucketRegion = "europe-west6"
	DestinationGCSUpdateGCSBucketRegionAsiaEast1              DestinationGCSUpdateGCSBucketRegion = "asia-east1"
	DestinationGCSUpdateGCSBucketRegionAsiaEast2              DestinationGCSUpdateGCSBucketRegion = "asia-east2"
	DestinationGCSUpdateGCSBucketRegionAsiaNortheast1         DestinationGCSUpdateGCSBucketRegion = "asia-northeast1"
	DestinationGCSUpdateGCSBucketRegionAsiaNortheast2         DestinationGCSUpdateGCSBucketRegion = "asia-northeast2"
	DestinationGCSUpdateGCSBucketRegionAsiaNortheast3         DestinationGCSUpdateGCSBucketRegion = "asia-northeast3"
	DestinationGCSUpdateGCSBucketRegionAsiaSouth1             DestinationGCSUpdateGCSBucketRegion = "asia-south1"
	DestinationGCSUpdateGCSBucketRegionAsiaSouth2             DestinationGCSUpdateGCSBucketRegion = "asia-south2"
	DestinationGCSUpdateGCSBucketRegionAsiaSoutheast1         DestinationGCSUpdateGCSBucketRegion = "asia-southeast1"
	DestinationGCSUpdateGCSBucketRegionAsiaSoutheast2         DestinationGCSUpdateGCSBucketRegion = "asia-southeast2"
	DestinationGCSUpdateGCSBucketRegionAustraliaSoutheast1    DestinationGCSUpdateGCSBucketRegion = "australia-southeast1"
	DestinationGCSUpdateGCSBucketRegionAustraliaSoutheast2    DestinationGCSUpdateGCSBucketRegion = "australia-southeast2"
	DestinationGCSUpdateGCSBucketRegionAsia                   DestinationGCSUpdateGCSBucketRegion = "asia"
	DestinationGCSUpdateGCSBucketRegionEu                     DestinationGCSUpdateGCSBucketRegion = "eu"
	DestinationGCSUpdateGCSBucketRegionUs                     DestinationGCSUpdateGCSBucketRegion = "us"
	DestinationGCSUpdateGCSBucketRegionAsia1                  DestinationGCSUpdateGCSBucketRegion = "asia1"
	DestinationGCSUpdateGCSBucketRegionEur4                   DestinationGCSUpdateGCSBucketRegion = "eur4"
	DestinationGCSUpdateGCSBucketRegionNam4                   DestinationGCSUpdateGCSBucketRegion = "nam4"
)

func (e DestinationGCSUpdateGCSBucketRegion) ToPointer() *DestinationGCSUpdateGCSBucketRegion {
	return &e
}
func (e *DestinationGCSUpdateGCSBucketRegion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "northamerica-northeast1":
		fallthrough
	case "northamerica-northeast2":
		fallthrough
	case "us-central1":
		fallthrough
	case "us-east1":
		fallthrough
	case "us-east4":
		fallthrough
	case "us-west1":
		fallthrough
	case "us-west2":
		fallthrough
	case "us-west3":
		fallthrough
	case "us-west4":
		fallthrough
	case "southamerica-east1":
		fallthrough
	case "southamerica-west1":
		fallthrough
	case "europe-central2":
		fallthrough
	case "europe-north1":
		fallthrough
	case "europe-west1":
		fallthrough
	case "europe-west2":
		fallthrough
	case "europe-west3":
		fallthrough
	case "europe-west4":
		fallthrough
	case "europe-west6":
		fallthrough
	case "asia-east1":
		fallthrough
	case "asia-east2":
		fallthrough
	case "asia-northeast1":
		fallthrough
	case "asia-northeast2":
		fallthrough
	case "asia-northeast3":
		fallthrough
	case "asia-south1":
		fallthrough
	case "asia-south2":
		fallthrough
	case "asia-southeast1":
		fallthrough
	case "asia-southeast2":
		fallthrough
	case "australia-southeast1":
		fallthrough
	case "australia-southeast2":
		fallthrough
	case "asia":
		fallthrough
	case "eu":
		fallthrough
	case "us":
		fallthrough
	case "asia1":
		fallthrough
	case "eur4":
		fallthrough
	case "nam4":
		*e = DestinationGCSUpdateGCSBucketRegion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGCSUpdateGCSBucketRegion: %v", v)
	}
}

type DestinationGcsUpdateDestinationType string

const (
	DestinationGcsUpdateDestinationTypeGcs DestinationGcsUpdateDestinationType = "gcs"
)

func (e DestinationGcsUpdateDestinationType) ToPointer() *DestinationGcsUpdateDestinationType {
	return &e
}
func (e *DestinationGcsUpdateDestinationType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "gcs":
		*e = DestinationGcsUpdateDestinationType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsUpdateDestinationType: %v", v)
	}
}

type DestinationGcsUpdate struct {
	// An HMAC key is a type of credential and can be associated with a service account or a user account in Cloud Storage. Read more <a href="https://cloud.google.com/storage/docs/authentication/hmackeys">here</a>.
	Credential *DestinationGcsUpdateAuthentication `json:"credential,omitempty"`
	// Output data format. One of the following formats must be selected - <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-avro#advantages_of_avro">AVRO</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-parquet#parquet_schemas">PARQUET</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-csv#loading_csv_data_into_a_table">CSV</a> format, or <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-json#loading_json_data_into_a_new_table">JSONL</a> format.
	Format *DestinationGcsUpdateOutputFormat `json:"format,omitempty"`
	// You can find the bucket name in the App Engine Admin console Application Settings page, under the label Google Cloud Storage Bucket. Read more <a href="https://cloud.google.com/storage/docs/naming-buckets">here</a>.
	GcsBucketName *string `json:"gcs_bucket_name,omitempty"`
	// GCS Bucket Path string Subdirectory under the above bucket to sync the data into.
	GcsBucketPath *string `json:"gcs_bucket_path,omitempty"`
	// Select a Region of the GCS Bucket. Read more <a href="https://cloud.google.com/storage/docs/locations">here</a>.
	GcsBucketRegion *DestinationGCSUpdateGCSBucketRegion `default:"us" json:"gcs_bucket_region"`
	destinationType *DestinationGcsUpdateDestinationType `const:"gcs" json:"destinationType"`
}

func (d DestinationGcsUpdate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsUpdate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationGcsUpdate) GetCredential() *DestinationGcsUpdateAuthentication {
	if d == nil {
		return nil
	}
	return d.Credential
}

func (d *DestinationGcsUpdate) GetFormat() *DestinationGcsUpdateOutputFormat {
	if d == nil {
		return nil
	}
	return d.Format
}

func (d *DestinationGcsUpdate) GetGcsBucketName() *string {
	if d == nil {
		return nil
	}
	return d.GcsBucketName
}

func (d *DestinationGcsUpdate) GetGcsBucketPath() *string {
	if d == nil {
		return nil
	}
	return d.GcsBucketPath
}

func (d *DestinationGcsUpdate) GetGcsBucketRegion() *DestinationGCSUpdateGCSBucketRegion {
	if d == nil {
		return nil
	}
	return d.GcsBucketRegion
}

func (d *DestinationGcsUpdate) GetDestinationType() *DestinationGcsUpdateDestinationType {
	return DestinationGcsUpdateDestinationTypeGcs.ToPointer()
}
