// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

type DestinationGcsUpdateCredentialType string

const (
	DestinationGcsUpdateCredentialTypeHmacKey DestinationGcsUpdateCredentialType = "HMAC_KEY"
)

func (e DestinationGcsUpdateCredentialType) ToPointer() *DestinationGcsUpdateCredentialType {
	return &e
}
func (e *DestinationGcsUpdateCredentialType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "HMAC_KEY":
		*e = DestinationGcsUpdateCredentialType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsUpdateCredentialType: %v", v)
	}
}

type DestinationGcsUpdateHMACKey struct {
	CredentialType *DestinationGcsUpdateCredentialType `default:"HMAC_KEY" json:"credential_type"`
	// When linked to a service account, this ID is 61 characters long; when linked to a user account, it is 24 characters long. Read more <a href="https://cloud.google.com/storage/docs/authentication/hmackeys#overview">here</a>.
	HmacKeyAccessID string `json:"hmac_key_access_id"`
	// The corresponding secret for the access ID. It is a 40-character base-64 encoded string.  Read more <a href="https://cloud.google.com/storage/docs/authentication/hmackeys#secrets">here</a>.
	HmacKeySecret string `json:"hmac_key_secret"`
}

func (d DestinationGcsUpdateHMACKey) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsUpdateHMACKey) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationGcsUpdateHMACKey) GetCredentialType() *DestinationGcsUpdateCredentialType {
	if o == nil {
		return nil
	}
	return o.CredentialType
}

func (o *DestinationGcsUpdateHMACKey) GetHmacKeyAccessID() string {
	if o == nil {
		return ""
	}
	return o.HmacKeyAccessID
}

func (o *DestinationGcsUpdateHMACKey) GetHmacKeySecret() string {
	if o == nil {
		return ""
	}
	return o.HmacKeySecret
}

type DestinationGcsUpdateAuthenticationType string

const (
	DestinationGcsUpdateAuthenticationTypeDestinationGcsUpdateHMACKey DestinationGcsUpdateAuthenticationType = "destination-gcs-update_HMAC Key"
)

// DestinationGcsUpdateAuthentication - An HMAC key is a type of credential and can be associated with a service account or a user account in Cloud Storage. Read more <a href="https://cloud.google.com/storage/docs/authentication/hmackeys">here</a>.
type DestinationGcsUpdateAuthentication struct {
	DestinationGcsUpdateHMACKey *DestinationGcsUpdateHMACKey `queryParam:"inline"`

	Type DestinationGcsUpdateAuthenticationType
}

func CreateDestinationGcsUpdateAuthenticationDestinationGcsUpdateHMACKey(destinationGcsUpdateHMACKey DestinationGcsUpdateHMACKey) DestinationGcsUpdateAuthentication {
	typ := DestinationGcsUpdateAuthenticationTypeDestinationGcsUpdateHMACKey

	return DestinationGcsUpdateAuthentication{
		DestinationGcsUpdateHMACKey: &destinationGcsUpdateHMACKey,
		Type:                        typ,
	}
}

func (u *DestinationGcsUpdateAuthentication) UnmarshalJSON(data []byte) error {

	var destinationGcsUpdateHMACKey DestinationGcsUpdateHMACKey = DestinationGcsUpdateHMACKey{}
	if err := utils.UnmarshalJSON(data, &destinationGcsUpdateHMACKey, "", true, true); err == nil {
		u.DestinationGcsUpdateHMACKey = &destinationGcsUpdateHMACKey
		u.Type = DestinationGcsUpdateAuthenticationTypeDestinationGcsUpdateHMACKey
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationGcsUpdateAuthentication", string(data))
}

func (u DestinationGcsUpdateAuthentication) MarshalJSON() ([]byte, error) {
	if u.DestinationGcsUpdateHMACKey != nil {
		return utils.MarshalJSON(u.DestinationGcsUpdateHMACKey, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationGcsUpdateAuthentication: all fields are null")
}

// DestinationGcsUpdateSchemasCompressionCodec - The compression algorithm used to compress data pages.
type DestinationGcsUpdateSchemasCompressionCodec string

const (
	DestinationGcsUpdateSchemasCompressionCodecUncompressed DestinationGcsUpdateSchemasCompressionCodec = "UNCOMPRESSED"
	DestinationGcsUpdateSchemasCompressionCodecSnappy       DestinationGcsUpdateSchemasCompressionCodec = "SNAPPY"
	DestinationGcsUpdateSchemasCompressionCodecGzip         DestinationGcsUpdateSchemasCompressionCodec = "GZIP"
	DestinationGcsUpdateSchemasCompressionCodecLzo          DestinationGcsUpdateSchemasCompressionCodec = "LZO"
	DestinationGcsUpdateSchemasCompressionCodecBrotli       DestinationGcsUpdateSchemasCompressionCodec = "BROTLI"
	DestinationGcsUpdateSchemasCompressionCodecLz4          DestinationGcsUpdateSchemasCompressionCodec = "LZ4"
	DestinationGcsUpdateSchemasCompressionCodecZstd         DestinationGcsUpdateSchemasCompressionCodec = "ZSTD"
)

func (e DestinationGcsUpdateSchemasCompressionCodec) ToPointer() *DestinationGcsUpdateSchemasCompressionCodec {
	return &e
}
func (e *DestinationGcsUpdateSchemasCompressionCodec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "UNCOMPRESSED":
		fallthrough
	case "SNAPPY":
		fallthrough
	case "GZIP":
		fallthrough
	case "LZO":
		fallthrough
	case "BROTLI":
		fallthrough
	case "LZ4":
		fallthrough
	case "ZSTD":
		*e = DestinationGcsUpdateSchemasCompressionCodec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsUpdateSchemasCompressionCodec: %v", v)
	}
}

type DestinationGcsUpdateSchemasFormatOutputFormatFormatType string

const (
	DestinationGcsUpdateSchemasFormatOutputFormatFormatTypeParquet DestinationGcsUpdateSchemasFormatOutputFormatFormatType = "Parquet"
)

func (e DestinationGcsUpdateSchemasFormatOutputFormatFormatType) ToPointer() *DestinationGcsUpdateSchemasFormatOutputFormatFormatType {
	return &e
}
func (e *DestinationGcsUpdateSchemasFormatOutputFormatFormatType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Parquet":
		*e = DestinationGcsUpdateSchemasFormatOutputFormatFormatType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsUpdateSchemasFormatOutputFormatFormatType: %v", v)
	}
}

type DestinationGcsUpdateParquetColumnarStorage struct {
	// This is the size of a row group being buffered in memory. It limits the memory usage when writing. Larger values will improve the IO when reading, but consume more memory when writing. Default: 128 MB.
	BlockSizeMb *int64 `default:"128" json:"block_size_mb"`
	// The compression algorithm used to compress data pages.
	CompressionCodec *DestinationGcsUpdateSchemasCompressionCodec `default:"UNCOMPRESSED" json:"compression_codec"`
	// Default: true.
	DictionaryEncoding *bool `default:"true" json:"dictionary_encoding"`
	// There is one dictionary page per column per row group when dictionary encoding is used. The dictionary page size works like the page size but for dictionary. Default: 1024 KB.
	DictionaryPageSizeKb *int64                                                   `default:"1024" json:"dictionary_page_size_kb"`
	FormatType           *DestinationGcsUpdateSchemasFormatOutputFormatFormatType `default:"Parquet" json:"format_type"`
	// Maximum size allowed as padding to align row groups. This is also the minimum size of a row group. Default: 8 MB.
	MaxPaddingSizeMb *int64 `default:"8" json:"max_padding_size_mb"`
	// The page size is for compression. A block is composed of pages. A page is the smallest unit that must be read fully to access a single record. If this value is too small, the compression will deteriorate. Default: 1024 KB.
	PageSizeKb *int64 `default:"1024" json:"page_size_kb"`
}

func (d DestinationGcsUpdateParquetColumnarStorage) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsUpdateParquetColumnarStorage) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationGcsUpdateParquetColumnarStorage) GetBlockSizeMb() *int64 {
	if o == nil {
		return nil
	}
	return o.BlockSizeMb
}

func (o *DestinationGcsUpdateParquetColumnarStorage) GetCompressionCodec() *DestinationGcsUpdateSchemasCompressionCodec {
	if o == nil {
		return nil
	}
	return o.CompressionCodec
}

func (o *DestinationGcsUpdateParquetColumnarStorage) GetDictionaryEncoding() *bool {
	if o == nil {
		return nil
	}
	return o.DictionaryEncoding
}

func (o *DestinationGcsUpdateParquetColumnarStorage) GetDictionaryPageSizeKb() *int64 {
	if o == nil {
		return nil
	}
	return o.DictionaryPageSizeKb
}

func (o *DestinationGcsUpdateParquetColumnarStorage) GetFormatType() *DestinationGcsUpdateSchemasFormatOutputFormatFormatType {
	if o == nil {
		return nil
	}
	return o.FormatType
}

func (o *DestinationGcsUpdateParquetColumnarStorage) GetMaxPaddingSizeMb() *int64 {
	if o == nil {
		return nil
	}
	return o.MaxPaddingSizeMb
}

func (o *DestinationGcsUpdateParquetColumnarStorage) GetPageSizeKb() *int64 {
	if o == nil {
		return nil
	}
	return o.PageSizeKb
}

type DestinationGcsUpdateSchemasFormatOutputFormatCompressionType string

const (
	DestinationGcsUpdateSchemasFormatOutputFormatCompressionTypeGzip DestinationGcsUpdateSchemasFormatOutputFormatCompressionType = "GZIP"
)

func (e DestinationGcsUpdateSchemasFormatOutputFormatCompressionType) ToPointer() *DestinationGcsUpdateSchemasFormatOutputFormatCompressionType {
	return &e
}
func (e *DestinationGcsUpdateSchemasFormatOutputFormatCompressionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "GZIP":
		*e = DestinationGcsUpdateSchemasFormatOutputFormatCompressionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsUpdateSchemasFormatOutputFormatCompressionType: %v", v)
	}
}

type DestinationGcsUpdateSchemasGZIP struct {
	CompressionType *DestinationGcsUpdateSchemasFormatOutputFormatCompressionType `default:"GZIP" json:"compression_type"`
}

func (d DestinationGcsUpdateSchemasGZIP) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsUpdateSchemasGZIP) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationGcsUpdateSchemasGZIP) GetCompressionType() *DestinationGcsUpdateSchemasFormatOutputFormatCompressionType {
	if o == nil {
		return nil
	}
	return o.CompressionType
}

type DestinationGcsUpdateSchemasFormatCompressionType string

const (
	DestinationGcsUpdateSchemasFormatCompressionTypeNoCompression DestinationGcsUpdateSchemasFormatCompressionType = "No Compression"
)

func (e DestinationGcsUpdateSchemasFormatCompressionType) ToPointer() *DestinationGcsUpdateSchemasFormatCompressionType {
	return &e
}
func (e *DestinationGcsUpdateSchemasFormatCompressionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "No Compression":
		*e = DestinationGcsUpdateSchemasFormatCompressionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsUpdateSchemasFormatCompressionType: %v", v)
	}
}

type DestinationGcsUpdateSchemasFormatNoCompression struct {
	CompressionType *DestinationGcsUpdateSchemasFormatCompressionType `default:"No Compression" json:"compression_type"`
}

func (d DestinationGcsUpdateSchemasFormatNoCompression) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsUpdateSchemasFormatNoCompression) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationGcsUpdateSchemasFormatNoCompression) GetCompressionType() *DestinationGcsUpdateSchemasFormatCompressionType {
	if o == nil {
		return nil
	}
	return o.CompressionType
}

type DestinationGcsUpdateSchemasCompressionUnionType string

const (
	DestinationGcsUpdateSchemasCompressionUnionTypeDestinationGcsUpdateSchemasFormatNoCompression DestinationGcsUpdateSchemasCompressionUnionType = "destination-gcs-update_Schemas_format_No Compression"
	DestinationGcsUpdateSchemasCompressionUnionTypeDestinationGcsUpdateSchemasGZIP                DestinationGcsUpdateSchemasCompressionUnionType = "destination-gcs-update_Schemas_GZIP"
)

// DestinationGcsUpdateSchemasCompression - Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").
type DestinationGcsUpdateSchemasCompression struct {
	DestinationGcsUpdateSchemasFormatNoCompression *DestinationGcsUpdateSchemasFormatNoCompression `queryParam:"inline"`
	DestinationGcsUpdateSchemasGZIP                *DestinationGcsUpdateSchemasGZIP                `queryParam:"inline"`

	Type DestinationGcsUpdateSchemasCompressionUnionType
}

func CreateDestinationGcsUpdateSchemasCompressionDestinationGcsUpdateSchemasFormatNoCompression(destinationGcsUpdateSchemasFormatNoCompression DestinationGcsUpdateSchemasFormatNoCompression) DestinationGcsUpdateSchemasCompression {
	typ := DestinationGcsUpdateSchemasCompressionUnionTypeDestinationGcsUpdateSchemasFormatNoCompression

	return DestinationGcsUpdateSchemasCompression{
		DestinationGcsUpdateSchemasFormatNoCompression: &destinationGcsUpdateSchemasFormatNoCompression,
		Type: typ,
	}
}

func CreateDestinationGcsUpdateSchemasCompressionDestinationGcsUpdateSchemasGZIP(destinationGcsUpdateSchemasGZIP DestinationGcsUpdateSchemasGZIP) DestinationGcsUpdateSchemasCompression {
	typ := DestinationGcsUpdateSchemasCompressionUnionTypeDestinationGcsUpdateSchemasGZIP

	return DestinationGcsUpdateSchemasCompression{
		DestinationGcsUpdateSchemasGZIP: &destinationGcsUpdateSchemasGZIP,
		Type:                            typ,
	}
}

func (u *DestinationGcsUpdateSchemasCompression) UnmarshalJSON(data []byte) error {

	var destinationGcsUpdateSchemasFormatNoCompression DestinationGcsUpdateSchemasFormatNoCompression = DestinationGcsUpdateSchemasFormatNoCompression{}
	if err := utils.UnmarshalJSON(data, &destinationGcsUpdateSchemasFormatNoCompression, "", true, true); err == nil {
		u.DestinationGcsUpdateSchemasFormatNoCompression = &destinationGcsUpdateSchemasFormatNoCompression
		u.Type = DestinationGcsUpdateSchemasCompressionUnionTypeDestinationGcsUpdateSchemasFormatNoCompression
		return nil
	}

	var destinationGcsUpdateSchemasGZIP DestinationGcsUpdateSchemasGZIP = DestinationGcsUpdateSchemasGZIP{}
	if err := utils.UnmarshalJSON(data, &destinationGcsUpdateSchemasGZIP, "", true, true); err == nil {
		u.DestinationGcsUpdateSchemasGZIP = &destinationGcsUpdateSchemasGZIP
		u.Type = DestinationGcsUpdateSchemasCompressionUnionTypeDestinationGcsUpdateSchemasGZIP
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationGcsUpdateSchemasCompression", string(data))
}

func (u DestinationGcsUpdateSchemasCompression) MarshalJSON() ([]byte, error) {
	if u.DestinationGcsUpdateSchemasFormatNoCompression != nil {
		return utils.MarshalJSON(u.DestinationGcsUpdateSchemasFormatNoCompression, "", true)
	}

	if u.DestinationGcsUpdateSchemasGZIP != nil {
		return utils.MarshalJSON(u.DestinationGcsUpdateSchemasGZIP, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationGcsUpdateSchemasCompression: all fields are null")
}

type DestinationGcsUpdateSchemasFormatFormatType string

const (
	DestinationGcsUpdateSchemasFormatFormatTypeJsonl DestinationGcsUpdateSchemasFormatFormatType = "JSONL"
)

func (e DestinationGcsUpdateSchemasFormatFormatType) ToPointer() *DestinationGcsUpdateSchemasFormatFormatType {
	return &e
}
func (e *DestinationGcsUpdateSchemasFormatFormatType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "JSONL":
		*e = DestinationGcsUpdateSchemasFormatFormatType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsUpdateSchemasFormatFormatType: %v", v)
	}
}

type DestinationGcsUpdateJSONLinesNewlineDelimitedJSON struct {
	// Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").
	Compression *DestinationGcsUpdateSchemasCompression      `json:"compression,omitempty"`
	FormatType  *DestinationGcsUpdateSchemasFormatFormatType `default:"JSONL" json:"format_type"`
}

func (d DestinationGcsUpdateJSONLinesNewlineDelimitedJSON) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsUpdateJSONLinesNewlineDelimitedJSON) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationGcsUpdateJSONLinesNewlineDelimitedJSON) GetCompression() *DestinationGcsUpdateSchemasCompression {
	if o == nil {
		return nil
	}
	return o.Compression
}

func (o *DestinationGcsUpdateJSONLinesNewlineDelimitedJSON) GetFormatType() *DestinationGcsUpdateSchemasFormatFormatType {
	if o == nil {
		return nil
	}
	return o.FormatType
}

type DestinationGcsUpdateSchemasCompressionType string

const (
	DestinationGcsUpdateSchemasCompressionTypeGzip DestinationGcsUpdateSchemasCompressionType = "GZIP"
)

func (e DestinationGcsUpdateSchemasCompressionType) ToPointer() *DestinationGcsUpdateSchemasCompressionType {
	return &e
}
func (e *DestinationGcsUpdateSchemasCompressionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "GZIP":
		*e = DestinationGcsUpdateSchemasCompressionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsUpdateSchemasCompressionType: %v", v)
	}
}

type DestinationGcsUpdateGZIP struct {
	CompressionType *DestinationGcsUpdateSchemasCompressionType `default:"GZIP" json:"compression_type"`
}

func (d DestinationGcsUpdateGZIP) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsUpdateGZIP) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationGcsUpdateGZIP) GetCompressionType() *DestinationGcsUpdateSchemasCompressionType {
	if o == nil {
		return nil
	}
	return o.CompressionType
}

type DestinationGcsUpdateCompressionType string

const (
	DestinationGcsUpdateCompressionTypeNoCompression DestinationGcsUpdateCompressionType = "No Compression"
)

func (e DestinationGcsUpdateCompressionType) ToPointer() *DestinationGcsUpdateCompressionType {
	return &e
}
func (e *DestinationGcsUpdateCompressionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "No Compression":
		*e = DestinationGcsUpdateCompressionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsUpdateCompressionType: %v", v)
	}
}

type DestinationGcsUpdateSchemasNoCompression struct {
	CompressionType *DestinationGcsUpdateCompressionType `default:"No Compression" json:"compression_type"`
}

func (d DestinationGcsUpdateSchemasNoCompression) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsUpdateSchemasNoCompression) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationGcsUpdateSchemasNoCompression) GetCompressionType() *DestinationGcsUpdateCompressionType {
	if o == nil {
		return nil
	}
	return o.CompressionType
}

type DestinationGcsUpdateCompressionUnionType string

const (
	DestinationGcsUpdateCompressionUnionTypeDestinationGcsUpdateSchemasNoCompression DestinationGcsUpdateCompressionUnionType = "destination-gcs-update_Schemas_No Compression"
	DestinationGcsUpdateCompressionUnionTypeDestinationGcsUpdateGZIP                 DestinationGcsUpdateCompressionUnionType = "destination-gcs-update_GZIP"
)

// DestinationGcsUpdateCompression - Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".csv.gz").
type DestinationGcsUpdateCompression struct {
	DestinationGcsUpdateSchemasNoCompression *DestinationGcsUpdateSchemasNoCompression `queryParam:"inline"`
	DestinationGcsUpdateGZIP                 *DestinationGcsUpdateGZIP                 `queryParam:"inline"`

	Type DestinationGcsUpdateCompressionUnionType
}

func CreateDestinationGcsUpdateCompressionDestinationGcsUpdateSchemasNoCompression(destinationGcsUpdateSchemasNoCompression DestinationGcsUpdateSchemasNoCompression) DestinationGcsUpdateCompression {
	typ := DestinationGcsUpdateCompressionUnionTypeDestinationGcsUpdateSchemasNoCompression

	return DestinationGcsUpdateCompression{
		DestinationGcsUpdateSchemasNoCompression: &destinationGcsUpdateSchemasNoCompression,
		Type:                                     typ,
	}
}

func CreateDestinationGcsUpdateCompressionDestinationGcsUpdateGZIP(destinationGcsUpdateGZIP DestinationGcsUpdateGZIP) DestinationGcsUpdateCompression {
	typ := DestinationGcsUpdateCompressionUnionTypeDestinationGcsUpdateGZIP

	return DestinationGcsUpdateCompression{
		DestinationGcsUpdateGZIP: &destinationGcsUpdateGZIP,
		Type:                     typ,
	}
}

func (u *DestinationGcsUpdateCompression) UnmarshalJSON(data []byte) error {

	var destinationGcsUpdateSchemasNoCompression DestinationGcsUpdateSchemasNoCompression = DestinationGcsUpdateSchemasNoCompression{}
	if err := utils.UnmarshalJSON(data, &destinationGcsUpdateSchemasNoCompression, "", true, true); err == nil {
		u.DestinationGcsUpdateSchemasNoCompression = &destinationGcsUpdateSchemasNoCompression
		u.Type = DestinationGcsUpdateCompressionUnionTypeDestinationGcsUpdateSchemasNoCompression
		return nil
	}

	var destinationGcsUpdateGZIP DestinationGcsUpdateGZIP = DestinationGcsUpdateGZIP{}
	if err := utils.UnmarshalJSON(data, &destinationGcsUpdateGZIP, "", true, true); err == nil {
		u.DestinationGcsUpdateGZIP = &destinationGcsUpdateGZIP
		u.Type = DestinationGcsUpdateCompressionUnionTypeDestinationGcsUpdateGZIP
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationGcsUpdateCompression", string(data))
}

func (u DestinationGcsUpdateCompression) MarshalJSON() ([]byte, error) {
	if u.DestinationGcsUpdateSchemasNoCompression != nil {
		return utils.MarshalJSON(u.DestinationGcsUpdateSchemasNoCompression, "", true)
	}

	if u.DestinationGcsUpdateGZIP != nil {
		return utils.MarshalJSON(u.DestinationGcsUpdateGZIP, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationGcsUpdateCompression: all fields are null")
}

// DestinationGcsUpdateNormalization - Whether the input JSON data should be normalized (flattened) in the output CSV. Please refer to docs for details.
type DestinationGcsUpdateNormalization string

const (
	DestinationGcsUpdateNormalizationNoFlattening        DestinationGcsUpdateNormalization = "No flattening"
	DestinationGcsUpdateNormalizationRootLevelFlattening DestinationGcsUpdateNormalization = "Root level flattening"
)

func (e DestinationGcsUpdateNormalization) ToPointer() *DestinationGcsUpdateNormalization {
	return &e
}
func (e *DestinationGcsUpdateNormalization) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "No flattening":
		fallthrough
	case "Root level flattening":
		*e = DestinationGcsUpdateNormalization(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsUpdateNormalization: %v", v)
	}
}

type DestinationGcsUpdateSchemasFormatType string

const (
	DestinationGcsUpdateSchemasFormatTypeCsv DestinationGcsUpdateSchemasFormatType = "CSV"
)

func (e DestinationGcsUpdateSchemasFormatType) ToPointer() *DestinationGcsUpdateSchemasFormatType {
	return &e
}
func (e *DestinationGcsUpdateSchemasFormatType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CSV":
		*e = DestinationGcsUpdateSchemasFormatType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsUpdateSchemasFormatType: %v", v)
	}
}

type DestinationGcsUpdateCSVCommaSeparatedValues struct {
	// Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".csv.gz").
	Compression *DestinationGcsUpdateCompression `json:"compression,omitempty"`
	// Whether the input JSON data should be normalized (flattened) in the output CSV. Please refer to docs for details.
	Flattening *DestinationGcsUpdateNormalization     `default:"No flattening" json:"flattening"`
	FormatType *DestinationGcsUpdateSchemasFormatType `default:"CSV" json:"format_type"`
}

func (d DestinationGcsUpdateCSVCommaSeparatedValues) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsUpdateCSVCommaSeparatedValues) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationGcsUpdateCSVCommaSeparatedValues) GetCompression() *DestinationGcsUpdateCompression {
	if o == nil {
		return nil
	}
	return o.Compression
}

func (o *DestinationGcsUpdateCSVCommaSeparatedValues) GetFlattening() *DestinationGcsUpdateNormalization {
	if o == nil {
		return nil
	}
	return o.Flattening
}

func (o *DestinationGcsUpdateCSVCommaSeparatedValues) GetFormatType() *DestinationGcsUpdateSchemasFormatType {
	if o == nil {
		return nil
	}
	return o.FormatType
}

type DestinationGcsUpdateSchemasFormatOutputFormat1CompressionCodecCodec string

const (
	DestinationGcsUpdateSchemasFormatOutputFormat1CompressionCodecCodecSnappy DestinationGcsUpdateSchemasFormatOutputFormat1CompressionCodecCodec = "snappy"
)

func (e DestinationGcsUpdateSchemasFormatOutputFormat1CompressionCodecCodec) ToPointer() *DestinationGcsUpdateSchemasFormatOutputFormat1CompressionCodecCodec {
	return &e
}
func (e *DestinationGcsUpdateSchemasFormatOutputFormat1CompressionCodecCodec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "snappy":
		*e = DestinationGcsUpdateSchemasFormatOutputFormat1CompressionCodecCodec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsUpdateSchemasFormatOutputFormat1CompressionCodecCodec: %v", v)
	}
}

type DestinationGcsUpdateSnappy struct {
	Codec *DestinationGcsUpdateSchemasFormatOutputFormat1CompressionCodecCodec `default:"snappy" json:"codec"`
}

func (d DestinationGcsUpdateSnappy) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsUpdateSnappy) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationGcsUpdateSnappy) GetCodec() *DestinationGcsUpdateSchemasFormatOutputFormat1CompressionCodecCodec {
	if o == nil {
		return nil
	}
	return o.Codec
}

type DestinationGcsUpdateSchemasFormatOutputFormat1Codec string

const (
	DestinationGcsUpdateSchemasFormatOutputFormat1CodecZstandard DestinationGcsUpdateSchemasFormatOutputFormat1Codec = "zstandard"
)

func (e DestinationGcsUpdateSchemasFormatOutputFormat1Codec) ToPointer() *DestinationGcsUpdateSchemasFormatOutputFormat1Codec {
	return &e
}
func (e *DestinationGcsUpdateSchemasFormatOutputFormat1Codec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "zstandard":
		*e = DestinationGcsUpdateSchemasFormatOutputFormat1Codec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsUpdateSchemasFormatOutputFormat1Codec: %v", v)
	}
}

type DestinationGcsUpdateZstandard struct {
	Codec *DestinationGcsUpdateSchemasFormatOutputFormat1Codec `default:"zstandard" json:"codec"`
	// Negative levels are 'fast' modes akin to lz4 or snappy, levels above 9 are generally for archival purposes, and levels above 18 use a lot of memory.
	CompressionLevel *int64 `default:"3" json:"compression_level"`
	// If true, include a checksum with each data block.
	IncludeChecksum *bool `default:"false" json:"include_checksum"`
}

func (d DestinationGcsUpdateZstandard) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsUpdateZstandard) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationGcsUpdateZstandard) GetCodec() *DestinationGcsUpdateSchemasFormatOutputFormat1Codec {
	if o == nil {
		return nil
	}
	return o.Codec
}

func (o *DestinationGcsUpdateZstandard) GetCompressionLevel() *int64 {
	if o == nil {
		return nil
	}
	return o.CompressionLevel
}

func (o *DestinationGcsUpdateZstandard) GetIncludeChecksum() *bool {
	if o == nil {
		return nil
	}
	return o.IncludeChecksum
}

type DestinationGcsUpdateSchemasFormatOutputFormatCodec string

const (
	DestinationGcsUpdateSchemasFormatOutputFormatCodecXz DestinationGcsUpdateSchemasFormatOutputFormatCodec = "xz"
)

func (e DestinationGcsUpdateSchemasFormatOutputFormatCodec) ToPointer() *DestinationGcsUpdateSchemasFormatOutputFormatCodec {
	return &e
}
func (e *DestinationGcsUpdateSchemasFormatOutputFormatCodec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "xz":
		*e = DestinationGcsUpdateSchemasFormatOutputFormatCodec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsUpdateSchemasFormatOutputFormatCodec: %v", v)
	}
}

type DestinationGcsUpdateXz struct {
	Codec *DestinationGcsUpdateSchemasFormatOutputFormatCodec `default:"xz" json:"codec"`
	// The presets 0-3 are fast presets with medium compression. The presets 4-6 are fairly slow presets with high compression. The default preset is 6. The presets 7-9 are like the preset 6 but use bigger dictionaries and have higher compressor and decompressor memory requirements. Unless the uncompressed size of the file exceeds 8 MiB, 16 MiB, or 32 MiB, it is waste of memory to use the presets 7, 8, or 9, respectively. Read more <a href="https://commons.apache.org/proper/commons-compress/apidocs/org/apache/commons/compress/compressors/xz/XZCompressorOutputStream.html#XZCompressorOutputStream-java.io.OutputStream-int-">here</a> for details.
	CompressionLevel *int64 `default:"6" json:"compression_level"`
}

func (d DestinationGcsUpdateXz) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsUpdateXz) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationGcsUpdateXz) GetCodec() *DestinationGcsUpdateSchemasFormatOutputFormatCodec {
	if o == nil {
		return nil
	}
	return o.Codec
}

func (o *DestinationGcsUpdateXz) GetCompressionLevel() *int64 {
	if o == nil {
		return nil
	}
	return o.CompressionLevel
}

type DestinationGcsUpdateSchemasFormatCodec string

const (
	DestinationGcsUpdateSchemasFormatCodecBzip2 DestinationGcsUpdateSchemasFormatCodec = "bzip2"
)

func (e DestinationGcsUpdateSchemasFormatCodec) ToPointer() *DestinationGcsUpdateSchemasFormatCodec {
	return &e
}
func (e *DestinationGcsUpdateSchemasFormatCodec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "bzip2":
		*e = DestinationGcsUpdateSchemasFormatCodec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsUpdateSchemasFormatCodec: %v", v)
	}
}

type DestinationGcsUpdateBzip2 struct {
	Codec *DestinationGcsUpdateSchemasFormatCodec `default:"bzip2" json:"codec"`
}

func (d DestinationGcsUpdateBzip2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsUpdateBzip2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationGcsUpdateBzip2) GetCodec() *DestinationGcsUpdateSchemasFormatCodec {
	if o == nil {
		return nil
	}
	return o.Codec
}

type DestinationGcsUpdateSchemasCodec string

const (
	DestinationGcsUpdateSchemasCodecDeflate DestinationGcsUpdateSchemasCodec = "Deflate"
)

func (e DestinationGcsUpdateSchemasCodec) ToPointer() *DestinationGcsUpdateSchemasCodec {
	return &e
}
func (e *DestinationGcsUpdateSchemasCodec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Deflate":
		*e = DestinationGcsUpdateSchemasCodec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsUpdateSchemasCodec: %v", v)
	}
}

type DestinationGcsUpdateDeflate struct {
	Codec *DestinationGcsUpdateSchemasCodec `default:"Deflate" json:"codec"`
	// 0: no compression & fastest, 9: best compression & slowest.
	CompressionLevel *int64 `default:"0" json:"compression_level"`
}

func (d DestinationGcsUpdateDeflate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsUpdateDeflate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationGcsUpdateDeflate) GetCodec() *DestinationGcsUpdateSchemasCodec {
	if o == nil {
		return nil
	}
	return o.Codec
}

func (o *DestinationGcsUpdateDeflate) GetCompressionLevel() *int64 {
	if o == nil {
		return nil
	}
	return o.CompressionLevel
}

type DestinationGcsUpdateCodec string

const (
	DestinationGcsUpdateCodecNoCompression DestinationGcsUpdateCodec = "no compression"
)

func (e DestinationGcsUpdateCodec) ToPointer() *DestinationGcsUpdateCodec {
	return &e
}
func (e *DestinationGcsUpdateCodec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "no compression":
		*e = DestinationGcsUpdateCodec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsUpdateCodec: %v", v)
	}
}

type DestinationGcsUpdateNoCompression struct {
	Codec *DestinationGcsUpdateCodec `default:"no compression" json:"codec"`
}

func (d DestinationGcsUpdateNoCompression) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsUpdateNoCompression) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationGcsUpdateNoCompression) GetCodec() *DestinationGcsUpdateCodec {
	if o == nil {
		return nil
	}
	return o.Codec
}

type DestinationGcsUpdateCompressionCodecType string

const (
	DestinationGcsUpdateCompressionCodecTypeDestinationGcsUpdateNoCompression DestinationGcsUpdateCompressionCodecType = "destination-gcs-update_No Compression"
	DestinationGcsUpdateCompressionCodecTypeDestinationGcsUpdateDeflate       DestinationGcsUpdateCompressionCodecType = "destination-gcs-update_Deflate"
	DestinationGcsUpdateCompressionCodecTypeDestinationGcsUpdateBzip2         DestinationGcsUpdateCompressionCodecType = "destination-gcs-update_bzip2"
	DestinationGcsUpdateCompressionCodecTypeDestinationGcsUpdateXz            DestinationGcsUpdateCompressionCodecType = "destination-gcs-update_xz"
	DestinationGcsUpdateCompressionCodecTypeDestinationGcsUpdateZstandard     DestinationGcsUpdateCompressionCodecType = "destination-gcs-update_zstandard"
	DestinationGcsUpdateCompressionCodecTypeDestinationGcsUpdateSnappy        DestinationGcsUpdateCompressionCodecType = "destination-gcs-update_snappy"
)

// DestinationGcsUpdateCompressionCodec - The compression algorithm used to compress data. Default to no compression.
type DestinationGcsUpdateCompressionCodec struct {
	DestinationGcsUpdateNoCompression *DestinationGcsUpdateNoCompression `queryParam:"inline"`
	DestinationGcsUpdateDeflate       *DestinationGcsUpdateDeflate       `queryParam:"inline"`
	DestinationGcsUpdateBzip2         *DestinationGcsUpdateBzip2         `queryParam:"inline"`
	DestinationGcsUpdateXz            *DestinationGcsUpdateXz            `queryParam:"inline"`
	DestinationGcsUpdateZstandard     *DestinationGcsUpdateZstandard     `queryParam:"inline"`
	DestinationGcsUpdateSnappy        *DestinationGcsUpdateSnappy        `queryParam:"inline"`

	Type DestinationGcsUpdateCompressionCodecType
}

func CreateDestinationGcsUpdateCompressionCodecDestinationGcsUpdateNoCompression(destinationGcsUpdateNoCompression DestinationGcsUpdateNoCompression) DestinationGcsUpdateCompressionCodec {
	typ := DestinationGcsUpdateCompressionCodecTypeDestinationGcsUpdateNoCompression

	return DestinationGcsUpdateCompressionCodec{
		DestinationGcsUpdateNoCompression: &destinationGcsUpdateNoCompression,
		Type:                              typ,
	}
}

func CreateDestinationGcsUpdateCompressionCodecDestinationGcsUpdateDeflate(destinationGcsUpdateDeflate DestinationGcsUpdateDeflate) DestinationGcsUpdateCompressionCodec {
	typ := DestinationGcsUpdateCompressionCodecTypeDestinationGcsUpdateDeflate

	return DestinationGcsUpdateCompressionCodec{
		DestinationGcsUpdateDeflate: &destinationGcsUpdateDeflate,
		Type:                        typ,
	}
}

func CreateDestinationGcsUpdateCompressionCodecDestinationGcsUpdateBzip2(destinationGcsUpdateBzip2 DestinationGcsUpdateBzip2) DestinationGcsUpdateCompressionCodec {
	typ := DestinationGcsUpdateCompressionCodecTypeDestinationGcsUpdateBzip2

	return DestinationGcsUpdateCompressionCodec{
		DestinationGcsUpdateBzip2: &destinationGcsUpdateBzip2,
		Type:                      typ,
	}
}

func CreateDestinationGcsUpdateCompressionCodecDestinationGcsUpdateXz(destinationGcsUpdateXz DestinationGcsUpdateXz) DestinationGcsUpdateCompressionCodec {
	typ := DestinationGcsUpdateCompressionCodecTypeDestinationGcsUpdateXz

	return DestinationGcsUpdateCompressionCodec{
		DestinationGcsUpdateXz: &destinationGcsUpdateXz,
		Type:                   typ,
	}
}

func CreateDestinationGcsUpdateCompressionCodecDestinationGcsUpdateZstandard(destinationGcsUpdateZstandard DestinationGcsUpdateZstandard) DestinationGcsUpdateCompressionCodec {
	typ := DestinationGcsUpdateCompressionCodecTypeDestinationGcsUpdateZstandard

	return DestinationGcsUpdateCompressionCodec{
		DestinationGcsUpdateZstandard: &destinationGcsUpdateZstandard,
		Type:                          typ,
	}
}

func CreateDestinationGcsUpdateCompressionCodecDestinationGcsUpdateSnappy(destinationGcsUpdateSnappy DestinationGcsUpdateSnappy) DestinationGcsUpdateCompressionCodec {
	typ := DestinationGcsUpdateCompressionCodecTypeDestinationGcsUpdateSnappy

	return DestinationGcsUpdateCompressionCodec{
		DestinationGcsUpdateSnappy: &destinationGcsUpdateSnappy,
		Type:                       typ,
	}
}

func (u *DestinationGcsUpdateCompressionCodec) UnmarshalJSON(data []byte) error {

	var destinationGcsUpdateNoCompression DestinationGcsUpdateNoCompression = DestinationGcsUpdateNoCompression{}
	if err := utils.UnmarshalJSON(data, &destinationGcsUpdateNoCompression, "", true, true); err == nil {
		u.DestinationGcsUpdateNoCompression = &destinationGcsUpdateNoCompression
		u.Type = DestinationGcsUpdateCompressionCodecTypeDestinationGcsUpdateNoCompression
		return nil
	}

	var destinationGcsUpdateBzip2 DestinationGcsUpdateBzip2 = DestinationGcsUpdateBzip2{}
	if err := utils.UnmarshalJSON(data, &destinationGcsUpdateBzip2, "", true, true); err == nil {
		u.DestinationGcsUpdateBzip2 = &destinationGcsUpdateBzip2
		u.Type = DestinationGcsUpdateCompressionCodecTypeDestinationGcsUpdateBzip2
		return nil
	}

	var destinationGcsUpdateSnappy DestinationGcsUpdateSnappy = DestinationGcsUpdateSnappy{}
	if err := utils.UnmarshalJSON(data, &destinationGcsUpdateSnappy, "", true, true); err == nil {
		u.DestinationGcsUpdateSnappy = &destinationGcsUpdateSnappy
		u.Type = DestinationGcsUpdateCompressionCodecTypeDestinationGcsUpdateSnappy
		return nil
	}

	var destinationGcsUpdateDeflate DestinationGcsUpdateDeflate = DestinationGcsUpdateDeflate{}
	if err := utils.UnmarshalJSON(data, &destinationGcsUpdateDeflate, "", true, true); err == nil {
		u.DestinationGcsUpdateDeflate = &destinationGcsUpdateDeflate
		u.Type = DestinationGcsUpdateCompressionCodecTypeDestinationGcsUpdateDeflate
		return nil
	}

	var destinationGcsUpdateXz DestinationGcsUpdateXz = DestinationGcsUpdateXz{}
	if err := utils.UnmarshalJSON(data, &destinationGcsUpdateXz, "", true, true); err == nil {
		u.DestinationGcsUpdateXz = &destinationGcsUpdateXz
		u.Type = DestinationGcsUpdateCompressionCodecTypeDestinationGcsUpdateXz
		return nil
	}

	var destinationGcsUpdateZstandard DestinationGcsUpdateZstandard = DestinationGcsUpdateZstandard{}
	if err := utils.UnmarshalJSON(data, &destinationGcsUpdateZstandard, "", true, true); err == nil {
		u.DestinationGcsUpdateZstandard = &destinationGcsUpdateZstandard
		u.Type = DestinationGcsUpdateCompressionCodecTypeDestinationGcsUpdateZstandard
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationGcsUpdateCompressionCodec", string(data))
}

func (u DestinationGcsUpdateCompressionCodec) MarshalJSON() ([]byte, error) {
	if u.DestinationGcsUpdateNoCompression != nil {
		return utils.MarshalJSON(u.DestinationGcsUpdateNoCompression, "", true)
	}

	if u.DestinationGcsUpdateDeflate != nil {
		return utils.MarshalJSON(u.DestinationGcsUpdateDeflate, "", true)
	}

	if u.DestinationGcsUpdateBzip2 != nil {
		return utils.MarshalJSON(u.DestinationGcsUpdateBzip2, "", true)
	}

	if u.DestinationGcsUpdateXz != nil {
		return utils.MarshalJSON(u.DestinationGcsUpdateXz, "", true)
	}

	if u.DestinationGcsUpdateZstandard != nil {
		return utils.MarshalJSON(u.DestinationGcsUpdateZstandard, "", true)
	}

	if u.DestinationGcsUpdateSnappy != nil {
		return utils.MarshalJSON(u.DestinationGcsUpdateSnappy, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationGcsUpdateCompressionCodec: all fields are null")
}

type DestinationGcsUpdateFormatType string

const (
	DestinationGcsUpdateFormatTypeAvro DestinationGcsUpdateFormatType = "Avro"
)

func (e DestinationGcsUpdateFormatType) ToPointer() *DestinationGcsUpdateFormatType {
	return &e
}
func (e *DestinationGcsUpdateFormatType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Avro":
		*e = DestinationGcsUpdateFormatType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsUpdateFormatType: %v", v)
	}
}

type DestinationGcsUpdateAvroApacheAvro struct {
	// The compression algorithm used to compress data. Default to no compression.
	CompressionCodec DestinationGcsUpdateCompressionCodec `json:"compression_codec"`
	FormatType       *DestinationGcsUpdateFormatType      `default:"Avro" json:"format_type"`
}

func (d DestinationGcsUpdateAvroApacheAvro) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsUpdateAvroApacheAvro) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationGcsUpdateAvroApacheAvro) GetCompressionCodec() DestinationGcsUpdateCompressionCodec {
	if o == nil {
		return DestinationGcsUpdateCompressionCodec{}
	}
	return o.CompressionCodec
}

func (o *DestinationGcsUpdateAvroApacheAvro) GetFormatType() *DestinationGcsUpdateFormatType {
	if o == nil {
		return nil
	}
	return o.FormatType
}

type DestinationGcsUpdateOutputFormatType string

const (
	DestinationGcsUpdateOutputFormatTypeDestinationGcsUpdateAvroApacheAvro                DestinationGcsUpdateOutputFormatType = "destination-gcs-update_Avro: Apache Avro"
	DestinationGcsUpdateOutputFormatTypeDestinationGcsUpdateCSVCommaSeparatedValues       DestinationGcsUpdateOutputFormatType = "destination-gcs-update_CSV: Comma-Separated Values"
	DestinationGcsUpdateOutputFormatTypeDestinationGcsUpdateJSONLinesNewlineDelimitedJSON DestinationGcsUpdateOutputFormatType = "destination-gcs-update_JSON Lines: newline-delimited JSON"
	DestinationGcsUpdateOutputFormatTypeDestinationGcsUpdateParquetColumnarStorage        DestinationGcsUpdateOutputFormatType = "destination-gcs-update_Parquet: Columnar Storage"
)

// DestinationGcsUpdateOutputFormat - Output data format. One of the following formats must be selected - <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-avro#advantages_of_avro">AVRO</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-parquet#parquet_schemas">PARQUET</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-csv#loading_csv_data_into_a_table">CSV</a> format, or <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-json#loading_json_data_into_a_new_table">JSONL</a> format.
type DestinationGcsUpdateOutputFormat struct {
	DestinationGcsUpdateAvroApacheAvro                *DestinationGcsUpdateAvroApacheAvro                `queryParam:"inline"`
	DestinationGcsUpdateCSVCommaSeparatedValues       *DestinationGcsUpdateCSVCommaSeparatedValues       `queryParam:"inline"`
	DestinationGcsUpdateJSONLinesNewlineDelimitedJSON *DestinationGcsUpdateJSONLinesNewlineDelimitedJSON `queryParam:"inline"`
	DestinationGcsUpdateParquetColumnarStorage        *DestinationGcsUpdateParquetColumnarStorage        `queryParam:"inline"`

	Type DestinationGcsUpdateOutputFormatType
}

func CreateDestinationGcsUpdateOutputFormatDestinationGcsUpdateAvroApacheAvro(destinationGcsUpdateAvroApacheAvro DestinationGcsUpdateAvroApacheAvro) DestinationGcsUpdateOutputFormat {
	typ := DestinationGcsUpdateOutputFormatTypeDestinationGcsUpdateAvroApacheAvro

	return DestinationGcsUpdateOutputFormat{
		DestinationGcsUpdateAvroApacheAvro: &destinationGcsUpdateAvroApacheAvro,
		Type:                               typ,
	}
}

func CreateDestinationGcsUpdateOutputFormatDestinationGcsUpdateCSVCommaSeparatedValues(destinationGcsUpdateCSVCommaSeparatedValues DestinationGcsUpdateCSVCommaSeparatedValues) DestinationGcsUpdateOutputFormat {
	typ := DestinationGcsUpdateOutputFormatTypeDestinationGcsUpdateCSVCommaSeparatedValues

	return DestinationGcsUpdateOutputFormat{
		DestinationGcsUpdateCSVCommaSeparatedValues: &destinationGcsUpdateCSVCommaSeparatedValues,
		Type: typ,
	}
}

func CreateDestinationGcsUpdateOutputFormatDestinationGcsUpdateJSONLinesNewlineDelimitedJSON(destinationGcsUpdateJSONLinesNewlineDelimitedJSON DestinationGcsUpdateJSONLinesNewlineDelimitedJSON) DestinationGcsUpdateOutputFormat {
	typ := DestinationGcsUpdateOutputFormatTypeDestinationGcsUpdateJSONLinesNewlineDelimitedJSON

	return DestinationGcsUpdateOutputFormat{
		DestinationGcsUpdateJSONLinesNewlineDelimitedJSON: &destinationGcsUpdateJSONLinesNewlineDelimitedJSON,
		Type: typ,
	}
}

func CreateDestinationGcsUpdateOutputFormatDestinationGcsUpdateParquetColumnarStorage(destinationGcsUpdateParquetColumnarStorage DestinationGcsUpdateParquetColumnarStorage) DestinationGcsUpdateOutputFormat {
	typ := DestinationGcsUpdateOutputFormatTypeDestinationGcsUpdateParquetColumnarStorage

	return DestinationGcsUpdateOutputFormat{
		DestinationGcsUpdateParquetColumnarStorage: &destinationGcsUpdateParquetColumnarStorage,
		Type: typ,
	}
}

func (u *DestinationGcsUpdateOutputFormat) UnmarshalJSON(data []byte) error {

	var destinationGcsUpdateAvroApacheAvro DestinationGcsUpdateAvroApacheAvro = DestinationGcsUpdateAvroApacheAvro{}
	if err := utils.UnmarshalJSON(data, &destinationGcsUpdateAvroApacheAvro, "", true, true); err == nil {
		u.DestinationGcsUpdateAvroApacheAvro = &destinationGcsUpdateAvroApacheAvro
		u.Type = DestinationGcsUpdateOutputFormatTypeDestinationGcsUpdateAvroApacheAvro
		return nil
	}

	var destinationGcsUpdateJSONLinesNewlineDelimitedJSON DestinationGcsUpdateJSONLinesNewlineDelimitedJSON = DestinationGcsUpdateJSONLinesNewlineDelimitedJSON{}
	if err := utils.UnmarshalJSON(data, &destinationGcsUpdateJSONLinesNewlineDelimitedJSON, "", true, true); err == nil {
		u.DestinationGcsUpdateJSONLinesNewlineDelimitedJSON = &destinationGcsUpdateJSONLinesNewlineDelimitedJSON
		u.Type = DestinationGcsUpdateOutputFormatTypeDestinationGcsUpdateJSONLinesNewlineDelimitedJSON
		return nil
	}

	var destinationGcsUpdateCSVCommaSeparatedValues DestinationGcsUpdateCSVCommaSeparatedValues = DestinationGcsUpdateCSVCommaSeparatedValues{}
	if err := utils.UnmarshalJSON(data, &destinationGcsUpdateCSVCommaSeparatedValues, "", true, true); err == nil {
		u.DestinationGcsUpdateCSVCommaSeparatedValues = &destinationGcsUpdateCSVCommaSeparatedValues
		u.Type = DestinationGcsUpdateOutputFormatTypeDestinationGcsUpdateCSVCommaSeparatedValues
		return nil
	}

	var destinationGcsUpdateParquetColumnarStorage DestinationGcsUpdateParquetColumnarStorage = DestinationGcsUpdateParquetColumnarStorage{}
	if err := utils.UnmarshalJSON(data, &destinationGcsUpdateParquetColumnarStorage, "", true, true); err == nil {
		u.DestinationGcsUpdateParquetColumnarStorage = &destinationGcsUpdateParquetColumnarStorage
		u.Type = DestinationGcsUpdateOutputFormatTypeDestinationGcsUpdateParquetColumnarStorage
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationGcsUpdateOutputFormat", string(data))
}

func (u DestinationGcsUpdateOutputFormat) MarshalJSON() ([]byte, error) {
	if u.DestinationGcsUpdateAvroApacheAvro != nil {
		return utils.MarshalJSON(u.DestinationGcsUpdateAvroApacheAvro, "", true)
	}

	if u.DestinationGcsUpdateCSVCommaSeparatedValues != nil {
		return utils.MarshalJSON(u.DestinationGcsUpdateCSVCommaSeparatedValues, "", true)
	}

	if u.DestinationGcsUpdateJSONLinesNewlineDelimitedJSON != nil {
		return utils.MarshalJSON(u.DestinationGcsUpdateJSONLinesNewlineDelimitedJSON, "", true)
	}

	if u.DestinationGcsUpdateParquetColumnarStorage != nil {
		return utils.MarshalJSON(u.DestinationGcsUpdateParquetColumnarStorage, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationGcsUpdateOutputFormat: all fields are null")
}

// DestinationGCSUpdateGCSBucketRegion - Select a Region of the GCS Bucket. Read more <a href="https://cloud.google.com/storage/docs/locations">here</a>.
type DestinationGCSUpdateGCSBucketRegion string

const (
	DestinationGCSUpdateGCSBucketRegionNorthamericaNortheast1 DestinationGCSUpdateGCSBucketRegion = "northamerica-northeast1"
	DestinationGCSUpdateGCSBucketRegionNorthamericaNortheast2 DestinationGCSUpdateGCSBucketRegion = "northamerica-northeast2"
	DestinationGCSUpdateGCSBucketRegionUsCentral1             DestinationGCSUpdateGCSBucketRegion = "us-central1"
	DestinationGCSUpdateGCSBucketRegionUsEast1                DestinationGCSUpdateGCSBucketRegion = "us-east1"
	DestinationGCSUpdateGCSBucketRegionUsEast4                DestinationGCSUpdateGCSBucketRegion = "us-east4"
	DestinationGCSUpdateGCSBucketRegionUsWest1                DestinationGCSUpdateGCSBucketRegion = "us-west1"
	DestinationGCSUpdateGCSBucketRegionUsWest2                DestinationGCSUpdateGCSBucketRegion = "us-west2"
	DestinationGCSUpdateGCSBucketRegionUsWest3                DestinationGCSUpdateGCSBucketRegion = "us-west3"
	DestinationGCSUpdateGCSBucketRegionUsWest4                DestinationGCSUpdateGCSBucketRegion = "us-west4"
	DestinationGCSUpdateGCSBucketRegionSouthamericaEast1      DestinationGCSUpdateGCSBucketRegion = "southamerica-east1"
	DestinationGCSUpdateGCSBucketRegionSouthamericaWest1      DestinationGCSUpdateGCSBucketRegion = "southamerica-west1"
	DestinationGCSUpdateGCSBucketRegionEuropeCentral2         DestinationGCSUpdateGCSBucketRegion = "europe-central2"
	DestinationGCSUpdateGCSBucketRegionEuropeNorth1           DestinationGCSUpdateGCSBucketRegion = "europe-north1"
	DestinationGCSUpdateGCSBucketRegionEuropeWest1            DestinationGCSUpdateGCSBucketRegion = "europe-west1"
	DestinationGCSUpdateGCSBucketRegionEuropeWest2            DestinationGCSUpdateGCSBucketRegion = "europe-west2"
	DestinationGCSUpdateGCSBucketRegionEuropeWest3            DestinationGCSUpdateGCSBucketRegion = "europe-west3"
	DestinationGCSUpdateGCSBucketRegionEuropeWest4            DestinationGCSUpdateGCSBucketRegion = "europe-west4"
	DestinationGCSUpdateGCSBucketRegionEuropeWest6            DestinationGCSUpdateGCSBucketRegion = "europe-west6"
	DestinationGCSUpdateGCSBucketRegionAsiaEast1              DestinationGCSUpdateGCSBucketRegion = "asia-east1"
	DestinationGCSUpdateGCSBucketRegionAsiaEast2              DestinationGCSUpdateGCSBucketRegion = "asia-east2"
	DestinationGCSUpdateGCSBucketRegionAsiaNortheast1         DestinationGCSUpdateGCSBucketRegion = "asia-northeast1"
	DestinationGCSUpdateGCSBucketRegionAsiaNortheast2         DestinationGCSUpdateGCSBucketRegion = "asia-northeast2"
	DestinationGCSUpdateGCSBucketRegionAsiaNortheast3         DestinationGCSUpdateGCSBucketRegion = "asia-northeast3"
	DestinationGCSUpdateGCSBucketRegionAsiaSouth1             DestinationGCSUpdateGCSBucketRegion = "asia-south1"
	DestinationGCSUpdateGCSBucketRegionAsiaSouth2             DestinationGCSUpdateGCSBucketRegion = "asia-south2"
	DestinationGCSUpdateGCSBucketRegionAsiaSoutheast1         DestinationGCSUpdateGCSBucketRegion = "asia-southeast1"
	DestinationGCSUpdateGCSBucketRegionAsiaSoutheast2         DestinationGCSUpdateGCSBucketRegion = "asia-southeast2"
	DestinationGCSUpdateGCSBucketRegionAustraliaSoutheast1    DestinationGCSUpdateGCSBucketRegion = "australia-southeast1"
	DestinationGCSUpdateGCSBucketRegionAustraliaSoutheast2    DestinationGCSUpdateGCSBucketRegion = "australia-southeast2"
	DestinationGCSUpdateGCSBucketRegionAsia                   DestinationGCSUpdateGCSBucketRegion = "asia"
	DestinationGCSUpdateGCSBucketRegionEu                     DestinationGCSUpdateGCSBucketRegion = "eu"
	DestinationGCSUpdateGCSBucketRegionUs                     DestinationGCSUpdateGCSBucketRegion = "us"
	DestinationGCSUpdateGCSBucketRegionAsia1                  DestinationGCSUpdateGCSBucketRegion = "asia1"
	DestinationGCSUpdateGCSBucketRegionEur4                   DestinationGCSUpdateGCSBucketRegion = "eur4"
	DestinationGCSUpdateGCSBucketRegionNam4                   DestinationGCSUpdateGCSBucketRegion = "nam4"
)

func (e DestinationGCSUpdateGCSBucketRegion) ToPointer() *DestinationGCSUpdateGCSBucketRegion {
	return &e
}
func (e *DestinationGCSUpdateGCSBucketRegion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "northamerica-northeast1":
		fallthrough
	case "northamerica-northeast2":
		fallthrough
	case "us-central1":
		fallthrough
	case "us-east1":
		fallthrough
	case "us-east4":
		fallthrough
	case "us-west1":
		fallthrough
	case "us-west2":
		fallthrough
	case "us-west3":
		fallthrough
	case "us-west4":
		fallthrough
	case "southamerica-east1":
		fallthrough
	case "southamerica-west1":
		fallthrough
	case "europe-central2":
		fallthrough
	case "europe-north1":
		fallthrough
	case "europe-west1":
		fallthrough
	case "europe-west2":
		fallthrough
	case "europe-west3":
		fallthrough
	case "europe-west4":
		fallthrough
	case "europe-west6":
		fallthrough
	case "asia-east1":
		fallthrough
	case "asia-east2":
		fallthrough
	case "asia-northeast1":
		fallthrough
	case "asia-northeast2":
		fallthrough
	case "asia-northeast3":
		fallthrough
	case "asia-south1":
		fallthrough
	case "asia-south2":
		fallthrough
	case "asia-southeast1":
		fallthrough
	case "asia-southeast2":
		fallthrough
	case "australia-southeast1":
		fallthrough
	case "australia-southeast2":
		fallthrough
	case "asia":
		fallthrough
	case "eu":
		fallthrough
	case "us":
		fallthrough
	case "asia1":
		fallthrough
	case "eur4":
		fallthrough
	case "nam4":
		*e = DestinationGCSUpdateGCSBucketRegion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGCSUpdateGCSBucketRegion: %v", v)
	}
}

type DestinationGcsUpdate struct {
	// An HMAC key is a type of credential and can be associated with a service account or a user account in Cloud Storage. Read more <a href="https://cloud.google.com/storage/docs/authentication/hmackeys">here</a>.
	Credential DestinationGcsUpdateAuthentication `json:"credential"`
	// Output data format. One of the following formats must be selected - <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-avro#advantages_of_avro">AVRO</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-parquet#parquet_schemas">PARQUET</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-csv#loading_csv_data_into_a_table">CSV</a> format, or <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-json#loading_json_data_into_a_new_table">JSONL</a> format.
	Format DestinationGcsUpdateOutputFormat `json:"format"`
	// You can find the bucket name in the App Engine Admin console Application Settings page, under the label Google Cloud Storage Bucket. Read more <a href="https://cloud.google.com/storage/docs/naming-buckets">here</a>.
	GcsBucketName string `json:"gcs_bucket_name"`
	// GCS Bucket Path string Subdirectory under the above bucket to sync the data into.
	GcsBucketPath string `json:"gcs_bucket_path"`
	// Select a Region of the GCS Bucket. Read more <a href="https://cloud.google.com/storage/docs/locations">here</a>.
	GcsBucketRegion *DestinationGCSUpdateGCSBucketRegion `default:"us" json:"gcs_bucket_region"`
}

func (d DestinationGcsUpdate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsUpdate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *DestinationGcsUpdate) GetCredential() DestinationGcsUpdateAuthentication {
	if o == nil {
		return DestinationGcsUpdateAuthentication{}
	}
	return o.Credential
}

func (o *DestinationGcsUpdate) GetFormat() DestinationGcsUpdateOutputFormat {
	if o == nil {
		return DestinationGcsUpdateOutputFormat{}
	}
	return o.Format
}

func (o *DestinationGcsUpdate) GetGcsBucketName() string {
	if o == nil {
		return ""
	}
	return o.GcsBucketName
}

func (o *DestinationGcsUpdate) GetGcsBucketPath() string {
	if o == nil {
		return ""
	}
	return o.GcsBucketPath
}

func (o *DestinationGcsUpdate) GetGcsBucketRegion() *DestinationGCSUpdateGCSBucketRegion {
	if o == nil {
		return nil
	}
	return o.GcsBucketRegion
}
