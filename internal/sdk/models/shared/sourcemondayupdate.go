// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/types"
)

type SourceMondayUpdateAPIToken struct {
	// API Token for making authenticated requests.
	APIToken *string `json:"api_token,omitempty"`
	authType *string `const:"api_token" json:"auth_type,omitempty"`
}

func (s SourceMondayUpdateAPIToken) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMondayUpdateAPIToken) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceMondayUpdateAPIToken) GetAPIToken() *string {
	if s == nil {
		return nil
	}
	return s.APIToken
}

func (s *SourceMondayUpdateAPIToken) GetAuthType() *string {
	return types.Pointer("api_token")
}

type SourceMondayUpdateOAuth20 struct {
	// Access Token for making authenticated requests.
	AccessToken *string `json:"access_token,omitempty"`
	authType    *string `const:"oauth2.0" json:"auth_type,omitempty"`
	// The Client ID of your OAuth application.
	ClientID *string `json:"client_id,omitempty"`
	// The Client Secret of your OAuth application.
	ClientSecret *string `json:"client_secret,omitempty"`
	// Slug/subdomain of the account, or the first part of the URL that comes before .monday.com
	Subdomain *string `default:"" json:"subdomain"`
}

func (s SourceMondayUpdateOAuth20) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMondayUpdateOAuth20) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceMondayUpdateOAuth20) GetAccessToken() *string {
	if s == nil {
		return nil
	}
	return s.AccessToken
}

func (s *SourceMondayUpdateOAuth20) GetAuthType() *string {
	return types.Pointer("oauth2.0")
}

func (s *SourceMondayUpdateOAuth20) GetClientID() *string {
	if s == nil {
		return nil
	}
	return s.ClientID
}

func (s *SourceMondayUpdateOAuth20) GetClientSecret() *string {
	if s == nil {
		return nil
	}
	return s.ClientSecret
}

func (s *SourceMondayUpdateOAuth20) GetSubdomain() *string {
	if s == nil {
		return nil
	}
	return s.Subdomain
}

type SourceMondayUpdateAuthorizationMethodType string

const (
	SourceMondayUpdateAuthorizationMethodTypeSourceMondayUpdateOAuth20  SourceMondayUpdateAuthorizationMethodType = "source-monday-update_OAuth2.0"
	SourceMondayUpdateAuthorizationMethodTypeSourceMondayUpdateAPIToken SourceMondayUpdateAuthorizationMethodType = "source-monday-update_API Token"
)

type SourceMondayUpdateAuthorizationMethod struct {
	SourceMondayUpdateOAuth20  *SourceMondayUpdateOAuth20  `queryParam:"inline" union:"member"`
	SourceMondayUpdateAPIToken *SourceMondayUpdateAPIToken `queryParam:"inline" union:"member"`

	Type SourceMondayUpdateAuthorizationMethodType
}

func CreateSourceMondayUpdateAuthorizationMethodSourceMondayUpdateOAuth20(sourceMondayUpdateOAuth20 SourceMondayUpdateOAuth20) SourceMondayUpdateAuthorizationMethod {
	typ := SourceMondayUpdateAuthorizationMethodTypeSourceMondayUpdateOAuth20

	return SourceMondayUpdateAuthorizationMethod{
		SourceMondayUpdateOAuth20: &sourceMondayUpdateOAuth20,
		Type:                      typ,
	}
}

func CreateSourceMondayUpdateAuthorizationMethodSourceMondayUpdateAPIToken(sourceMondayUpdateAPIToken SourceMondayUpdateAPIToken) SourceMondayUpdateAuthorizationMethod {
	typ := SourceMondayUpdateAuthorizationMethodTypeSourceMondayUpdateAPIToken

	return SourceMondayUpdateAuthorizationMethod{
		SourceMondayUpdateAPIToken: &sourceMondayUpdateAPIToken,
		Type:                       typ,
	}
}

func (u *SourceMondayUpdateAuthorizationMethod) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var sourceMondayUpdateOAuth20 SourceMondayUpdateOAuth20 = SourceMondayUpdateOAuth20{}
	if err := utils.UnmarshalJSON(data, &sourceMondayUpdateOAuth20, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceMondayUpdateAuthorizationMethodTypeSourceMondayUpdateOAuth20,
			Value: &sourceMondayUpdateOAuth20,
		})
	}

	var sourceMondayUpdateAPIToken SourceMondayUpdateAPIToken = SourceMondayUpdateAPIToken{}
	if err := utils.UnmarshalJSON(data, &sourceMondayUpdateAPIToken, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceMondayUpdateAuthorizationMethodTypeSourceMondayUpdateAPIToken,
			Value: &sourceMondayUpdateAPIToken,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMondayUpdateAuthorizationMethod", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMondayUpdateAuthorizationMethod", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceMondayUpdateAuthorizationMethodType)
	switch best.Type {
	case SourceMondayUpdateAuthorizationMethodTypeSourceMondayUpdateOAuth20:
		u.SourceMondayUpdateOAuth20 = best.Value.(*SourceMondayUpdateOAuth20)
		return nil
	case SourceMondayUpdateAuthorizationMethodTypeSourceMondayUpdateAPIToken:
		u.SourceMondayUpdateAPIToken = best.Value.(*SourceMondayUpdateAPIToken)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMondayUpdateAuthorizationMethod", string(data))
}

func (u SourceMondayUpdateAuthorizationMethod) MarshalJSON() ([]byte, error) {
	if u.SourceMondayUpdateOAuth20 != nil {
		return utils.MarshalJSON(u.SourceMondayUpdateOAuth20, "", true)
	}

	if u.SourceMondayUpdateAPIToken != nil {
		return utils.MarshalJSON(u.SourceMondayUpdateAPIToken, "", true)
	}

	return nil, errors.New("could not marshal union type SourceMondayUpdateAuthorizationMethod: all fields are null")
}

type SourceMondayUpdateSourceType string

const (
	SourceMondayUpdateSourceTypeMonday SourceMondayUpdateSourceType = "monday"
)

func (e SourceMondayUpdateSourceType) ToPointer() *SourceMondayUpdateSourceType {
	return &e
}
func (e *SourceMondayUpdateSourceType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "monday":
		*e = SourceMondayUpdateSourceType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMondayUpdateSourceType: %v", v)
	}
}

type SourceMondayUpdate struct {
	// The IDs of the boards that the Items and Boards streams will extract records from. When left empty, streams will extract records from all boards that exist within the account.
	BoardIds    []int64                                `json:"board_ids,omitempty"`
	Credentials *SourceMondayUpdateAuthorizationMethod `json:"credentials,omitempty"`
	// The number of worker threads to use for the sync.
	NumWorkers           *int64                        `default:"4" json:"num_workers"`
	sourceType           *SourceMondayUpdateSourceType `const:"monday" json:"sourceType"`
	AdditionalProperties any                           `additionalProperties:"true" json:"-"`
}

func (s SourceMondayUpdate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMondayUpdate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceMondayUpdate) GetBoardIds() []int64 {
	if s == nil {
		return nil
	}
	return s.BoardIds
}

func (s *SourceMondayUpdate) GetCredentials() *SourceMondayUpdateAuthorizationMethod {
	if s == nil {
		return nil
	}
	return s.Credentials
}

func (s *SourceMondayUpdate) GetNumWorkers() *int64 {
	if s == nil {
		return nil
	}
	return s.NumWorkers
}

func (s *SourceMondayUpdate) GetSourceType() *SourceMondayUpdateSourceType {
	return SourceMondayUpdateSourceTypeMonday.ToPointer()
}

func (s *SourceMondayUpdate) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}
