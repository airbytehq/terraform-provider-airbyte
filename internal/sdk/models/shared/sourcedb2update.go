// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/types"
)

// SourceDb2UpdateTLSEncryptedVerifyCertificate - Verify and use the cert provided by the server.
type SourceDb2UpdateTLSEncryptedVerifyCertificate struct {
	encryptionMethod *string `const:"encrypted_verify_certificate" json:"encryption_method,omitempty"`
	// Key Store Password
	KeyStorePassword *string `json:"key_store_password,omitempty"`
	// Privacy Enhanced Mail (PEM) files are concatenated certificate containers frequently used in certificate installations
	SslCertificate *string `json:"ssl_certificate,omitempty"`
}

func (s SourceDb2UpdateTLSEncryptedVerifyCertificate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceDb2UpdateTLSEncryptedVerifyCertificate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceDb2UpdateTLSEncryptedVerifyCertificate) GetEncryptionMethod() *string {
	return types.Pointer("encrypted_verify_certificate")
}

func (s *SourceDb2UpdateTLSEncryptedVerifyCertificate) GetKeyStorePassword() *string {
	if s == nil {
		return nil
	}
	return s.KeyStorePassword
}

func (s *SourceDb2UpdateTLSEncryptedVerifyCertificate) GetSslCertificate() *string {
	if s == nil {
		return nil
	}
	return s.SslCertificate
}

// SourceDb2UpdateUnencrypted - Data transfer will not be encrypted.
type SourceDb2UpdateUnencrypted struct {
	encryptionMethod *string `const:"unencrypted" json:"encryption_method,omitempty"`
}

func (s SourceDb2UpdateUnencrypted) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceDb2UpdateUnencrypted) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceDb2UpdateUnencrypted) GetEncryptionMethod() *string {
	return types.Pointer("unencrypted")
}

type SourceDb2UpdateEncryptionType string

const (
	SourceDb2UpdateEncryptionTypeSourceDb2UpdateUnencrypted                   SourceDb2UpdateEncryptionType = "source-db2-update_Unencrypted"
	SourceDb2UpdateEncryptionTypeSourceDb2UpdateTLSEncryptedVerifyCertificate SourceDb2UpdateEncryptionType = "source-db2-update_TLS Encrypted (verify certificate)"
)

// SourceDb2UpdateEncryption - Encryption method to use when communicating with the database
type SourceDb2UpdateEncryption struct {
	SourceDb2UpdateUnencrypted                   *SourceDb2UpdateUnencrypted                   `queryParam:"inline" union:"member"`
	SourceDb2UpdateTLSEncryptedVerifyCertificate *SourceDb2UpdateTLSEncryptedVerifyCertificate `queryParam:"inline" union:"member"`

	Type SourceDb2UpdateEncryptionType
}

func CreateSourceDb2UpdateEncryptionSourceDb2UpdateUnencrypted(sourceDb2UpdateUnencrypted SourceDb2UpdateUnencrypted) SourceDb2UpdateEncryption {
	typ := SourceDb2UpdateEncryptionTypeSourceDb2UpdateUnencrypted

	return SourceDb2UpdateEncryption{
		SourceDb2UpdateUnencrypted: &sourceDb2UpdateUnencrypted,
		Type:                       typ,
	}
}

func CreateSourceDb2UpdateEncryptionSourceDb2UpdateTLSEncryptedVerifyCertificate(sourceDb2UpdateTLSEncryptedVerifyCertificate SourceDb2UpdateTLSEncryptedVerifyCertificate) SourceDb2UpdateEncryption {
	typ := SourceDb2UpdateEncryptionTypeSourceDb2UpdateTLSEncryptedVerifyCertificate

	return SourceDb2UpdateEncryption{
		SourceDb2UpdateTLSEncryptedVerifyCertificate: &sourceDb2UpdateTLSEncryptedVerifyCertificate,
		Type: typ,
	}
}

func (u *SourceDb2UpdateEncryption) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var sourceDb2UpdateUnencrypted SourceDb2UpdateUnencrypted = SourceDb2UpdateUnencrypted{}
	if err := utils.UnmarshalJSON(data, &sourceDb2UpdateUnencrypted, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceDb2UpdateEncryptionTypeSourceDb2UpdateUnencrypted,
			Value: &sourceDb2UpdateUnencrypted,
		})
	}

	var sourceDb2UpdateTLSEncryptedVerifyCertificate SourceDb2UpdateTLSEncryptedVerifyCertificate = SourceDb2UpdateTLSEncryptedVerifyCertificate{}
	if err := utils.UnmarshalJSON(data, &sourceDb2UpdateTLSEncryptedVerifyCertificate, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceDb2UpdateEncryptionTypeSourceDb2UpdateTLSEncryptedVerifyCertificate,
			Value: &sourceDb2UpdateTLSEncryptedVerifyCertificate,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceDb2UpdateEncryption", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceDb2UpdateEncryption", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceDb2UpdateEncryptionType)
	switch best.Type {
	case SourceDb2UpdateEncryptionTypeSourceDb2UpdateUnencrypted:
		u.SourceDb2UpdateUnencrypted = best.Value.(*SourceDb2UpdateUnencrypted)
		return nil
	case SourceDb2UpdateEncryptionTypeSourceDb2UpdateTLSEncryptedVerifyCertificate:
		u.SourceDb2UpdateTLSEncryptedVerifyCertificate = best.Value.(*SourceDb2UpdateTLSEncryptedVerifyCertificate)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceDb2UpdateEncryption", string(data))
}

func (u SourceDb2UpdateEncryption) MarshalJSON() ([]byte, error) {
	if u.SourceDb2UpdateUnencrypted != nil {
		return utils.MarshalJSON(u.SourceDb2UpdateUnencrypted, "", true)
	}

	if u.SourceDb2UpdateTLSEncryptedVerifyCertificate != nil {
		return utils.MarshalJSON(u.SourceDb2UpdateTLSEncryptedVerifyCertificate, "", true)
	}

	return nil, errors.New("could not marshal union type SourceDb2UpdateEncryption: all fields are null")
}

type SourceDb2UpdateSourceType string

const (
	SourceDb2UpdateSourceTypeDb2 SourceDb2UpdateSourceType = "db2"
)

func (e SourceDb2UpdateSourceType) ToPointer() *SourceDb2UpdateSourceType {
	return &e
}
func (e *SourceDb2UpdateSourceType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "db2":
		*e = SourceDb2UpdateSourceType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceDb2UpdateSourceType: %v", v)
	}
}

type SourceDb2Update struct {
	// Name of the database.
	Db *string `json:"db,omitempty"`
	// Encryption method to use when communicating with the database
	Encryption *SourceDb2UpdateEncryption `json:"encryption,omitempty"`
	// Host of the Db2.
	Host *string `json:"host,omitempty"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// Password associated with the username.
	Password *string `json:"password,omitempty"`
	// Port of the database.
	Port *int64 `default:"8123" json:"port"`
	// Username to use to access the database.
	Username   *string                    `json:"username,omitempty"`
	sourceType *SourceDb2UpdateSourceType `const:"db2" json:"sourceType"`
}

func (s SourceDb2Update) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceDb2Update) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceDb2Update) GetDb() *string {
	if s == nil {
		return nil
	}
	return s.Db
}

func (s *SourceDb2Update) GetEncryption() *SourceDb2UpdateEncryption {
	if s == nil {
		return nil
	}
	return s.Encryption
}

func (s *SourceDb2Update) GetHost() *string {
	if s == nil {
		return nil
	}
	return s.Host
}

func (s *SourceDb2Update) GetJdbcURLParams() *string {
	if s == nil {
		return nil
	}
	return s.JdbcURLParams
}

func (s *SourceDb2Update) GetPassword() *string {
	if s == nil {
		return nil
	}
	return s.Password
}

func (s *SourceDb2Update) GetPort() *int64 {
	if s == nil {
		return nil
	}
	return s.Port
}

func (s *SourceDb2Update) GetUsername() *string {
	if s == nil {
		return nil
	}
	return s.Username
}

func (s *SourceDb2Update) GetSourceType() *SourceDb2UpdateSourceType {
	return SourceDb2UpdateSourceTypeDb2.ToPointer()
}
