// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

type SourceMongodbV2UpdateSchemasClusterType string

const (
	SourceMongodbV2UpdateSchemasClusterTypeSelfManagedReplicaSet SourceMongodbV2UpdateSchemasClusterType = "SELF_MANAGED_REPLICA_SET"
)

func (e SourceMongodbV2UpdateSchemasClusterType) ToPointer() *SourceMongodbV2UpdateSchemasClusterType {
	return &e
}
func (e *SourceMongodbV2UpdateSchemasClusterType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SELF_MANAGED_REPLICA_SET":
		*e = SourceMongodbV2UpdateSchemasClusterType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMongodbV2UpdateSchemasClusterType: %v", v)
	}
}

// SourceMongodbV2UpdateSelfManagedReplicaSet - MongoDB self-hosted cluster configured as a replica set
type SourceMongodbV2UpdateSelfManagedReplicaSet struct {
	clusterType SourceMongodbV2UpdateSchemasClusterType `const:"SELF_MANAGED_REPLICA_SET" json:"cluster_type"`
	// The connection string of the cluster that you want to replicate.  https://www.mongodb.com/docs/manual/reference/connection-string/#find-your-self-hosted-deployment-s-connection-string for more information.
	ConnectionString string `json:"connection_string"`
	// The name of the MongoDB database that contains the collection(s) to replicate.
	Database string `json:"database"`
	// The username which is used to access the database.
	Username *string `json:"username,omitempty"`
	// The password associated with this username.
	Password *string `json:"password,omitempty"`
	// The authentication source where the user information is stored.
	AuthSource *string `default:"admin" json:"auth_source"`
	// When enabled, syncs will validate and structure records against the stream's schema.
	SchemaEnforced       *bool `default:"true" json:"schema_enforced"`
	AdditionalProperties any   `additionalProperties:"true" json:"-"`
}

func (s SourceMongodbV2UpdateSelfManagedReplicaSet) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMongodbV2UpdateSelfManagedReplicaSet) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceMongodbV2UpdateSelfManagedReplicaSet) GetClusterType() SourceMongodbV2UpdateSchemasClusterType {
	return SourceMongodbV2UpdateSchemasClusterTypeSelfManagedReplicaSet
}

func (o *SourceMongodbV2UpdateSelfManagedReplicaSet) GetConnectionString() string {
	if o == nil {
		return ""
	}
	return o.ConnectionString
}

func (o *SourceMongodbV2UpdateSelfManagedReplicaSet) GetDatabase() string {
	if o == nil {
		return ""
	}
	return o.Database
}

func (o *SourceMongodbV2UpdateSelfManagedReplicaSet) GetUsername() *string {
	if o == nil {
		return nil
	}
	return o.Username
}

func (o *SourceMongodbV2UpdateSelfManagedReplicaSet) GetPassword() *string {
	if o == nil {
		return nil
	}
	return o.Password
}

func (o *SourceMongodbV2UpdateSelfManagedReplicaSet) GetAuthSource() *string {
	if o == nil {
		return nil
	}
	return o.AuthSource
}

func (o *SourceMongodbV2UpdateSelfManagedReplicaSet) GetSchemaEnforced() *bool {
	if o == nil {
		return nil
	}
	return o.SchemaEnforced
}

func (o *SourceMongodbV2UpdateSelfManagedReplicaSet) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

type SourceMongodbV2UpdateSchemasDatabaseConfigClusterType string

const (
	SourceMongodbV2UpdateSchemasDatabaseConfigClusterTypeAtlasReplicaSet SourceMongodbV2UpdateSchemasDatabaseConfigClusterType = "ATLAS_REPLICA_SET"
)

func (e SourceMongodbV2UpdateSchemasDatabaseConfigClusterType) ToPointer() *SourceMongodbV2UpdateSchemasDatabaseConfigClusterType {
	return &e
}
func (e *SourceMongodbV2UpdateSchemasDatabaseConfigClusterType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "ATLAS_REPLICA_SET":
		*e = SourceMongodbV2UpdateSchemasDatabaseConfigClusterType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMongodbV2UpdateSchemasDatabaseConfigClusterType: %v", v)
	}
}

// SourceMongodbV2UpdateMongoDBAtlasReplicaSet - MongoDB Atlas-hosted cluster configured as a replica set
type SourceMongodbV2UpdateMongoDBAtlasReplicaSet struct {
	clusterType SourceMongodbV2UpdateSchemasDatabaseConfigClusterType `const:"ATLAS_REPLICA_SET" json:"cluster_type"`
	// The connection string of the cluster that you want to replicate.
	ConnectionString string `json:"connection_string"`
	// The name of the MongoDB database that contains the collection(s) to replicate.
	Database string `json:"database"`
	// The username which is used to access the database.
	Username string `json:"username"`
	// The password associated with this username.
	Password string `json:"password"`
	// The authentication source where the user information is stored.  See https://www.mongodb.com/docs/manual/reference/connection-string/#mongodb-urioption-urioption.authSource for more details.
	AuthSource *string `default:"admin" json:"auth_source"`
	// When enabled, syncs will validate and structure records against the stream's schema.
	SchemaEnforced       *bool `default:"true" json:"schema_enforced"`
	AdditionalProperties any   `additionalProperties:"true" json:"-"`
}

func (s SourceMongodbV2UpdateMongoDBAtlasReplicaSet) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMongodbV2UpdateMongoDBAtlasReplicaSet) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceMongodbV2UpdateMongoDBAtlasReplicaSet) GetClusterType() SourceMongodbV2UpdateSchemasDatabaseConfigClusterType {
	return SourceMongodbV2UpdateSchemasDatabaseConfigClusterTypeAtlasReplicaSet
}

func (o *SourceMongodbV2UpdateMongoDBAtlasReplicaSet) GetConnectionString() string {
	if o == nil {
		return ""
	}
	return o.ConnectionString
}

func (o *SourceMongodbV2UpdateMongoDBAtlasReplicaSet) GetDatabase() string {
	if o == nil {
		return ""
	}
	return o.Database
}

func (o *SourceMongodbV2UpdateMongoDBAtlasReplicaSet) GetUsername() string {
	if o == nil {
		return ""
	}
	return o.Username
}

func (o *SourceMongodbV2UpdateMongoDBAtlasReplicaSet) GetPassword() string {
	if o == nil {
		return ""
	}
	return o.Password
}

func (o *SourceMongodbV2UpdateMongoDBAtlasReplicaSet) GetAuthSource() *string {
	if o == nil {
		return nil
	}
	return o.AuthSource
}

func (o *SourceMongodbV2UpdateMongoDBAtlasReplicaSet) GetSchemaEnforced() *bool {
	if o == nil {
		return nil
	}
	return o.SchemaEnforced
}

func (o *SourceMongodbV2UpdateMongoDBAtlasReplicaSet) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

type SourceMongodbV2UpdateClusterTypeType string

const (
	SourceMongodbV2UpdateClusterTypeTypeSourceMongodbV2UpdateMongoDBAtlasReplicaSet SourceMongodbV2UpdateClusterTypeType = "source-mongodb-v2-update_MongoDB Atlas Replica Set"
	SourceMongodbV2UpdateClusterTypeTypeSourceMongodbV2UpdateSelfManagedReplicaSet  SourceMongodbV2UpdateClusterTypeType = "source-mongodb-v2-update_Self-Managed Replica Set"
)

// SourceMongodbV2UpdateClusterType - Configures the MongoDB cluster type.
type SourceMongodbV2UpdateClusterType struct {
	SourceMongodbV2UpdateMongoDBAtlasReplicaSet *SourceMongodbV2UpdateMongoDBAtlasReplicaSet `queryParam:"inline"`
	SourceMongodbV2UpdateSelfManagedReplicaSet  *SourceMongodbV2UpdateSelfManagedReplicaSet  `queryParam:"inline"`

	Type SourceMongodbV2UpdateClusterTypeType
}

func CreateSourceMongodbV2UpdateClusterTypeSourceMongodbV2UpdateMongoDBAtlasReplicaSet(sourceMongodbV2UpdateMongoDBAtlasReplicaSet SourceMongodbV2UpdateMongoDBAtlasReplicaSet) SourceMongodbV2UpdateClusterType {
	typ := SourceMongodbV2UpdateClusterTypeTypeSourceMongodbV2UpdateMongoDBAtlasReplicaSet

	return SourceMongodbV2UpdateClusterType{
		SourceMongodbV2UpdateMongoDBAtlasReplicaSet: &sourceMongodbV2UpdateMongoDBAtlasReplicaSet,
		Type: typ,
	}
}

func CreateSourceMongodbV2UpdateClusterTypeSourceMongodbV2UpdateSelfManagedReplicaSet(sourceMongodbV2UpdateSelfManagedReplicaSet SourceMongodbV2UpdateSelfManagedReplicaSet) SourceMongodbV2UpdateClusterType {
	typ := SourceMongodbV2UpdateClusterTypeTypeSourceMongodbV2UpdateSelfManagedReplicaSet

	return SourceMongodbV2UpdateClusterType{
		SourceMongodbV2UpdateSelfManagedReplicaSet: &sourceMongodbV2UpdateSelfManagedReplicaSet,
		Type: typ,
	}
}

func (u *SourceMongodbV2UpdateClusterType) UnmarshalJSON(data []byte) error {

	var sourceMongodbV2UpdateMongoDBAtlasReplicaSet SourceMongodbV2UpdateMongoDBAtlasReplicaSet = SourceMongodbV2UpdateMongoDBAtlasReplicaSet{}
	if err := utils.UnmarshalJSON(data, &sourceMongodbV2UpdateMongoDBAtlasReplicaSet, "", true, true); err == nil {
		u.SourceMongodbV2UpdateMongoDBAtlasReplicaSet = &sourceMongodbV2UpdateMongoDBAtlasReplicaSet
		u.Type = SourceMongodbV2UpdateClusterTypeTypeSourceMongodbV2UpdateMongoDBAtlasReplicaSet
		return nil
	}

	var sourceMongodbV2UpdateSelfManagedReplicaSet SourceMongodbV2UpdateSelfManagedReplicaSet = SourceMongodbV2UpdateSelfManagedReplicaSet{}
	if err := utils.UnmarshalJSON(data, &sourceMongodbV2UpdateSelfManagedReplicaSet, "", true, true); err == nil {
		u.SourceMongodbV2UpdateSelfManagedReplicaSet = &sourceMongodbV2UpdateSelfManagedReplicaSet
		u.Type = SourceMongodbV2UpdateClusterTypeTypeSourceMongodbV2UpdateSelfManagedReplicaSet
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMongodbV2UpdateClusterType", string(data))
}

func (u SourceMongodbV2UpdateClusterType) MarshalJSON() ([]byte, error) {
	if u.SourceMongodbV2UpdateMongoDBAtlasReplicaSet != nil {
		return utils.MarshalJSON(u.SourceMongodbV2UpdateMongoDBAtlasReplicaSet, "", true)
	}

	if u.SourceMongodbV2UpdateSelfManagedReplicaSet != nil {
		return utils.MarshalJSON(u.SourceMongodbV2UpdateSelfManagedReplicaSet, "", true)
	}

	return nil, errors.New("could not marshal union type SourceMongodbV2UpdateClusterType: all fields are null")
}

// SourceMongodbV2UpdateInvalidCDCPositionBehaviorAdvanced - Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value into the WAL. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss.
type SourceMongodbV2UpdateInvalidCDCPositionBehaviorAdvanced string

const (
	SourceMongodbV2UpdateInvalidCDCPositionBehaviorAdvancedFailSync   SourceMongodbV2UpdateInvalidCDCPositionBehaviorAdvanced = "Fail sync"
	SourceMongodbV2UpdateInvalidCDCPositionBehaviorAdvancedReSyncData SourceMongodbV2UpdateInvalidCDCPositionBehaviorAdvanced = "Re-sync data"
)

func (e SourceMongodbV2UpdateInvalidCDCPositionBehaviorAdvanced) ToPointer() *SourceMongodbV2UpdateInvalidCDCPositionBehaviorAdvanced {
	return &e
}
func (e *SourceMongodbV2UpdateInvalidCDCPositionBehaviorAdvanced) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Fail sync":
		fallthrough
	case "Re-sync data":
		*e = SourceMongodbV2UpdateInvalidCDCPositionBehaviorAdvanced(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMongodbV2UpdateInvalidCDCPositionBehaviorAdvanced: %v", v)
	}
}

// SourceMongodbV2UpdateCaptureModeAdvanced - Determines how Airbyte looks up the value of an updated document. If 'Lookup' is chosen, the current value of the document will be read. If 'Post Image' is chosen, then the version of the document immediately after an update will be read. WARNING : Severe data loss will occur if this option is chosen and the appropriate settings are not set on your Mongo instance : https://www.mongodb.com/docs/manual/changeStreams/#change-streams-with-document-pre-and-post-images.
type SourceMongodbV2UpdateCaptureModeAdvanced string

const (
	SourceMongodbV2UpdateCaptureModeAdvancedLookup    SourceMongodbV2UpdateCaptureModeAdvanced = "Lookup"
	SourceMongodbV2UpdateCaptureModeAdvancedPostImage SourceMongodbV2UpdateCaptureModeAdvanced = "Post Image"
)

func (e SourceMongodbV2UpdateCaptureModeAdvanced) ToPointer() *SourceMongodbV2UpdateCaptureModeAdvanced {
	return &e
}
func (e *SourceMongodbV2UpdateCaptureModeAdvanced) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Lookup":
		fallthrough
	case "Post Image":
		*e = SourceMongodbV2UpdateCaptureModeAdvanced(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMongodbV2UpdateCaptureModeAdvanced: %v", v)
	}
}

type SourceMongodbV2Update struct {
	// Configures the MongoDB cluster type.
	DatabaseConfig SourceMongodbV2UpdateClusterType `json:"database_config"`
	// The amount of time the connector will wait when it launches to determine if there is new data to sync or not. Defaults to 300 seconds. Valid range: 120 seconds to 1200 seconds.
	InitialWaitingSeconds *int64 `default:"300" json:"initial_waiting_seconds"`
	// The size of the internal queue. This may interfere with memory consumption and efficiency of the connector, please be careful.
	QueueSize *int64 `default:"10000" json:"queue_size"`
	// The maximum number of documents to sample when attempting to discover the unique fields for a collection.
	DiscoverSampleSize *int64 `default:"10000" json:"discover_sample_size"`
	// Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value into the WAL. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss.
	InvalidCdcCursorPositionBehavior *SourceMongodbV2UpdateInvalidCDCPositionBehaviorAdvanced `default:"Fail sync" json:"invalid_cdc_cursor_position_behavior"`
	// Determines how Airbyte looks up the value of an updated document. If 'Lookup' is chosen, the current value of the document will be read. If 'Post Image' is chosen, then the version of the document immediately after an update will be read. WARNING : Severe data loss will occur if this option is chosen and the appropriate settings are not set on your Mongo instance : https://www.mongodb.com/docs/manual/changeStreams/#change-streams-with-document-pre-and-post-images.
	UpdateCaptureMode *SourceMongodbV2UpdateCaptureModeAdvanced `default:"Lookup" json:"update_capture_mode"`
	// The amount of time an initial load is allowed to continue for before catching up on CDC logs.
	InitialLoadTimeoutHours *int64 `default:"8" json:"initial_load_timeout_hours"`
}

func (s SourceMongodbV2Update) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMongodbV2Update) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *SourceMongodbV2Update) GetDatabaseConfig() SourceMongodbV2UpdateClusterType {
	if o == nil {
		return SourceMongodbV2UpdateClusterType{}
	}
	return o.DatabaseConfig
}

func (o *SourceMongodbV2Update) GetInitialWaitingSeconds() *int64 {
	if o == nil {
		return nil
	}
	return o.InitialWaitingSeconds
}

func (o *SourceMongodbV2Update) GetQueueSize() *int64 {
	if o == nil {
		return nil
	}
	return o.QueueSize
}

func (o *SourceMongodbV2Update) GetDiscoverSampleSize() *int64 {
	if o == nil {
		return nil
	}
	return o.DiscoverSampleSize
}

func (o *SourceMongodbV2Update) GetInvalidCdcCursorPositionBehavior() *SourceMongodbV2UpdateInvalidCDCPositionBehaviorAdvanced {
	if o == nil {
		return nil
	}
	return o.InvalidCdcCursorPositionBehavior
}

func (o *SourceMongodbV2Update) GetUpdateCaptureMode() *SourceMongodbV2UpdateCaptureModeAdvanced {
	if o == nil {
		return nil
	}
	return o.UpdateCaptureMode
}

func (o *SourceMongodbV2Update) GetInitialLoadTimeoutHours() *int64 {
	if o == nil {
		return nil
	}
	return o.InitialLoadTimeoutHours
}
