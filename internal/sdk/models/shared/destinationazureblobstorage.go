// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

type DestinationAzureBlobStorageFlattening string

const (
	DestinationAzureBlobStorageFlatteningNoFlattening        DestinationAzureBlobStorageFlattening = "No flattening"
	DestinationAzureBlobStorageFlatteningRootLevelFlattening DestinationAzureBlobStorageFlattening = "Root level flattening"
)

func (e DestinationAzureBlobStorageFlattening) ToPointer() *DestinationAzureBlobStorageFlattening {
	return &e
}
func (e *DestinationAzureBlobStorageFlattening) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "No flattening":
		fallthrough
	case "Root level flattening":
		*e = DestinationAzureBlobStorageFlattening(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationAzureBlobStorageFlattening: %v", v)
	}
}

type DestinationAzureBlobStorageFormatType string

const (
	DestinationAzureBlobStorageFormatTypeJsonl DestinationAzureBlobStorageFormatType = "JSONL"
)

func (e DestinationAzureBlobStorageFormatType) ToPointer() *DestinationAzureBlobStorageFormatType {
	return &e
}
func (e *DestinationAzureBlobStorageFormatType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "JSONL":
		*e = DestinationAzureBlobStorageFormatType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationAzureBlobStorageFormatType: %v", v)
	}
}

type DestinationAzureBlobStorageJSONLinesNewlineDelimitedJSON struct {
	Flattening           *DestinationAzureBlobStorageFlattening `default:"No flattening" json:"flattening"`
	FormatType           *DestinationAzureBlobStorageFormatType `default:"JSONL" json:"format_type"`
	AdditionalProperties any                                    `additionalProperties:"true" json:"-"`
}

func (d DestinationAzureBlobStorageJSONLinesNewlineDelimitedJSON) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationAzureBlobStorageJSONLinesNewlineDelimitedJSON) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationAzureBlobStorageJSONLinesNewlineDelimitedJSON) GetFlattening() *DestinationAzureBlobStorageFlattening {
	if o == nil {
		return nil
	}
	return o.Flattening
}

func (o *DestinationAzureBlobStorageJSONLinesNewlineDelimitedJSON) GetFormatType() *DestinationAzureBlobStorageFormatType {
	if o == nil {
		return nil
	}
	return o.FormatType
}

func (o *DestinationAzureBlobStorageJSONLinesNewlineDelimitedJSON) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

type Flattening string

const (
	FlatteningNoFlattening        Flattening = "No flattening"
	FlatteningRootLevelFlattening Flattening = "Root level flattening"
)

func (e Flattening) ToPointer() *Flattening {
	return &e
}
func (e *Flattening) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "No flattening":
		fallthrough
	case "Root level flattening":
		*e = Flattening(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Flattening: %v", v)
	}
}

type FormatType string

const (
	FormatTypeCsv FormatType = "CSV"
)

func (e FormatType) ToPointer() *FormatType {
	return &e
}
func (e *FormatType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CSV":
		*e = FormatType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for FormatType: %v", v)
	}
}

type CSVCommaSeparatedValues struct {
	Flattening           *Flattening `default:"No flattening" json:"flattening"`
	FormatType           *FormatType `default:"CSV" json:"format_type"`
	AdditionalProperties any         `additionalProperties:"true" json:"-"`
}

func (c CSVCommaSeparatedValues) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CSVCommaSeparatedValues) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *CSVCommaSeparatedValues) GetFlattening() *Flattening {
	if o == nil {
		return nil
	}
	return o.Flattening
}

func (o *CSVCommaSeparatedValues) GetFormatType() *FormatType {
	if o == nil {
		return nil
	}
	return o.FormatType
}

func (o *CSVCommaSeparatedValues) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

type OutputFormatType string

const (
	OutputFormatTypeCSVCommaSeparatedValues                                  OutputFormatType = "CSV: Comma-Separated Values"
	OutputFormatTypeDestinationAzureBlobStorageJSONLinesNewlineDelimitedJSON OutputFormatType = "destination-azure-blob-storage_JSON Lines: Newline-delimited JSON"
)

// OutputFormat - Format of the data output.
type OutputFormat struct {
	CSVCommaSeparatedValues                                  *CSVCommaSeparatedValues                                  `queryParam:"inline"`
	DestinationAzureBlobStorageJSONLinesNewlineDelimitedJSON *DestinationAzureBlobStorageJSONLinesNewlineDelimitedJSON `queryParam:"inline"`

	Type OutputFormatType
}

func CreateOutputFormatCSVCommaSeparatedValues(csvCommaSeparatedValues CSVCommaSeparatedValues) OutputFormat {
	typ := OutputFormatTypeCSVCommaSeparatedValues

	return OutputFormat{
		CSVCommaSeparatedValues: &csvCommaSeparatedValues,
		Type:                    typ,
	}
}

func CreateOutputFormatDestinationAzureBlobStorageJSONLinesNewlineDelimitedJSON(destinationAzureBlobStorageJSONLinesNewlineDelimitedJSON DestinationAzureBlobStorageJSONLinesNewlineDelimitedJSON) OutputFormat {
	typ := OutputFormatTypeDestinationAzureBlobStorageJSONLinesNewlineDelimitedJSON

	return OutputFormat{
		DestinationAzureBlobStorageJSONLinesNewlineDelimitedJSON: &destinationAzureBlobStorageJSONLinesNewlineDelimitedJSON,
		Type: typ,
	}
}

func (u *OutputFormat) UnmarshalJSON(data []byte) error {

	var csvCommaSeparatedValues CSVCommaSeparatedValues = CSVCommaSeparatedValues{}
	if err := utils.UnmarshalJSON(data, &csvCommaSeparatedValues, "", true, true); err == nil {
		u.CSVCommaSeparatedValues = &csvCommaSeparatedValues
		u.Type = OutputFormatTypeCSVCommaSeparatedValues
		return nil
	}

	var destinationAzureBlobStorageJSONLinesNewlineDelimitedJSON DestinationAzureBlobStorageJSONLinesNewlineDelimitedJSON = DestinationAzureBlobStorageJSONLinesNewlineDelimitedJSON{}
	if err := utils.UnmarshalJSON(data, &destinationAzureBlobStorageJSONLinesNewlineDelimitedJSON, "", true, true); err == nil {
		u.DestinationAzureBlobStorageJSONLinesNewlineDelimitedJSON = &destinationAzureBlobStorageJSONLinesNewlineDelimitedJSON
		u.Type = OutputFormatTypeDestinationAzureBlobStorageJSONLinesNewlineDelimitedJSON
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for OutputFormat", string(data))
}

func (u OutputFormat) MarshalJSON() ([]byte, error) {
	if u.CSVCommaSeparatedValues != nil {
		return utils.MarshalJSON(u.CSVCommaSeparatedValues, "", true)
	}

	if u.DestinationAzureBlobStorageJSONLinesNewlineDelimitedJSON != nil {
		return utils.MarshalJSON(u.DestinationAzureBlobStorageJSONLinesNewlineDelimitedJSON, "", true)
	}

	return nil, errors.New("could not marshal union type OutputFormat: all fields are null")
}

type DestinationAzureBlobStorageAzureBlobStorage string

const (
	DestinationAzureBlobStorageAzureBlobStorageAzureBlobStorage DestinationAzureBlobStorageAzureBlobStorage = "azure-blob-storage"
)

func (e DestinationAzureBlobStorageAzureBlobStorage) ToPointer() *DestinationAzureBlobStorageAzureBlobStorage {
	return &e
}
func (e *DestinationAzureBlobStorageAzureBlobStorage) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "azure-blob-storage":
		*e = DestinationAzureBlobStorageAzureBlobStorage(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationAzureBlobStorageAzureBlobStorage: %v", v)
	}
}

type DestinationAzureBlobStorage struct {
	// The Azure blob storage account key. If you set this value, you must not set the Shared Access Signature.
	AzureBlobStorageAccountKey *string `json:"azure_blob_storage_account_key,omitempty"`
	// The name of the Azure Blob Storage Account. Read more <a href="https://learn.microsoft.com/en-gb/azure/storage/blobs/storage-blobs-introduction#storage-accounts">here</a>.
	AzureBlobStorageAccountName string `json:"azure_blob_storage_account_name"`
	// The name of the Azure Blob Storage Container. Read more <a href="https://learn.microsoft.com/en-gb/azure/storage/blobs/storage-blobs-introduction#containers">here</a>.
	AzureBlobStorageContainerName string `json:"azure_blob_storage_container_name"`
	// This is Azure Blob Storage endpoint domain name. Leave default value (or leave it empty if run container from command line) to use Microsoft native from example.
	AzureBlobStorageEndpointDomainName *string `json:"azure_blob_storage_endpoint_domain_name,omitempty"`
	// The amount of megabytes after which the connector should spill the records in a new blob object. Make sure to configure size greater than individual records. Enter 0 if not applicable.
	AzureBlobStorageSpillSize *int64 `default:"500" json:"azure_blob_storage_spill_size"`
	// Format of the data output.
	Format OutputFormat `json:"format"`
	// A shared access signature (SAS) provides secure delegated access to resources in your storage account. Read more <a href="https://learn.microsoft.com/en-gb/azure/storage/common/storage-sas-overview?toc=%2Fazure%2Fstorage%2Fblobs%2Ftoc.json&bc=%2Fazure%2Fstorage%2Fblobs%2Fbreadcrumb%2Ftoc.json">here</a>. If you set this value, you must not set the account key.
	SharedAccessSignature *string                                     `json:"shared_access_signature,omitempty"`
	destinationType       DestinationAzureBlobStorageAzureBlobStorage `const:"azure-blob-storage" json:"destinationType"`
}

func (d DestinationAzureBlobStorage) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationAzureBlobStorage) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *DestinationAzureBlobStorage) GetAzureBlobStorageAccountKey() *string {
	if o == nil {
		return nil
	}
	return o.AzureBlobStorageAccountKey
}

func (o *DestinationAzureBlobStorage) GetAzureBlobStorageAccountName() string {
	if o == nil {
		return ""
	}
	return o.AzureBlobStorageAccountName
}

func (o *DestinationAzureBlobStorage) GetAzureBlobStorageContainerName() string {
	if o == nil {
		return ""
	}
	return o.AzureBlobStorageContainerName
}

func (o *DestinationAzureBlobStorage) GetAzureBlobStorageEndpointDomainName() *string {
	if o == nil {
		return nil
	}
	return o.AzureBlobStorageEndpointDomainName
}

func (o *DestinationAzureBlobStorage) GetAzureBlobStorageSpillSize() *int64 {
	if o == nil {
		return nil
	}
	return o.AzureBlobStorageSpillSize
}

func (o *DestinationAzureBlobStorage) GetFormat() OutputFormat {
	if o == nil {
		return OutputFormat{}
	}
	return o.Format
}

func (o *DestinationAzureBlobStorage) GetSharedAccessSignature() *string {
	if o == nil {
		return nil
	}
	return o.SharedAccessSignature
}

func (o *DestinationAzureBlobStorage) GetDestinationType() DestinationAzureBlobStorageAzureBlobStorage {
	return DestinationAzureBlobStorageAzureBlobStorageAzureBlobStorage
}
