// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

type DestinationMssqlLoadType string

const (
	DestinationMssqlLoadTypeBulk DestinationMssqlLoadType = "BULK"
)

func (e DestinationMssqlLoadType) ToPointer() *DestinationMssqlLoadType {
	return &e
}
func (e *DestinationMssqlLoadType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "BULK":
		*e = DestinationMssqlLoadType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationMssqlLoadType: %v", v)
	}
}

// BulkLoad - Configuration details for using the BULK loading mechanism.
type BulkLoad struct {
	// The Azure blob storage account key. Mutually exclusive with a Shared Access Signature
	AzureBlobStorageAccountKey *string `json:"azure_blob_storage_account_key,omitempty"`
	// The name of the Azure Blob Storage account. See: https://learn.microsoft.com/azure/storage/blobs/storage-blobs-introduction#storage-accounts
	AzureBlobStorageAccountName string `json:"azure_blob_storage_account_name"`
	// The name of the Azure Blob Storage container. See: https://learn.microsoft.com/azure/storage/blobs/storage-blobs-introduction#containers
	AzureBlobStorageContainerName string `json:"azure_blob_storage_container_name"`
	// Specifies the external data source name configured in MSSQL, which references the Azure Blob container. See: https://learn.microsoft.com/sql/t-sql/statements/bulk-insert-transact-sql
	BulkLoadDataSource string `json:"bulk_load_data_source"`
	// When enabled, Airbyte will validate all values before loading them into the destination table. This provides stronger data integrity guarantees but may significantly impact performance.
	BulkLoadValidateValuesPreLoad *bool                     `default:"false" json:"bulk_load_validate_values_pre_load"`
	LoadType                      *DestinationMssqlLoadType `default:"BULK" json:"load_type"`
	// A shared access signature (SAS) provides secure delegated access to resources in your storage account. See: https://learn.microsoft.com/azure/storage/common/storage-sas-overview.Mutually exclusive with an account key
	SharedAccessSignature *string `json:"shared_access_signature,omitempty"`
	AdditionalProperties  any     `additionalProperties:"true" json:"-"`
}

func (b BulkLoad) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(b, "", false)
}

func (b *BulkLoad) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &b, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (b *BulkLoad) GetAzureBlobStorageAccountKey() *string {
	if b == nil {
		return nil
	}
	return b.AzureBlobStorageAccountKey
}

func (b *BulkLoad) GetAzureBlobStorageAccountName() string {
	if b == nil {
		return ""
	}
	return b.AzureBlobStorageAccountName
}

func (b *BulkLoad) GetAzureBlobStorageContainerName() string {
	if b == nil {
		return ""
	}
	return b.AzureBlobStorageContainerName
}

func (b *BulkLoad) GetBulkLoadDataSource() string {
	if b == nil {
		return ""
	}
	return b.BulkLoadDataSource
}

func (b *BulkLoad) GetBulkLoadValidateValuesPreLoad() *bool {
	if b == nil {
		return nil
	}
	return b.BulkLoadValidateValuesPreLoad
}

func (b *BulkLoad) GetLoadType() *DestinationMssqlLoadType {
	if b == nil {
		return nil
	}
	return b.LoadType
}

func (b *BulkLoad) GetSharedAccessSignature() *string {
	if b == nil {
		return nil
	}
	return b.SharedAccessSignature
}

func (b *BulkLoad) GetAdditionalProperties() any {
	if b == nil {
		return nil
	}
	return b.AdditionalProperties
}

type DestinationMssqlSchemasLoadType string

const (
	DestinationMssqlSchemasLoadTypeInsert DestinationMssqlSchemasLoadType = "INSERT"
)

func (e DestinationMssqlSchemasLoadType) ToPointer() *DestinationMssqlSchemasLoadType {
	return &e
}
func (e *DestinationMssqlSchemasLoadType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "INSERT":
		*e = DestinationMssqlSchemasLoadType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationMssqlSchemasLoadType: %v", v)
	}
}

// InsertLoad - Configuration details for using the INSERT loading mechanism.
type InsertLoad struct {
	LoadType             *DestinationMssqlSchemasLoadType `default:"INSERT" json:"load_type"`
	AdditionalProperties any                              `additionalProperties:"true" json:"-"`
}

func (i InsertLoad) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InsertLoad) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (i *InsertLoad) GetLoadType() *DestinationMssqlSchemasLoadType {
	if i == nil {
		return nil
	}
	return i.LoadType
}

func (i *InsertLoad) GetAdditionalProperties() any {
	if i == nil {
		return nil
	}
	return i.AdditionalProperties
}

type LoadTypeType string

const (
	LoadTypeTypeInsertLoad LoadTypeType = "Insert Load"
	LoadTypeTypeBulkLoad   LoadTypeType = "Bulk Load"
)

// LoadType - Specifies the type of load mechanism (e.g., BULK, INSERT) and its associated configuration.
type LoadType struct {
	InsertLoad *InsertLoad `queryParam:"inline" union:"member"`
	BulkLoad   *BulkLoad   `queryParam:"inline" union:"member"`

	Type LoadTypeType
}

func CreateLoadTypeInsertLoad(insertLoad InsertLoad) LoadType {
	typ := LoadTypeTypeInsertLoad

	return LoadType{
		InsertLoad: &insertLoad,
		Type:       typ,
	}
}

func CreateLoadTypeBulkLoad(bulkLoad BulkLoad) LoadType {
	typ := LoadTypeTypeBulkLoad

	return LoadType{
		BulkLoad: &bulkLoad,
		Type:     typ,
	}
}

func (u *LoadType) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var insertLoad InsertLoad = InsertLoad{}
	if err := utils.UnmarshalJSON(data, &insertLoad, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  LoadTypeTypeInsertLoad,
			Value: &insertLoad,
		})
	}

	var bulkLoad BulkLoad = BulkLoad{}
	if err := utils.UnmarshalJSON(data, &bulkLoad, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  LoadTypeTypeBulkLoad,
			Value: &bulkLoad,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for LoadType", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for LoadType", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(LoadTypeType)
	switch best.Type {
	case LoadTypeTypeInsertLoad:
		u.InsertLoad = best.Value.(*InsertLoad)
		return nil
	case LoadTypeTypeBulkLoad:
		u.BulkLoad = best.Value.(*BulkLoad)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for LoadType", string(data))
}

func (u LoadType) MarshalJSON() ([]byte, error) {
	if u.InsertLoad != nil {
		return utils.MarshalJSON(u.InsertLoad, "", true)
	}

	if u.BulkLoad != nil {
		return utils.MarshalJSON(u.BulkLoad, "", true)
	}

	return nil, errors.New("could not marshal union type LoadType: all fields are null")
}

type DestinationMssqlSchemasName string

const (
	DestinationMssqlSchemasNameEncryptedVerifyCertificate DestinationMssqlSchemasName = "encrypted_verify_certificate"
)

func (e DestinationMssqlSchemasName) ToPointer() *DestinationMssqlSchemasName {
	return &e
}
func (e *DestinationMssqlSchemasName) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "encrypted_verify_certificate":
		*e = DestinationMssqlSchemasName(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationMssqlSchemasName: %v", v)
	}
}

// DestinationMssqlEncryptedVerifyCertificate - Verify and use the certificate provided by the server.
type DestinationMssqlEncryptedVerifyCertificate struct {
	// Specifies the host name of the server. The value of this property must match the subject property of the certificate.
	HostNameInCertificate *string                      `json:"hostNameInCertificate,omitempty"`
	Name                  *DestinationMssqlSchemasName `default:"encrypted_verify_certificate" json:"name"`
	// Specifies the name of the trust store.
	TrustStoreName *string `json:"trustStoreName,omitempty"`
	// Specifies the password of the trust store.
	TrustStorePassword   *string `json:"trustStorePassword,omitempty"`
	AdditionalProperties any     `additionalProperties:"true" json:"-"`
}

func (d DestinationMssqlEncryptedVerifyCertificate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationMssqlEncryptedVerifyCertificate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationMssqlEncryptedVerifyCertificate) GetHostNameInCertificate() *string {
	if d == nil {
		return nil
	}
	return d.HostNameInCertificate
}

func (d *DestinationMssqlEncryptedVerifyCertificate) GetName() *DestinationMssqlSchemasName {
	if d == nil {
		return nil
	}
	return d.Name
}

func (d *DestinationMssqlEncryptedVerifyCertificate) GetTrustStoreName() *string {
	if d == nil {
		return nil
	}
	return d.TrustStoreName
}

func (d *DestinationMssqlEncryptedVerifyCertificate) GetTrustStorePassword() *string {
	if d == nil {
		return nil
	}
	return d.TrustStorePassword
}

func (d *DestinationMssqlEncryptedVerifyCertificate) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationMssqlName string

const (
	DestinationMssqlNameEncryptedTrustServerCertificate DestinationMssqlName = "encrypted_trust_server_certificate"
)

func (e DestinationMssqlName) ToPointer() *DestinationMssqlName {
	return &e
}
func (e *DestinationMssqlName) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "encrypted_trust_server_certificate":
		*e = DestinationMssqlName(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationMssqlName: %v", v)
	}
}

// DestinationMssqlEncryptedTrustServerCertificate - Use the certificate provided by the server without verification. (For testing purposes only!)
type DestinationMssqlEncryptedTrustServerCertificate struct {
	Name                 *DestinationMssqlName `default:"encrypted_trust_server_certificate" json:"name"`
	AdditionalProperties any                   `additionalProperties:"true" json:"-"`
}

func (d DestinationMssqlEncryptedTrustServerCertificate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationMssqlEncryptedTrustServerCertificate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationMssqlEncryptedTrustServerCertificate) GetName() *DestinationMssqlName {
	if d == nil {
		return nil
	}
	return d.Name
}

func (d *DestinationMssqlEncryptedTrustServerCertificate) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type Name string

const (
	NameUnencrypted Name = "unencrypted"
)

func (e Name) ToPointer() *Name {
	return &e
}
func (e *Name) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "unencrypted":
		*e = Name(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Name: %v", v)
	}
}

// DestinationMssqlUnencrypted - The data transfer will not be encrypted.
type DestinationMssqlUnencrypted struct {
	Name                 *Name `default:"unencrypted" json:"name"`
	AdditionalProperties any   `additionalProperties:"true" json:"-"`
}

func (d DestinationMssqlUnencrypted) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationMssqlUnencrypted) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationMssqlUnencrypted) GetName() *Name {
	if d == nil {
		return nil
	}
	return d.Name
}

func (d *DestinationMssqlUnencrypted) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type SSLMethodType string

const (
	SSLMethodTypeDestinationMssqlUnencrypted                     SSLMethodType = "destination-mssql_Unencrypted"
	SSLMethodTypeDestinationMssqlEncryptedTrustServerCertificate SSLMethodType = "destination-mssql_Encrypted (trust server certificate)"
	SSLMethodTypeDestinationMssqlEncryptedVerifyCertificate      SSLMethodType = "destination-mssql_Encrypted (verify certificate)"
)

// SSLMethod - The encryption method which is used to communicate with the database.
type SSLMethod struct {
	DestinationMssqlUnencrypted                     *DestinationMssqlUnencrypted                     `queryParam:"inline" union:"member"`
	DestinationMssqlEncryptedTrustServerCertificate *DestinationMssqlEncryptedTrustServerCertificate `queryParam:"inline" union:"member"`
	DestinationMssqlEncryptedVerifyCertificate      *DestinationMssqlEncryptedVerifyCertificate      `queryParam:"inline" union:"member"`

	Type SSLMethodType
}

func CreateSSLMethodDestinationMssqlUnencrypted(destinationMssqlUnencrypted DestinationMssqlUnencrypted) SSLMethod {
	typ := SSLMethodTypeDestinationMssqlUnencrypted

	return SSLMethod{
		DestinationMssqlUnencrypted: &destinationMssqlUnencrypted,
		Type:                        typ,
	}
}

func CreateSSLMethodDestinationMssqlEncryptedTrustServerCertificate(destinationMssqlEncryptedTrustServerCertificate DestinationMssqlEncryptedTrustServerCertificate) SSLMethod {
	typ := SSLMethodTypeDestinationMssqlEncryptedTrustServerCertificate

	return SSLMethod{
		DestinationMssqlEncryptedTrustServerCertificate: &destinationMssqlEncryptedTrustServerCertificate,
		Type: typ,
	}
}

func CreateSSLMethodDestinationMssqlEncryptedVerifyCertificate(destinationMssqlEncryptedVerifyCertificate DestinationMssqlEncryptedVerifyCertificate) SSLMethod {
	typ := SSLMethodTypeDestinationMssqlEncryptedVerifyCertificate

	return SSLMethod{
		DestinationMssqlEncryptedVerifyCertificate: &destinationMssqlEncryptedVerifyCertificate,
		Type: typ,
	}
}

func (u *SSLMethod) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var destinationMssqlUnencrypted DestinationMssqlUnencrypted = DestinationMssqlUnencrypted{}
	if err := utils.UnmarshalJSON(data, &destinationMssqlUnencrypted, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SSLMethodTypeDestinationMssqlUnencrypted,
			Value: &destinationMssqlUnencrypted,
		})
	}

	var destinationMssqlEncryptedTrustServerCertificate DestinationMssqlEncryptedTrustServerCertificate = DestinationMssqlEncryptedTrustServerCertificate{}
	if err := utils.UnmarshalJSON(data, &destinationMssqlEncryptedTrustServerCertificate, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SSLMethodTypeDestinationMssqlEncryptedTrustServerCertificate,
			Value: &destinationMssqlEncryptedTrustServerCertificate,
		})
	}

	var destinationMssqlEncryptedVerifyCertificate DestinationMssqlEncryptedVerifyCertificate = DestinationMssqlEncryptedVerifyCertificate{}
	if err := utils.UnmarshalJSON(data, &destinationMssqlEncryptedVerifyCertificate, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SSLMethodTypeDestinationMssqlEncryptedVerifyCertificate,
			Value: &destinationMssqlEncryptedVerifyCertificate,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SSLMethod", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SSLMethod", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SSLMethodType)
	switch best.Type {
	case SSLMethodTypeDestinationMssqlUnencrypted:
		u.DestinationMssqlUnencrypted = best.Value.(*DestinationMssqlUnencrypted)
		return nil
	case SSLMethodTypeDestinationMssqlEncryptedTrustServerCertificate:
		u.DestinationMssqlEncryptedTrustServerCertificate = best.Value.(*DestinationMssqlEncryptedTrustServerCertificate)
		return nil
	case SSLMethodTypeDestinationMssqlEncryptedVerifyCertificate:
		u.DestinationMssqlEncryptedVerifyCertificate = best.Value.(*DestinationMssqlEncryptedVerifyCertificate)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SSLMethod", string(data))
}

func (u SSLMethod) MarshalJSON() ([]byte, error) {
	if u.DestinationMssqlUnencrypted != nil {
		return utils.MarshalJSON(u.DestinationMssqlUnencrypted, "", true)
	}

	if u.DestinationMssqlEncryptedTrustServerCertificate != nil {
		return utils.MarshalJSON(u.DestinationMssqlEncryptedTrustServerCertificate, "", true)
	}

	if u.DestinationMssqlEncryptedVerifyCertificate != nil {
		return utils.MarshalJSON(u.DestinationMssqlEncryptedVerifyCertificate, "", true)
	}

	return nil, errors.New("could not marshal union type SSLMethod: all fields are null")
}

type DestinationMssqlSchemasTunnelMethodTunnelMethod string

const (
	DestinationMssqlSchemasTunnelMethodTunnelMethodSSHPasswordAuth DestinationMssqlSchemasTunnelMethodTunnelMethod = "SSH_PASSWORD_AUTH"
)

func (e DestinationMssqlSchemasTunnelMethodTunnelMethod) ToPointer() *DestinationMssqlSchemasTunnelMethodTunnelMethod {
	return &e
}
func (e *DestinationMssqlSchemasTunnelMethodTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_PASSWORD_AUTH":
		*e = DestinationMssqlSchemasTunnelMethodTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationMssqlSchemasTunnelMethodTunnelMethod: %v", v)
	}
}

// DestinationMssqlPasswordAuthentication - Connect through a jump server tunnel host using username and password authentication
type DestinationMssqlPasswordAuthentication struct {
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost   string                                           `json:"tunnel_host"`
	TunnelMethod *DestinationMssqlSchemasTunnelMethodTunnelMethod `default:"SSH_PASSWORD_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser string `json:"tunnel_user"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword   string `json:"tunnel_user_password"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (d DestinationMssqlPasswordAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationMssqlPasswordAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationMssqlPasswordAuthentication) GetTunnelHost() string {
	if d == nil {
		return ""
	}
	return d.TunnelHost
}

func (d *DestinationMssqlPasswordAuthentication) GetTunnelMethod() *DestinationMssqlSchemasTunnelMethodTunnelMethod {
	if d == nil {
		return nil
	}
	return d.TunnelMethod
}

func (d *DestinationMssqlPasswordAuthentication) GetTunnelPort() *int64 {
	if d == nil {
		return nil
	}
	return d.TunnelPort
}

func (d *DestinationMssqlPasswordAuthentication) GetTunnelUser() string {
	if d == nil {
		return ""
	}
	return d.TunnelUser
}

func (d *DestinationMssqlPasswordAuthentication) GetTunnelUserPassword() string {
	if d == nil {
		return ""
	}
	return d.TunnelUserPassword
}

func (d *DestinationMssqlPasswordAuthentication) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationMssqlSchemasTunnelMethod string

const (
	DestinationMssqlSchemasTunnelMethodSSHKeyAuth DestinationMssqlSchemasTunnelMethod = "SSH_KEY_AUTH"
)

func (e DestinationMssqlSchemasTunnelMethod) ToPointer() *DestinationMssqlSchemasTunnelMethod {
	return &e
}
func (e *DestinationMssqlSchemasTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_KEY_AUTH":
		*e = DestinationMssqlSchemasTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationMssqlSchemasTunnelMethod: %v", v)
	}
}

// DestinationMssqlSSHKeyAuthentication - Connect through a jump server tunnel host using username and ssh key
type DestinationMssqlSSHKeyAuthentication struct {
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey string `json:"ssh_key"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost   string                               `json:"tunnel_host"`
	TunnelMethod *DestinationMssqlSchemasTunnelMethod `default:"SSH_KEY_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser           string `json:"tunnel_user"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (d DestinationMssqlSSHKeyAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationMssqlSSHKeyAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationMssqlSSHKeyAuthentication) GetSSHKey() string {
	if d == nil {
		return ""
	}
	return d.SSHKey
}

func (d *DestinationMssqlSSHKeyAuthentication) GetTunnelHost() string {
	if d == nil {
		return ""
	}
	return d.TunnelHost
}

func (d *DestinationMssqlSSHKeyAuthentication) GetTunnelMethod() *DestinationMssqlSchemasTunnelMethod {
	if d == nil {
		return nil
	}
	return d.TunnelMethod
}

func (d *DestinationMssqlSSHKeyAuthentication) GetTunnelPort() *int64 {
	if d == nil {
		return nil
	}
	return d.TunnelPort
}

func (d *DestinationMssqlSSHKeyAuthentication) GetTunnelUser() string {
	if d == nil {
		return ""
	}
	return d.TunnelUser
}

func (d *DestinationMssqlSSHKeyAuthentication) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationMssqlTunnelMethod string

const (
	DestinationMssqlTunnelMethodNoTunnel DestinationMssqlTunnelMethod = "NO_TUNNEL"
)

func (e DestinationMssqlTunnelMethod) ToPointer() *DestinationMssqlTunnelMethod {
	return &e
}
func (e *DestinationMssqlTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NO_TUNNEL":
		*e = DestinationMssqlTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationMssqlTunnelMethod: %v", v)
	}
}

// DestinationMssqlNoTunnel - No ssh tunnel needed to connect to database
type DestinationMssqlNoTunnel struct {
	TunnelMethod         *DestinationMssqlTunnelMethod `default:"NO_TUNNEL" json:"tunnel_method"`
	AdditionalProperties any                           `additionalProperties:"true" json:"-"`
}

func (d DestinationMssqlNoTunnel) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationMssqlNoTunnel) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationMssqlNoTunnel) GetTunnelMethod() *DestinationMssqlTunnelMethod {
	if d == nil {
		return nil
	}
	return d.TunnelMethod
}

func (d *DestinationMssqlNoTunnel) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationMssqlSSHTunnelMethodType string

const (
	DestinationMssqlSSHTunnelMethodTypeDestinationMssqlNoTunnel               DestinationMssqlSSHTunnelMethodType = "destination-mssql_No Tunnel"
	DestinationMssqlSSHTunnelMethodTypeDestinationMssqlSSHKeyAuthentication   DestinationMssqlSSHTunnelMethodType = "destination-mssql_SSH Key Authentication"
	DestinationMssqlSSHTunnelMethodTypeDestinationMssqlPasswordAuthentication DestinationMssqlSSHTunnelMethodType = "destination-mssql_Password Authentication"
)

// DestinationMssqlSSHTunnelMethod - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type DestinationMssqlSSHTunnelMethod struct {
	DestinationMssqlNoTunnel               *DestinationMssqlNoTunnel               `queryParam:"inline" union:"member"`
	DestinationMssqlSSHKeyAuthentication   *DestinationMssqlSSHKeyAuthentication   `queryParam:"inline" union:"member"`
	DestinationMssqlPasswordAuthentication *DestinationMssqlPasswordAuthentication `queryParam:"inline" union:"member"`

	Type DestinationMssqlSSHTunnelMethodType
}

func CreateDestinationMssqlSSHTunnelMethodDestinationMssqlNoTunnel(destinationMssqlNoTunnel DestinationMssqlNoTunnel) DestinationMssqlSSHTunnelMethod {
	typ := DestinationMssqlSSHTunnelMethodTypeDestinationMssqlNoTunnel

	return DestinationMssqlSSHTunnelMethod{
		DestinationMssqlNoTunnel: &destinationMssqlNoTunnel,
		Type:                     typ,
	}
}

func CreateDestinationMssqlSSHTunnelMethodDestinationMssqlSSHKeyAuthentication(destinationMssqlSSHKeyAuthentication DestinationMssqlSSHKeyAuthentication) DestinationMssqlSSHTunnelMethod {
	typ := DestinationMssqlSSHTunnelMethodTypeDestinationMssqlSSHKeyAuthentication

	return DestinationMssqlSSHTunnelMethod{
		DestinationMssqlSSHKeyAuthentication: &destinationMssqlSSHKeyAuthentication,
		Type:                                 typ,
	}
}

func CreateDestinationMssqlSSHTunnelMethodDestinationMssqlPasswordAuthentication(destinationMssqlPasswordAuthentication DestinationMssqlPasswordAuthentication) DestinationMssqlSSHTunnelMethod {
	typ := DestinationMssqlSSHTunnelMethodTypeDestinationMssqlPasswordAuthentication

	return DestinationMssqlSSHTunnelMethod{
		DestinationMssqlPasswordAuthentication: &destinationMssqlPasswordAuthentication,
		Type:                                   typ,
	}
}

func (u *DestinationMssqlSSHTunnelMethod) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var destinationMssqlNoTunnel DestinationMssqlNoTunnel = DestinationMssqlNoTunnel{}
	if err := utils.UnmarshalJSON(data, &destinationMssqlNoTunnel, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationMssqlSSHTunnelMethodTypeDestinationMssqlNoTunnel,
			Value: &destinationMssqlNoTunnel,
		})
	}

	var destinationMssqlSSHKeyAuthentication DestinationMssqlSSHKeyAuthentication = DestinationMssqlSSHKeyAuthentication{}
	if err := utils.UnmarshalJSON(data, &destinationMssqlSSHKeyAuthentication, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationMssqlSSHTunnelMethodTypeDestinationMssqlSSHKeyAuthentication,
			Value: &destinationMssqlSSHKeyAuthentication,
		})
	}

	var destinationMssqlPasswordAuthentication DestinationMssqlPasswordAuthentication = DestinationMssqlPasswordAuthentication{}
	if err := utils.UnmarshalJSON(data, &destinationMssqlPasswordAuthentication, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationMssqlSSHTunnelMethodTypeDestinationMssqlPasswordAuthentication,
			Value: &destinationMssqlPasswordAuthentication,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationMssqlSSHTunnelMethod", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationMssqlSSHTunnelMethod", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(DestinationMssqlSSHTunnelMethodType)
	switch best.Type {
	case DestinationMssqlSSHTunnelMethodTypeDestinationMssqlNoTunnel:
		u.DestinationMssqlNoTunnel = best.Value.(*DestinationMssqlNoTunnel)
		return nil
	case DestinationMssqlSSHTunnelMethodTypeDestinationMssqlSSHKeyAuthentication:
		u.DestinationMssqlSSHKeyAuthentication = best.Value.(*DestinationMssqlSSHKeyAuthentication)
		return nil
	case DestinationMssqlSSHTunnelMethodTypeDestinationMssqlPasswordAuthentication:
		u.DestinationMssqlPasswordAuthentication = best.Value.(*DestinationMssqlPasswordAuthentication)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationMssqlSSHTunnelMethod", string(data))
}

func (u DestinationMssqlSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.DestinationMssqlNoTunnel != nil {
		return utils.MarshalJSON(u.DestinationMssqlNoTunnel, "", true)
	}

	if u.DestinationMssqlSSHKeyAuthentication != nil {
		return utils.MarshalJSON(u.DestinationMssqlSSHKeyAuthentication, "", true)
	}

	if u.DestinationMssqlPasswordAuthentication != nil {
		return utils.MarshalJSON(u.DestinationMssqlPasswordAuthentication, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationMssqlSSHTunnelMethod: all fields are null")
}

type DestinationMssqlDestinationType string

const (
	DestinationMssqlDestinationTypeMssql DestinationMssqlDestinationType = "mssql"
)

func (e DestinationMssqlDestinationType) ToPointer() *DestinationMssqlDestinationType {
	return &e
}
func (e *DestinationMssqlDestinationType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "mssql":
		*e = DestinationMssqlDestinationType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationMssqlDestinationType: %v", v)
	}
}

type DestinationMssql struct {
	// The name of the MSSQL database.
	Database string `json:"database"`
	// The host name of the MSSQL database.
	Host string `json:"host"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// Specifies the type of load mechanism (e.g., BULK, INSERT) and its associated configuration.
	LoadType LoadType `json:"load_type"`
	// The password associated with this username.
	Password *string `json:"password,omitempty"`
	// The port of the MSSQL database.
	Port int64 `json:"port"`
	// The default schema tables are written to if the source does not specify a namespace. The usual value for this field is "public".
	Schema *string `default:"public" json:"schema"`
	// The encryption method which is used to communicate with the database.
	SslMethod SSLMethod `json:"ssl_method"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod *DestinationMssqlSSHTunnelMethod `json:"tunnel_method,omitempty"`
	// The username which is used to access the database.
	User                 string                           `json:"user"`
	destinationType      *DestinationMssqlDestinationType `const:"mssql" json:"destinationType"`
	AdditionalProperties any                              `additionalProperties:"true" json:"-"`
}

func (d DestinationMssql) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationMssql) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationMssql) GetDatabase() string {
	if d == nil {
		return ""
	}
	return d.Database
}

func (d *DestinationMssql) GetHost() string {
	if d == nil {
		return ""
	}
	return d.Host
}

func (d *DestinationMssql) GetJdbcURLParams() *string {
	if d == nil {
		return nil
	}
	return d.JdbcURLParams
}

func (d *DestinationMssql) GetLoadType() LoadType {
	if d == nil {
		return LoadType{}
	}
	return d.LoadType
}

func (d *DestinationMssql) GetPassword() *string {
	if d == nil {
		return nil
	}
	return d.Password
}

func (d *DestinationMssql) GetPort() int64 {
	if d == nil {
		return 0
	}
	return d.Port
}

func (d *DestinationMssql) GetSchema() *string {
	if d == nil {
		return nil
	}
	return d.Schema
}

func (d *DestinationMssql) GetSslMethod() SSLMethod {
	if d == nil {
		return SSLMethod{}
	}
	return d.SslMethod
}

func (d *DestinationMssql) GetTunnelMethod() *DestinationMssqlSSHTunnelMethod {
	if d == nil {
		return nil
	}
	return d.TunnelMethod
}

func (d *DestinationMssql) GetUser() string {
	if d == nil {
		return ""
	}
	return d.User
}

func (d *DestinationMssql) GetDestinationType() *DestinationMssqlDestinationType {
	return DestinationMssqlDestinationTypeMssql.ToPointer()
}

func (d *DestinationMssql) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}
