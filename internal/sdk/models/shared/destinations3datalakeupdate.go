// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

// DestinationS3DataLakeUpdateS3BucketRegion - The region of the S3 bucket. See <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-available-regions">here</a> for all region codes.
type DestinationS3DataLakeUpdateS3BucketRegion string

const (
	DestinationS3DataLakeUpdateS3BucketRegionUnknown      DestinationS3DataLakeUpdateS3BucketRegion = ""
	DestinationS3DataLakeUpdateS3BucketRegionAfSouth1     DestinationS3DataLakeUpdateS3BucketRegion = "af-south-1"
	DestinationS3DataLakeUpdateS3BucketRegionApEast1      DestinationS3DataLakeUpdateS3BucketRegion = "ap-east-1"
	DestinationS3DataLakeUpdateS3BucketRegionApNortheast1 DestinationS3DataLakeUpdateS3BucketRegion = "ap-northeast-1"
	DestinationS3DataLakeUpdateS3BucketRegionApNortheast2 DestinationS3DataLakeUpdateS3BucketRegion = "ap-northeast-2"
	DestinationS3DataLakeUpdateS3BucketRegionApNortheast3 DestinationS3DataLakeUpdateS3BucketRegion = "ap-northeast-3"
	DestinationS3DataLakeUpdateS3BucketRegionApSouth1     DestinationS3DataLakeUpdateS3BucketRegion = "ap-south-1"
	DestinationS3DataLakeUpdateS3BucketRegionApSouth2     DestinationS3DataLakeUpdateS3BucketRegion = "ap-south-2"
	DestinationS3DataLakeUpdateS3BucketRegionApSoutheast1 DestinationS3DataLakeUpdateS3BucketRegion = "ap-southeast-1"
	DestinationS3DataLakeUpdateS3BucketRegionApSoutheast2 DestinationS3DataLakeUpdateS3BucketRegion = "ap-southeast-2"
	DestinationS3DataLakeUpdateS3BucketRegionApSoutheast3 DestinationS3DataLakeUpdateS3BucketRegion = "ap-southeast-3"
	DestinationS3DataLakeUpdateS3BucketRegionApSoutheast4 DestinationS3DataLakeUpdateS3BucketRegion = "ap-southeast-4"
	DestinationS3DataLakeUpdateS3BucketRegionCaCentral1   DestinationS3DataLakeUpdateS3BucketRegion = "ca-central-1"
	DestinationS3DataLakeUpdateS3BucketRegionCaWest1      DestinationS3DataLakeUpdateS3BucketRegion = "ca-west-1"
	DestinationS3DataLakeUpdateS3BucketRegionCnNorth1     DestinationS3DataLakeUpdateS3BucketRegion = "cn-north-1"
	DestinationS3DataLakeUpdateS3BucketRegionCnNorthwest1 DestinationS3DataLakeUpdateS3BucketRegion = "cn-northwest-1"
	DestinationS3DataLakeUpdateS3BucketRegionEuCentral1   DestinationS3DataLakeUpdateS3BucketRegion = "eu-central-1"
	DestinationS3DataLakeUpdateS3BucketRegionEuCentral2   DestinationS3DataLakeUpdateS3BucketRegion = "eu-central-2"
	DestinationS3DataLakeUpdateS3BucketRegionEuNorth1     DestinationS3DataLakeUpdateS3BucketRegion = "eu-north-1"
	DestinationS3DataLakeUpdateS3BucketRegionEuSouth1     DestinationS3DataLakeUpdateS3BucketRegion = "eu-south-1"
	DestinationS3DataLakeUpdateS3BucketRegionEuSouth2     DestinationS3DataLakeUpdateS3BucketRegion = "eu-south-2"
	DestinationS3DataLakeUpdateS3BucketRegionEuWest1      DestinationS3DataLakeUpdateS3BucketRegion = "eu-west-1"
	DestinationS3DataLakeUpdateS3BucketRegionEuWest2      DestinationS3DataLakeUpdateS3BucketRegion = "eu-west-2"
	DestinationS3DataLakeUpdateS3BucketRegionEuWest3      DestinationS3DataLakeUpdateS3BucketRegion = "eu-west-3"
	DestinationS3DataLakeUpdateS3BucketRegionIlCentral1   DestinationS3DataLakeUpdateS3BucketRegion = "il-central-1"
	DestinationS3DataLakeUpdateS3BucketRegionMeCentral1   DestinationS3DataLakeUpdateS3BucketRegion = "me-central-1"
	DestinationS3DataLakeUpdateS3BucketRegionMeSouth1     DestinationS3DataLakeUpdateS3BucketRegion = "me-south-1"
	DestinationS3DataLakeUpdateS3BucketRegionSaEast1      DestinationS3DataLakeUpdateS3BucketRegion = "sa-east-1"
	DestinationS3DataLakeUpdateS3BucketRegionUsEast1      DestinationS3DataLakeUpdateS3BucketRegion = "us-east-1"
	DestinationS3DataLakeUpdateS3BucketRegionUsEast2      DestinationS3DataLakeUpdateS3BucketRegion = "us-east-2"
	DestinationS3DataLakeUpdateS3BucketRegionUsGovEast1   DestinationS3DataLakeUpdateS3BucketRegion = "us-gov-east-1"
	DestinationS3DataLakeUpdateS3BucketRegionUsGovWest1   DestinationS3DataLakeUpdateS3BucketRegion = "us-gov-west-1"
	DestinationS3DataLakeUpdateS3BucketRegionUsWest1      DestinationS3DataLakeUpdateS3BucketRegion = "us-west-1"
	DestinationS3DataLakeUpdateS3BucketRegionUsWest2      DestinationS3DataLakeUpdateS3BucketRegion = "us-west-2"
)

func (e DestinationS3DataLakeUpdateS3BucketRegion) ToPointer() *DestinationS3DataLakeUpdateS3BucketRegion {
	return &e
}
func (e *DestinationS3DataLakeUpdateS3BucketRegion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "":
		fallthrough
	case "af-south-1":
		fallthrough
	case "ap-east-1":
		fallthrough
	case "ap-northeast-1":
		fallthrough
	case "ap-northeast-2":
		fallthrough
	case "ap-northeast-3":
		fallthrough
	case "ap-south-1":
		fallthrough
	case "ap-south-2":
		fallthrough
	case "ap-southeast-1":
		fallthrough
	case "ap-southeast-2":
		fallthrough
	case "ap-southeast-3":
		fallthrough
	case "ap-southeast-4":
		fallthrough
	case "ca-central-1":
		fallthrough
	case "ca-west-1":
		fallthrough
	case "cn-north-1":
		fallthrough
	case "cn-northwest-1":
		fallthrough
	case "eu-central-1":
		fallthrough
	case "eu-central-2":
		fallthrough
	case "eu-north-1":
		fallthrough
	case "eu-south-1":
		fallthrough
	case "eu-south-2":
		fallthrough
	case "eu-west-1":
		fallthrough
	case "eu-west-2":
		fallthrough
	case "eu-west-3":
		fallthrough
	case "il-central-1":
		fallthrough
	case "me-central-1":
		fallthrough
	case "me-south-1":
		fallthrough
	case "sa-east-1":
		fallthrough
	case "us-east-1":
		fallthrough
	case "us-east-2":
		fallthrough
	case "us-gov-east-1":
		fallthrough
	case "us-gov-west-1":
		fallthrough
	case "us-west-1":
		fallthrough
	case "us-west-2":
		*e = DestinationS3DataLakeUpdateS3BucketRegion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3DataLakeUpdateS3BucketRegion: %v", v)
	}
}

type DestinationS3DataLakeUpdateSchemasCatalogTypeCatalogType string

const (
	DestinationS3DataLakeUpdateSchemasCatalogTypeCatalogTypeRest DestinationS3DataLakeUpdateSchemasCatalogTypeCatalogType = "REST"
)

func (e DestinationS3DataLakeUpdateSchemasCatalogTypeCatalogType) ToPointer() *DestinationS3DataLakeUpdateSchemasCatalogTypeCatalogType {
	return &e
}
func (e *DestinationS3DataLakeUpdateSchemasCatalogTypeCatalogType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "REST":
		*e = DestinationS3DataLakeUpdateSchemasCatalogTypeCatalogType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3DataLakeUpdateSchemasCatalogTypeCatalogType: %v", v)
	}
}

// DestinationS3DataLakeUpdateRestCatalog - Configuration details for connecting to a REST catalog.
type DestinationS3DataLakeUpdateRestCatalog struct {
	CatalogType *DestinationS3DataLakeUpdateSchemasCatalogTypeCatalogType `default:"REST" json:"catalog_type"`
	// The base URL of the Rest server used to connect to the Rest catalog.
	ServerURI string `json:"server_uri"`
	// The namespace to be used in the Table identifier.
	//            This will ONLY be used if the `Destination Namespace` setting for the connection is set to
	//            `Destination-defined` or `Source-defined`
	Namespace            string `json:"namespace"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (d DestinationS3DataLakeUpdateRestCatalog) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationS3DataLakeUpdateRestCatalog) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationS3DataLakeUpdateRestCatalog) GetCatalogType() *DestinationS3DataLakeUpdateSchemasCatalogTypeCatalogType {
	if o == nil {
		return nil
	}
	return o.CatalogType
}

func (o *DestinationS3DataLakeUpdateRestCatalog) GetServerURI() string {
	if o == nil {
		return ""
	}
	return o.ServerURI
}

func (o *DestinationS3DataLakeUpdateRestCatalog) GetNamespace() string {
	if o == nil {
		return ""
	}
	return o.Namespace
}

func (o *DestinationS3DataLakeUpdateRestCatalog) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

type DestinationS3DataLakeUpdateSchemasCatalogType string

const (
	DestinationS3DataLakeUpdateSchemasCatalogTypeGlue DestinationS3DataLakeUpdateSchemasCatalogType = "GLUE"
)

func (e DestinationS3DataLakeUpdateSchemasCatalogType) ToPointer() *DestinationS3DataLakeUpdateSchemasCatalogType {
	return &e
}
func (e *DestinationS3DataLakeUpdateSchemasCatalogType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "GLUE":
		*e = DestinationS3DataLakeUpdateSchemasCatalogType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3DataLakeUpdateSchemasCatalogType: %v", v)
	}
}

// DestinationS3DataLakeUpdateGlueCatalog - Configuration details for connecting to an AWS Glue-based Iceberg catalog.
type DestinationS3DataLakeUpdateGlueCatalog struct {
	CatalogType *DestinationS3DataLakeUpdateSchemasCatalogType `default:"GLUE" json:"catalog_type"`
	// The AWS Account ID associated with the Glue service used by the Iceberg catalog.
	GlueID string `json:"glue_id"`
	// The ARN of the AWS role to assume. Only usable in Airbyte Cloud.
	RoleArn *string `json:"role_arn,omitempty"`
	// The Glue database name. This will ONLY be used if the `Destination Namespace` setting for the connection is set to `Destination-defined` or `Source-defined`
	DatabaseName         string `json:"database_name"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (d DestinationS3DataLakeUpdateGlueCatalog) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationS3DataLakeUpdateGlueCatalog) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationS3DataLakeUpdateGlueCatalog) GetCatalogType() *DestinationS3DataLakeUpdateSchemasCatalogType {
	if o == nil {
		return nil
	}
	return o.CatalogType
}

func (o *DestinationS3DataLakeUpdateGlueCatalog) GetGlueID() string {
	if o == nil {
		return ""
	}
	return o.GlueID
}

func (o *DestinationS3DataLakeUpdateGlueCatalog) GetRoleArn() *string {
	if o == nil {
		return nil
	}
	return o.RoleArn
}

func (o *DestinationS3DataLakeUpdateGlueCatalog) GetDatabaseName() string {
	if o == nil {
		return ""
	}
	return o.DatabaseName
}

func (o *DestinationS3DataLakeUpdateGlueCatalog) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

type DestinationS3DataLakeUpdateSchemasCatalogTypeCatalogTypeCatalogType string

const (
	DestinationS3DataLakeUpdateSchemasCatalogTypeCatalogTypeCatalogTypeNessie DestinationS3DataLakeUpdateSchemasCatalogTypeCatalogTypeCatalogType = "NESSIE"
)

func (e DestinationS3DataLakeUpdateSchemasCatalogTypeCatalogTypeCatalogType) ToPointer() *DestinationS3DataLakeUpdateSchemasCatalogTypeCatalogTypeCatalogType {
	return &e
}
func (e *DestinationS3DataLakeUpdateSchemasCatalogTypeCatalogTypeCatalogType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NESSIE":
		*e = DestinationS3DataLakeUpdateSchemasCatalogTypeCatalogTypeCatalogType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3DataLakeUpdateSchemasCatalogTypeCatalogTypeCatalogType: %v", v)
	}
}

// DestinationS3DataLakeUpdateNessieCatalog - Configuration details for connecting to a Nessie-based Iceberg catalog.
type DestinationS3DataLakeUpdateNessieCatalog struct {
	CatalogType *DestinationS3DataLakeUpdateSchemasCatalogTypeCatalogTypeCatalogType `default:"NESSIE" json:"catalog_type"`
	// The base URL of the Nessie server used to connect to the Nessie catalog.
	ServerURI string `json:"server_uri"`
	// Optional token for authentication with the Nessie server.
	AccessToken *string `json:"access_token,omitempty"`
	// The Nessie namespace to be used in the Table identifier.
	//            This will ONLY be used if the `Destination Namespace` setting for the connection is set to
	//            `Destination-defined` or `Source-defined`
	Namespace            string `json:"namespace"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (d DestinationS3DataLakeUpdateNessieCatalog) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationS3DataLakeUpdateNessieCatalog) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationS3DataLakeUpdateNessieCatalog) GetCatalogType() *DestinationS3DataLakeUpdateSchemasCatalogTypeCatalogTypeCatalogType {
	if o == nil {
		return nil
	}
	return o.CatalogType
}

func (o *DestinationS3DataLakeUpdateNessieCatalog) GetServerURI() string {
	if o == nil {
		return ""
	}
	return o.ServerURI
}

func (o *DestinationS3DataLakeUpdateNessieCatalog) GetAccessToken() *string {
	if o == nil {
		return nil
	}
	return o.AccessToken
}

func (o *DestinationS3DataLakeUpdateNessieCatalog) GetNamespace() string {
	if o == nil {
		return ""
	}
	return o.Namespace
}

func (o *DestinationS3DataLakeUpdateNessieCatalog) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

type DestinationS3DataLakeUpdateCatalogTypeType string

const (
	DestinationS3DataLakeUpdateCatalogTypeTypeDestinationS3DataLakeUpdateNessieCatalog DestinationS3DataLakeUpdateCatalogTypeType = "destination-s3-data-lake-update_Nessie Catalog"
	DestinationS3DataLakeUpdateCatalogTypeTypeDestinationS3DataLakeUpdateGlueCatalog   DestinationS3DataLakeUpdateCatalogTypeType = "destination-s3-data-lake-update_Glue Catalog"
	DestinationS3DataLakeUpdateCatalogTypeTypeDestinationS3DataLakeUpdateRestCatalog   DestinationS3DataLakeUpdateCatalogTypeType = "destination-s3-data-lake-update_Rest Catalog"
)

// DestinationS3DataLakeUpdateCatalogType - Specifies the type of Iceberg catalog (e.g., NESSIE, GLUE, REST) and its associated configuration.
type DestinationS3DataLakeUpdateCatalogType struct {
	DestinationS3DataLakeUpdateNessieCatalog *DestinationS3DataLakeUpdateNessieCatalog `queryParam:"inline"`
	DestinationS3DataLakeUpdateGlueCatalog   *DestinationS3DataLakeUpdateGlueCatalog   `queryParam:"inline"`
	DestinationS3DataLakeUpdateRestCatalog   *DestinationS3DataLakeUpdateRestCatalog   `queryParam:"inline"`

	Type DestinationS3DataLakeUpdateCatalogTypeType
}

func CreateDestinationS3DataLakeUpdateCatalogTypeDestinationS3DataLakeUpdateNessieCatalog(destinationS3DataLakeUpdateNessieCatalog DestinationS3DataLakeUpdateNessieCatalog) DestinationS3DataLakeUpdateCatalogType {
	typ := DestinationS3DataLakeUpdateCatalogTypeTypeDestinationS3DataLakeUpdateNessieCatalog

	return DestinationS3DataLakeUpdateCatalogType{
		DestinationS3DataLakeUpdateNessieCatalog: &destinationS3DataLakeUpdateNessieCatalog,
		Type:                                     typ,
	}
}

func CreateDestinationS3DataLakeUpdateCatalogTypeDestinationS3DataLakeUpdateGlueCatalog(destinationS3DataLakeUpdateGlueCatalog DestinationS3DataLakeUpdateGlueCatalog) DestinationS3DataLakeUpdateCatalogType {
	typ := DestinationS3DataLakeUpdateCatalogTypeTypeDestinationS3DataLakeUpdateGlueCatalog

	return DestinationS3DataLakeUpdateCatalogType{
		DestinationS3DataLakeUpdateGlueCatalog: &destinationS3DataLakeUpdateGlueCatalog,
		Type:                                   typ,
	}
}

func CreateDestinationS3DataLakeUpdateCatalogTypeDestinationS3DataLakeUpdateRestCatalog(destinationS3DataLakeUpdateRestCatalog DestinationS3DataLakeUpdateRestCatalog) DestinationS3DataLakeUpdateCatalogType {
	typ := DestinationS3DataLakeUpdateCatalogTypeTypeDestinationS3DataLakeUpdateRestCatalog

	return DestinationS3DataLakeUpdateCatalogType{
		DestinationS3DataLakeUpdateRestCatalog: &destinationS3DataLakeUpdateRestCatalog,
		Type:                                   typ,
	}
}

func (u *DestinationS3DataLakeUpdateCatalogType) UnmarshalJSON(data []byte) error {

	var destinationS3DataLakeUpdateRestCatalog DestinationS3DataLakeUpdateRestCatalog = DestinationS3DataLakeUpdateRestCatalog{}
	if err := utils.UnmarshalJSON(data, &destinationS3DataLakeUpdateRestCatalog, "", true, true); err == nil {
		u.DestinationS3DataLakeUpdateRestCatalog = &destinationS3DataLakeUpdateRestCatalog
		u.Type = DestinationS3DataLakeUpdateCatalogTypeTypeDestinationS3DataLakeUpdateRestCatalog
		return nil
	}

	var destinationS3DataLakeUpdateNessieCatalog DestinationS3DataLakeUpdateNessieCatalog = DestinationS3DataLakeUpdateNessieCatalog{}
	if err := utils.UnmarshalJSON(data, &destinationS3DataLakeUpdateNessieCatalog, "", true, true); err == nil {
		u.DestinationS3DataLakeUpdateNessieCatalog = &destinationS3DataLakeUpdateNessieCatalog
		u.Type = DestinationS3DataLakeUpdateCatalogTypeTypeDestinationS3DataLakeUpdateNessieCatalog
		return nil
	}

	var destinationS3DataLakeUpdateGlueCatalog DestinationS3DataLakeUpdateGlueCatalog = DestinationS3DataLakeUpdateGlueCatalog{}
	if err := utils.UnmarshalJSON(data, &destinationS3DataLakeUpdateGlueCatalog, "", true, true); err == nil {
		u.DestinationS3DataLakeUpdateGlueCatalog = &destinationS3DataLakeUpdateGlueCatalog
		u.Type = DestinationS3DataLakeUpdateCatalogTypeTypeDestinationS3DataLakeUpdateGlueCatalog
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationS3DataLakeUpdateCatalogType", string(data))
}

func (u DestinationS3DataLakeUpdateCatalogType) MarshalJSON() ([]byte, error) {
	if u.DestinationS3DataLakeUpdateNessieCatalog != nil {
		return utils.MarshalJSON(u.DestinationS3DataLakeUpdateNessieCatalog, "", true)
	}

	if u.DestinationS3DataLakeUpdateGlueCatalog != nil {
		return utils.MarshalJSON(u.DestinationS3DataLakeUpdateGlueCatalog, "", true)
	}

	if u.DestinationS3DataLakeUpdateRestCatalog != nil {
		return utils.MarshalJSON(u.DestinationS3DataLakeUpdateRestCatalog, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationS3DataLakeUpdateCatalogType: all fields are null")
}

// DestinationS3DataLakeUpdate - Defines the configurations required to connect to an Iceberg catalog, including warehouse location, main branch name, and catalog type specifics.
type DestinationS3DataLakeUpdate struct {
	// The AWS Access Key ID with permissions for S3 and Glue operations.
	AccessKeyID *string `json:"access_key_id,omitempty"`
	// The AWS Secret Access Key paired with the Access Key ID for AWS authentication.
	SecretAccessKey *string `json:"secret_access_key,omitempty"`
	// The name of the S3 bucket that will host the Iceberg data.
	S3BucketName string `json:"s3_bucket_name"`
	// The region of the S3 bucket. See <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-available-regions">here</a> for all region codes.
	S3BucketRegion DestinationS3DataLakeUpdateS3BucketRegion `json:"s3_bucket_region"`
	// Your S3 endpoint url. Read more <a href="https://docs.aws.amazon.com/general/latest/gr/s3.html#:~:text=Service%20endpoints-,Amazon%20S3%20endpoints,-When%20you%20use">here</a>
	S3Endpoint *string `json:"s3_endpoint,omitempty"`
	// The root location of the data warehouse used by the Iceberg catalog. Typically includes a bucket name and path within that bucket. Must include the storage protocol (such as "s3://" for Amazon S3).
	WarehouseLocation string `json:"warehouse_location"`
	// The primary or default branch name in the catalog. Most query engines will use "main" by default. See <a href="https://iceberg.apache.org/docs/latest/branching/">Iceberg documentation</a> for more information.
	MainBranchName *string `default:"main" json:"main_branch_name"`
	// Specifies the type of Iceberg catalog (e.g., NESSIE, GLUE, REST) and its associated configuration.
	CatalogType DestinationS3DataLakeUpdateCatalogType `json:"catalog_type"`
}

func (d DestinationS3DataLakeUpdate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationS3DataLakeUpdate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *DestinationS3DataLakeUpdate) GetAccessKeyID() *string {
	if o == nil {
		return nil
	}
	return o.AccessKeyID
}

func (o *DestinationS3DataLakeUpdate) GetSecretAccessKey() *string {
	if o == nil {
		return nil
	}
	return o.SecretAccessKey
}

func (o *DestinationS3DataLakeUpdate) GetS3BucketName() string {
	if o == nil {
		return ""
	}
	return o.S3BucketName
}

func (o *DestinationS3DataLakeUpdate) GetS3BucketRegion() DestinationS3DataLakeUpdateS3BucketRegion {
	if o == nil {
		return DestinationS3DataLakeUpdateS3BucketRegion("")
	}
	return o.S3BucketRegion
}

func (o *DestinationS3DataLakeUpdate) GetS3Endpoint() *string {
	if o == nil {
		return nil
	}
	return o.S3Endpoint
}

func (o *DestinationS3DataLakeUpdate) GetWarehouseLocation() string {
	if o == nil {
		return ""
	}
	return o.WarehouseLocation
}

func (o *DestinationS3DataLakeUpdate) GetMainBranchName() *string {
	if o == nil {
		return nil
	}
	return o.MainBranchName
}

func (o *DestinationS3DataLakeUpdate) GetCatalogType() DestinationS3DataLakeUpdateCatalogType {
	if o == nil {
		return DestinationS3DataLakeUpdateCatalogType{}
	}
	return o.CatalogType
}
