// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

// DestinationS3UpdateSchemasCompressionCodec - The compression algorithm used to compress data pages.
type DestinationS3UpdateSchemasCompressionCodec string

const (
	DestinationS3UpdateSchemasCompressionCodecUncompressed DestinationS3UpdateSchemasCompressionCodec = "UNCOMPRESSED"
	DestinationS3UpdateSchemasCompressionCodecSnappy       DestinationS3UpdateSchemasCompressionCodec = "SNAPPY"
	DestinationS3UpdateSchemasCompressionCodecGzip         DestinationS3UpdateSchemasCompressionCodec = "GZIP"
	DestinationS3UpdateSchemasCompressionCodecLzo          DestinationS3UpdateSchemasCompressionCodec = "LZO"
	DestinationS3UpdateSchemasCompressionCodecBrotli       DestinationS3UpdateSchemasCompressionCodec = "BROTLI"
	DestinationS3UpdateSchemasCompressionCodecLz4          DestinationS3UpdateSchemasCompressionCodec = "LZ4"
	DestinationS3UpdateSchemasCompressionCodecZstd         DestinationS3UpdateSchemasCompressionCodec = "ZSTD"
)

func (e DestinationS3UpdateSchemasCompressionCodec) ToPointer() *DestinationS3UpdateSchemasCompressionCodec {
	return &e
}
func (e *DestinationS3UpdateSchemasCompressionCodec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "UNCOMPRESSED":
		fallthrough
	case "SNAPPY":
		fallthrough
	case "GZIP":
		fallthrough
	case "LZO":
		fallthrough
	case "BROTLI":
		fallthrough
	case "LZ4":
		fallthrough
	case "ZSTD":
		*e = DestinationS3UpdateSchemasCompressionCodec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3UpdateSchemasCompressionCodec: %v", v)
	}
}

type DestinationS3UpdateSchemasFormatOutputFormatFormatType string

const (
	DestinationS3UpdateSchemasFormatOutputFormatFormatTypeParquet DestinationS3UpdateSchemasFormatOutputFormatFormatType = "Parquet"
)

func (e DestinationS3UpdateSchemasFormatOutputFormatFormatType) ToPointer() *DestinationS3UpdateSchemasFormatOutputFormatFormatType {
	return &e
}
func (e *DestinationS3UpdateSchemasFormatOutputFormatFormatType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Parquet":
		*e = DestinationS3UpdateSchemasFormatOutputFormatFormatType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3UpdateSchemasFormatOutputFormatFormatType: %v", v)
	}
}

type DestinationS3UpdateParquetColumnarStorage struct {
	// This is the size of a row group being buffered in memory. It limits the memory usage when writing. Larger values will improve the IO when reading, but consume more memory when writing. Default: 128 MB.
	BlockSizeMb *int64 `default:"128" json:"block_size_mb"`
	// The compression algorithm used to compress data pages.
	CompressionCodec *DestinationS3UpdateSchemasCompressionCodec `default:"UNCOMPRESSED" json:"compression_codec"`
	// Default: true.
	DictionaryEncoding *bool `default:"true" json:"dictionary_encoding"`
	// There is one dictionary page per column per row group when dictionary encoding is used. The dictionary page size works like the page size but for dictionary. Default: 1024 KB.
	DictionaryPageSizeKb *int64                                                  `default:"1024" json:"dictionary_page_size_kb"`
	FormatType           *DestinationS3UpdateSchemasFormatOutputFormatFormatType `default:"Parquet" json:"format_type"`
	// Maximum size allowed as padding to align row groups. This is also the minimum size of a row group. Default: 8 MB.
	MaxPaddingSizeMb *int64 `default:"8" json:"max_padding_size_mb"`
	// The page size is for compression. A block is composed of pages. A page is the smallest unit that must be read fully to access a single record. If this value is too small, the compression will deteriorate. Default: 1024 KB.
	PageSizeKb *int64 `default:"1024" json:"page_size_kb"`
}

func (d DestinationS3UpdateParquetColumnarStorage) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationS3UpdateParquetColumnarStorage) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationS3UpdateParquetColumnarStorage) GetBlockSizeMb() *int64 {
	if o == nil {
		return nil
	}
	return o.BlockSizeMb
}

func (o *DestinationS3UpdateParquetColumnarStorage) GetCompressionCodec() *DestinationS3UpdateSchemasCompressionCodec {
	if o == nil {
		return nil
	}
	return o.CompressionCodec
}

func (o *DestinationS3UpdateParquetColumnarStorage) GetDictionaryEncoding() *bool {
	if o == nil {
		return nil
	}
	return o.DictionaryEncoding
}

func (o *DestinationS3UpdateParquetColumnarStorage) GetDictionaryPageSizeKb() *int64 {
	if o == nil {
		return nil
	}
	return o.DictionaryPageSizeKb
}

func (o *DestinationS3UpdateParquetColumnarStorage) GetFormatType() *DestinationS3UpdateSchemasFormatOutputFormatFormatType {
	if o == nil {
		return nil
	}
	return o.FormatType
}

func (o *DestinationS3UpdateParquetColumnarStorage) GetMaxPaddingSizeMb() *int64 {
	if o == nil {
		return nil
	}
	return o.MaxPaddingSizeMb
}

func (o *DestinationS3UpdateParquetColumnarStorage) GetPageSizeKb() *int64 {
	if o == nil {
		return nil
	}
	return o.PageSizeKb
}

type DestinationS3UpdateSchemasFormatOutputFormat3CompressionCodecCodec string

const (
	DestinationS3UpdateSchemasFormatOutputFormat3CompressionCodecCodecSnappy DestinationS3UpdateSchemasFormatOutputFormat3CompressionCodecCodec = "snappy"
)

func (e DestinationS3UpdateSchemasFormatOutputFormat3CompressionCodecCodec) ToPointer() *DestinationS3UpdateSchemasFormatOutputFormat3CompressionCodecCodec {
	return &e
}
func (e *DestinationS3UpdateSchemasFormatOutputFormat3CompressionCodecCodec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "snappy":
		*e = DestinationS3UpdateSchemasFormatOutputFormat3CompressionCodecCodec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3UpdateSchemasFormatOutputFormat3CompressionCodecCodec: %v", v)
	}
}

type DestinationS3UpdateSnappy struct {
	Codec *DestinationS3UpdateSchemasFormatOutputFormat3CompressionCodecCodec `default:"snappy" json:"codec"`
}

func (d DestinationS3UpdateSnappy) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationS3UpdateSnappy) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationS3UpdateSnappy) GetCodec() *DestinationS3UpdateSchemasFormatOutputFormat3CompressionCodecCodec {
	if o == nil {
		return nil
	}
	return o.Codec
}

type DestinationS3UpdateSchemasFormatOutputFormat3Codec string

const (
	DestinationS3UpdateSchemasFormatOutputFormat3CodecZstandard DestinationS3UpdateSchemasFormatOutputFormat3Codec = "zstandard"
)

func (e DestinationS3UpdateSchemasFormatOutputFormat3Codec) ToPointer() *DestinationS3UpdateSchemasFormatOutputFormat3Codec {
	return &e
}
func (e *DestinationS3UpdateSchemasFormatOutputFormat3Codec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "zstandard":
		*e = DestinationS3UpdateSchemasFormatOutputFormat3Codec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3UpdateSchemasFormatOutputFormat3Codec: %v", v)
	}
}

type DestinationS3UpdateZstandard struct {
	Codec *DestinationS3UpdateSchemasFormatOutputFormat3Codec `default:"zstandard" json:"codec"`
	// Negative levels are 'fast' modes akin to lz4 or snappy, levels above 9 are generally for archival purposes, and levels above 18 use a lot of memory.
	CompressionLevel *int64 `default:"3" json:"compression_level"`
	// If true, include a checksum with each data block.
	IncludeChecksum *bool `default:"false" json:"include_checksum"`
}

func (d DestinationS3UpdateZstandard) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationS3UpdateZstandard) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationS3UpdateZstandard) GetCodec() *DestinationS3UpdateSchemasFormatOutputFormat3Codec {
	if o == nil {
		return nil
	}
	return o.Codec
}

func (o *DestinationS3UpdateZstandard) GetCompressionLevel() *int64 {
	if o == nil {
		return nil
	}
	return o.CompressionLevel
}

func (o *DestinationS3UpdateZstandard) GetIncludeChecksum() *bool {
	if o == nil {
		return nil
	}
	return o.IncludeChecksum
}

type DestinationS3UpdateSchemasFormatOutputFormatCodec string

const (
	DestinationS3UpdateSchemasFormatOutputFormatCodecXz DestinationS3UpdateSchemasFormatOutputFormatCodec = "xz"
)

func (e DestinationS3UpdateSchemasFormatOutputFormatCodec) ToPointer() *DestinationS3UpdateSchemasFormatOutputFormatCodec {
	return &e
}
func (e *DestinationS3UpdateSchemasFormatOutputFormatCodec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "xz":
		*e = DestinationS3UpdateSchemasFormatOutputFormatCodec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3UpdateSchemasFormatOutputFormatCodec: %v", v)
	}
}

type DestinationS3UpdateXz struct {
	Codec *DestinationS3UpdateSchemasFormatOutputFormatCodec `default:"xz" json:"codec"`
	// See <a href="https://commons.apache.org/proper/commons-compress/apidocs/org/apache/commons/compress/compressors/xz/XZCompressorOutputStream.html#XZCompressorOutputStream-java.io.OutputStream-int-">here</a> for details.
	CompressionLevel *int64 `default:"6" json:"compression_level"`
}

func (d DestinationS3UpdateXz) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationS3UpdateXz) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationS3UpdateXz) GetCodec() *DestinationS3UpdateSchemasFormatOutputFormatCodec {
	if o == nil {
		return nil
	}
	return o.Codec
}

func (o *DestinationS3UpdateXz) GetCompressionLevel() *int64 {
	if o == nil {
		return nil
	}
	return o.CompressionLevel
}

type DestinationS3UpdateSchemasFormatCodec string

const (
	DestinationS3UpdateSchemasFormatCodecBzip2 DestinationS3UpdateSchemasFormatCodec = "bzip2"
)

func (e DestinationS3UpdateSchemasFormatCodec) ToPointer() *DestinationS3UpdateSchemasFormatCodec {
	return &e
}
func (e *DestinationS3UpdateSchemasFormatCodec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "bzip2":
		*e = DestinationS3UpdateSchemasFormatCodec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3UpdateSchemasFormatCodec: %v", v)
	}
}

type DestinationS3UpdateBzip2 struct {
	Codec *DestinationS3UpdateSchemasFormatCodec `default:"bzip2" json:"codec"`
}

func (d DestinationS3UpdateBzip2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationS3UpdateBzip2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationS3UpdateBzip2) GetCodec() *DestinationS3UpdateSchemasFormatCodec {
	if o == nil {
		return nil
	}
	return o.Codec
}

type DestinationS3UpdateSchemasCodec string

const (
	DestinationS3UpdateSchemasCodecDeflate DestinationS3UpdateSchemasCodec = "Deflate"
)

func (e DestinationS3UpdateSchemasCodec) ToPointer() *DestinationS3UpdateSchemasCodec {
	return &e
}
func (e *DestinationS3UpdateSchemasCodec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Deflate":
		*e = DestinationS3UpdateSchemasCodec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3UpdateSchemasCodec: %v", v)
	}
}

type DestinationS3UpdateDeflate struct {
	Codec *DestinationS3UpdateSchemasCodec `default:"Deflate" json:"codec"`
	// 0: no compression & fastest, 9: best compression & slowest.
	CompressionLevel *int64 `default:"0" json:"compression_level"`
}

func (d DestinationS3UpdateDeflate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationS3UpdateDeflate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationS3UpdateDeflate) GetCodec() *DestinationS3UpdateSchemasCodec {
	if o == nil {
		return nil
	}
	return o.Codec
}

func (o *DestinationS3UpdateDeflate) GetCompressionLevel() *int64 {
	if o == nil {
		return nil
	}
	return o.CompressionLevel
}

type DestinationS3UpdateCodec string

const (
	DestinationS3UpdateCodecNoCompression DestinationS3UpdateCodec = "no compression"
)

func (e DestinationS3UpdateCodec) ToPointer() *DestinationS3UpdateCodec {
	return &e
}
func (e *DestinationS3UpdateCodec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "no compression":
		*e = DestinationS3UpdateCodec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3UpdateCodec: %v", v)
	}
}

type DestinationS3UpdateSchemasFormatNoCompression struct {
	Codec *DestinationS3UpdateCodec `default:"no compression" json:"codec"`
}

func (d DestinationS3UpdateSchemasFormatNoCompression) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationS3UpdateSchemasFormatNoCompression) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationS3UpdateSchemasFormatNoCompression) GetCodec() *DestinationS3UpdateCodec {
	if o == nil {
		return nil
	}
	return o.Codec
}

type DestinationS3UpdateCompressionCodecType string

const (
	DestinationS3UpdateCompressionCodecTypeDestinationS3UpdateSchemasFormatNoCompression DestinationS3UpdateCompressionCodecType = "destination-s3-update_Schemas_format_No Compression"
	DestinationS3UpdateCompressionCodecTypeDestinationS3UpdateDeflate                    DestinationS3UpdateCompressionCodecType = "destination-s3-update_Deflate"
	DestinationS3UpdateCompressionCodecTypeDestinationS3UpdateBzip2                      DestinationS3UpdateCompressionCodecType = "destination-s3-update_bzip2"
	DestinationS3UpdateCompressionCodecTypeDestinationS3UpdateXz                         DestinationS3UpdateCompressionCodecType = "destination-s3-update_xz"
	DestinationS3UpdateCompressionCodecTypeDestinationS3UpdateZstandard                  DestinationS3UpdateCompressionCodecType = "destination-s3-update_zstandard"
	DestinationS3UpdateCompressionCodecTypeDestinationS3UpdateSnappy                     DestinationS3UpdateCompressionCodecType = "destination-s3-update_snappy"
)

// DestinationS3UpdateCompressionCodec - The compression algorithm used to compress data. Default to no compression.
type DestinationS3UpdateCompressionCodec struct {
	DestinationS3UpdateSchemasFormatNoCompression *DestinationS3UpdateSchemasFormatNoCompression
	DestinationS3UpdateDeflate                    *DestinationS3UpdateDeflate
	DestinationS3UpdateBzip2                      *DestinationS3UpdateBzip2
	DestinationS3UpdateXz                         *DestinationS3UpdateXz
	DestinationS3UpdateZstandard                  *DestinationS3UpdateZstandard
	DestinationS3UpdateSnappy                     *DestinationS3UpdateSnappy

	Type DestinationS3UpdateCompressionCodecType
}

func CreateDestinationS3UpdateCompressionCodecDestinationS3UpdateSchemasFormatNoCompression(destinationS3UpdateSchemasFormatNoCompression DestinationS3UpdateSchemasFormatNoCompression) DestinationS3UpdateCompressionCodec {
	typ := DestinationS3UpdateCompressionCodecTypeDestinationS3UpdateSchemasFormatNoCompression

	return DestinationS3UpdateCompressionCodec{
		DestinationS3UpdateSchemasFormatNoCompression: &destinationS3UpdateSchemasFormatNoCompression,
		Type: typ,
	}
}

func CreateDestinationS3UpdateCompressionCodecDestinationS3UpdateDeflate(destinationS3UpdateDeflate DestinationS3UpdateDeflate) DestinationS3UpdateCompressionCodec {
	typ := DestinationS3UpdateCompressionCodecTypeDestinationS3UpdateDeflate

	return DestinationS3UpdateCompressionCodec{
		DestinationS3UpdateDeflate: &destinationS3UpdateDeflate,
		Type:                       typ,
	}
}

func CreateDestinationS3UpdateCompressionCodecDestinationS3UpdateBzip2(destinationS3UpdateBzip2 DestinationS3UpdateBzip2) DestinationS3UpdateCompressionCodec {
	typ := DestinationS3UpdateCompressionCodecTypeDestinationS3UpdateBzip2

	return DestinationS3UpdateCompressionCodec{
		DestinationS3UpdateBzip2: &destinationS3UpdateBzip2,
		Type:                     typ,
	}
}

func CreateDestinationS3UpdateCompressionCodecDestinationS3UpdateXz(destinationS3UpdateXz DestinationS3UpdateXz) DestinationS3UpdateCompressionCodec {
	typ := DestinationS3UpdateCompressionCodecTypeDestinationS3UpdateXz

	return DestinationS3UpdateCompressionCodec{
		DestinationS3UpdateXz: &destinationS3UpdateXz,
		Type:                  typ,
	}
}

func CreateDestinationS3UpdateCompressionCodecDestinationS3UpdateZstandard(destinationS3UpdateZstandard DestinationS3UpdateZstandard) DestinationS3UpdateCompressionCodec {
	typ := DestinationS3UpdateCompressionCodecTypeDestinationS3UpdateZstandard

	return DestinationS3UpdateCompressionCodec{
		DestinationS3UpdateZstandard: &destinationS3UpdateZstandard,
		Type:                         typ,
	}
}

func CreateDestinationS3UpdateCompressionCodecDestinationS3UpdateSnappy(destinationS3UpdateSnappy DestinationS3UpdateSnappy) DestinationS3UpdateCompressionCodec {
	typ := DestinationS3UpdateCompressionCodecTypeDestinationS3UpdateSnappy

	return DestinationS3UpdateCompressionCodec{
		DestinationS3UpdateSnappy: &destinationS3UpdateSnappy,
		Type:                      typ,
	}
}

func (u *DestinationS3UpdateCompressionCodec) UnmarshalJSON(data []byte) error {

	var destinationS3UpdateSchemasFormatNoCompression DestinationS3UpdateSchemasFormatNoCompression = DestinationS3UpdateSchemasFormatNoCompression{}
	if err := utils.UnmarshalJSON(data, &destinationS3UpdateSchemasFormatNoCompression, "", true, true); err == nil {
		u.DestinationS3UpdateSchemasFormatNoCompression = &destinationS3UpdateSchemasFormatNoCompression
		u.Type = DestinationS3UpdateCompressionCodecTypeDestinationS3UpdateSchemasFormatNoCompression
		return nil
	}

	var destinationS3UpdateBzip2 DestinationS3UpdateBzip2 = DestinationS3UpdateBzip2{}
	if err := utils.UnmarshalJSON(data, &destinationS3UpdateBzip2, "", true, true); err == nil {
		u.DestinationS3UpdateBzip2 = &destinationS3UpdateBzip2
		u.Type = DestinationS3UpdateCompressionCodecTypeDestinationS3UpdateBzip2
		return nil
	}

	var destinationS3UpdateSnappy DestinationS3UpdateSnappy = DestinationS3UpdateSnappy{}
	if err := utils.UnmarshalJSON(data, &destinationS3UpdateSnappy, "", true, true); err == nil {
		u.DestinationS3UpdateSnappy = &destinationS3UpdateSnappy
		u.Type = DestinationS3UpdateCompressionCodecTypeDestinationS3UpdateSnappy
		return nil
	}

	var destinationS3UpdateDeflate DestinationS3UpdateDeflate = DestinationS3UpdateDeflate{}
	if err := utils.UnmarshalJSON(data, &destinationS3UpdateDeflate, "", true, true); err == nil {
		u.DestinationS3UpdateDeflate = &destinationS3UpdateDeflate
		u.Type = DestinationS3UpdateCompressionCodecTypeDestinationS3UpdateDeflate
		return nil
	}

	var destinationS3UpdateXz DestinationS3UpdateXz = DestinationS3UpdateXz{}
	if err := utils.UnmarshalJSON(data, &destinationS3UpdateXz, "", true, true); err == nil {
		u.DestinationS3UpdateXz = &destinationS3UpdateXz
		u.Type = DestinationS3UpdateCompressionCodecTypeDestinationS3UpdateXz
		return nil
	}

	var destinationS3UpdateZstandard DestinationS3UpdateZstandard = DestinationS3UpdateZstandard{}
	if err := utils.UnmarshalJSON(data, &destinationS3UpdateZstandard, "", true, true); err == nil {
		u.DestinationS3UpdateZstandard = &destinationS3UpdateZstandard
		u.Type = DestinationS3UpdateCompressionCodecTypeDestinationS3UpdateZstandard
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u DestinationS3UpdateCompressionCodec) MarshalJSON() ([]byte, error) {
	if u.DestinationS3UpdateSchemasFormatNoCompression != nil {
		return utils.MarshalJSON(u.DestinationS3UpdateSchemasFormatNoCompression, "", true)
	}

	if u.DestinationS3UpdateDeflate != nil {
		return utils.MarshalJSON(u.DestinationS3UpdateDeflate, "", true)
	}

	if u.DestinationS3UpdateBzip2 != nil {
		return utils.MarshalJSON(u.DestinationS3UpdateBzip2, "", true)
	}

	if u.DestinationS3UpdateXz != nil {
		return utils.MarshalJSON(u.DestinationS3UpdateXz, "", true)
	}

	if u.DestinationS3UpdateZstandard != nil {
		return utils.MarshalJSON(u.DestinationS3UpdateZstandard, "", true)
	}

	if u.DestinationS3UpdateSnappy != nil {
		return utils.MarshalJSON(u.DestinationS3UpdateSnappy, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type DestinationS3UpdateSchemasFormatFormatType string

const (
	DestinationS3UpdateSchemasFormatFormatTypeAvro DestinationS3UpdateSchemasFormatFormatType = "Avro"
)

func (e DestinationS3UpdateSchemasFormatFormatType) ToPointer() *DestinationS3UpdateSchemasFormatFormatType {
	return &e
}
func (e *DestinationS3UpdateSchemasFormatFormatType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Avro":
		*e = DestinationS3UpdateSchemasFormatFormatType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3UpdateSchemasFormatFormatType: %v", v)
	}
}

type DestinationS3UpdateAvroApacheAvro struct {
	// The compression algorithm used to compress data. Default to no compression.
	CompressionCodec DestinationS3UpdateCompressionCodec         `json:"compression_codec"`
	FormatType       *DestinationS3UpdateSchemasFormatFormatType `default:"Avro" json:"format_type"`
}

func (d DestinationS3UpdateAvroApacheAvro) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationS3UpdateAvroApacheAvro) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationS3UpdateAvroApacheAvro) GetCompressionCodec() DestinationS3UpdateCompressionCodec {
	if o == nil {
		return DestinationS3UpdateCompressionCodec{}
	}
	return o.CompressionCodec
}

func (o *DestinationS3UpdateAvroApacheAvro) GetFormatType() *DestinationS3UpdateSchemasFormatFormatType {
	if o == nil {
		return nil
	}
	return o.FormatType
}

type DestinationS3UpdateSchemasFormatOutputFormatCompressionType string

const (
	DestinationS3UpdateSchemasFormatOutputFormatCompressionTypeGzip DestinationS3UpdateSchemasFormatOutputFormatCompressionType = "GZIP"
)

func (e DestinationS3UpdateSchemasFormatOutputFormatCompressionType) ToPointer() *DestinationS3UpdateSchemasFormatOutputFormatCompressionType {
	return &e
}
func (e *DestinationS3UpdateSchemasFormatOutputFormatCompressionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "GZIP":
		*e = DestinationS3UpdateSchemasFormatOutputFormatCompressionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3UpdateSchemasFormatOutputFormatCompressionType: %v", v)
	}
}

type DestinationS3UpdateSchemasGZIP struct {
	CompressionType *DestinationS3UpdateSchemasFormatOutputFormatCompressionType `default:"GZIP" json:"compression_type"`
}

func (d DestinationS3UpdateSchemasGZIP) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationS3UpdateSchemasGZIP) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationS3UpdateSchemasGZIP) GetCompressionType() *DestinationS3UpdateSchemasFormatOutputFormatCompressionType {
	if o == nil {
		return nil
	}
	return o.CompressionType
}

type DestinationS3UpdateSchemasFormatCompressionType string

const (
	DestinationS3UpdateSchemasFormatCompressionTypeNoCompression DestinationS3UpdateSchemasFormatCompressionType = "No Compression"
)

func (e DestinationS3UpdateSchemasFormatCompressionType) ToPointer() *DestinationS3UpdateSchemasFormatCompressionType {
	return &e
}
func (e *DestinationS3UpdateSchemasFormatCompressionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "No Compression":
		*e = DestinationS3UpdateSchemasFormatCompressionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3UpdateSchemasFormatCompressionType: %v", v)
	}
}

type DestinationS3UpdateSchemasNoCompression struct {
	CompressionType *DestinationS3UpdateSchemasFormatCompressionType `default:"No Compression" json:"compression_type"`
}

func (d DestinationS3UpdateSchemasNoCompression) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationS3UpdateSchemasNoCompression) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationS3UpdateSchemasNoCompression) GetCompressionType() *DestinationS3UpdateSchemasFormatCompressionType {
	if o == nil {
		return nil
	}
	return o.CompressionType
}

type DestinationS3UpdateSchemasCompressionUnionType string

const (
	DestinationS3UpdateSchemasCompressionUnionTypeDestinationS3UpdateSchemasNoCompression DestinationS3UpdateSchemasCompressionUnionType = "destination-s3-update_Schemas_No Compression"
	DestinationS3UpdateSchemasCompressionUnionTypeDestinationS3UpdateSchemasGZIP          DestinationS3UpdateSchemasCompressionUnionType = "destination-s3-update_Schemas_GZIP"
)

// DestinationS3UpdateSchemasCompression - Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").
type DestinationS3UpdateSchemasCompression struct {
	DestinationS3UpdateSchemasNoCompression *DestinationS3UpdateSchemasNoCompression
	DestinationS3UpdateSchemasGZIP          *DestinationS3UpdateSchemasGZIP

	Type DestinationS3UpdateSchemasCompressionUnionType
}

func CreateDestinationS3UpdateSchemasCompressionDestinationS3UpdateSchemasNoCompression(destinationS3UpdateSchemasNoCompression DestinationS3UpdateSchemasNoCompression) DestinationS3UpdateSchemasCompression {
	typ := DestinationS3UpdateSchemasCompressionUnionTypeDestinationS3UpdateSchemasNoCompression

	return DestinationS3UpdateSchemasCompression{
		DestinationS3UpdateSchemasNoCompression: &destinationS3UpdateSchemasNoCompression,
		Type:                                    typ,
	}
}

func CreateDestinationS3UpdateSchemasCompressionDestinationS3UpdateSchemasGZIP(destinationS3UpdateSchemasGZIP DestinationS3UpdateSchemasGZIP) DestinationS3UpdateSchemasCompression {
	typ := DestinationS3UpdateSchemasCompressionUnionTypeDestinationS3UpdateSchemasGZIP

	return DestinationS3UpdateSchemasCompression{
		DestinationS3UpdateSchemasGZIP: &destinationS3UpdateSchemasGZIP,
		Type:                           typ,
	}
}

func (u *DestinationS3UpdateSchemasCompression) UnmarshalJSON(data []byte) error {

	var destinationS3UpdateSchemasNoCompression DestinationS3UpdateSchemasNoCompression = DestinationS3UpdateSchemasNoCompression{}
	if err := utils.UnmarshalJSON(data, &destinationS3UpdateSchemasNoCompression, "", true, true); err == nil {
		u.DestinationS3UpdateSchemasNoCompression = &destinationS3UpdateSchemasNoCompression
		u.Type = DestinationS3UpdateSchemasCompressionUnionTypeDestinationS3UpdateSchemasNoCompression
		return nil
	}

	var destinationS3UpdateSchemasGZIP DestinationS3UpdateSchemasGZIP = DestinationS3UpdateSchemasGZIP{}
	if err := utils.UnmarshalJSON(data, &destinationS3UpdateSchemasGZIP, "", true, true); err == nil {
		u.DestinationS3UpdateSchemasGZIP = &destinationS3UpdateSchemasGZIP
		u.Type = DestinationS3UpdateSchemasCompressionUnionTypeDestinationS3UpdateSchemasGZIP
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u DestinationS3UpdateSchemasCompression) MarshalJSON() ([]byte, error) {
	if u.DestinationS3UpdateSchemasNoCompression != nil {
		return utils.MarshalJSON(u.DestinationS3UpdateSchemasNoCompression, "", true)
	}

	if u.DestinationS3UpdateSchemasGZIP != nil {
		return utils.MarshalJSON(u.DestinationS3UpdateSchemasGZIP, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

// DestinationS3UpdateSchemasFlattening - Whether the input json data should be normalized (flattened) in the output JSON Lines. Please refer to docs for details.
type DestinationS3UpdateSchemasFlattening string

const (
	DestinationS3UpdateSchemasFlatteningNoFlattening        DestinationS3UpdateSchemasFlattening = "No flattening"
	DestinationS3UpdateSchemasFlatteningRootLevelFlattening DestinationS3UpdateSchemasFlattening = "Root level flattening"
)

func (e DestinationS3UpdateSchemasFlattening) ToPointer() *DestinationS3UpdateSchemasFlattening {
	return &e
}
func (e *DestinationS3UpdateSchemasFlattening) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "No flattening":
		fallthrough
	case "Root level flattening":
		*e = DestinationS3UpdateSchemasFlattening(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3UpdateSchemasFlattening: %v", v)
	}
}

type DestinationS3UpdateSchemasFormatType string

const (
	DestinationS3UpdateSchemasFormatTypeJsonl DestinationS3UpdateSchemasFormatType = "JSONL"
)

func (e DestinationS3UpdateSchemasFormatType) ToPointer() *DestinationS3UpdateSchemasFormatType {
	return &e
}
func (e *DestinationS3UpdateSchemasFormatType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "JSONL":
		*e = DestinationS3UpdateSchemasFormatType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3UpdateSchemasFormatType: %v", v)
	}
}

type DestinationS3UpdateJSONLinesNewlineDelimitedJSON struct {
	// Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").
	Compression *DestinationS3UpdateSchemasCompression `json:"compression,omitempty"`
	// Whether the input json data should be normalized (flattened) in the output JSON Lines. Please refer to docs for details.
	Flattening *DestinationS3UpdateSchemasFlattening `default:"No flattening" json:"flattening"`
	FormatType *DestinationS3UpdateSchemasFormatType `default:"JSONL" json:"format_type"`
}

func (d DestinationS3UpdateJSONLinesNewlineDelimitedJSON) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationS3UpdateJSONLinesNewlineDelimitedJSON) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationS3UpdateJSONLinesNewlineDelimitedJSON) GetCompression() *DestinationS3UpdateSchemasCompression {
	if o == nil {
		return nil
	}
	return o.Compression
}

func (o *DestinationS3UpdateJSONLinesNewlineDelimitedJSON) GetFlattening() *DestinationS3UpdateSchemasFlattening {
	if o == nil {
		return nil
	}
	return o.Flattening
}

func (o *DestinationS3UpdateJSONLinesNewlineDelimitedJSON) GetFormatType() *DestinationS3UpdateSchemasFormatType {
	if o == nil {
		return nil
	}
	return o.FormatType
}

type DestinationS3UpdateSchemasCompressionType string

const (
	DestinationS3UpdateSchemasCompressionTypeGzip DestinationS3UpdateSchemasCompressionType = "GZIP"
)

func (e DestinationS3UpdateSchemasCompressionType) ToPointer() *DestinationS3UpdateSchemasCompressionType {
	return &e
}
func (e *DestinationS3UpdateSchemasCompressionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "GZIP":
		*e = DestinationS3UpdateSchemasCompressionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3UpdateSchemasCompressionType: %v", v)
	}
}

type DestinationS3UpdateGZIP struct {
	CompressionType *DestinationS3UpdateSchemasCompressionType `default:"GZIP" json:"compression_type"`
}

func (d DestinationS3UpdateGZIP) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationS3UpdateGZIP) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationS3UpdateGZIP) GetCompressionType() *DestinationS3UpdateSchemasCompressionType {
	if o == nil {
		return nil
	}
	return o.CompressionType
}

type DestinationS3UpdateCompressionType string

const (
	DestinationS3UpdateCompressionTypeNoCompression DestinationS3UpdateCompressionType = "No Compression"
)

func (e DestinationS3UpdateCompressionType) ToPointer() *DestinationS3UpdateCompressionType {
	return &e
}
func (e *DestinationS3UpdateCompressionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "No Compression":
		*e = DestinationS3UpdateCompressionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3UpdateCompressionType: %v", v)
	}
}

type DestinationS3UpdateNoCompression struct {
	CompressionType *DestinationS3UpdateCompressionType `default:"No Compression" json:"compression_type"`
}

func (d DestinationS3UpdateNoCompression) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationS3UpdateNoCompression) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationS3UpdateNoCompression) GetCompressionType() *DestinationS3UpdateCompressionType {
	if o == nil {
		return nil
	}
	return o.CompressionType
}

type DestinationS3UpdateCompressionUnionType string

const (
	DestinationS3UpdateCompressionUnionTypeDestinationS3UpdateNoCompression DestinationS3UpdateCompressionUnionType = "destination-s3-update_No Compression"
	DestinationS3UpdateCompressionUnionTypeDestinationS3UpdateGZIP          DestinationS3UpdateCompressionUnionType = "destination-s3-update_GZIP"
)

// DestinationS3UpdateCompression - Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".csv.gz").
type DestinationS3UpdateCompression struct {
	DestinationS3UpdateNoCompression *DestinationS3UpdateNoCompression
	DestinationS3UpdateGZIP          *DestinationS3UpdateGZIP

	Type DestinationS3UpdateCompressionUnionType
}

func CreateDestinationS3UpdateCompressionDestinationS3UpdateNoCompression(destinationS3UpdateNoCompression DestinationS3UpdateNoCompression) DestinationS3UpdateCompression {
	typ := DestinationS3UpdateCompressionUnionTypeDestinationS3UpdateNoCompression

	return DestinationS3UpdateCompression{
		DestinationS3UpdateNoCompression: &destinationS3UpdateNoCompression,
		Type:                             typ,
	}
}

func CreateDestinationS3UpdateCompressionDestinationS3UpdateGZIP(destinationS3UpdateGZIP DestinationS3UpdateGZIP) DestinationS3UpdateCompression {
	typ := DestinationS3UpdateCompressionUnionTypeDestinationS3UpdateGZIP

	return DestinationS3UpdateCompression{
		DestinationS3UpdateGZIP: &destinationS3UpdateGZIP,
		Type:                    typ,
	}
}

func (u *DestinationS3UpdateCompression) UnmarshalJSON(data []byte) error {

	var destinationS3UpdateNoCompression DestinationS3UpdateNoCompression = DestinationS3UpdateNoCompression{}
	if err := utils.UnmarshalJSON(data, &destinationS3UpdateNoCompression, "", true, true); err == nil {
		u.DestinationS3UpdateNoCompression = &destinationS3UpdateNoCompression
		u.Type = DestinationS3UpdateCompressionUnionTypeDestinationS3UpdateNoCompression
		return nil
	}

	var destinationS3UpdateGZIP DestinationS3UpdateGZIP = DestinationS3UpdateGZIP{}
	if err := utils.UnmarshalJSON(data, &destinationS3UpdateGZIP, "", true, true); err == nil {
		u.DestinationS3UpdateGZIP = &destinationS3UpdateGZIP
		u.Type = DestinationS3UpdateCompressionUnionTypeDestinationS3UpdateGZIP
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u DestinationS3UpdateCompression) MarshalJSON() ([]byte, error) {
	if u.DestinationS3UpdateNoCompression != nil {
		return utils.MarshalJSON(u.DestinationS3UpdateNoCompression, "", true)
	}

	if u.DestinationS3UpdateGZIP != nil {
		return utils.MarshalJSON(u.DestinationS3UpdateGZIP, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

// DestinationS3UpdateFlattening - Whether the input json data should be normalized (flattened) in the output CSV. Please refer to docs for details.
type DestinationS3UpdateFlattening string

const (
	DestinationS3UpdateFlatteningNoFlattening        DestinationS3UpdateFlattening = "No flattening"
	DestinationS3UpdateFlatteningRootLevelFlattening DestinationS3UpdateFlattening = "Root level flattening"
)

func (e DestinationS3UpdateFlattening) ToPointer() *DestinationS3UpdateFlattening {
	return &e
}
func (e *DestinationS3UpdateFlattening) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "No flattening":
		fallthrough
	case "Root level flattening":
		*e = DestinationS3UpdateFlattening(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3UpdateFlattening: %v", v)
	}
}

type DestinationS3UpdateFormatType string

const (
	DestinationS3UpdateFormatTypeCsv DestinationS3UpdateFormatType = "CSV"
)

func (e DestinationS3UpdateFormatType) ToPointer() *DestinationS3UpdateFormatType {
	return &e
}
func (e *DestinationS3UpdateFormatType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CSV":
		*e = DestinationS3UpdateFormatType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3UpdateFormatType: %v", v)
	}
}

type DestinationS3UpdateCSVCommaSeparatedValues struct {
	// Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".csv.gz").
	Compression *DestinationS3UpdateCompression `json:"compression,omitempty"`
	// Whether the input json data should be normalized (flattened) in the output CSV. Please refer to docs for details.
	Flattening *DestinationS3UpdateFlattening `default:"No flattening" json:"flattening"`
	FormatType *DestinationS3UpdateFormatType `default:"CSV" json:"format_type"`
}

func (d DestinationS3UpdateCSVCommaSeparatedValues) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationS3UpdateCSVCommaSeparatedValues) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationS3UpdateCSVCommaSeparatedValues) GetCompression() *DestinationS3UpdateCompression {
	if o == nil {
		return nil
	}
	return o.Compression
}

func (o *DestinationS3UpdateCSVCommaSeparatedValues) GetFlattening() *DestinationS3UpdateFlattening {
	if o == nil {
		return nil
	}
	return o.Flattening
}

func (o *DestinationS3UpdateCSVCommaSeparatedValues) GetFormatType() *DestinationS3UpdateFormatType {
	if o == nil {
		return nil
	}
	return o.FormatType
}

type DestinationS3UpdateOutputFormatType string

const (
	DestinationS3UpdateOutputFormatTypeDestinationS3UpdateCSVCommaSeparatedValues       DestinationS3UpdateOutputFormatType = "destination-s3-update_CSV: Comma-Separated Values"
	DestinationS3UpdateOutputFormatTypeDestinationS3UpdateJSONLinesNewlineDelimitedJSON DestinationS3UpdateOutputFormatType = "destination-s3-update_JSON Lines: Newline-delimited JSON"
	DestinationS3UpdateOutputFormatTypeDestinationS3UpdateAvroApacheAvro                DestinationS3UpdateOutputFormatType = "destination-s3-update_Avro: Apache Avro"
	DestinationS3UpdateOutputFormatTypeDestinationS3UpdateParquetColumnarStorage        DestinationS3UpdateOutputFormatType = "destination-s3-update_Parquet: Columnar Storage"
)

// DestinationS3UpdateOutputFormat - Format of the data output. See <a href="https://docs.airbyte.com/integrations/destinations/s3/#supported-output-schema">here</a> for more details
type DestinationS3UpdateOutputFormat struct {
	DestinationS3UpdateCSVCommaSeparatedValues       *DestinationS3UpdateCSVCommaSeparatedValues
	DestinationS3UpdateJSONLinesNewlineDelimitedJSON *DestinationS3UpdateJSONLinesNewlineDelimitedJSON
	DestinationS3UpdateAvroApacheAvro                *DestinationS3UpdateAvroApacheAvro
	DestinationS3UpdateParquetColumnarStorage        *DestinationS3UpdateParquetColumnarStorage

	Type DestinationS3UpdateOutputFormatType
}

func CreateDestinationS3UpdateOutputFormatDestinationS3UpdateCSVCommaSeparatedValues(destinationS3UpdateCSVCommaSeparatedValues DestinationS3UpdateCSVCommaSeparatedValues) DestinationS3UpdateOutputFormat {
	typ := DestinationS3UpdateOutputFormatTypeDestinationS3UpdateCSVCommaSeparatedValues

	return DestinationS3UpdateOutputFormat{
		DestinationS3UpdateCSVCommaSeparatedValues: &destinationS3UpdateCSVCommaSeparatedValues,
		Type: typ,
	}
}

func CreateDestinationS3UpdateOutputFormatDestinationS3UpdateJSONLinesNewlineDelimitedJSON(destinationS3UpdateJSONLinesNewlineDelimitedJSON DestinationS3UpdateJSONLinesNewlineDelimitedJSON) DestinationS3UpdateOutputFormat {
	typ := DestinationS3UpdateOutputFormatTypeDestinationS3UpdateJSONLinesNewlineDelimitedJSON

	return DestinationS3UpdateOutputFormat{
		DestinationS3UpdateJSONLinesNewlineDelimitedJSON: &destinationS3UpdateJSONLinesNewlineDelimitedJSON,
		Type: typ,
	}
}

func CreateDestinationS3UpdateOutputFormatDestinationS3UpdateAvroApacheAvro(destinationS3UpdateAvroApacheAvro DestinationS3UpdateAvroApacheAvro) DestinationS3UpdateOutputFormat {
	typ := DestinationS3UpdateOutputFormatTypeDestinationS3UpdateAvroApacheAvro

	return DestinationS3UpdateOutputFormat{
		DestinationS3UpdateAvroApacheAvro: &destinationS3UpdateAvroApacheAvro,
		Type:                              typ,
	}
}

func CreateDestinationS3UpdateOutputFormatDestinationS3UpdateParquetColumnarStorage(destinationS3UpdateParquetColumnarStorage DestinationS3UpdateParquetColumnarStorage) DestinationS3UpdateOutputFormat {
	typ := DestinationS3UpdateOutputFormatTypeDestinationS3UpdateParquetColumnarStorage

	return DestinationS3UpdateOutputFormat{
		DestinationS3UpdateParquetColumnarStorage: &destinationS3UpdateParquetColumnarStorage,
		Type: typ,
	}
}

func (u *DestinationS3UpdateOutputFormat) UnmarshalJSON(data []byte) error {

	var destinationS3UpdateAvroApacheAvro DestinationS3UpdateAvroApacheAvro = DestinationS3UpdateAvroApacheAvro{}
	if err := utils.UnmarshalJSON(data, &destinationS3UpdateAvroApacheAvro, "", true, true); err == nil {
		u.DestinationS3UpdateAvroApacheAvro = &destinationS3UpdateAvroApacheAvro
		u.Type = DestinationS3UpdateOutputFormatTypeDestinationS3UpdateAvroApacheAvro
		return nil
	}

	var destinationS3UpdateCSVCommaSeparatedValues DestinationS3UpdateCSVCommaSeparatedValues = DestinationS3UpdateCSVCommaSeparatedValues{}
	if err := utils.UnmarshalJSON(data, &destinationS3UpdateCSVCommaSeparatedValues, "", true, true); err == nil {
		u.DestinationS3UpdateCSVCommaSeparatedValues = &destinationS3UpdateCSVCommaSeparatedValues
		u.Type = DestinationS3UpdateOutputFormatTypeDestinationS3UpdateCSVCommaSeparatedValues
		return nil
	}

	var destinationS3UpdateJSONLinesNewlineDelimitedJSON DestinationS3UpdateJSONLinesNewlineDelimitedJSON = DestinationS3UpdateJSONLinesNewlineDelimitedJSON{}
	if err := utils.UnmarshalJSON(data, &destinationS3UpdateJSONLinesNewlineDelimitedJSON, "", true, true); err == nil {
		u.DestinationS3UpdateJSONLinesNewlineDelimitedJSON = &destinationS3UpdateJSONLinesNewlineDelimitedJSON
		u.Type = DestinationS3UpdateOutputFormatTypeDestinationS3UpdateJSONLinesNewlineDelimitedJSON
		return nil
	}

	var destinationS3UpdateParquetColumnarStorage DestinationS3UpdateParquetColumnarStorage = DestinationS3UpdateParquetColumnarStorage{}
	if err := utils.UnmarshalJSON(data, &destinationS3UpdateParquetColumnarStorage, "", true, true); err == nil {
		u.DestinationS3UpdateParquetColumnarStorage = &destinationS3UpdateParquetColumnarStorage
		u.Type = DestinationS3UpdateOutputFormatTypeDestinationS3UpdateParquetColumnarStorage
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u DestinationS3UpdateOutputFormat) MarshalJSON() ([]byte, error) {
	if u.DestinationS3UpdateCSVCommaSeparatedValues != nil {
		return utils.MarshalJSON(u.DestinationS3UpdateCSVCommaSeparatedValues, "", true)
	}

	if u.DestinationS3UpdateJSONLinesNewlineDelimitedJSON != nil {
		return utils.MarshalJSON(u.DestinationS3UpdateJSONLinesNewlineDelimitedJSON, "", true)
	}

	if u.DestinationS3UpdateAvroApacheAvro != nil {
		return utils.MarshalJSON(u.DestinationS3UpdateAvroApacheAvro, "", true)
	}

	if u.DestinationS3UpdateParquetColumnarStorage != nil {
		return utils.MarshalJSON(u.DestinationS3UpdateParquetColumnarStorage, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

// DestinationS3UpdateS3BucketRegion - The region of the S3 bucket. See <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-available-regions">here</a> for all region codes.
type DestinationS3UpdateS3BucketRegion string

const (
	DestinationS3UpdateS3BucketRegionUnknown      DestinationS3UpdateS3BucketRegion = ""
	DestinationS3UpdateS3BucketRegionAfSouth1     DestinationS3UpdateS3BucketRegion = "af-south-1"
	DestinationS3UpdateS3BucketRegionApEast1      DestinationS3UpdateS3BucketRegion = "ap-east-1"
	DestinationS3UpdateS3BucketRegionApNortheast1 DestinationS3UpdateS3BucketRegion = "ap-northeast-1"
	DestinationS3UpdateS3BucketRegionApNortheast2 DestinationS3UpdateS3BucketRegion = "ap-northeast-2"
	DestinationS3UpdateS3BucketRegionApNortheast3 DestinationS3UpdateS3BucketRegion = "ap-northeast-3"
	DestinationS3UpdateS3BucketRegionApSouth1     DestinationS3UpdateS3BucketRegion = "ap-south-1"
	DestinationS3UpdateS3BucketRegionApSouth2     DestinationS3UpdateS3BucketRegion = "ap-south-2"
	DestinationS3UpdateS3BucketRegionApSoutheast1 DestinationS3UpdateS3BucketRegion = "ap-southeast-1"
	DestinationS3UpdateS3BucketRegionApSoutheast2 DestinationS3UpdateS3BucketRegion = "ap-southeast-2"
	DestinationS3UpdateS3BucketRegionApSoutheast3 DestinationS3UpdateS3BucketRegion = "ap-southeast-3"
	DestinationS3UpdateS3BucketRegionApSoutheast4 DestinationS3UpdateS3BucketRegion = "ap-southeast-4"
	DestinationS3UpdateS3BucketRegionCaCentral1   DestinationS3UpdateS3BucketRegion = "ca-central-1"
	DestinationS3UpdateS3BucketRegionCaWest1      DestinationS3UpdateS3BucketRegion = "ca-west-1"
	DestinationS3UpdateS3BucketRegionCnNorth1     DestinationS3UpdateS3BucketRegion = "cn-north-1"
	DestinationS3UpdateS3BucketRegionCnNorthwest1 DestinationS3UpdateS3BucketRegion = "cn-northwest-1"
	DestinationS3UpdateS3BucketRegionEuCentral1   DestinationS3UpdateS3BucketRegion = "eu-central-1"
	DestinationS3UpdateS3BucketRegionEuCentral2   DestinationS3UpdateS3BucketRegion = "eu-central-2"
	DestinationS3UpdateS3BucketRegionEuNorth1     DestinationS3UpdateS3BucketRegion = "eu-north-1"
	DestinationS3UpdateS3BucketRegionEuSouth1     DestinationS3UpdateS3BucketRegion = "eu-south-1"
	DestinationS3UpdateS3BucketRegionEuSouth2     DestinationS3UpdateS3BucketRegion = "eu-south-2"
	DestinationS3UpdateS3BucketRegionEuWest1      DestinationS3UpdateS3BucketRegion = "eu-west-1"
	DestinationS3UpdateS3BucketRegionEuWest2      DestinationS3UpdateS3BucketRegion = "eu-west-2"
	DestinationS3UpdateS3BucketRegionEuWest3      DestinationS3UpdateS3BucketRegion = "eu-west-3"
	DestinationS3UpdateS3BucketRegionIlCentral1   DestinationS3UpdateS3BucketRegion = "il-central-1"
	DestinationS3UpdateS3BucketRegionMeCentral1   DestinationS3UpdateS3BucketRegion = "me-central-1"
	DestinationS3UpdateS3BucketRegionMeSouth1     DestinationS3UpdateS3BucketRegion = "me-south-1"
	DestinationS3UpdateS3BucketRegionSaEast1      DestinationS3UpdateS3BucketRegion = "sa-east-1"
	DestinationS3UpdateS3BucketRegionUsEast1      DestinationS3UpdateS3BucketRegion = "us-east-1"
	DestinationS3UpdateS3BucketRegionUsEast2      DestinationS3UpdateS3BucketRegion = "us-east-2"
	DestinationS3UpdateS3BucketRegionUsGovEast1   DestinationS3UpdateS3BucketRegion = "us-gov-east-1"
	DestinationS3UpdateS3BucketRegionUsGovWest1   DestinationS3UpdateS3BucketRegion = "us-gov-west-1"
	DestinationS3UpdateS3BucketRegionUsWest1      DestinationS3UpdateS3BucketRegion = "us-west-1"
	DestinationS3UpdateS3BucketRegionUsWest2      DestinationS3UpdateS3BucketRegion = "us-west-2"
)

func (e DestinationS3UpdateS3BucketRegion) ToPointer() *DestinationS3UpdateS3BucketRegion {
	return &e
}
func (e *DestinationS3UpdateS3BucketRegion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "":
		fallthrough
	case "af-south-1":
		fallthrough
	case "ap-east-1":
		fallthrough
	case "ap-northeast-1":
		fallthrough
	case "ap-northeast-2":
		fallthrough
	case "ap-northeast-3":
		fallthrough
	case "ap-south-1":
		fallthrough
	case "ap-south-2":
		fallthrough
	case "ap-southeast-1":
		fallthrough
	case "ap-southeast-2":
		fallthrough
	case "ap-southeast-3":
		fallthrough
	case "ap-southeast-4":
		fallthrough
	case "ca-central-1":
		fallthrough
	case "ca-west-1":
		fallthrough
	case "cn-north-1":
		fallthrough
	case "cn-northwest-1":
		fallthrough
	case "eu-central-1":
		fallthrough
	case "eu-central-2":
		fallthrough
	case "eu-north-1":
		fallthrough
	case "eu-south-1":
		fallthrough
	case "eu-south-2":
		fallthrough
	case "eu-west-1":
		fallthrough
	case "eu-west-2":
		fallthrough
	case "eu-west-3":
		fallthrough
	case "il-central-1":
		fallthrough
	case "me-central-1":
		fallthrough
	case "me-south-1":
		fallthrough
	case "sa-east-1":
		fallthrough
	case "us-east-1":
		fallthrough
	case "us-east-2":
		fallthrough
	case "us-gov-east-1":
		fallthrough
	case "us-gov-west-1":
		fallthrough
	case "us-west-1":
		fallthrough
	case "us-west-2":
		*e = DestinationS3UpdateS3BucketRegion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3UpdateS3BucketRegion: %v", v)
	}
}

type DestinationS3Update struct {
	// The access key ID to access the S3 bucket. Airbyte requires Read and Write permissions to the given bucket. Read more <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">here</a>.
	AccessKeyID *string `json:"access_key_id,omitempty"`
	// The pattern allows you to set the file-name format for the S3 staging file(s)
	FileNamePattern *string `json:"file_name_pattern,omitempty"`
	// Format of the data output. See <a href="https://docs.airbyte.com/integrations/destinations/s3/#supported-output-schema">here</a> for more details
	Format DestinationS3UpdateOutputFormat `json:"format"`
	// The name of the S3 bucket. Read more <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/create-bucket-overview.html">here</a>.
	S3BucketName string `json:"s3_bucket_name"`
	// Directory under the S3 bucket where data will be written. Read more <a href="https://docs.airbyte.com/integrations/destinations/s3#:~:text=to%20format%20the-,bucket%20path,-%3A">here</a>
	S3BucketPath string `json:"s3_bucket_path"`
	// The region of the S3 bucket. See <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-available-regions">here</a> for all region codes.
	S3BucketRegion *DestinationS3UpdateS3BucketRegion `default:"" json:"s3_bucket_region"`
	// Your S3 endpoint url. Read more <a href="https://docs.aws.amazon.com/general/latest/gr/s3.html#:~:text=Service%20endpoints-,Amazon%20S3%20endpoints,-When%20you%20use">here</a>
	S3Endpoint *string `default:"" json:"s3_endpoint"`
	// Format string on how data will be organized inside the S3 bucket directory. Read more <a href="https://docs.airbyte.com/integrations/destinations/s3#:~:text=The%20full%20path%20of%20the%20output%20data%20with%20the%20default%20S3%20path%20format">here</a>
	S3PathFormat *string `json:"s3_path_format,omitempty"`
	// The corresponding secret to the access key ID. Read more <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">here</a>
	SecretAccessKey *string `json:"secret_access_key,omitempty"`
}

func (d DestinationS3Update) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationS3Update) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *DestinationS3Update) GetAccessKeyID() *string {
	if o == nil {
		return nil
	}
	return o.AccessKeyID
}

func (o *DestinationS3Update) GetFileNamePattern() *string {
	if o == nil {
		return nil
	}
	return o.FileNamePattern
}

func (o *DestinationS3Update) GetFormat() DestinationS3UpdateOutputFormat {
	if o == nil {
		return DestinationS3UpdateOutputFormat{}
	}
	return o.Format
}

func (o *DestinationS3Update) GetS3BucketName() string {
	if o == nil {
		return ""
	}
	return o.S3BucketName
}

func (o *DestinationS3Update) GetS3BucketPath() string {
	if o == nil {
		return ""
	}
	return o.S3BucketPath
}

func (o *DestinationS3Update) GetS3BucketRegion() *DestinationS3UpdateS3BucketRegion {
	if o == nil {
		return nil
	}
	return o.S3BucketRegion
}

func (o *DestinationS3Update) GetS3Endpoint() *string {
	if o == nil {
		return nil
	}
	return o.S3Endpoint
}

func (o *DestinationS3Update) GetS3PathFormat() *string {
	if o == nil {
		return nil
	}
	return o.S3PathFormat
}

func (o *DestinationS3Update) GetSecretAccessKey() *string {
	if o == nil {
		return nil
	}
	return o.SecretAccessKey
}
