// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

// DestinationS3UpdateSchemasCompressionCodec - The compression algorithm used to compress data pages.
type DestinationS3UpdateSchemasCompressionCodec string

const (
	DestinationS3UpdateSchemasCompressionCodecUncompressed DestinationS3UpdateSchemasCompressionCodec = "UNCOMPRESSED"
	DestinationS3UpdateSchemasCompressionCodecSnappy       DestinationS3UpdateSchemasCompressionCodec = "SNAPPY"
	DestinationS3UpdateSchemasCompressionCodecGzip         DestinationS3UpdateSchemasCompressionCodec = "GZIP"
	DestinationS3UpdateSchemasCompressionCodecLzo          DestinationS3UpdateSchemasCompressionCodec = "LZO"
	DestinationS3UpdateSchemasCompressionCodecBrotli       DestinationS3UpdateSchemasCompressionCodec = "BROTLI"
	DestinationS3UpdateSchemasCompressionCodecLz4          DestinationS3UpdateSchemasCompressionCodec = "LZ4"
	DestinationS3UpdateSchemasCompressionCodecZstd         DestinationS3UpdateSchemasCompressionCodec = "ZSTD"
)

func (e DestinationS3UpdateSchemasCompressionCodec) ToPointer() *DestinationS3UpdateSchemasCompressionCodec {
	return &e
}
func (e *DestinationS3UpdateSchemasCompressionCodec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "UNCOMPRESSED":
		fallthrough
	case "SNAPPY":
		fallthrough
	case "GZIP":
		fallthrough
	case "LZO":
		fallthrough
	case "BROTLI":
		fallthrough
	case "LZ4":
		fallthrough
	case "ZSTD":
		*e = DestinationS3UpdateSchemasCompressionCodec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3UpdateSchemasCompressionCodec: %v", v)
	}
}

type DestinationS3UpdateSchemasFormatOutputFormatFormatType string

const (
	DestinationS3UpdateSchemasFormatOutputFormatFormatTypeParquet DestinationS3UpdateSchemasFormatOutputFormatFormatType = "Parquet"
)

func (e DestinationS3UpdateSchemasFormatOutputFormatFormatType) ToPointer() *DestinationS3UpdateSchemasFormatOutputFormatFormatType {
	return &e
}
func (e *DestinationS3UpdateSchemasFormatOutputFormatFormatType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Parquet":
		*e = DestinationS3UpdateSchemasFormatOutputFormatFormatType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3UpdateSchemasFormatOutputFormatFormatType: %v", v)
	}
}

type DestinationS3UpdateParquetColumnarStorage struct {
	// This is the size of a row group being buffered in memory. It limits the memory usage when writing. Larger values will improve the IO when reading, but consume more memory when writing. Default: 128 MB.
	BlockSizeMb *int64 `default:"128" json:"block_size_mb"`
	// The compression algorithm used to compress data pages.
	CompressionCodec *DestinationS3UpdateSchemasCompressionCodec `default:"UNCOMPRESSED" json:"compression_codec"`
	// Default: true.
	DictionaryEncoding *bool `json:"dictionary_encoding,omitempty"`
	// There is one dictionary page per column per row group when dictionary encoding is used. The dictionary page size works like the page size but for dictionary. Default: 1024 KB.
	DictionaryPageSizeKb *int64                                                  `default:"1024" json:"dictionary_page_size_kb"`
	FormatType           *DestinationS3UpdateSchemasFormatOutputFormatFormatType `default:"Parquet" json:"format_type"`
	// Maximum size allowed as padding to align row groups. This is also the minimum size of a row group. Default: 8 MB.
	MaxPaddingSizeMb *int64 `default:"8" json:"max_padding_size_mb"`
	// The page size is for compression. A block is composed of pages. A page is the smallest unit that must be read fully to access a single record. If this value is too small, the compression will deteriorate. Default: 1024 KB.
	PageSizeKb           *int64 `default:"1024" json:"page_size_kb"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (d DestinationS3UpdateParquetColumnarStorage) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationS3UpdateParquetColumnarStorage) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationS3UpdateParquetColumnarStorage) GetBlockSizeMb() *int64 {
	if d == nil {
		return nil
	}
	return d.BlockSizeMb
}

func (d *DestinationS3UpdateParquetColumnarStorage) GetCompressionCodec() *DestinationS3UpdateSchemasCompressionCodec {
	if d == nil {
		return nil
	}
	return d.CompressionCodec
}

func (d *DestinationS3UpdateParquetColumnarStorage) GetDictionaryEncoding() *bool {
	if d == nil {
		return nil
	}
	return d.DictionaryEncoding
}

func (d *DestinationS3UpdateParquetColumnarStorage) GetDictionaryPageSizeKb() *int64 {
	if d == nil {
		return nil
	}
	return d.DictionaryPageSizeKb
}

func (d *DestinationS3UpdateParquetColumnarStorage) GetFormatType() *DestinationS3UpdateSchemasFormatOutputFormatFormatType {
	if d == nil {
		return nil
	}
	return d.FormatType
}

func (d *DestinationS3UpdateParquetColumnarStorage) GetMaxPaddingSizeMb() *int64 {
	if d == nil {
		return nil
	}
	return d.MaxPaddingSizeMb
}

func (d *DestinationS3UpdateParquetColumnarStorage) GetPageSizeKb() *int64 {
	if d == nil {
		return nil
	}
	return d.PageSizeKb
}

func (d *DestinationS3UpdateParquetColumnarStorage) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationS3UpdateSchemasFormatOutputFormat3CompressionCodecCodec string

const (
	DestinationS3UpdateSchemasFormatOutputFormat3CompressionCodecCodecSnappy DestinationS3UpdateSchemasFormatOutputFormat3CompressionCodecCodec = "snappy"
)

func (e DestinationS3UpdateSchemasFormatOutputFormat3CompressionCodecCodec) ToPointer() *DestinationS3UpdateSchemasFormatOutputFormat3CompressionCodecCodec {
	return &e
}
func (e *DestinationS3UpdateSchemasFormatOutputFormat3CompressionCodecCodec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "snappy":
		*e = DestinationS3UpdateSchemasFormatOutputFormat3CompressionCodecCodec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3UpdateSchemasFormatOutputFormat3CompressionCodecCodec: %v", v)
	}
}

type DestinationS3UpdateSnappy struct {
	Codec                *DestinationS3UpdateSchemasFormatOutputFormat3CompressionCodecCodec `default:"snappy" json:"codec"`
	AdditionalProperties any                                                                 `additionalProperties:"true" json:"-"`
}

func (d DestinationS3UpdateSnappy) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationS3UpdateSnappy) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationS3UpdateSnappy) GetCodec() *DestinationS3UpdateSchemasFormatOutputFormat3CompressionCodecCodec {
	if d == nil {
		return nil
	}
	return d.Codec
}

func (d *DestinationS3UpdateSnappy) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationS3UpdateSchemasFormatOutputFormat3Codec string

const (
	DestinationS3UpdateSchemasFormatOutputFormat3CodecZstandard DestinationS3UpdateSchemasFormatOutputFormat3Codec = "zstandard"
)

func (e DestinationS3UpdateSchemasFormatOutputFormat3Codec) ToPointer() *DestinationS3UpdateSchemasFormatOutputFormat3Codec {
	return &e
}
func (e *DestinationS3UpdateSchemasFormatOutputFormat3Codec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "zstandard":
		*e = DestinationS3UpdateSchemasFormatOutputFormat3Codec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3UpdateSchemasFormatOutputFormat3Codec: %v", v)
	}
}

type DestinationS3UpdateZstandard struct {
	Codec                *DestinationS3UpdateSchemasFormatOutputFormat3Codec `default:"zstandard" json:"codec"`
	CompressionLevel     *int64                                              `json:"compression_level,omitempty"`
	IncludeChecksum      *bool                                               `json:"include_checksum,omitempty"`
	AdditionalProperties any                                                 `additionalProperties:"true" json:"-"`
}

func (d DestinationS3UpdateZstandard) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationS3UpdateZstandard) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationS3UpdateZstandard) GetCodec() *DestinationS3UpdateSchemasFormatOutputFormat3Codec {
	if d == nil {
		return nil
	}
	return d.Codec
}

func (d *DestinationS3UpdateZstandard) GetCompressionLevel() *int64 {
	if d == nil {
		return nil
	}
	return d.CompressionLevel
}

func (d *DestinationS3UpdateZstandard) GetIncludeChecksum() *bool {
	if d == nil {
		return nil
	}
	return d.IncludeChecksum
}

func (d *DestinationS3UpdateZstandard) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationS3UpdateSchemasFormatOutputFormatCodec string

const (
	DestinationS3UpdateSchemasFormatOutputFormatCodecXz DestinationS3UpdateSchemasFormatOutputFormatCodec = "xz"
)

func (e DestinationS3UpdateSchemasFormatOutputFormatCodec) ToPointer() *DestinationS3UpdateSchemasFormatOutputFormatCodec {
	return &e
}
func (e *DestinationS3UpdateSchemasFormatOutputFormatCodec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "xz":
		*e = DestinationS3UpdateSchemasFormatOutputFormatCodec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3UpdateSchemasFormatOutputFormatCodec: %v", v)
	}
}

type DestinationS3UpdateXz struct {
	Codec                *DestinationS3UpdateSchemasFormatOutputFormatCodec `default:"xz" json:"codec"`
	CompressionLevel     *int64                                             `json:"compression_level,omitempty"`
	AdditionalProperties any                                                `additionalProperties:"true" json:"-"`
}

func (d DestinationS3UpdateXz) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationS3UpdateXz) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationS3UpdateXz) GetCodec() *DestinationS3UpdateSchemasFormatOutputFormatCodec {
	if d == nil {
		return nil
	}
	return d.Codec
}

func (d *DestinationS3UpdateXz) GetCompressionLevel() *int64 {
	if d == nil {
		return nil
	}
	return d.CompressionLevel
}

func (d *DestinationS3UpdateXz) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationS3UpdateSchemasFormatCodec string

const (
	DestinationS3UpdateSchemasFormatCodecBzip2 DestinationS3UpdateSchemasFormatCodec = "bzip2"
)

func (e DestinationS3UpdateSchemasFormatCodec) ToPointer() *DestinationS3UpdateSchemasFormatCodec {
	return &e
}
func (e *DestinationS3UpdateSchemasFormatCodec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "bzip2":
		*e = DestinationS3UpdateSchemasFormatCodec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3UpdateSchemasFormatCodec: %v", v)
	}
}

type DestinationS3UpdateBzip2 struct {
	Codec                *DestinationS3UpdateSchemasFormatCodec `default:"bzip2" json:"codec"`
	AdditionalProperties any                                    `additionalProperties:"true" json:"-"`
}

func (d DestinationS3UpdateBzip2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationS3UpdateBzip2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationS3UpdateBzip2) GetCodec() *DestinationS3UpdateSchemasFormatCodec {
	if d == nil {
		return nil
	}
	return d.Codec
}

func (d *DestinationS3UpdateBzip2) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationS3UpdateSchemasCodec string

const (
	DestinationS3UpdateSchemasCodecDeflate DestinationS3UpdateSchemasCodec = "Deflate"
)

func (e DestinationS3UpdateSchemasCodec) ToPointer() *DestinationS3UpdateSchemasCodec {
	return &e
}
func (e *DestinationS3UpdateSchemasCodec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Deflate":
		*e = DestinationS3UpdateSchemasCodec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3UpdateSchemasCodec: %v", v)
	}
}

type DestinationS3UpdateDeflate struct {
	Codec                *DestinationS3UpdateSchemasCodec `default:"Deflate" json:"codec"`
	CompressionLevel     *int64                           `json:"compression_level,omitempty"`
	AdditionalProperties any                              `additionalProperties:"true" json:"-"`
}

func (d DestinationS3UpdateDeflate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationS3UpdateDeflate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationS3UpdateDeflate) GetCodec() *DestinationS3UpdateSchemasCodec {
	if d == nil {
		return nil
	}
	return d.Codec
}

func (d *DestinationS3UpdateDeflate) GetCompressionLevel() *int64 {
	if d == nil {
		return nil
	}
	return d.CompressionLevel
}

func (d *DestinationS3UpdateDeflate) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationS3UpdateCodec string

const (
	DestinationS3UpdateCodecNoCompression DestinationS3UpdateCodec = "no compression"
)

func (e DestinationS3UpdateCodec) ToPointer() *DestinationS3UpdateCodec {
	return &e
}
func (e *DestinationS3UpdateCodec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "no compression":
		*e = DestinationS3UpdateCodec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3UpdateCodec: %v", v)
	}
}

type DestinationS3UpdateSchemasFormatNoCompression struct {
	Codec                *DestinationS3UpdateCodec `default:"no compression" json:"codec"`
	AdditionalProperties any                       `additionalProperties:"true" json:"-"`
}

func (d DestinationS3UpdateSchemasFormatNoCompression) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationS3UpdateSchemasFormatNoCompression) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationS3UpdateSchemasFormatNoCompression) GetCodec() *DestinationS3UpdateCodec {
	if d == nil {
		return nil
	}
	return d.Codec
}

func (d *DestinationS3UpdateSchemasFormatNoCompression) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationS3UpdateCompressionCodecType string

const (
	DestinationS3UpdateCompressionCodecTypeDestinationS3UpdateSchemasFormatNoCompression DestinationS3UpdateCompressionCodecType = "destination-s3-update_Schemas_format_no compression"
	DestinationS3UpdateCompressionCodecTypeDestinationS3UpdateDeflate                    DestinationS3UpdateCompressionCodecType = "destination-s3-update_Deflate"
	DestinationS3UpdateCompressionCodecTypeDestinationS3UpdateBzip2                      DestinationS3UpdateCompressionCodecType = "destination-s3-update_bzip2"
	DestinationS3UpdateCompressionCodecTypeDestinationS3UpdateXz                         DestinationS3UpdateCompressionCodecType = "destination-s3-update_xz"
	DestinationS3UpdateCompressionCodecTypeDestinationS3UpdateZstandard                  DestinationS3UpdateCompressionCodecType = "destination-s3-update_zstandard"
	DestinationS3UpdateCompressionCodecTypeDestinationS3UpdateSnappy                     DestinationS3UpdateCompressionCodecType = "destination-s3-update_snappy"
)

// DestinationS3UpdateCompressionCodec - The compression algorithm used to compress data. Default to no compression.
type DestinationS3UpdateCompressionCodec struct {
	DestinationS3UpdateSchemasFormatNoCompression *DestinationS3UpdateSchemasFormatNoCompression `queryParam:"inline" union:"member"`
	DestinationS3UpdateDeflate                    *DestinationS3UpdateDeflate                    `queryParam:"inline" union:"member"`
	DestinationS3UpdateBzip2                      *DestinationS3UpdateBzip2                      `queryParam:"inline" union:"member"`
	DestinationS3UpdateXz                         *DestinationS3UpdateXz                         `queryParam:"inline" union:"member"`
	DestinationS3UpdateZstandard                  *DestinationS3UpdateZstandard                  `queryParam:"inline" union:"member"`
	DestinationS3UpdateSnappy                     *DestinationS3UpdateSnappy                     `queryParam:"inline" union:"member"`

	Type DestinationS3UpdateCompressionCodecType
}

func CreateDestinationS3UpdateCompressionCodecDestinationS3UpdateSchemasFormatNoCompression(destinationS3UpdateSchemasFormatNoCompression DestinationS3UpdateSchemasFormatNoCompression) DestinationS3UpdateCompressionCodec {
	typ := DestinationS3UpdateCompressionCodecTypeDestinationS3UpdateSchemasFormatNoCompression

	return DestinationS3UpdateCompressionCodec{
		DestinationS3UpdateSchemasFormatNoCompression: &destinationS3UpdateSchemasFormatNoCompression,
		Type: typ,
	}
}

func CreateDestinationS3UpdateCompressionCodecDestinationS3UpdateDeflate(destinationS3UpdateDeflate DestinationS3UpdateDeflate) DestinationS3UpdateCompressionCodec {
	typ := DestinationS3UpdateCompressionCodecTypeDestinationS3UpdateDeflate

	return DestinationS3UpdateCompressionCodec{
		DestinationS3UpdateDeflate: &destinationS3UpdateDeflate,
		Type:                       typ,
	}
}

func CreateDestinationS3UpdateCompressionCodecDestinationS3UpdateBzip2(destinationS3UpdateBzip2 DestinationS3UpdateBzip2) DestinationS3UpdateCompressionCodec {
	typ := DestinationS3UpdateCompressionCodecTypeDestinationS3UpdateBzip2

	return DestinationS3UpdateCompressionCodec{
		DestinationS3UpdateBzip2: &destinationS3UpdateBzip2,
		Type:                     typ,
	}
}

func CreateDestinationS3UpdateCompressionCodecDestinationS3UpdateXz(destinationS3UpdateXz DestinationS3UpdateXz) DestinationS3UpdateCompressionCodec {
	typ := DestinationS3UpdateCompressionCodecTypeDestinationS3UpdateXz

	return DestinationS3UpdateCompressionCodec{
		DestinationS3UpdateXz: &destinationS3UpdateXz,
		Type:                  typ,
	}
}

func CreateDestinationS3UpdateCompressionCodecDestinationS3UpdateZstandard(destinationS3UpdateZstandard DestinationS3UpdateZstandard) DestinationS3UpdateCompressionCodec {
	typ := DestinationS3UpdateCompressionCodecTypeDestinationS3UpdateZstandard

	return DestinationS3UpdateCompressionCodec{
		DestinationS3UpdateZstandard: &destinationS3UpdateZstandard,
		Type:                         typ,
	}
}

func CreateDestinationS3UpdateCompressionCodecDestinationS3UpdateSnappy(destinationS3UpdateSnappy DestinationS3UpdateSnappy) DestinationS3UpdateCompressionCodec {
	typ := DestinationS3UpdateCompressionCodecTypeDestinationS3UpdateSnappy

	return DestinationS3UpdateCompressionCodec{
		DestinationS3UpdateSnappy: &destinationS3UpdateSnappy,
		Type:                      typ,
	}
}

func (u *DestinationS3UpdateCompressionCodec) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var destinationS3UpdateSchemasFormatNoCompression DestinationS3UpdateSchemasFormatNoCompression = DestinationS3UpdateSchemasFormatNoCompression{}
	if err := utils.UnmarshalJSON(data, &destinationS3UpdateSchemasFormatNoCompression, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationS3UpdateCompressionCodecTypeDestinationS3UpdateSchemasFormatNoCompression,
			Value: &destinationS3UpdateSchemasFormatNoCompression,
		})
	}

	var destinationS3UpdateDeflate DestinationS3UpdateDeflate = DestinationS3UpdateDeflate{}
	if err := utils.UnmarshalJSON(data, &destinationS3UpdateDeflate, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationS3UpdateCompressionCodecTypeDestinationS3UpdateDeflate,
			Value: &destinationS3UpdateDeflate,
		})
	}

	var destinationS3UpdateBzip2 DestinationS3UpdateBzip2 = DestinationS3UpdateBzip2{}
	if err := utils.UnmarshalJSON(data, &destinationS3UpdateBzip2, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationS3UpdateCompressionCodecTypeDestinationS3UpdateBzip2,
			Value: &destinationS3UpdateBzip2,
		})
	}

	var destinationS3UpdateXz DestinationS3UpdateXz = DestinationS3UpdateXz{}
	if err := utils.UnmarshalJSON(data, &destinationS3UpdateXz, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationS3UpdateCompressionCodecTypeDestinationS3UpdateXz,
			Value: &destinationS3UpdateXz,
		})
	}

	var destinationS3UpdateZstandard DestinationS3UpdateZstandard = DestinationS3UpdateZstandard{}
	if err := utils.UnmarshalJSON(data, &destinationS3UpdateZstandard, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationS3UpdateCompressionCodecTypeDestinationS3UpdateZstandard,
			Value: &destinationS3UpdateZstandard,
		})
	}

	var destinationS3UpdateSnappy DestinationS3UpdateSnappy = DestinationS3UpdateSnappy{}
	if err := utils.UnmarshalJSON(data, &destinationS3UpdateSnappy, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationS3UpdateCompressionCodecTypeDestinationS3UpdateSnappy,
			Value: &destinationS3UpdateSnappy,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationS3UpdateCompressionCodec", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationS3UpdateCompressionCodec", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(DestinationS3UpdateCompressionCodecType)
	switch best.Type {
	case DestinationS3UpdateCompressionCodecTypeDestinationS3UpdateSchemasFormatNoCompression:
		u.DestinationS3UpdateSchemasFormatNoCompression = best.Value.(*DestinationS3UpdateSchemasFormatNoCompression)
		return nil
	case DestinationS3UpdateCompressionCodecTypeDestinationS3UpdateDeflate:
		u.DestinationS3UpdateDeflate = best.Value.(*DestinationS3UpdateDeflate)
		return nil
	case DestinationS3UpdateCompressionCodecTypeDestinationS3UpdateBzip2:
		u.DestinationS3UpdateBzip2 = best.Value.(*DestinationS3UpdateBzip2)
		return nil
	case DestinationS3UpdateCompressionCodecTypeDestinationS3UpdateXz:
		u.DestinationS3UpdateXz = best.Value.(*DestinationS3UpdateXz)
		return nil
	case DestinationS3UpdateCompressionCodecTypeDestinationS3UpdateZstandard:
		u.DestinationS3UpdateZstandard = best.Value.(*DestinationS3UpdateZstandard)
		return nil
	case DestinationS3UpdateCompressionCodecTypeDestinationS3UpdateSnappy:
		u.DestinationS3UpdateSnappy = best.Value.(*DestinationS3UpdateSnappy)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationS3UpdateCompressionCodec", string(data))
}

func (u DestinationS3UpdateCompressionCodec) MarshalJSON() ([]byte, error) {
	if u.DestinationS3UpdateSchemasFormatNoCompression != nil {
		return utils.MarshalJSON(u.DestinationS3UpdateSchemasFormatNoCompression, "", true)
	}

	if u.DestinationS3UpdateDeflate != nil {
		return utils.MarshalJSON(u.DestinationS3UpdateDeflate, "", true)
	}

	if u.DestinationS3UpdateBzip2 != nil {
		return utils.MarshalJSON(u.DestinationS3UpdateBzip2, "", true)
	}

	if u.DestinationS3UpdateXz != nil {
		return utils.MarshalJSON(u.DestinationS3UpdateXz, "", true)
	}

	if u.DestinationS3UpdateZstandard != nil {
		return utils.MarshalJSON(u.DestinationS3UpdateZstandard, "", true)
	}

	if u.DestinationS3UpdateSnappy != nil {
		return utils.MarshalJSON(u.DestinationS3UpdateSnappy, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationS3UpdateCompressionCodec: all fields are null")
}

type DestinationS3UpdateSchemasFormatFormatType string

const (
	DestinationS3UpdateSchemasFormatFormatTypeAvro DestinationS3UpdateSchemasFormatFormatType = "Avro"
)

func (e DestinationS3UpdateSchemasFormatFormatType) ToPointer() *DestinationS3UpdateSchemasFormatFormatType {
	return &e
}
func (e *DestinationS3UpdateSchemasFormatFormatType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Avro":
		*e = DestinationS3UpdateSchemasFormatFormatType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3UpdateSchemasFormatFormatType: %v", v)
	}
}

type DestinationS3UpdateAvroApacheAvro struct {
	// The compression algorithm used to compress data. Default to no compression.
	CompressionCodec     *DestinationS3UpdateCompressionCodec        `json:"compression_codec,omitempty"`
	FormatType           *DestinationS3UpdateSchemasFormatFormatType `default:"Avro" json:"format_type"`
	AdditionalProperties any                                         `additionalProperties:"true" json:"-"`
}

func (d DestinationS3UpdateAvroApacheAvro) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationS3UpdateAvroApacheAvro) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationS3UpdateAvroApacheAvro) GetCompressionCodec() *DestinationS3UpdateCompressionCodec {
	if d == nil {
		return nil
	}
	return d.CompressionCodec
}

func (d *DestinationS3UpdateAvroApacheAvro) GetFormatType() *DestinationS3UpdateSchemasFormatFormatType {
	if d == nil {
		return nil
	}
	return d.FormatType
}

func (d *DestinationS3UpdateAvroApacheAvro) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationS3UpdateSchemasFormatOutputFormatCompressionType string

const (
	DestinationS3UpdateSchemasFormatOutputFormatCompressionTypeGzip DestinationS3UpdateSchemasFormatOutputFormatCompressionType = "GZIP"
)

func (e DestinationS3UpdateSchemasFormatOutputFormatCompressionType) ToPointer() *DestinationS3UpdateSchemasFormatOutputFormatCompressionType {
	return &e
}
func (e *DestinationS3UpdateSchemasFormatOutputFormatCompressionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "GZIP":
		*e = DestinationS3UpdateSchemasFormatOutputFormatCompressionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3UpdateSchemasFormatOutputFormatCompressionType: %v", v)
	}
}

type DestinationS3UpdateSchemasGZIP struct {
	CompressionType      *DestinationS3UpdateSchemasFormatOutputFormatCompressionType `default:"GZIP" json:"compression_type"`
	AdditionalProperties any                                                          `additionalProperties:"true" json:"-"`
}

func (d DestinationS3UpdateSchemasGZIP) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationS3UpdateSchemasGZIP) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationS3UpdateSchemasGZIP) GetCompressionType() *DestinationS3UpdateSchemasFormatOutputFormatCompressionType {
	if d == nil {
		return nil
	}
	return d.CompressionType
}

func (d *DestinationS3UpdateSchemasGZIP) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationS3UpdateSchemasFormatCompressionType string

const (
	DestinationS3UpdateSchemasFormatCompressionTypeNoCompression DestinationS3UpdateSchemasFormatCompressionType = "No Compression"
)

func (e DestinationS3UpdateSchemasFormatCompressionType) ToPointer() *DestinationS3UpdateSchemasFormatCompressionType {
	return &e
}
func (e *DestinationS3UpdateSchemasFormatCompressionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "No Compression":
		*e = DestinationS3UpdateSchemasFormatCompressionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3UpdateSchemasFormatCompressionType: %v", v)
	}
}

type DestinationS3UpdateSchemasNoCompression struct {
	CompressionType      *DestinationS3UpdateSchemasFormatCompressionType `default:"No Compression" json:"compression_type"`
	AdditionalProperties any                                              `additionalProperties:"true" json:"-"`
}

func (d DestinationS3UpdateSchemasNoCompression) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationS3UpdateSchemasNoCompression) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationS3UpdateSchemasNoCompression) GetCompressionType() *DestinationS3UpdateSchemasFormatCompressionType {
	if d == nil {
		return nil
	}
	return d.CompressionType
}

func (d *DestinationS3UpdateSchemasNoCompression) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationS3UpdateSchemasCompressionUnionType string

const (
	DestinationS3UpdateSchemasCompressionUnionTypeDestinationS3UpdateSchemasNoCompression DestinationS3UpdateSchemasCompressionUnionType = "destination-s3-update_Schemas_No Compression"
	DestinationS3UpdateSchemasCompressionUnionTypeDestinationS3UpdateSchemasGZIP          DestinationS3UpdateSchemasCompressionUnionType = "destination-s3-update_Schemas_GZIP"
)

// DestinationS3UpdateSchemasCompression - Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").
type DestinationS3UpdateSchemasCompression struct {
	DestinationS3UpdateSchemasNoCompression *DestinationS3UpdateSchemasNoCompression `queryParam:"inline" union:"member"`
	DestinationS3UpdateSchemasGZIP          *DestinationS3UpdateSchemasGZIP          `queryParam:"inline" union:"member"`

	Type DestinationS3UpdateSchemasCompressionUnionType
}

func CreateDestinationS3UpdateSchemasCompressionDestinationS3UpdateSchemasNoCompression(destinationS3UpdateSchemasNoCompression DestinationS3UpdateSchemasNoCompression) DestinationS3UpdateSchemasCompression {
	typ := DestinationS3UpdateSchemasCompressionUnionTypeDestinationS3UpdateSchemasNoCompression

	return DestinationS3UpdateSchemasCompression{
		DestinationS3UpdateSchemasNoCompression: &destinationS3UpdateSchemasNoCompression,
		Type:                                    typ,
	}
}

func CreateDestinationS3UpdateSchemasCompressionDestinationS3UpdateSchemasGZIP(destinationS3UpdateSchemasGZIP DestinationS3UpdateSchemasGZIP) DestinationS3UpdateSchemasCompression {
	typ := DestinationS3UpdateSchemasCompressionUnionTypeDestinationS3UpdateSchemasGZIP

	return DestinationS3UpdateSchemasCompression{
		DestinationS3UpdateSchemasGZIP: &destinationS3UpdateSchemasGZIP,
		Type:                           typ,
	}
}

func (u *DestinationS3UpdateSchemasCompression) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var destinationS3UpdateSchemasNoCompression DestinationS3UpdateSchemasNoCompression = DestinationS3UpdateSchemasNoCompression{}
	if err := utils.UnmarshalJSON(data, &destinationS3UpdateSchemasNoCompression, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationS3UpdateSchemasCompressionUnionTypeDestinationS3UpdateSchemasNoCompression,
			Value: &destinationS3UpdateSchemasNoCompression,
		})
	}

	var destinationS3UpdateSchemasGZIP DestinationS3UpdateSchemasGZIP = DestinationS3UpdateSchemasGZIP{}
	if err := utils.UnmarshalJSON(data, &destinationS3UpdateSchemasGZIP, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationS3UpdateSchemasCompressionUnionTypeDestinationS3UpdateSchemasGZIP,
			Value: &destinationS3UpdateSchemasGZIP,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationS3UpdateSchemasCompression", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationS3UpdateSchemasCompression", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(DestinationS3UpdateSchemasCompressionUnionType)
	switch best.Type {
	case DestinationS3UpdateSchemasCompressionUnionTypeDestinationS3UpdateSchemasNoCompression:
		u.DestinationS3UpdateSchemasNoCompression = best.Value.(*DestinationS3UpdateSchemasNoCompression)
		return nil
	case DestinationS3UpdateSchemasCompressionUnionTypeDestinationS3UpdateSchemasGZIP:
		u.DestinationS3UpdateSchemasGZIP = best.Value.(*DestinationS3UpdateSchemasGZIP)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationS3UpdateSchemasCompression", string(data))
}

func (u DestinationS3UpdateSchemasCompression) MarshalJSON() ([]byte, error) {
	if u.DestinationS3UpdateSchemasNoCompression != nil {
		return utils.MarshalJSON(u.DestinationS3UpdateSchemasNoCompression, "", true)
	}

	if u.DestinationS3UpdateSchemasGZIP != nil {
		return utils.MarshalJSON(u.DestinationS3UpdateSchemasGZIP, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationS3UpdateSchemasCompression: all fields are null")
}

type DestinationS3UpdateSchemasFlattening string

const (
	DestinationS3UpdateSchemasFlatteningNoFlattening        DestinationS3UpdateSchemasFlattening = "No flattening"
	DestinationS3UpdateSchemasFlatteningRootLevelFlattening DestinationS3UpdateSchemasFlattening = "Root level flattening"
)

func (e DestinationS3UpdateSchemasFlattening) ToPointer() *DestinationS3UpdateSchemasFlattening {
	return &e
}
func (e *DestinationS3UpdateSchemasFlattening) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "No flattening":
		fallthrough
	case "Root level flattening":
		*e = DestinationS3UpdateSchemasFlattening(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3UpdateSchemasFlattening: %v", v)
	}
}

type DestinationS3UpdateSchemasFormatType string

const (
	DestinationS3UpdateSchemasFormatTypeJsonl DestinationS3UpdateSchemasFormatType = "JSONL"
)

func (e DestinationS3UpdateSchemasFormatType) ToPointer() *DestinationS3UpdateSchemasFormatType {
	return &e
}
func (e *DestinationS3UpdateSchemasFormatType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "JSONL":
		*e = DestinationS3UpdateSchemasFormatType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3UpdateSchemasFormatType: %v", v)
	}
}

type DestinationS3UpdateJSONLinesNewlineDelimitedJSON struct {
	// Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").
	Compression          *DestinationS3UpdateSchemasCompression `json:"compression,omitempty"`
	Flattening           *DestinationS3UpdateSchemasFlattening  `default:"No flattening" json:"flattening"`
	FormatType           *DestinationS3UpdateSchemasFormatType  `default:"JSONL" json:"format_type"`
	AdditionalProperties any                                    `additionalProperties:"true" json:"-"`
}

func (d DestinationS3UpdateJSONLinesNewlineDelimitedJSON) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationS3UpdateJSONLinesNewlineDelimitedJSON) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationS3UpdateJSONLinesNewlineDelimitedJSON) GetCompression() *DestinationS3UpdateSchemasCompression {
	if d == nil {
		return nil
	}
	return d.Compression
}

func (d *DestinationS3UpdateJSONLinesNewlineDelimitedJSON) GetFlattening() *DestinationS3UpdateSchemasFlattening {
	if d == nil {
		return nil
	}
	return d.Flattening
}

func (d *DestinationS3UpdateJSONLinesNewlineDelimitedJSON) GetFormatType() *DestinationS3UpdateSchemasFormatType {
	if d == nil {
		return nil
	}
	return d.FormatType
}

func (d *DestinationS3UpdateJSONLinesNewlineDelimitedJSON) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationS3UpdateSchemasCompressionType string

const (
	DestinationS3UpdateSchemasCompressionTypeGzip DestinationS3UpdateSchemasCompressionType = "GZIP"
)

func (e DestinationS3UpdateSchemasCompressionType) ToPointer() *DestinationS3UpdateSchemasCompressionType {
	return &e
}
func (e *DestinationS3UpdateSchemasCompressionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "GZIP":
		*e = DestinationS3UpdateSchemasCompressionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3UpdateSchemasCompressionType: %v", v)
	}
}

type DestinationS3UpdateGZIP struct {
	CompressionType      *DestinationS3UpdateSchemasCompressionType `default:"GZIP" json:"compression_type"`
	AdditionalProperties any                                        `additionalProperties:"true" json:"-"`
}

func (d DestinationS3UpdateGZIP) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationS3UpdateGZIP) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationS3UpdateGZIP) GetCompressionType() *DestinationS3UpdateSchemasCompressionType {
	if d == nil {
		return nil
	}
	return d.CompressionType
}

func (d *DestinationS3UpdateGZIP) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationS3UpdateCompressionType string

const (
	DestinationS3UpdateCompressionTypeNoCompression DestinationS3UpdateCompressionType = "No Compression"
)

func (e DestinationS3UpdateCompressionType) ToPointer() *DestinationS3UpdateCompressionType {
	return &e
}
func (e *DestinationS3UpdateCompressionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "No Compression":
		*e = DestinationS3UpdateCompressionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3UpdateCompressionType: %v", v)
	}
}

type DestinationS3UpdateNoCompression struct {
	CompressionType      *DestinationS3UpdateCompressionType `default:"No Compression" json:"compression_type"`
	AdditionalProperties any                                 `additionalProperties:"true" json:"-"`
}

func (d DestinationS3UpdateNoCompression) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationS3UpdateNoCompression) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationS3UpdateNoCompression) GetCompressionType() *DestinationS3UpdateCompressionType {
	if d == nil {
		return nil
	}
	return d.CompressionType
}

func (d *DestinationS3UpdateNoCompression) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationS3UpdateCompressionUnionType string

const (
	DestinationS3UpdateCompressionUnionTypeDestinationS3UpdateNoCompression DestinationS3UpdateCompressionUnionType = "destination-s3-update_No Compression"
	DestinationS3UpdateCompressionUnionTypeDestinationS3UpdateGZIP          DestinationS3UpdateCompressionUnionType = "destination-s3-update_GZIP"
)

// DestinationS3UpdateCompression - Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").
type DestinationS3UpdateCompression struct {
	DestinationS3UpdateNoCompression *DestinationS3UpdateNoCompression `queryParam:"inline" union:"member"`
	DestinationS3UpdateGZIP          *DestinationS3UpdateGZIP          `queryParam:"inline" union:"member"`

	Type DestinationS3UpdateCompressionUnionType
}

func CreateDestinationS3UpdateCompressionDestinationS3UpdateNoCompression(destinationS3UpdateNoCompression DestinationS3UpdateNoCompression) DestinationS3UpdateCompression {
	typ := DestinationS3UpdateCompressionUnionTypeDestinationS3UpdateNoCompression

	return DestinationS3UpdateCompression{
		DestinationS3UpdateNoCompression: &destinationS3UpdateNoCompression,
		Type:                             typ,
	}
}

func CreateDestinationS3UpdateCompressionDestinationS3UpdateGZIP(destinationS3UpdateGZIP DestinationS3UpdateGZIP) DestinationS3UpdateCompression {
	typ := DestinationS3UpdateCompressionUnionTypeDestinationS3UpdateGZIP

	return DestinationS3UpdateCompression{
		DestinationS3UpdateGZIP: &destinationS3UpdateGZIP,
		Type:                    typ,
	}
}

func (u *DestinationS3UpdateCompression) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var destinationS3UpdateNoCompression DestinationS3UpdateNoCompression = DestinationS3UpdateNoCompression{}
	if err := utils.UnmarshalJSON(data, &destinationS3UpdateNoCompression, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationS3UpdateCompressionUnionTypeDestinationS3UpdateNoCompression,
			Value: &destinationS3UpdateNoCompression,
		})
	}

	var destinationS3UpdateGZIP DestinationS3UpdateGZIP = DestinationS3UpdateGZIP{}
	if err := utils.UnmarshalJSON(data, &destinationS3UpdateGZIP, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationS3UpdateCompressionUnionTypeDestinationS3UpdateGZIP,
			Value: &destinationS3UpdateGZIP,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationS3UpdateCompression", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationS3UpdateCompression", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(DestinationS3UpdateCompressionUnionType)
	switch best.Type {
	case DestinationS3UpdateCompressionUnionTypeDestinationS3UpdateNoCompression:
		u.DestinationS3UpdateNoCompression = best.Value.(*DestinationS3UpdateNoCompression)
		return nil
	case DestinationS3UpdateCompressionUnionTypeDestinationS3UpdateGZIP:
		u.DestinationS3UpdateGZIP = best.Value.(*DestinationS3UpdateGZIP)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationS3UpdateCompression", string(data))
}

func (u DestinationS3UpdateCompression) MarshalJSON() ([]byte, error) {
	if u.DestinationS3UpdateNoCompression != nil {
		return utils.MarshalJSON(u.DestinationS3UpdateNoCompression, "", true)
	}

	if u.DestinationS3UpdateGZIP != nil {
		return utils.MarshalJSON(u.DestinationS3UpdateGZIP, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationS3UpdateCompression: all fields are null")
}

type DestinationS3UpdateFlattening string

const (
	DestinationS3UpdateFlatteningNoFlattening        DestinationS3UpdateFlattening = "No flattening"
	DestinationS3UpdateFlatteningRootLevelFlattening DestinationS3UpdateFlattening = "Root level flattening"
)

func (e DestinationS3UpdateFlattening) ToPointer() *DestinationS3UpdateFlattening {
	return &e
}
func (e *DestinationS3UpdateFlattening) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "No flattening":
		fallthrough
	case "Root level flattening":
		*e = DestinationS3UpdateFlattening(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3UpdateFlattening: %v", v)
	}
}

type DestinationS3UpdateFormatType string

const (
	DestinationS3UpdateFormatTypeCsv DestinationS3UpdateFormatType = "CSV"
)

func (e DestinationS3UpdateFormatType) ToPointer() *DestinationS3UpdateFormatType {
	return &e
}
func (e *DestinationS3UpdateFormatType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CSV":
		*e = DestinationS3UpdateFormatType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3UpdateFormatType: %v", v)
	}
}

type DestinationS3UpdateCSVCommaSeparatedValues struct {
	// Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").
	Compression          *DestinationS3UpdateCompression `json:"compression,omitempty"`
	Flattening           *DestinationS3UpdateFlattening  `default:"No flattening" json:"flattening"`
	FormatType           *DestinationS3UpdateFormatType  `default:"CSV" json:"format_type"`
	AdditionalProperties any                             `additionalProperties:"true" json:"-"`
}

func (d DestinationS3UpdateCSVCommaSeparatedValues) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationS3UpdateCSVCommaSeparatedValues) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationS3UpdateCSVCommaSeparatedValues) GetCompression() *DestinationS3UpdateCompression {
	if d == nil {
		return nil
	}
	return d.Compression
}

func (d *DestinationS3UpdateCSVCommaSeparatedValues) GetFlattening() *DestinationS3UpdateFlattening {
	if d == nil {
		return nil
	}
	return d.Flattening
}

func (d *DestinationS3UpdateCSVCommaSeparatedValues) GetFormatType() *DestinationS3UpdateFormatType {
	if d == nil {
		return nil
	}
	return d.FormatType
}

func (d *DestinationS3UpdateCSVCommaSeparatedValues) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationS3UpdateOutputFormatType string

const (
	DestinationS3UpdateOutputFormatTypeDestinationS3UpdateCSVCommaSeparatedValues       DestinationS3UpdateOutputFormatType = "destination-s3-update_CSV: Comma-Separated Values"
	DestinationS3UpdateOutputFormatTypeDestinationS3UpdateJSONLinesNewlineDelimitedJSON DestinationS3UpdateOutputFormatType = "destination-s3-update_JSON Lines: Newline-delimited JSON"
	DestinationS3UpdateOutputFormatTypeDestinationS3UpdateAvroApacheAvro                DestinationS3UpdateOutputFormatType = "destination-s3-update_Avro: Apache Avro"
	DestinationS3UpdateOutputFormatTypeDestinationS3UpdateParquetColumnarStorage        DestinationS3UpdateOutputFormatType = "destination-s3-update_Parquet: Columnar Storage"
)

// DestinationS3UpdateOutputFormat - Format of the data output. See <a href="https://docs.airbyte.com/integrations/destinations/s3/#supported-output-schema">here</a> for more details
type DestinationS3UpdateOutputFormat struct {
	DestinationS3UpdateCSVCommaSeparatedValues       *DestinationS3UpdateCSVCommaSeparatedValues       `queryParam:"inline" union:"member"`
	DestinationS3UpdateJSONLinesNewlineDelimitedJSON *DestinationS3UpdateJSONLinesNewlineDelimitedJSON `queryParam:"inline" union:"member"`
	DestinationS3UpdateAvroApacheAvro                *DestinationS3UpdateAvroApacheAvro                `queryParam:"inline" union:"member"`
	DestinationS3UpdateParquetColumnarStorage        *DestinationS3UpdateParquetColumnarStorage        `queryParam:"inline" union:"member"`

	Type DestinationS3UpdateOutputFormatType
}

func CreateDestinationS3UpdateOutputFormatDestinationS3UpdateCSVCommaSeparatedValues(destinationS3UpdateCSVCommaSeparatedValues DestinationS3UpdateCSVCommaSeparatedValues) DestinationS3UpdateOutputFormat {
	typ := DestinationS3UpdateOutputFormatTypeDestinationS3UpdateCSVCommaSeparatedValues

	return DestinationS3UpdateOutputFormat{
		DestinationS3UpdateCSVCommaSeparatedValues: &destinationS3UpdateCSVCommaSeparatedValues,
		Type: typ,
	}
}

func CreateDestinationS3UpdateOutputFormatDestinationS3UpdateJSONLinesNewlineDelimitedJSON(destinationS3UpdateJSONLinesNewlineDelimitedJSON DestinationS3UpdateJSONLinesNewlineDelimitedJSON) DestinationS3UpdateOutputFormat {
	typ := DestinationS3UpdateOutputFormatTypeDestinationS3UpdateJSONLinesNewlineDelimitedJSON

	return DestinationS3UpdateOutputFormat{
		DestinationS3UpdateJSONLinesNewlineDelimitedJSON: &destinationS3UpdateJSONLinesNewlineDelimitedJSON,
		Type: typ,
	}
}

func CreateDestinationS3UpdateOutputFormatDestinationS3UpdateAvroApacheAvro(destinationS3UpdateAvroApacheAvro DestinationS3UpdateAvroApacheAvro) DestinationS3UpdateOutputFormat {
	typ := DestinationS3UpdateOutputFormatTypeDestinationS3UpdateAvroApacheAvro

	return DestinationS3UpdateOutputFormat{
		DestinationS3UpdateAvroApacheAvro: &destinationS3UpdateAvroApacheAvro,
		Type:                              typ,
	}
}

func CreateDestinationS3UpdateOutputFormatDestinationS3UpdateParquetColumnarStorage(destinationS3UpdateParquetColumnarStorage DestinationS3UpdateParquetColumnarStorage) DestinationS3UpdateOutputFormat {
	typ := DestinationS3UpdateOutputFormatTypeDestinationS3UpdateParquetColumnarStorage

	return DestinationS3UpdateOutputFormat{
		DestinationS3UpdateParquetColumnarStorage: &destinationS3UpdateParquetColumnarStorage,
		Type: typ,
	}
}

func (u *DestinationS3UpdateOutputFormat) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var destinationS3UpdateCSVCommaSeparatedValues DestinationS3UpdateCSVCommaSeparatedValues = DestinationS3UpdateCSVCommaSeparatedValues{}
	if err := utils.UnmarshalJSON(data, &destinationS3UpdateCSVCommaSeparatedValues, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationS3UpdateOutputFormatTypeDestinationS3UpdateCSVCommaSeparatedValues,
			Value: &destinationS3UpdateCSVCommaSeparatedValues,
		})
	}

	var destinationS3UpdateJSONLinesNewlineDelimitedJSON DestinationS3UpdateJSONLinesNewlineDelimitedJSON = DestinationS3UpdateJSONLinesNewlineDelimitedJSON{}
	if err := utils.UnmarshalJSON(data, &destinationS3UpdateJSONLinesNewlineDelimitedJSON, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationS3UpdateOutputFormatTypeDestinationS3UpdateJSONLinesNewlineDelimitedJSON,
			Value: &destinationS3UpdateJSONLinesNewlineDelimitedJSON,
		})
	}

	var destinationS3UpdateAvroApacheAvro DestinationS3UpdateAvroApacheAvro = DestinationS3UpdateAvroApacheAvro{}
	if err := utils.UnmarshalJSON(data, &destinationS3UpdateAvroApacheAvro, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationS3UpdateOutputFormatTypeDestinationS3UpdateAvroApacheAvro,
			Value: &destinationS3UpdateAvroApacheAvro,
		})
	}

	var destinationS3UpdateParquetColumnarStorage DestinationS3UpdateParquetColumnarStorage = DestinationS3UpdateParquetColumnarStorage{}
	if err := utils.UnmarshalJSON(data, &destinationS3UpdateParquetColumnarStorage, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationS3UpdateOutputFormatTypeDestinationS3UpdateParquetColumnarStorage,
			Value: &destinationS3UpdateParquetColumnarStorage,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationS3UpdateOutputFormat", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationS3UpdateOutputFormat", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(DestinationS3UpdateOutputFormatType)
	switch best.Type {
	case DestinationS3UpdateOutputFormatTypeDestinationS3UpdateCSVCommaSeparatedValues:
		u.DestinationS3UpdateCSVCommaSeparatedValues = best.Value.(*DestinationS3UpdateCSVCommaSeparatedValues)
		return nil
	case DestinationS3UpdateOutputFormatTypeDestinationS3UpdateJSONLinesNewlineDelimitedJSON:
		u.DestinationS3UpdateJSONLinesNewlineDelimitedJSON = best.Value.(*DestinationS3UpdateJSONLinesNewlineDelimitedJSON)
		return nil
	case DestinationS3UpdateOutputFormatTypeDestinationS3UpdateAvroApacheAvro:
		u.DestinationS3UpdateAvroApacheAvro = best.Value.(*DestinationS3UpdateAvroApacheAvro)
		return nil
	case DestinationS3UpdateOutputFormatTypeDestinationS3UpdateParquetColumnarStorage:
		u.DestinationS3UpdateParquetColumnarStorage = best.Value.(*DestinationS3UpdateParquetColumnarStorage)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationS3UpdateOutputFormat", string(data))
}

func (u DestinationS3UpdateOutputFormat) MarshalJSON() ([]byte, error) {
	if u.DestinationS3UpdateCSVCommaSeparatedValues != nil {
		return utils.MarshalJSON(u.DestinationS3UpdateCSVCommaSeparatedValues, "", true)
	}

	if u.DestinationS3UpdateJSONLinesNewlineDelimitedJSON != nil {
		return utils.MarshalJSON(u.DestinationS3UpdateJSONLinesNewlineDelimitedJSON, "", true)
	}

	if u.DestinationS3UpdateAvroApacheAvro != nil {
		return utils.MarshalJSON(u.DestinationS3UpdateAvroApacheAvro, "", true)
	}

	if u.DestinationS3UpdateParquetColumnarStorage != nil {
		return utils.MarshalJSON(u.DestinationS3UpdateParquetColumnarStorage, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationS3UpdateOutputFormat: all fields are null")
}

// DestinationS3UpdateS3BucketRegion - The region of the S3 bucket. See <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-available-regions">here</a> for all region codes.
type DestinationS3UpdateS3BucketRegion string

const (
	DestinationS3UpdateS3BucketRegionUnknown      DestinationS3UpdateS3BucketRegion = ""
	DestinationS3UpdateS3BucketRegionAfSouth1     DestinationS3UpdateS3BucketRegion = "af-south-1"
	DestinationS3UpdateS3BucketRegionApEast1      DestinationS3UpdateS3BucketRegion = "ap-east-1"
	DestinationS3UpdateS3BucketRegionApNortheast1 DestinationS3UpdateS3BucketRegion = "ap-northeast-1"
	DestinationS3UpdateS3BucketRegionApNortheast2 DestinationS3UpdateS3BucketRegion = "ap-northeast-2"
	DestinationS3UpdateS3BucketRegionApNortheast3 DestinationS3UpdateS3BucketRegion = "ap-northeast-3"
	DestinationS3UpdateS3BucketRegionApSouth1     DestinationS3UpdateS3BucketRegion = "ap-south-1"
	DestinationS3UpdateS3BucketRegionApSouth2     DestinationS3UpdateS3BucketRegion = "ap-south-2"
	DestinationS3UpdateS3BucketRegionApSoutheast1 DestinationS3UpdateS3BucketRegion = "ap-southeast-1"
	DestinationS3UpdateS3BucketRegionApSoutheast2 DestinationS3UpdateS3BucketRegion = "ap-southeast-2"
	DestinationS3UpdateS3BucketRegionApSoutheast3 DestinationS3UpdateS3BucketRegion = "ap-southeast-3"
	DestinationS3UpdateS3BucketRegionApSoutheast4 DestinationS3UpdateS3BucketRegion = "ap-southeast-4"
	DestinationS3UpdateS3BucketRegionCaCentral1   DestinationS3UpdateS3BucketRegion = "ca-central-1"
	DestinationS3UpdateS3BucketRegionCaWest1      DestinationS3UpdateS3BucketRegion = "ca-west-1"
	DestinationS3UpdateS3BucketRegionCnNorth1     DestinationS3UpdateS3BucketRegion = "cn-north-1"
	DestinationS3UpdateS3BucketRegionCnNorthwest1 DestinationS3UpdateS3BucketRegion = "cn-northwest-1"
	DestinationS3UpdateS3BucketRegionEuCentral1   DestinationS3UpdateS3BucketRegion = "eu-central-1"
	DestinationS3UpdateS3BucketRegionEuCentral2   DestinationS3UpdateS3BucketRegion = "eu-central-2"
	DestinationS3UpdateS3BucketRegionEuNorth1     DestinationS3UpdateS3BucketRegion = "eu-north-1"
	DestinationS3UpdateS3BucketRegionEuSouth1     DestinationS3UpdateS3BucketRegion = "eu-south-1"
	DestinationS3UpdateS3BucketRegionEuSouth2     DestinationS3UpdateS3BucketRegion = "eu-south-2"
	DestinationS3UpdateS3BucketRegionEuWest1      DestinationS3UpdateS3BucketRegion = "eu-west-1"
	DestinationS3UpdateS3BucketRegionEuWest2      DestinationS3UpdateS3BucketRegion = "eu-west-2"
	DestinationS3UpdateS3BucketRegionEuWest3      DestinationS3UpdateS3BucketRegion = "eu-west-3"
	DestinationS3UpdateS3BucketRegionIlCentral1   DestinationS3UpdateS3BucketRegion = "il-central-1"
	DestinationS3UpdateS3BucketRegionMeCentral1   DestinationS3UpdateS3BucketRegion = "me-central-1"
	DestinationS3UpdateS3BucketRegionMeSouth1     DestinationS3UpdateS3BucketRegion = "me-south-1"
	DestinationS3UpdateS3BucketRegionSaEast1      DestinationS3UpdateS3BucketRegion = "sa-east-1"
	DestinationS3UpdateS3BucketRegionUsEast1      DestinationS3UpdateS3BucketRegion = "us-east-1"
	DestinationS3UpdateS3BucketRegionUsEast2      DestinationS3UpdateS3BucketRegion = "us-east-2"
	DestinationS3UpdateS3BucketRegionUsGovEast1   DestinationS3UpdateS3BucketRegion = "us-gov-east-1"
	DestinationS3UpdateS3BucketRegionUsGovWest1   DestinationS3UpdateS3BucketRegion = "us-gov-west-1"
	DestinationS3UpdateS3BucketRegionUsWest1      DestinationS3UpdateS3BucketRegion = "us-west-1"
	DestinationS3UpdateS3BucketRegionUsWest2      DestinationS3UpdateS3BucketRegion = "us-west-2"
)

func (e DestinationS3UpdateS3BucketRegion) ToPointer() *DestinationS3UpdateS3BucketRegion {
	return &e
}
func (e *DestinationS3UpdateS3BucketRegion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "":
		fallthrough
	case "af-south-1":
		fallthrough
	case "ap-east-1":
		fallthrough
	case "ap-northeast-1":
		fallthrough
	case "ap-northeast-2":
		fallthrough
	case "ap-northeast-3":
		fallthrough
	case "ap-south-1":
		fallthrough
	case "ap-south-2":
		fallthrough
	case "ap-southeast-1":
		fallthrough
	case "ap-southeast-2":
		fallthrough
	case "ap-southeast-3":
		fallthrough
	case "ap-southeast-4":
		fallthrough
	case "ca-central-1":
		fallthrough
	case "ca-west-1":
		fallthrough
	case "cn-north-1":
		fallthrough
	case "cn-northwest-1":
		fallthrough
	case "eu-central-1":
		fallthrough
	case "eu-central-2":
		fallthrough
	case "eu-north-1":
		fallthrough
	case "eu-south-1":
		fallthrough
	case "eu-south-2":
		fallthrough
	case "eu-west-1":
		fallthrough
	case "eu-west-2":
		fallthrough
	case "eu-west-3":
		fallthrough
	case "il-central-1":
		fallthrough
	case "me-central-1":
		fallthrough
	case "me-south-1":
		fallthrough
	case "sa-east-1":
		fallthrough
	case "us-east-1":
		fallthrough
	case "us-east-2":
		fallthrough
	case "us-gov-east-1":
		fallthrough
	case "us-gov-west-1":
		fallthrough
	case "us-west-1":
		fallthrough
	case "us-west-2":
		*e = DestinationS3UpdateS3BucketRegion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3UpdateS3BucketRegion: %v", v)
	}
}

type DestinationS3UpdateDestinationType string

const (
	DestinationS3UpdateDestinationTypeS3 DestinationS3UpdateDestinationType = "s3"
)

func (e DestinationS3UpdateDestinationType) ToPointer() *DestinationS3UpdateDestinationType {
	return &e
}
func (e *DestinationS3UpdateDestinationType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "s3":
		*e = DestinationS3UpdateDestinationType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3UpdateDestinationType: %v", v)
	}
}

type DestinationS3Update struct {
	// The access key ID to access the S3 bucket. Airbyte requires Read and Write permissions to the given bucket. Read more <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">here</a>.
	AccessKeyID *string `json:"access_key_id,omitempty"`
	// Pattern to match file names in the bucket directory. Read more <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/ListingKeysUsingAPIs.html">here</a>
	FileNamePattern *string `json:"file_name_pattern,omitempty"`
	// Format of the data output. See <a href="https://docs.airbyte.com/integrations/destinations/s3/#supported-output-schema">here</a> for more details
	Format *DestinationS3UpdateOutputFormat `json:"format,omitempty"`
	// The ARN of the AWS role to assume. Only usable in Airbyte Cloud.
	RoleArn *string `json:"role_arn,omitempty"`
	// The name of the S3 bucket. Read more <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/create-bucket-overview.html">here</a>.
	S3BucketName *string `json:"s3_bucket_name,omitempty"`
	// Directory under the S3 bucket where data will be written. Read more <a href="https://docs.airbyte.com/integrations/destinations/s3#:~:text=to%20format%20the-,bucket%20path,-%3A">here</a>
	S3BucketPath *string `json:"s3_bucket_path,omitempty"`
	// The region of the S3 bucket. See <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-available-regions">here</a> for all region codes.
	S3BucketRegion *DestinationS3UpdateS3BucketRegion `default:"" json:"s3_bucket_region"`
	// Your S3 endpoint url. Read more <a href="https://docs.aws.amazon.com/general/latest/gr/s3.html#:~:text=Service%20endpoints-,Amazon%20S3%20endpoints,-When%20you%20use">here</a>
	S3Endpoint *string `json:"s3_endpoint,omitempty"`
	// Format string on how data will be organized inside the bucket directory. Read more <a href="https://docs.airbyte.com/integrations/destinations/s3#:~:text=The%20full%20path%20of%20the%20output%20data%20with%20the%20default%20S3%20path%20format">here</a>
	S3PathFormat *string `json:"s3_path_format,omitempty"`
	// The corresponding secret to the access key ID. Read more <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">here</a>
	SecretAccessKey      *string                             `json:"secret_access_key,omitempty"`
	destinationType      *DestinationS3UpdateDestinationType `const:"s3" json:"destinationType"`
	AdditionalProperties any                                 `additionalProperties:"true" json:"-"`
}

func (d DestinationS3Update) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationS3Update) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationS3Update) GetAccessKeyID() *string {
	if d == nil {
		return nil
	}
	return d.AccessKeyID
}

func (d *DestinationS3Update) GetFileNamePattern() *string {
	if d == nil {
		return nil
	}
	return d.FileNamePattern
}

func (d *DestinationS3Update) GetFormat() *DestinationS3UpdateOutputFormat {
	if d == nil {
		return nil
	}
	return d.Format
}

func (d *DestinationS3Update) GetRoleArn() *string {
	if d == nil {
		return nil
	}
	return d.RoleArn
}

func (d *DestinationS3Update) GetS3BucketName() *string {
	if d == nil {
		return nil
	}
	return d.S3BucketName
}

func (d *DestinationS3Update) GetS3BucketPath() *string {
	if d == nil {
		return nil
	}
	return d.S3BucketPath
}

func (d *DestinationS3Update) GetS3BucketRegion() *DestinationS3UpdateS3BucketRegion {
	if d == nil {
		return nil
	}
	return d.S3BucketRegion
}

func (d *DestinationS3Update) GetS3Endpoint() *string {
	if d == nil {
		return nil
	}
	return d.S3Endpoint
}

func (d *DestinationS3Update) GetS3PathFormat() *string {
	if d == nil {
		return nil
	}
	return d.S3PathFormat
}

func (d *DestinationS3Update) GetSecretAccessKey() *string {
	if d == nil {
		return nil
	}
	return d.SecretAccessKey
}

func (d *DestinationS3Update) GetDestinationType() *DestinationS3UpdateDestinationType {
	return DestinationS3UpdateDestinationTypeS3.ToPointer()
}

func (d *DestinationS3Update) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}
