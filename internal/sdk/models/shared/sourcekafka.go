// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/types"
)

type DeserializationStrategy string

const (
	DeserializationStrategyTopicNameStrategy       DeserializationStrategy = "TopicNameStrategy"
	DeserializationStrategyRecordNameStrategy      DeserializationStrategy = "RecordNameStrategy"
	DeserializationStrategyTopicRecordNameStrategy DeserializationStrategy = "TopicRecordNameStrategy"
)

func (e DeserializationStrategy) ToPointer() *DeserializationStrategy {
	return &e
}
func (e *DeserializationStrategy) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "TopicNameStrategy":
		fallthrough
	case "RecordNameStrategy":
		fallthrough
	case "TopicRecordNameStrategy":
		*e = DeserializationStrategy(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DeserializationStrategy: %v", v)
	}
}

type Avro struct {
	DeserializationStrategy *DeserializationStrategy `default:"TopicNameStrategy" json:"deserialization_strategy"`
	deserializationType     *string                  `const:"AVRO" json:"deserialization_type,omitempty"`
	SchemaRegistryPassword  *string                  `default:"" json:"schema_registry_password"`
	SchemaRegistryURL       *string                  `json:"schema_registry_url,omitempty"`
	SchemaRegistryUsername  *string                  `default:"" json:"schema_registry_username"`
}

func (a Avro) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *Avro) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (a *Avro) GetDeserializationStrategy() *DeserializationStrategy {
	if a == nil {
		return nil
	}
	return a.DeserializationStrategy
}

func (a *Avro) GetDeserializationType() *string {
	return types.Pointer("AVRO")
}

func (a *Avro) GetSchemaRegistryPassword() *string {
	if a == nil {
		return nil
	}
	return a.SchemaRegistryPassword
}

func (a *Avro) GetSchemaRegistryURL() *string {
	if a == nil {
		return nil
	}
	return a.SchemaRegistryURL
}

func (a *Avro) GetSchemaRegistryUsername() *string {
	if a == nil {
		return nil
	}
	return a.SchemaRegistryUsername
}

type JSON struct {
	deserializationType *string `const:"JSON" json:"deserialization_type,omitempty"`
}

func (j JSON) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(j, "", false)
}

func (j *JSON) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &j, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (j *JSON) GetDeserializationType() *string {
	return types.Pointer("JSON")
}

type MessageFormatType string

const (
	MessageFormatTypeJSON MessageFormatType = "JSON"
	MessageFormatTypeAvro MessageFormatType = "AVRO"
)

// MessageFormat - The serialization used based on this
type MessageFormat struct {
	JSON *JSON `queryParam:"inline" union:"member"`
	Avro *Avro `queryParam:"inline" union:"member"`

	Type MessageFormatType
}

func CreateMessageFormatJSON(json JSON) MessageFormat {
	typ := MessageFormatTypeJSON

	return MessageFormat{
		JSON: &json,
		Type: typ,
	}
}

func CreateMessageFormatAvro(avro Avro) MessageFormat {
	typ := MessageFormatTypeAvro

	return MessageFormat{
		Avro: &avro,
		Type: typ,
	}
}

func (u *MessageFormat) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var json JSON = JSON{}
	if err := utils.UnmarshalJSON(data, &json, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  MessageFormatTypeJSON,
			Value: &json,
		})
	}

	var avro Avro = Avro{}
	if err := utils.UnmarshalJSON(data, &avro, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  MessageFormatTypeAvro,
			Value: &avro,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for MessageFormat", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for MessageFormat", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(MessageFormatType)
	switch best.Type {
	case MessageFormatTypeJSON:
		u.JSON = best.Value.(*JSON)
		return nil
	case MessageFormatTypeAvro:
		u.Avro = best.Value.(*Avro)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for MessageFormat", string(data))
}

func (u MessageFormat) MarshalJSON() ([]byte, error) {
	if u.JSON != nil {
		return utils.MarshalJSON(u.JSON, "", true)
	}

	if u.Avro != nil {
		return utils.MarshalJSON(u.Avro, "", true)
	}

	return nil, errors.New("could not marshal union type MessageFormat: all fields are null")
}

// AutoOffsetReset - What to do when there is no initial offset in Kafka or if the current offset does not exist any more on the server - earliest: automatically reset the offset to the earliest offset, latest: automatically reset the offset to the latest offset, none: throw exception to the consumer if no previous offset is found for the consumer's group, anything else: throw exception to the consumer.
type AutoOffsetReset string

const (
	AutoOffsetResetLatest   AutoOffsetReset = "latest"
	AutoOffsetResetEarliest AutoOffsetReset = "earliest"
	AutoOffsetResetNone     AutoOffsetReset = "none"
)

func (e AutoOffsetReset) ToPointer() *AutoOffsetReset {
	return &e
}
func (e *AutoOffsetReset) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "latest":
		fallthrough
	case "earliest":
		fallthrough
	case "none":
		*e = AutoOffsetReset(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AutoOffsetReset: %v", v)
	}
}

// ClientDNSLookup - Controls how the client uses DNS lookups. If set to use_all_dns_ips, connect to each returned IP address in sequence until a successful connection is established. After a disconnection, the next IP is used. Once all IPs have been used once, the client resolves the IP(s) from the hostname again. If set to resolve_canonical_bootstrap_servers_only, resolve each bootstrap address into a list of canonical names. After the bootstrap phase, this behaves the same as use_all_dns_ips. If set to default (deprecated), attempt to connect to the first IP address returned by the lookup, even if the lookup returns multiple IP addresses.
type ClientDNSLookup string

const (
	ClientDNSLookupDefault                              ClientDNSLookup = "default"
	ClientDNSLookupUseAllDNSIps                         ClientDNSLookup = "use_all_dns_ips"
	ClientDNSLookupResolveCanonicalBootstrapServersOnly ClientDNSLookup = "resolve_canonical_bootstrap_servers_only"
)

func (e ClientDNSLookup) ToPointer() *ClientDNSLookup {
	return &e
}
func (e *ClientDNSLookup) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "default":
		fallthrough
	case "use_all_dns_ips":
		fallthrough
	case "resolve_canonical_bootstrap_servers_only":
		*e = ClientDNSLookup(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ClientDNSLookup: %v", v)
	}
}

// SASLMechanism - The SASL mechanism used for client connections. This may be any mechanism for which a security provider is available.
type SASLMechanism string

const (
	SASLMechanismGssapi      SASLMechanism = "GSSAPI"
	SASLMechanismOauthbearer SASLMechanism = "OAUTHBEARER"
	SASLMechanismScramSha256 SASLMechanism = "SCRAM-SHA-256"
	SASLMechanismScramSha512 SASLMechanism = "SCRAM-SHA-512"
	SASLMechanismPlain       SASLMechanism = "PLAIN"
	SASLMechanismAwsMskIam   SASLMechanism = "AWS_MSK_IAM"
)

func (e SASLMechanism) ToPointer() *SASLMechanism {
	return &e
}
func (e *SASLMechanism) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "GSSAPI":
		fallthrough
	case "OAUTHBEARER":
		fallthrough
	case "SCRAM-SHA-256":
		fallthrough
	case "SCRAM-SHA-512":
		fallthrough
	case "PLAIN":
		fallthrough
	case "AWS_MSK_IAM":
		*e = SASLMechanism(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SASLMechanism: %v", v)
	}
}

type SaslSsl struct {
	// Endpoint for requesting tokens if setting SASL Mechanism to OAUTHBEARER
	OauthbearerTokenEndpointURL *string `default:"" json:"oauthbearer_token_endpoint_url"`
	// The JAAS login context parameters for SASL connections in the format used by JAAS configuration files.
	SaslJaasConfig *string `default:"" json:"sasl_jaas_config"`
	// The SASL mechanism used for client connections. This may be any mechanism for which a security provider is available.
	SaslMechanism    *SASLMechanism `default:"GSSAPI" json:"sasl_mechanism"`
	securityProtocol string         `const:"SASL_SSL" json:"security_protocol"`
}

func (s SaslSsl) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SaslSsl) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SaslSsl) GetOauthbearerTokenEndpointURL() *string {
	if s == nil {
		return nil
	}
	return s.OauthbearerTokenEndpointURL
}

func (s *SaslSsl) GetSaslJaasConfig() *string {
	if s == nil {
		return nil
	}
	return s.SaslJaasConfig
}

func (s *SaslSsl) GetSaslMechanism() *SASLMechanism {
	if s == nil {
		return nil
	}
	return s.SaslMechanism
}

func (s *SaslSsl) GetSecurityProtocol() string {
	return "SASL_SSL"
}

type SaslPlaintext struct {
	// The JAAS login context parameters for SASL connections in the format used by JAAS configuration files.
	SaslJaasConfig *string `default:"" json:"sasl_jaas_config"`
	// The SASL mechanism used for client connections. This may be any mechanism for which a security provider is available.
	saslMechanism    string `const:"PLAIN" json:"sasl_mechanism"`
	securityProtocol string `const:"SASL_PLAINTEXT" json:"security_protocol"`
}

func (s SaslPlaintext) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SaslPlaintext) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SaslPlaintext) GetSaslJaasConfig() *string {
	if s == nil {
		return nil
	}
	return s.SaslJaasConfig
}

func (s *SaslPlaintext) GetSaslMechanism() string {
	return "PLAIN"
}

func (s *SaslPlaintext) GetSecurityProtocol() string {
	return "SASL_PLAINTEXT"
}

type Plaintext struct {
	securityProtocol string `const:"PLAINTEXT" json:"security_protocol"`
}

func (p Plaintext) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *Plaintext) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (p *Plaintext) GetSecurityProtocol() string {
	return "PLAINTEXT"
}

type ProtocolType string

const (
	ProtocolTypePlaintext     ProtocolType = "PLAINTEXT"
	ProtocolTypeSaslPlaintext ProtocolType = "SASL PLAINTEXT"
	ProtocolTypeSaslSsl       ProtocolType = "SASL SSL"
)

// The Protocol used to communicate with brokers.
type Protocol struct {
	Plaintext     *Plaintext     `queryParam:"inline" union:"member"`
	SaslPlaintext *SaslPlaintext `queryParam:"inline" union:"member"`
	SaslSsl       *SaslSsl       `queryParam:"inline" union:"member"`

	Type ProtocolType
}

func CreateProtocolPlaintext(plaintext Plaintext) Protocol {
	typ := ProtocolTypePlaintext

	return Protocol{
		Plaintext: &plaintext,
		Type:      typ,
	}
}

func CreateProtocolSaslPlaintext(saslPlaintext SaslPlaintext) Protocol {
	typ := ProtocolTypeSaslPlaintext

	return Protocol{
		SaslPlaintext: &saslPlaintext,
		Type:          typ,
	}
}

func CreateProtocolSaslSsl(saslSsl SaslSsl) Protocol {
	typ := ProtocolTypeSaslSsl

	return Protocol{
		SaslSsl: &saslSsl,
		Type:    typ,
	}
}

func (u *Protocol) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var plaintext Plaintext = Plaintext{}
	if err := utils.UnmarshalJSON(data, &plaintext, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ProtocolTypePlaintext,
			Value: &plaintext,
		})
	}

	var saslPlaintext SaslPlaintext = SaslPlaintext{}
	if err := utils.UnmarshalJSON(data, &saslPlaintext, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ProtocolTypeSaslPlaintext,
			Value: &saslPlaintext,
		})
	}

	var saslSsl SaslSsl = SaslSsl{}
	if err := utils.UnmarshalJSON(data, &saslSsl, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ProtocolTypeSaslSsl,
			Value: &saslSsl,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for Protocol", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for Protocol", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(ProtocolType)
	switch best.Type {
	case ProtocolTypePlaintext:
		u.Plaintext = best.Value.(*Plaintext)
		return nil
	case ProtocolTypeSaslPlaintext:
		u.SaslPlaintext = best.Value.(*SaslPlaintext)
		return nil
	case ProtocolTypeSaslSsl:
		u.SaslSsl = best.Value.(*SaslSsl)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Protocol", string(data))
}

func (u Protocol) MarshalJSON() ([]byte, error) {
	if u.Plaintext != nil {
		return utils.MarshalJSON(u.Plaintext, "", true)
	}

	if u.SaslPlaintext != nil {
		return utils.MarshalJSON(u.SaslPlaintext, "", true)
	}

	if u.SaslSsl != nil {
		return utils.MarshalJSON(u.SaslSsl, "", true)
	}

	return nil, errors.New("could not marshal union type Protocol: all fields are null")
}

type SubscribeToAllTopicsMatchingSpecifiedPattern struct {
	// The Topic pattern from which the records will be read.
	subscriptionType string `const:"subscribe" json:"subscription_type"`
	TopicPattern     string `json:"topic_pattern"`
}

func (s SubscribeToAllTopicsMatchingSpecifiedPattern) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SubscribeToAllTopicsMatchingSpecifiedPattern) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SubscribeToAllTopicsMatchingSpecifiedPattern) GetSubscriptionType() string {
	return "subscribe"
}

func (s *SubscribeToAllTopicsMatchingSpecifiedPattern) GetTopicPattern() string {
	if s == nil {
		return ""
	}
	return s.TopicPattern
}

type ManuallyAssignAListOfPartitions struct {
	// Manually assign a list of partitions to this consumer. This interface does not allow for incremental assignment and will replace the previous assignment (if there is one). If the given list of topic partitions is empty, it is treated the same as unsubscribe().
	subscriptionType string `const:"assign" json:"subscription_type"`
	TopicPartitions  string `json:"topic_partitions"`
}

func (m ManuallyAssignAListOfPartitions) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(m, "", false)
}

func (m *ManuallyAssignAListOfPartitions) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &m, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (m *ManuallyAssignAListOfPartitions) GetSubscriptionType() string {
	return "assign"
}

func (m *ManuallyAssignAListOfPartitions) GetTopicPartitions() string {
	if m == nil {
		return ""
	}
	return m.TopicPartitions
}

type SubscriptionMethodType string

const (
	SubscriptionMethodTypeManuallyAssignAListOfPartitions              SubscriptionMethodType = "Manually assign a list of partitions"
	SubscriptionMethodTypeSubscribeToAllTopicsMatchingSpecifiedPattern SubscriptionMethodType = "Subscribe to all topics matching specified pattern"
)

// SubscriptionMethod - You can choose to manually assign a list of partitions, or subscribe to all topics matching specified pattern to get dynamically assigned partitions.
type SubscriptionMethod struct {
	ManuallyAssignAListOfPartitions              *ManuallyAssignAListOfPartitions              `queryParam:"inline" union:"member"`
	SubscribeToAllTopicsMatchingSpecifiedPattern *SubscribeToAllTopicsMatchingSpecifiedPattern `queryParam:"inline" union:"member"`

	Type SubscriptionMethodType
}

func CreateSubscriptionMethodManuallyAssignAListOfPartitions(manuallyAssignAListOfPartitions ManuallyAssignAListOfPartitions) SubscriptionMethod {
	typ := SubscriptionMethodTypeManuallyAssignAListOfPartitions

	return SubscriptionMethod{
		ManuallyAssignAListOfPartitions: &manuallyAssignAListOfPartitions,
		Type:                            typ,
	}
}

func CreateSubscriptionMethodSubscribeToAllTopicsMatchingSpecifiedPattern(subscribeToAllTopicsMatchingSpecifiedPattern SubscribeToAllTopicsMatchingSpecifiedPattern) SubscriptionMethod {
	typ := SubscriptionMethodTypeSubscribeToAllTopicsMatchingSpecifiedPattern

	return SubscriptionMethod{
		SubscribeToAllTopicsMatchingSpecifiedPattern: &subscribeToAllTopicsMatchingSpecifiedPattern,
		Type: typ,
	}
}

func (u *SubscriptionMethod) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var manuallyAssignAListOfPartitions ManuallyAssignAListOfPartitions = ManuallyAssignAListOfPartitions{}
	if err := utils.UnmarshalJSON(data, &manuallyAssignAListOfPartitions, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SubscriptionMethodTypeManuallyAssignAListOfPartitions,
			Value: &manuallyAssignAListOfPartitions,
		})
	}

	var subscribeToAllTopicsMatchingSpecifiedPattern SubscribeToAllTopicsMatchingSpecifiedPattern = SubscribeToAllTopicsMatchingSpecifiedPattern{}
	if err := utils.UnmarshalJSON(data, &subscribeToAllTopicsMatchingSpecifiedPattern, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SubscriptionMethodTypeSubscribeToAllTopicsMatchingSpecifiedPattern,
			Value: &subscribeToAllTopicsMatchingSpecifiedPattern,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SubscriptionMethod", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SubscriptionMethod", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SubscriptionMethodType)
	switch best.Type {
	case SubscriptionMethodTypeManuallyAssignAListOfPartitions:
		u.ManuallyAssignAListOfPartitions = best.Value.(*ManuallyAssignAListOfPartitions)
		return nil
	case SubscriptionMethodTypeSubscribeToAllTopicsMatchingSpecifiedPattern:
		u.SubscribeToAllTopicsMatchingSpecifiedPattern = best.Value.(*SubscribeToAllTopicsMatchingSpecifiedPattern)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SubscriptionMethod", string(data))
}

func (u SubscriptionMethod) MarshalJSON() ([]byte, error) {
	if u.ManuallyAssignAListOfPartitions != nil {
		return utils.MarshalJSON(u.ManuallyAssignAListOfPartitions, "", true)
	}

	if u.SubscribeToAllTopicsMatchingSpecifiedPattern != nil {
		return utils.MarshalJSON(u.SubscribeToAllTopicsMatchingSpecifiedPattern, "", true)
	}

	return nil, errors.New("could not marshal union type SubscriptionMethod: all fields are null")
}

type SourceKafkaSourceType string

const (
	SourceKafkaSourceTypeKafka SourceKafkaSourceType = "kafka"
)

func (e SourceKafkaSourceType) ToPointer() *SourceKafkaSourceType {
	return &e
}
func (e *SourceKafkaSourceType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "kafka":
		*e = SourceKafkaSourceType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceKafkaSourceType: %v", v)
	}
}

type SourceKafka struct {
	// The serialization used based on this
	MessageFormat *MessageFormat `json:"MessageFormat,omitempty"`
	// The frequency in milliseconds that the consumer offsets are auto-committed to Kafka if enable.auto.commit is set to true.
	AutoCommitIntervalMs *int64 `default:"5000" json:"auto_commit_interval_ms"`
	// What to do when there is no initial offset in Kafka or if the current offset does not exist any more on the server - earliest: automatically reset the offset to the earliest offset, latest: automatically reset the offset to the latest offset, none: throw exception to the consumer if no previous offset is found for the consumer's group, anything else: throw exception to the consumer.
	AutoOffsetReset *AutoOffsetReset `default:"latest" json:"auto_offset_reset"`
	// A list of host/port pairs to use for establishing the initial connection to the Kafka cluster. The client will make use of all servers irrespective of which servers are specified here for bootstrapping&mdash;this list only impacts the initial hosts used to discover the full set of servers. This list should be in the form <code>host1:port1,host2:port2,...</code>. Since these servers are just used for the initial connection to discover the full cluster membership (which may change dynamically), this list need not contain the full set of servers (you may want more than one, though, in case a server is down).
	BootstrapServers string `json:"bootstrap_servers"`
	// Controls how the client uses DNS lookups. If set to use_all_dns_ips, connect to each returned IP address in sequence until a successful connection is established. After a disconnection, the next IP is used. Once all IPs have been used once, the client resolves the IP(s) from the hostname again. If set to resolve_canonical_bootstrap_servers_only, resolve each bootstrap address into a list of canonical names. After the bootstrap phase, this behaves the same as use_all_dns_ips. If set to default (deprecated), attempt to connect to the first IP address returned by the lookup, even if the lookup returns multiple IP addresses.
	ClientDNSLookup *ClientDNSLookup `default:"use_all_dns_ips" json:"client_dns_lookup"`
	// An ID string to pass to the server when making requests. The purpose of this is to be able to track the source of requests beyond just ip/port by allowing a logical application name to be included in server-side request logging.
	ClientID *string `json:"client_id,omitempty"`
	// If true, the consumer's offset will be periodically committed in the background.
	EnableAutoCommit *bool `default:"true" json:"enable_auto_commit"`
	// The Group ID is how you distinguish different consumer groups.
	GroupID *string `json:"group_id,omitempty"`
	// The maximum number of records returned in a single call to poll(). Note, that max_poll_records does not impact the underlying fetching behavior. The consumer will cache the records from each fetch request and returns them incrementally from each poll.
	MaxPollRecords *int64 `default:"500" json:"max_poll_records"`
	// The Maximum to be processed per execution
	MaxRecordsProcess *int64 `default:"100000" json:"max_records_process"`
	// Amount of time in milliseconds Kafka connector should try to poll for messages.
	PollingTime *int64 `default:"100" json:"polling_time"`
	// The Protocol used to communicate with brokers.
	Protocol Protocol `json:"protocol"`
	// The size of the TCP receive buffer (SO_RCVBUF) to use when reading data. If the value is -1, the OS default will be used.
	ReceiveBufferBytes *int64 `default:"32768" json:"receive_buffer_bytes"`
	// The number of repeated calls to poll() if no messages were received.
	RepeatedCalls *int64 `default:"3" json:"repeated_calls"`
	// The configuration controls the maximum amount of time the client will wait for the response of a request. If the response is not received before the timeout elapses the client will resend the request if necessary or fail the request if retries are exhausted.
	RequestTimeoutMs *int64 `default:"30000" json:"request_timeout_ms"`
	// The amount of time to wait before attempting to retry a failed request to a given topic partition. This avoids repeatedly sending requests in a tight loop under some failure scenarios.
	RetryBackoffMs *int64 `default:"100" json:"retry_backoff_ms"`
	// You can choose to manually assign a list of partitions, or subscribe to all topics matching specified pattern to get dynamically assigned partitions.
	Subscription SubscriptionMethod `json:"subscription"`
	// The Topic to test in case the Airbyte can consume messages.
	TestTopic            *string                `json:"test_topic,omitempty"`
	sourceType           *SourceKafkaSourceType `const:"kafka" json:"sourceType"`
	AdditionalProperties any                    `additionalProperties:"true" json:"-"`
}

func (s SourceKafka) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceKafka) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceKafka) GetMessageFormat() *MessageFormat {
	if s == nil {
		return nil
	}
	return s.MessageFormat
}

func (s *SourceKafka) GetAutoCommitIntervalMs() *int64 {
	if s == nil {
		return nil
	}
	return s.AutoCommitIntervalMs
}

func (s *SourceKafka) GetAutoOffsetReset() *AutoOffsetReset {
	if s == nil {
		return nil
	}
	return s.AutoOffsetReset
}

func (s *SourceKafka) GetBootstrapServers() string {
	if s == nil {
		return ""
	}
	return s.BootstrapServers
}

func (s *SourceKafka) GetClientDNSLookup() *ClientDNSLookup {
	if s == nil {
		return nil
	}
	return s.ClientDNSLookup
}

func (s *SourceKafka) GetClientID() *string {
	if s == nil {
		return nil
	}
	return s.ClientID
}

func (s *SourceKafka) GetEnableAutoCommit() *bool {
	if s == nil {
		return nil
	}
	return s.EnableAutoCommit
}

func (s *SourceKafka) GetGroupID() *string {
	if s == nil {
		return nil
	}
	return s.GroupID
}

func (s *SourceKafka) GetMaxPollRecords() *int64 {
	if s == nil {
		return nil
	}
	return s.MaxPollRecords
}

func (s *SourceKafka) GetMaxRecordsProcess() *int64 {
	if s == nil {
		return nil
	}
	return s.MaxRecordsProcess
}

func (s *SourceKafka) GetPollingTime() *int64 {
	if s == nil {
		return nil
	}
	return s.PollingTime
}

func (s *SourceKafka) GetProtocol() Protocol {
	if s == nil {
		return Protocol{}
	}
	return s.Protocol
}

func (s *SourceKafka) GetReceiveBufferBytes() *int64 {
	if s == nil {
		return nil
	}
	return s.ReceiveBufferBytes
}

func (s *SourceKafka) GetRepeatedCalls() *int64 {
	if s == nil {
		return nil
	}
	return s.RepeatedCalls
}

func (s *SourceKafka) GetRequestTimeoutMs() *int64 {
	if s == nil {
		return nil
	}
	return s.RequestTimeoutMs
}

func (s *SourceKafka) GetRetryBackoffMs() *int64 {
	if s == nil {
		return nil
	}
	return s.RetryBackoffMs
}

func (s *SourceKafka) GetSubscription() SubscriptionMethod {
	if s == nil {
		return SubscriptionMethod{}
	}
	return s.Subscription
}

func (s *SourceKafka) GetTestTopic() *string {
	if s == nil {
		return nil
	}
	return s.TestTopic
}

func (s *SourceKafka) GetSourceType() *SourceKafkaSourceType {
	return SourceKafkaSourceTypeKafka.ToPointer()
}

func (s *SourceKafka) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}
