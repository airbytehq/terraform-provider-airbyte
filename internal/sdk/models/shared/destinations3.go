// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

type S3 string

const (
	S3S3 S3 = "s3"
)

func (e S3) ToPointer() *S3 {
	return &e
}
func (e *S3) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "s3":
		*e = S3(v)
		return nil
	default:
		return fmt.Errorf("invalid value for S3: %v", v)
	}
}

// DestinationS3SchemasCompressionCodec - The compression algorithm used to compress data pages.
type DestinationS3SchemasCompressionCodec string

const (
	DestinationS3SchemasCompressionCodecUncompressed DestinationS3SchemasCompressionCodec = "UNCOMPRESSED"
	DestinationS3SchemasCompressionCodecSnappy       DestinationS3SchemasCompressionCodec = "SNAPPY"
	DestinationS3SchemasCompressionCodecGzip         DestinationS3SchemasCompressionCodec = "GZIP"
	DestinationS3SchemasCompressionCodecLzo          DestinationS3SchemasCompressionCodec = "LZO"
	DestinationS3SchemasCompressionCodecBrotli       DestinationS3SchemasCompressionCodec = "BROTLI"
	DestinationS3SchemasCompressionCodecLz4          DestinationS3SchemasCompressionCodec = "LZ4"
	DestinationS3SchemasCompressionCodecZstd         DestinationS3SchemasCompressionCodec = "ZSTD"
)

func (e DestinationS3SchemasCompressionCodec) ToPointer() *DestinationS3SchemasCompressionCodec {
	return &e
}
func (e *DestinationS3SchemasCompressionCodec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "UNCOMPRESSED":
		fallthrough
	case "SNAPPY":
		fallthrough
	case "GZIP":
		fallthrough
	case "LZO":
		fallthrough
	case "BROTLI":
		fallthrough
	case "LZ4":
		fallthrough
	case "ZSTD":
		*e = DestinationS3SchemasCompressionCodec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3SchemasCompressionCodec: %v", v)
	}
}

type DestinationS3SchemasFormatOutputFormatFormatType string

const (
	DestinationS3SchemasFormatOutputFormatFormatTypeParquet DestinationS3SchemasFormatOutputFormatFormatType = "Parquet"
)

func (e DestinationS3SchemasFormatOutputFormatFormatType) ToPointer() *DestinationS3SchemasFormatOutputFormatFormatType {
	return &e
}
func (e *DestinationS3SchemasFormatOutputFormatFormatType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Parquet":
		*e = DestinationS3SchemasFormatOutputFormatFormatType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3SchemasFormatOutputFormatFormatType: %v", v)
	}
}

type DestinationS3ParquetColumnarStorage struct {
	// This is the size of a row group being buffered in memory. It limits the memory usage when writing. Larger values will improve the IO when reading, but consume more memory when writing. Default: 128 MB.
	BlockSizeMb *int64 `default:"128" json:"block_size_mb"`
	// The compression algorithm used to compress data pages.
	CompressionCodec *DestinationS3SchemasCompressionCodec `default:"UNCOMPRESSED" json:"compression_codec"`
	// Default: true.
	DictionaryEncoding *bool `default:"true" json:"dictionary_encoding"`
	// There is one dictionary page per column per row group when dictionary encoding is used. The dictionary page size works like the page size but for dictionary. Default: 1024 KB.
	DictionaryPageSizeKb *int64                                            `default:"1024" json:"dictionary_page_size_kb"`
	FormatType           *DestinationS3SchemasFormatOutputFormatFormatType `default:"Parquet" json:"format_type"`
	// Maximum size allowed as padding to align row groups. This is also the minimum size of a row group. Default: 8 MB.
	MaxPaddingSizeMb *int64 `default:"8" json:"max_padding_size_mb"`
	// The page size is for compression. A block is composed of pages. A page is the smallest unit that must be read fully to access a single record. If this value is too small, the compression will deteriorate. Default: 1024 KB.
	PageSizeKb *int64 `default:"1024" json:"page_size_kb"`
}

func (d DestinationS3ParquetColumnarStorage) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationS3ParquetColumnarStorage) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationS3ParquetColumnarStorage) GetBlockSizeMb() *int64 {
	if o == nil {
		return nil
	}
	return o.BlockSizeMb
}

func (o *DestinationS3ParquetColumnarStorage) GetCompressionCodec() *DestinationS3SchemasCompressionCodec {
	if o == nil {
		return nil
	}
	return o.CompressionCodec
}

func (o *DestinationS3ParquetColumnarStorage) GetDictionaryEncoding() *bool {
	if o == nil {
		return nil
	}
	return o.DictionaryEncoding
}

func (o *DestinationS3ParquetColumnarStorage) GetDictionaryPageSizeKb() *int64 {
	if o == nil {
		return nil
	}
	return o.DictionaryPageSizeKb
}

func (o *DestinationS3ParquetColumnarStorage) GetFormatType() *DestinationS3SchemasFormatOutputFormatFormatType {
	if o == nil {
		return nil
	}
	return o.FormatType
}

func (o *DestinationS3ParquetColumnarStorage) GetMaxPaddingSizeMb() *int64 {
	if o == nil {
		return nil
	}
	return o.MaxPaddingSizeMb
}

func (o *DestinationS3ParquetColumnarStorage) GetPageSizeKb() *int64 {
	if o == nil {
		return nil
	}
	return o.PageSizeKb
}

type DestinationS3SchemasFormatOutputFormat3CompressionCodecCodec string

const (
	DestinationS3SchemasFormatOutputFormat3CompressionCodecCodecSnappy DestinationS3SchemasFormatOutputFormat3CompressionCodecCodec = "snappy"
)

func (e DestinationS3SchemasFormatOutputFormat3CompressionCodecCodec) ToPointer() *DestinationS3SchemasFormatOutputFormat3CompressionCodecCodec {
	return &e
}
func (e *DestinationS3SchemasFormatOutputFormat3CompressionCodecCodec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "snappy":
		*e = DestinationS3SchemasFormatOutputFormat3CompressionCodecCodec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3SchemasFormatOutputFormat3CompressionCodecCodec: %v", v)
	}
}

type DestinationS3Snappy struct {
	Codec *DestinationS3SchemasFormatOutputFormat3CompressionCodecCodec `default:"snappy" json:"codec"`
}

func (d DestinationS3Snappy) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationS3Snappy) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationS3Snappy) GetCodec() *DestinationS3SchemasFormatOutputFormat3CompressionCodecCodec {
	if o == nil {
		return nil
	}
	return o.Codec
}

type DestinationS3SchemasFormatOutputFormat3Codec string

const (
	DestinationS3SchemasFormatOutputFormat3CodecZstandard DestinationS3SchemasFormatOutputFormat3Codec = "zstandard"
)

func (e DestinationS3SchemasFormatOutputFormat3Codec) ToPointer() *DestinationS3SchemasFormatOutputFormat3Codec {
	return &e
}
func (e *DestinationS3SchemasFormatOutputFormat3Codec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "zstandard":
		*e = DestinationS3SchemasFormatOutputFormat3Codec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3SchemasFormatOutputFormat3Codec: %v", v)
	}
}

type DestinationS3Zstandard struct {
	Codec *DestinationS3SchemasFormatOutputFormat3Codec `default:"zstandard" json:"codec"`
	// Negative levels are 'fast' modes akin to lz4 or snappy, levels above 9 are generally for archival purposes, and levels above 18 use a lot of memory.
	CompressionLevel *int64 `default:"3" json:"compression_level"`
	// If true, include a checksum with each data block.
	IncludeChecksum *bool `default:"false" json:"include_checksum"`
}

func (d DestinationS3Zstandard) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationS3Zstandard) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationS3Zstandard) GetCodec() *DestinationS3SchemasFormatOutputFormat3Codec {
	if o == nil {
		return nil
	}
	return o.Codec
}

func (o *DestinationS3Zstandard) GetCompressionLevel() *int64 {
	if o == nil {
		return nil
	}
	return o.CompressionLevel
}

func (o *DestinationS3Zstandard) GetIncludeChecksum() *bool {
	if o == nil {
		return nil
	}
	return o.IncludeChecksum
}

type DestinationS3SchemasFormatOutputFormatCodec string

const (
	DestinationS3SchemasFormatOutputFormatCodecXz DestinationS3SchemasFormatOutputFormatCodec = "xz"
)

func (e DestinationS3SchemasFormatOutputFormatCodec) ToPointer() *DestinationS3SchemasFormatOutputFormatCodec {
	return &e
}
func (e *DestinationS3SchemasFormatOutputFormatCodec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "xz":
		*e = DestinationS3SchemasFormatOutputFormatCodec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3SchemasFormatOutputFormatCodec: %v", v)
	}
}

type DestinationS3Xz struct {
	Codec *DestinationS3SchemasFormatOutputFormatCodec `default:"xz" json:"codec"`
	// See <a href="https://commons.apache.org/proper/commons-compress/apidocs/org/apache/commons/compress/compressors/xz/XZCompressorOutputStream.html#XZCompressorOutputStream-java.io.OutputStream-int-">here</a> for details.
	CompressionLevel *int64 `default:"6" json:"compression_level"`
}

func (d DestinationS3Xz) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationS3Xz) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationS3Xz) GetCodec() *DestinationS3SchemasFormatOutputFormatCodec {
	if o == nil {
		return nil
	}
	return o.Codec
}

func (o *DestinationS3Xz) GetCompressionLevel() *int64 {
	if o == nil {
		return nil
	}
	return o.CompressionLevel
}

type DestinationS3SchemasFormatCodec string

const (
	DestinationS3SchemasFormatCodecBzip2 DestinationS3SchemasFormatCodec = "bzip2"
)

func (e DestinationS3SchemasFormatCodec) ToPointer() *DestinationS3SchemasFormatCodec {
	return &e
}
func (e *DestinationS3SchemasFormatCodec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "bzip2":
		*e = DestinationS3SchemasFormatCodec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3SchemasFormatCodec: %v", v)
	}
}

type DestinationS3Bzip2 struct {
	Codec *DestinationS3SchemasFormatCodec `default:"bzip2" json:"codec"`
}

func (d DestinationS3Bzip2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationS3Bzip2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationS3Bzip2) GetCodec() *DestinationS3SchemasFormatCodec {
	if o == nil {
		return nil
	}
	return o.Codec
}

type DestinationS3SchemasCodec string

const (
	DestinationS3SchemasCodecDeflate DestinationS3SchemasCodec = "Deflate"
)

func (e DestinationS3SchemasCodec) ToPointer() *DestinationS3SchemasCodec {
	return &e
}
func (e *DestinationS3SchemasCodec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Deflate":
		*e = DestinationS3SchemasCodec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3SchemasCodec: %v", v)
	}
}

type DestinationS3Deflate struct {
	Codec *DestinationS3SchemasCodec `default:"Deflate" json:"codec"`
	// 0: no compression & fastest, 9: best compression & slowest.
	CompressionLevel *int64 `default:"0" json:"compression_level"`
}

func (d DestinationS3Deflate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationS3Deflate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationS3Deflate) GetCodec() *DestinationS3SchemasCodec {
	if o == nil {
		return nil
	}
	return o.Codec
}

func (o *DestinationS3Deflate) GetCompressionLevel() *int64 {
	if o == nil {
		return nil
	}
	return o.CompressionLevel
}

type DestinationS3Codec string

const (
	DestinationS3CodecNoCompression DestinationS3Codec = "no compression"
)

func (e DestinationS3Codec) ToPointer() *DestinationS3Codec {
	return &e
}
func (e *DestinationS3Codec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "no compression":
		*e = DestinationS3Codec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3Codec: %v", v)
	}
}

type DestinationS3SchemasFormatNoCompression struct {
	Codec *DestinationS3Codec `default:"no compression" json:"codec"`
}

func (d DestinationS3SchemasFormatNoCompression) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationS3SchemasFormatNoCompression) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationS3SchemasFormatNoCompression) GetCodec() *DestinationS3Codec {
	if o == nil {
		return nil
	}
	return o.Codec
}

type DestinationS3CompressionCodecType string

const (
	DestinationS3CompressionCodecTypeDestinationS3SchemasFormatNoCompression DestinationS3CompressionCodecType = "destination-s3_Schemas_format_No Compression"
	DestinationS3CompressionCodecTypeDestinationS3Deflate                    DestinationS3CompressionCodecType = "destination-s3_Deflate"
	DestinationS3CompressionCodecTypeDestinationS3Bzip2                      DestinationS3CompressionCodecType = "destination-s3_bzip2"
	DestinationS3CompressionCodecTypeDestinationS3Xz                         DestinationS3CompressionCodecType = "destination-s3_xz"
	DestinationS3CompressionCodecTypeDestinationS3Zstandard                  DestinationS3CompressionCodecType = "destination-s3_zstandard"
	DestinationS3CompressionCodecTypeDestinationS3Snappy                     DestinationS3CompressionCodecType = "destination-s3_snappy"
)

// DestinationS3CompressionCodec - The compression algorithm used to compress data. Default to no compression.
type DestinationS3CompressionCodec struct {
	DestinationS3SchemasFormatNoCompression *DestinationS3SchemasFormatNoCompression
	DestinationS3Deflate                    *DestinationS3Deflate
	DestinationS3Bzip2                      *DestinationS3Bzip2
	DestinationS3Xz                         *DestinationS3Xz
	DestinationS3Zstandard                  *DestinationS3Zstandard
	DestinationS3Snappy                     *DestinationS3Snappy

	Type DestinationS3CompressionCodecType
}

func CreateDestinationS3CompressionCodecDestinationS3SchemasFormatNoCompression(destinationS3SchemasFormatNoCompression DestinationS3SchemasFormatNoCompression) DestinationS3CompressionCodec {
	typ := DestinationS3CompressionCodecTypeDestinationS3SchemasFormatNoCompression

	return DestinationS3CompressionCodec{
		DestinationS3SchemasFormatNoCompression: &destinationS3SchemasFormatNoCompression,
		Type:                                    typ,
	}
}

func CreateDestinationS3CompressionCodecDestinationS3Deflate(destinationS3Deflate DestinationS3Deflate) DestinationS3CompressionCodec {
	typ := DestinationS3CompressionCodecTypeDestinationS3Deflate

	return DestinationS3CompressionCodec{
		DestinationS3Deflate: &destinationS3Deflate,
		Type:                 typ,
	}
}

func CreateDestinationS3CompressionCodecDestinationS3Bzip2(destinationS3Bzip2 DestinationS3Bzip2) DestinationS3CompressionCodec {
	typ := DestinationS3CompressionCodecTypeDestinationS3Bzip2

	return DestinationS3CompressionCodec{
		DestinationS3Bzip2: &destinationS3Bzip2,
		Type:               typ,
	}
}

func CreateDestinationS3CompressionCodecDestinationS3Xz(destinationS3Xz DestinationS3Xz) DestinationS3CompressionCodec {
	typ := DestinationS3CompressionCodecTypeDestinationS3Xz

	return DestinationS3CompressionCodec{
		DestinationS3Xz: &destinationS3Xz,
		Type:            typ,
	}
}

func CreateDestinationS3CompressionCodecDestinationS3Zstandard(destinationS3Zstandard DestinationS3Zstandard) DestinationS3CompressionCodec {
	typ := DestinationS3CompressionCodecTypeDestinationS3Zstandard

	return DestinationS3CompressionCodec{
		DestinationS3Zstandard: &destinationS3Zstandard,
		Type:                   typ,
	}
}

func CreateDestinationS3CompressionCodecDestinationS3Snappy(destinationS3Snappy DestinationS3Snappy) DestinationS3CompressionCodec {
	typ := DestinationS3CompressionCodecTypeDestinationS3Snappy

	return DestinationS3CompressionCodec{
		DestinationS3Snappy: &destinationS3Snappy,
		Type:                typ,
	}
}

func (u *DestinationS3CompressionCodec) UnmarshalJSON(data []byte) error {

	var destinationS3SchemasFormatNoCompression DestinationS3SchemasFormatNoCompression = DestinationS3SchemasFormatNoCompression{}
	if err := utils.UnmarshalJSON(data, &destinationS3SchemasFormatNoCompression, "", true, true); err == nil {
		u.DestinationS3SchemasFormatNoCompression = &destinationS3SchemasFormatNoCompression
		u.Type = DestinationS3CompressionCodecTypeDestinationS3SchemasFormatNoCompression
		return nil
	}

	var destinationS3Bzip2 DestinationS3Bzip2 = DestinationS3Bzip2{}
	if err := utils.UnmarshalJSON(data, &destinationS3Bzip2, "", true, true); err == nil {
		u.DestinationS3Bzip2 = &destinationS3Bzip2
		u.Type = DestinationS3CompressionCodecTypeDestinationS3Bzip2
		return nil
	}

	var destinationS3Snappy DestinationS3Snappy = DestinationS3Snappy{}
	if err := utils.UnmarshalJSON(data, &destinationS3Snappy, "", true, true); err == nil {
		u.DestinationS3Snappy = &destinationS3Snappy
		u.Type = DestinationS3CompressionCodecTypeDestinationS3Snappy
		return nil
	}

	var destinationS3Deflate DestinationS3Deflate = DestinationS3Deflate{}
	if err := utils.UnmarshalJSON(data, &destinationS3Deflate, "", true, true); err == nil {
		u.DestinationS3Deflate = &destinationS3Deflate
		u.Type = DestinationS3CompressionCodecTypeDestinationS3Deflate
		return nil
	}

	var destinationS3Xz DestinationS3Xz = DestinationS3Xz{}
	if err := utils.UnmarshalJSON(data, &destinationS3Xz, "", true, true); err == nil {
		u.DestinationS3Xz = &destinationS3Xz
		u.Type = DestinationS3CompressionCodecTypeDestinationS3Xz
		return nil
	}

	var destinationS3Zstandard DestinationS3Zstandard = DestinationS3Zstandard{}
	if err := utils.UnmarshalJSON(data, &destinationS3Zstandard, "", true, true); err == nil {
		u.DestinationS3Zstandard = &destinationS3Zstandard
		u.Type = DestinationS3CompressionCodecTypeDestinationS3Zstandard
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationS3CompressionCodec", string(data))
}

func (u DestinationS3CompressionCodec) MarshalJSON() ([]byte, error) {
	if u.DestinationS3SchemasFormatNoCompression != nil {
		return utils.MarshalJSON(u.DestinationS3SchemasFormatNoCompression, "", true)
	}

	if u.DestinationS3Deflate != nil {
		return utils.MarshalJSON(u.DestinationS3Deflate, "", true)
	}

	if u.DestinationS3Bzip2 != nil {
		return utils.MarshalJSON(u.DestinationS3Bzip2, "", true)
	}

	if u.DestinationS3Xz != nil {
		return utils.MarshalJSON(u.DestinationS3Xz, "", true)
	}

	if u.DestinationS3Zstandard != nil {
		return utils.MarshalJSON(u.DestinationS3Zstandard, "", true)
	}

	if u.DestinationS3Snappy != nil {
		return utils.MarshalJSON(u.DestinationS3Snappy, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationS3CompressionCodec: all fields are null")
}

type DestinationS3SchemasFormatFormatType string

const (
	DestinationS3SchemasFormatFormatTypeAvro DestinationS3SchemasFormatFormatType = "Avro"
)

func (e DestinationS3SchemasFormatFormatType) ToPointer() *DestinationS3SchemasFormatFormatType {
	return &e
}
func (e *DestinationS3SchemasFormatFormatType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Avro":
		*e = DestinationS3SchemasFormatFormatType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3SchemasFormatFormatType: %v", v)
	}
}

type DestinationS3AvroApacheAvro struct {
	// The compression algorithm used to compress data. Default to no compression.
	CompressionCodec DestinationS3CompressionCodec         `json:"compression_codec"`
	FormatType       *DestinationS3SchemasFormatFormatType `default:"Avro" json:"format_type"`
}

func (d DestinationS3AvroApacheAvro) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationS3AvroApacheAvro) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationS3AvroApacheAvro) GetCompressionCodec() DestinationS3CompressionCodec {
	if o == nil {
		return DestinationS3CompressionCodec{}
	}
	return o.CompressionCodec
}

func (o *DestinationS3AvroApacheAvro) GetFormatType() *DestinationS3SchemasFormatFormatType {
	if o == nil {
		return nil
	}
	return o.FormatType
}

type DestinationS3SchemasFormatOutputFormatCompressionType string

const (
	DestinationS3SchemasFormatOutputFormatCompressionTypeGzip DestinationS3SchemasFormatOutputFormatCompressionType = "GZIP"
)

func (e DestinationS3SchemasFormatOutputFormatCompressionType) ToPointer() *DestinationS3SchemasFormatOutputFormatCompressionType {
	return &e
}
func (e *DestinationS3SchemasFormatOutputFormatCompressionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "GZIP":
		*e = DestinationS3SchemasFormatOutputFormatCompressionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3SchemasFormatOutputFormatCompressionType: %v", v)
	}
}

type DestinationS3SchemasGZIP struct {
	CompressionType *DestinationS3SchemasFormatOutputFormatCompressionType `default:"GZIP" json:"compression_type"`
}

func (d DestinationS3SchemasGZIP) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationS3SchemasGZIP) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationS3SchemasGZIP) GetCompressionType() *DestinationS3SchemasFormatOutputFormatCompressionType {
	if o == nil {
		return nil
	}
	return o.CompressionType
}

type DestinationS3SchemasFormatCompressionType string

const (
	DestinationS3SchemasFormatCompressionTypeNoCompression DestinationS3SchemasFormatCompressionType = "No Compression"
)

func (e DestinationS3SchemasFormatCompressionType) ToPointer() *DestinationS3SchemasFormatCompressionType {
	return &e
}
func (e *DestinationS3SchemasFormatCompressionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "No Compression":
		*e = DestinationS3SchemasFormatCompressionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3SchemasFormatCompressionType: %v", v)
	}
}

type DestinationS3SchemasNoCompression struct {
	CompressionType *DestinationS3SchemasFormatCompressionType `default:"No Compression" json:"compression_type"`
}

func (d DestinationS3SchemasNoCompression) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationS3SchemasNoCompression) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationS3SchemasNoCompression) GetCompressionType() *DestinationS3SchemasFormatCompressionType {
	if o == nil {
		return nil
	}
	return o.CompressionType
}

type DestinationS3SchemasCompressionUnionType string

const (
	DestinationS3SchemasCompressionUnionTypeDestinationS3SchemasNoCompression DestinationS3SchemasCompressionUnionType = "destination-s3_Schemas_No Compression"
	DestinationS3SchemasCompressionUnionTypeDestinationS3SchemasGZIP          DestinationS3SchemasCompressionUnionType = "destination-s3_Schemas_GZIP"
)

// DestinationS3SchemasCompression - Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").
type DestinationS3SchemasCompression struct {
	DestinationS3SchemasNoCompression *DestinationS3SchemasNoCompression
	DestinationS3SchemasGZIP          *DestinationS3SchemasGZIP

	Type DestinationS3SchemasCompressionUnionType
}

func CreateDestinationS3SchemasCompressionDestinationS3SchemasNoCompression(destinationS3SchemasNoCompression DestinationS3SchemasNoCompression) DestinationS3SchemasCompression {
	typ := DestinationS3SchemasCompressionUnionTypeDestinationS3SchemasNoCompression

	return DestinationS3SchemasCompression{
		DestinationS3SchemasNoCompression: &destinationS3SchemasNoCompression,
		Type:                              typ,
	}
}

func CreateDestinationS3SchemasCompressionDestinationS3SchemasGZIP(destinationS3SchemasGZIP DestinationS3SchemasGZIP) DestinationS3SchemasCompression {
	typ := DestinationS3SchemasCompressionUnionTypeDestinationS3SchemasGZIP

	return DestinationS3SchemasCompression{
		DestinationS3SchemasGZIP: &destinationS3SchemasGZIP,
		Type:                     typ,
	}
}

func (u *DestinationS3SchemasCompression) UnmarshalJSON(data []byte) error {

	var destinationS3SchemasNoCompression DestinationS3SchemasNoCompression = DestinationS3SchemasNoCompression{}
	if err := utils.UnmarshalJSON(data, &destinationS3SchemasNoCompression, "", true, true); err == nil {
		u.DestinationS3SchemasNoCompression = &destinationS3SchemasNoCompression
		u.Type = DestinationS3SchemasCompressionUnionTypeDestinationS3SchemasNoCompression
		return nil
	}

	var destinationS3SchemasGZIP DestinationS3SchemasGZIP = DestinationS3SchemasGZIP{}
	if err := utils.UnmarshalJSON(data, &destinationS3SchemasGZIP, "", true, true); err == nil {
		u.DestinationS3SchemasGZIP = &destinationS3SchemasGZIP
		u.Type = DestinationS3SchemasCompressionUnionTypeDestinationS3SchemasGZIP
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationS3SchemasCompression", string(data))
}

func (u DestinationS3SchemasCompression) MarshalJSON() ([]byte, error) {
	if u.DestinationS3SchemasNoCompression != nil {
		return utils.MarshalJSON(u.DestinationS3SchemasNoCompression, "", true)
	}

	if u.DestinationS3SchemasGZIP != nil {
		return utils.MarshalJSON(u.DestinationS3SchemasGZIP, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationS3SchemasCompression: all fields are null")
}

// DestinationS3SchemasFlattening - Whether the input json data should be normalized (flattened) in the output JSON Lines. Please refer to docs for details.
type DestinationS3SchemasFlattening string

const (
	DestinationS3SchemasFlatteningNoFlattening        DestinationS3SchemasFlattening = "No flattening"
	DestinationS3SchemasFlatteningRootLevelFlattening DestinationS3SchemasFlattening = "Root level flattening"
)

func (e DestinationS3SchemasFlattening) ToPointer() *DestinationS3SchemasFlattening {
	return &e
}
func (e *DestinationS3SchemasFlattening) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "No flattening":
		fallthrough
	case "Root level flattening":
		*e = DestinationS3SchemasFlattening(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3SchemasFlattening: %v", v)
	}
}

type DestinationS3SchemasFormatType string

const (
	DestinationS3SchemasFormatTypeJsonl DestinationS3SchemasFormatType = "JSONL"
)

func (e DestinationS3SchemasFormatType) ToPointer() *DestinationS3SchemasFormatType {
	return &e
}
func (e *DestinationS3SchemasFormatType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "JSONL":
		*e = DestinationS3SchemasFormatType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3SchemasFormatType: %v", v)
	}
}

type DestinationS3JSONLinesNewlineDelimitedJSON struct {
	// Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").
	Compression *DestinationS3SchemasCompression `json:"compression,omitempty"`
	// Whether the input json data should be normalized (flattened) in the output JSON Lines. Please refer to docs for details.
	Flattening *DestinationS3SchemasFlattening `default:"No flattening" json:"flattening"`
	FormatType *DestinationS3SchemasFormatType `default:"JSONL" json:"format_type"`
}

func (d DestinationS3JSONLinesNewlineDelimitedJSON) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationS3JSONLinesNewlineDelimitedJSON) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationS3JSONLinesNewlineDelimitedJSON) GetCompression() *DestinationS3SchemasCompression {
	if o == nil {
		return nil
	}
	return o.Compression
}

func (o *DestinationS3JSONLinesNewlineDelimitedJSON) GetFlattening() *DestinationS3SchemasFlattening {
	if o == nil {
		return nil
	}
	return o.Flattening
}

func (o *DestinationS3JSONLinesNewlineDelimitedJSON) GetFormatType() *DestinationS3SchemasFormatType {
	if o == nil {
		return nil
	}
	return o.FormatType
}

type DestinationS3SchemasCompressionType string

const (
	DestinationS3SchemasCompressionTypeGzip DestinationS3SchemasCompressionType = "GZIP"
)

func (e DestinationS3SchemasCompressionType) ToPointer() *DestinationS3SchemasCompressionType {
	return &e
}
func (e *DestinationS3SchemasCompressionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "GZIP":
		*e = DestinationS3SchemasCompressionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3SchemasCompressionType: %v", v)
	}
}

type DestinationS3GZIP struct {
	CompressionType *DestinationS3SchemasCompressionType `default:"GZIP" json:"compression_type"`
}

func (d DestinationS3GZIP) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationS3GZIP) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationS3GZIP) GetCompressionType() *DestinationS3SchemasCompressionType {
	if o == nil {
		return nil
	}
	return o.CompressionType
}

type DestinationS3CompressionType string

const (
	DestinationS3CompressionTypeNoCompression DestinationS3CompressionType = "No Compression"
)

func (e DestinationS3CompressionType) ToPointer() *DestinationS3CompressionType {
	return &e
}
func (e *DestinationS3CompressionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "No Compression":
		*e = DestinationS3CompressionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3CompressionType: %v", v)
	}
}

type DestinationS3NoCompression struct {
	CompressionType *DestinationS3CompressionType `default:"No Compression" json:"compression_type"`
}

func (d DestinationS3NoCompression) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationS3NoCompression) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationS3NoCompression) GetCompressionType() *DestinationS3CompressionType {
	if o == nil {
		return nil
	}
	return o.CompressionType
}

type DestinationS3CompressionUnionType string

const (
	DestinationS3CompressionUnionTypeDestinationS3NoCompression DestinationS3CompressionUnionType = "destination-s3_No Compression"
	DestinationS3CompressionUnionTypeDestinationS3GZIP          DestinationS3CompressionUnionType = "destination-s3_GZIP"
)

// DestinationS3Compression - Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".csv.gz").
type DestinationS3Compression struct {
	DestinationS3NoCompression *DestinationS3NoCompression
	DestinationS3GZIP          *DestinationS3GZIP

	Type DestinationS3CompressionUnionType
}

func CreateDestinationS3CompressionDestinationS3NoCompression(destinationS3NoCompression DestinationS3NoCompression) DestinationS3Compression {
	typ := DestinationS3CompressionUnionTypeDestinationS3NoCompression

	return DestinationS3Compression{
		DestinationS3NoCompression: &destinationS3NoCompression,
		Type:                       typ,
	}
}

func CreateDestinationS3CompressionDestinationS3GZIP(destinationS3GZIP DestinationS3GZIP) DestinationS3Compression {
	typ := DestinationS3CompressionUnionTypeDestinationS3GZIP

	return DestinationS3Compression{
		DestinationS3GZIP: &destinationS3GZIP,
		Type:              typ,
	}
}

func (u *DestinationS3Compression) UnmarshalJSON(data []byte) error {

	var destinationS3NoCompression DestinationS3NoCompression = DestinationS3NoCompression{}
	if err := utils.UnmarshalJSON(data, &destinationS3NoCompression, "", true, true); err == nil {
		u.DestinationS3NoCompression = &destinationS3NoCompression
		u.Type = DestinationS3CompressionUnionTypeDestinationS3NoCompression
		return nil
	}

	var destinationS3GZIP DestinationS3GZIP = DestinationS3GZIP{}
	if err := utils.UnmarshalJSON(data, &destinationS3GZIP, "", true, true); err == nil {
		u.DestinationS3GZIP = &destinationS3GZIP
		u.Type = DestinationS3CompressionUnionTypeDestinationS3GZIP
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationS3Compression", string(data))
}

func (u DestinationS3Compression) MarshalJSON() ([]byte, error) {
	if u.DestinationS3NoCompression != nil {
		return utils.MarshalJSON(u.DestinationS3NoCompression, "", true)
	}

	if u.DestinationS3GZIP != nil {
		return utils.MarshalJSON(u.DestinationS3GZIP, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationS3Compression: all fields are null")
}

// DestinationS3Flattening - Whether the input json data should be normalized (flattened) in the output CSV. Please refer to docs for details.
type DestinationS3Flattening string

const (
	DestinationS3FlatteningNoFlattening        DestinationS3Flattening = "No flattening"
	DestinationS3FlatteningRootLevelFlattening DestinationS3Flattening = "Root level flattening"
)

func (e DestinationS3Flattening) ToPointer() *DestinationS3Flattening {
	return &e
}
func (e *DestinationS3Flattening) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "No flattening":
		fallthrough
	case "Root level flattening":
		*e = DestinationS3Flattening(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3Flattening: %v", v)
	}
}

type DestinationS3FormatType string

const (
	DestinationS3FormatTypeCsv DestinationS3FormatType = "CSV"
)

func (e DestinationS3FormatType) ToPointer() *DestinationS3FormatType {
	return &e
}
func (e *DestinationS3FormatType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CSV":
		*e = DestinationS3FormatType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3FormatType: %v", v)
	}
}

type DestinationS3CSVCommaSeparatedValues struct {
	// Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".csv.gz").
	Compression *DestinationS3Compression `json:"compression,omitempty"`
	// Whether the input json data should be normalized (flattened) in the output CSV. Please refer to docs for details.
	Flattening *DestinationS3Flattening `default:"No flattening" json:"flattening"`
	FormatType *DestinationS3FormatType `default:"CSV" json:"format_type"`
}

func (d DestinationS3CSVCommaSeparatedValues) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationS3CSVCommaSeparatedValues) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationS3CSVCommaSeparatedValues) GetCompression() *DestinationS3Compression {
	if o == nil {
		return nil
	}
	return o.Compression
}

func (o *DestinationS3CSVCommaSeparatedValues) GetFlattening() *DestinationS3Flattening {
	if o == nil {
		return nil
	}
	return o.Flattening
}

func (o *DestinationS3CSVCommaSeparatedValues) GetFormatType() *DestinationS3FormatType {
	if o == nil {
		return nil
	}
	return o.FormatType
}

type DestinationS3OutputFormatType string

const (
	DestinationS3OutputFormatTypeDestinationS3CSVCommaSeparatedValues       DestinationS3OutputFormatType = "destination-s3_CSV: Comma-Separated Values"
	DestinationS3OutputFormatTypeDestinationS3JSONLinesNewlineDelimitedJSON DestinationS3OutputFormatType = "destination-s3_JSON Lines: Newline-delimited JSON"
	DestinationS3OutputFormatTypeDestinationS3AvroApacheAvro                DestinationS3OutputFormatType = "destination-s3_Avro: Apache Avro"
	DestinationS3OutputFormatTypeDestinationS3ParquetColumnarStorage        DestinationS3OutputFormatType = "destination-s3_Parquet: Columnar Storage"
)

// DestinationS3OutputFormat - Format of the data output. See <a href="https://docs.airbyte.com/integrations/destinations/s3/#supported-output-schema">here</a> for more details
type DestinationS3OutputFormat struct {
	DestinationS3CSVCommaSeparatedValues       *DestinationS3CSVCommaSeparatedValues
	DestinationS3JSONLinesNewlineDelimitedJSON *DestinationS3JSONLinesNewlineDelimitedJSON
	DestinationS3AvroApacheAvro                *DestinationS3AvroApacheAvro
	DestinationS3ParquetColumnarStorage        *DestinationS3ParquetColumnarStorage

	Type DestinationS3OutputFormatType
}

func CreateDestinationS3OutputFormatDestinationS3CSVCommaSeparatedValues(destinationS3CSVCommaSeparatedValues DestinationS3CSVCommaSeparatedValues) DestinationS3OutputFormat {
	typ := DestinationS3OutputFormatTypeDestinationS3CSVCommaSeparatedValues

	return DestinationS3OutputFormat{
		DestinationS3CSVCommaSeparatedValues: &destinationS3CSVCommaSeparatedValues,
		Type:                                 typ,
	}
}

func CreateDestinationS3OutputFormatDestinationS3JSONLinesNewlineDelimitedJSON(destinationS3JSONLinesNewlineDelimitedJSON DestinationS3JSONLinesNewlineDelimitedJSON) DestinationS3OutputFormat {
	typ := DestinationS3OutputFormatTypeDestinationS3JSONLinesNewlineDelimitedJSON

	return DestinationS3OutputFormat{
		DestinationS3JSONLinesNewlineDelimitedJSON: &destinationS3JSONLinesNewlineDelimitedJSON,
		Type: typ,
	}
}

func CreateDestinationS3OutputFormatDestinationS3AvroApacheAvro(destinationS3AvroApacheAvro DestinationS3AvroApacheAvro) DestinationS3OutputFormat {
	typ := DestinationS3OutputFormatTypeDestinationS3AvroApacheAvro

	return DestinationS3OutputFormat{
		DestinationS3AvroApacheAvro: &destinationS3AvroApacheAvro,
		Type:                        typ,
	}
}

func CreateDestinationS3OutputFormatDestinationS3ParquetColumnarStorage(destinationS3ParquetColumnarStorage DestinationS3ParquetColumnarStorage) DestinationS3OutputFormat {
	typ := DestinationS3OutputFormatTypeDestinationS3ParquetColumnarStorage

	return DestinationS3OutputFormat{
		DestinationS3ParquetColumnarStorage: &destinationS3ParquetColumnarStorage,
		Type:                                typ,
	}
}

func (u *DestinationS3OutputFormat) UnmarshalJSON(data []byte) error {

	var destinationS3AvroApacheAvro DestinationS3AvroApacheAvro = DestinationS3AvroApacheAvro{}
	if err := utils.UnmarshalJSON(data, &destinationS3AvroApacheAvro, "", true, true); err == nil {
		u.DestinationS3AvroApacheAvro = &destinationS3AvroApacheAvro
		u.Type = DestinationS3OutputFormatTypeDestinationS3AvroApacheAvro
		return nil
	}

	var destinationS3CSVCommaSeparatedValues DestinationS3CSVCommaSeparatedValues = DestinationS3CSVCommaSeparatedValues{}
	if err := utils.UnmarshalJSON(data, &destinationS3CSVCommaSeparatedValues, "", true, true); err == nil {
		u.DestinationS3CSVCommaSeparatedValues = &destinationS3CSVCommaSeparatedValues
		u.Type = DestinationS3OutputFormatTypeDestinationS3CSVCommaSeparatedValues
		return nil
	}

	var destinationS3JSONLinesNewlineDelimitedJSON DestinationS3JSONLinesNewlineDelimitedJSON = DestinationS3JSONLinesNewlineDelimitedJSON{}
	if err := utils.UnmarshalJSON(data, &destinationS3JSONLinesNewlineDelimitedJSON, "", true, true); err == nil {
		u.DestinationS3JSONLinesNewlineDelimitedJSON = &destinationS3JSONLinesNewlineDelimitedJSON
		u.Type = DestinationS3OutputFormatTypeDestinationS3JSONLinesNewlineDelimitedJSON
		return nil
	}

	var destinationS3ParquetColumnarStorage DestinationS3ParquetColumnarStorage = DestinationS3ParquetColumnarStorage{}
	if err := utils.UnmarshalJSON(data, &destinationS3ParquetColumnarStorage, "", true, true); err == nil {
		u.DestinationS3ParquetColumnarStorage = &destinationS3ParquetColumnarStorage
		u.Type = DestinationS3OutputFormatTypeDestinationS3ParquetColumnarStorage
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationS3OutputFormat", string(data))
}

func (u DestinationS3OutputFormat) MarshalJSON() ([]byte, error) {
	if u.DestinationS3CSVCommaSeparatedValues != nil {
		return utils.MarshalJSON(u.DestinationS3CSVCommaSeparatedValues, "", true)
	}

	if u.DestinationS3JSONLinesNewlineDelimitedJSON != nil {
		return utils.MarshalJSON(u.DestinationS3JSONLinesNewlineDelimitedJSON, "", true)
	}

	if u.DestinationS3AvroApacheAvro != nil {
		return utils.MarshalJSON(u.DestinationS3AvroApacheAvro, "", true)
	}

	if u.DestinationS3ParquetColumnarStorage != nil {
		return utils.MarshalJSON(u.DestinationS3ParquetColumnarStorage, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationS3OutputFormat: all fields are null")
}

// DestinationS3S3BucketRegion - The region of the S3 bucket. See <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-available-regions">here</a> for all region codes.
type DestinationS3S3BucketRegion string

const (
	DestinationS3S3BucketRegionUnknown      DestinationS3S3BucketRegion = ""
	DestinationS3S3BucketRegionAfSouth1     DestinationS3S3BucketRegion = "af-south-1"
	DestinationS3S3BucketRegionApEast1      DestinationS3S3BucketRegion = "ap-east-1"
	DestinationS3S3BucketRegionApNortheast1 DestinationS3S3BucketRegion = "ap-northeast-1"
	DestinationS3S3BucketRegionApNortheast2 DestinationS3S3BucketRegion = "ap-northeast-2"
	DestinationS3S3BucketRegionApNortheast3 DestinationS3S3BucketRegion = "ap-northeast-3"
	DestinationS3S3BucketRegionApSouth1     DestinationS3S3BucketRegion = "ap-south-1"
	DestinationS3S3BucketRegionApSouth2     DestinationS3S3BucketRegion = "ap-south-2"
	DestinationS3S3BucketRegionApSoutheast1 DestinationS3S3BucketRegion = "ap-southeast-1"
	DestinationS3S3BucketRegionApSoutheast2 DestinationS3S3BucketRegion = "ap-southeast-2"
	DestinationS3S3BucketRegionApSoutheast3 DestinationS3S3BucketRegion = "ap-southeast-3"
	DestinationS3S3BucketRegionApSoutheast4 DestinationS3S3BucketRegion = "ap-southeast-4"
	DestinationS3S3BucketRegionCaCentral1   DestinationS3S3BucketRegion = "ca-central-1"
	DestinationS3S3BucketRegionCaWest1      DestinationS3S3BucketRegion = "ca-west-1"
	DestinationS3S3BucketRegionCnNorth1     DestinationS3S3BucketRegion = "cn-north-1"
	DestinationS3S3BucketRegionCnNorthwest1 DestinationS3S3BucketRegion = "cn-northwest-1"
	DestinationS3S3BucketRegionEuCentral1   DestinationS3S3BucketRegion = "eu-central-1"
	DestinationS3S3BucketRegionEuCentral2   DestinationS3S3BucketRegion = "eu-central-2"
	DestinationS3S3BucketRegionEuNorth1     DestinationS3S3BucketRegion = "eu-north-1"
	DestinationS3S3BucketRegionEuSouth1     DestinationS3S3BucketRegion = "eu-south-1"
	DestinationS3S3BucketRegionEuSouth2     DestinationS3S3BucketRegion = "eu-south-2"
	DestinationS3S3BucketRegionEuWest1      DestinationS3S3BucketRegion = "eu-west-1"
	DestinationS3S3BucketRegionEuWest2      DestinationS3S3BucketRegion = "eu-west-2"
	DestinationS3S3BucketRegionEuWest3      DestinationS3S3BucketRegion = "eu-west-3"
	DestinationS3S3BucketRegionIlCentral1   DestinationS3S3BucketRegion = "il-central-1"
	DestinationS3S3BucketRegionMeCentral1   DestinationS3S3BucketRegion = "me-central-1"
	DestinationS3S3BucketRegionMeSouth1     DestinationS3S3BucketRegion = "me-south-1"
	DestinationS3S3BucketRegionSaEast1      DestinationS3S3BucketRegion = "sa-east-1"
	DestinationS3S3BucketRegionUsEast1      DestinationS3S3BucketRegion = "us-east-1"
	DestinationS3S3BucketRegionUsEast2      DestinationS3S3BucketRegion = "us-east-2"
	DestinationS3S3BucketRegionUsGovEast1   DestinationS3S3BucketRegion = "us-gov-east-1"
	DestinationS3S3BucketRegionUsGovWest1   DestinationS3S3BucketRegion = "us-gov-west-1"
	DestinationS3S3BucketRegionUsWest1      DestinationS3S3BucketRegion = "us-west-1"
	DestinationS3S3BucketRegionUsWest2      DestinationS3S3BucketRegion = "us-west-2"
)

func (e DestinationS3S3BucketRegion) ToPointer() *DestinationS3S3BucketRegion {
	return &e
}
func (e *DestinationS3S3BucketRegion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "":
		fallthrough
	case "af-south-1":
		fallthrough
	case "ap-east-1":
		fallthrough
	case "ap-northeast-1":
		fallthrough
	case "ap-northeast-2":
		fallthrough
	case "ap-northeast-3":
		fallthrough
	case "ap-south-1":
		fallthrough
	case "ap-south-2":
		fallthrough
	case "ap-southeast-1":
		fallthrough
	case "ap-southeast-2":
		fallthrough
	case "ap-southeast-3":
		fallthrough
	case "ap-southeast-4":
		fallthrough
	case "ca-central-1":
		fallthrough
	case "ca-west-1":
		fallthrough
	case "cn-north-1":
		fallthrough
	case "cn-northwest-1":
		fallthrough
	case "eu-central-1":
		fallthrough
	case "eu-central-2":
		fallthrough
	case "eu-north-1":
		fallthrough
	case "eu-south-1":
		fallthrough
	case "eu-south-2":
		fallthrough
	case "eu-west-1":
		fallthrough
	case "eu-west-2":
		fallthrough
	case "eu-west-3":
		fallthrough
	case "il-central-1":
		fallthrough
	case "me-central-1":
		fallthrough
	case "me-south-1":
		fallthrough
	case "sa-east-1":
		fallthrough
	case "us-east-1":
		fallthrough
	case "us-east-2":
		fallthrough
	case "us-gov-east-1":
		fallthrough
	case "us-gov-west-1":
		fallthrough
	case "us-west-1":
		fallthrough
	case "us-west-2":
		*e = DestinationS3S3BucketRegion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3S3BucketRegion: %v", v)
	}
}

type DestinationS3 struct {
	// The access key ID to access the S3 bucket. Airbyte requires Read and Write permissions to the given bucket. Read more <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">here</a>.
	AccessKeyID     *string `json:"access_key_id,omitempty"`
	destinationType S3      `const:"s3" json:"destinationType"`
	// The pattern allows you to set the file-name format for the S3 staging file(s)
	FileNamePattern *string `json:"file_name_pattern,omitempty"`
	// Format of the data output. See <a href="https://docs.airbyte.com/integrations/destinations/s3/#supported-output-schema">here</a> for more details
	Format DestinationS3OutputFormat `json:"format"`
	// The Role ARN
	RoleArn *string `json:"role_arn,omitempty"`
	// The name of the S3 bucket. Read more <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/create-bucket-overview.html">here</a>.
	S3BucketName string `json:"s3_bucket_name"`
	// Directory under the S3 bucket where data will be written. Read more <a href="https://docs.airbyte.com/integrations/destinations/s3#:~:text=to%20format%20the-,bucket%20path,-%3A">here</a>
	S3BucketPath string `json:"s3_bucket_path"`
	// The region of the S3 bucket. See <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-available-regions">here</a> for all region codes.
	S3BucketRegion *DestinationS3S3BucketRegion `default:"" json:"s3_bucket_region"`
	// Your S3 endpoint url. Read more <a href="https://docs.aws.amazon.com/general/latest/gr/s3.html#:~:text=Service%20endpoints-,Amazon%20S3%20endpoints,-When%20you%20use">here</a>
	S3Endpoint *string `default:"" json:"s3_endpoint"`
	// Format string on how data will be organized inside the S3 bucket directory. Read more <a href="https://docs.airbyte.com/integrations/destinations/s3#:~:text=The%20full%20path%20of%20the%20output%20data%20with%20the%20default%20S3%20path%20format">here</a>
	S3PathFormat *string `json:"s3_path_format,omitempty"`
	// The corresponding secret to the access key ID. Read more <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">here</a>
	SecretAccessKey *string `json:"secret_access_key,omitempty"`
}

func (d DestinationS3) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationS3) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *DestinationS3) GetAccessKeyID() *string {
	if o == nil {
		return nil
	}
	return o.AccessKeyID
}

func (o *DestinationS3) GetDestinationType() S3 {
	return S3S3
}

func (o *DestinationS3) GetFileNamePattern() *string {
	if o == nil {
		return nil
	}
	return o.FileNamePattern
}

func (o *DestinationS3) GetFormat() DestinationS3OutputFormat {
	if o == nil {
		return DestinationS3OutputFormat{}
	}
	return o.Format
}

func (o *DestinationS3) GetRoleArn() *string {
	if o == nil {
		return nil
	}
	return o.RoleArn
}

func (o *DestinationS3) GetS3BucketName() string {
	if o == nil {
		return ""
	}
	return o.S3BucketName
}

func (o *DestinationS3) GetS3BucketPath() string {
	if o == nil {
		return ""
	}
	return o.S3BucketPath
}

func (o *DestinationS3) GetS3BucketRegion() *DestinationS3S3BucketRegion {
	if o == nil {
		return nil
	}
	return o.S3BucketRegion
}

func (o *DestinationS3) GetS3Endpoint() *string {
	if o == nil {
		return nil
	}
	return o.S3Endpoint
}

func (o *DestinationS3) GetS3PathFormat() *string {
	if o == nil {
		return nil
	}
	return o.S3PathFormat
}

func (o *DestinationS3) GetSecretAccessKey() *string {
	if o == nil {
		return nil
	}
	return o.SecretAccessKey
}
