// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

type DestinationChromaUpdateSchemasEmbeddingEmbedding7Mode string

const (
	DestinationChromaUpdateSchemasEmbeddingEmbedding7ModeNoEmbedding DestinationChromaUpdateSchemasEmbeddingEmbedding7Mode = "no_embedding"
)

func (e DestinationChromaUpdateSchemasEmbeddingEmbedding7Mode) ToPointer() *DestinationChromaUpdateSchemasEmbeddingEmbedding7Mode {
	return &e
}
func (e *DestinationChromaUpdateSchemasEmbeddingEmbedding7Mode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "no_embedding":
		*e = DestinationChromaUpdateSchemasEmbeddingEmbedding7Mode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationChromaUpdateSchemasEmbeddingEmbedding7Mode: %v", v)
	}
}

// DestinationChromaUpdateChromaDefaultEmbeddingFunction - Do not calculate embeddings. Chromadb uses the sentence transfomer (https://www.sbert.net/index.html) as a default if an embedding function is not defined. Note that depending on your hardware, calculating embeddings locally can be very slow and is mostly suited for prototypes.
type DestinationChromaUpdateChromaDefaultEmbeddingFunction struct {
	mode *DestinationChromaUpdateSchemasEmbeddingEmbedding7Mode `const:"no_embedding" json:"mode"`
}

func (d DestinationChromaUpdateChromaDefaultEmbeddingFunction) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationChromaUpdateChromaDefaultEmbeddingFunction) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationChromaUpdateChromaDefaultEmbeddingFunction) GetMode() *DestinationChromaUpdateSchemasEmbeddingEmbedding7Mode {
	return DestinationChromaUpdateSchemasEmbeddingEmbedding7ModeNoEmbedding.ToPointer()
}

type DestinationChromaUpdateSchemasEmbeddingEmbedding6Mode string

const (
	DestinationChromaUpdateSchemasEmbeddingEmbedding6ModeOpenaiCompatible DestinationChromaUpdateSchemasEmbeddingEmbedding6Mode = "openai_compatible"
)

func (e DestinationChromaUpdateSchemasEmbeddingEmbedding6Mode) ToPointer() *DestinationChromaUpdateSchemasEmbeddingEmbedding6Mode {
	return &e
}
func (e *DestinationChromaUpdateSchemasEmbeddingEmbedding6Mode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "openai_compatible":
		*e = DestinationChromaUpdateSchemasEmbeddingEmbedding6Mode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationChromaUpdateSchemasEmbeddingEmbedding6Mode: %v", v)
	}
}

// DestinationChromaUpdateOpenAICompatible - Use a service that's compatible with the OpenAI API to embed text.
type DestinationChromaUpdateOpenAICompatible struct {
	APIKey *string `default:"" json:"api_key"`
	// The base URL for your OpenAI-compatible service
	BaseURL *string `json:"base_url,omitempty"`
	// The number of dimensions the embedding model is generating
	Dimensions *int64                                                 `json:"dimensions,omitempty"`
	mode       *DestinationChromaUpdateSchemasEmbeddingEmbedding6Mode `const:"openai_compatible" json:"mode"`
	// The name of the model to use for embedding
	ModelName *string `default:"text-embedding-ada-002" json:"model_name"`
}

func (d DestinationChromaUpdateOpenAICompatible) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationChromaUpdateOpenAICompatible) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationChromaUpdateOpenAICompatible) GetAPIKey() *string {
	if d == nil {
		return nil
	}
	return d.APIKey
}

func (d *DestinationChromaUpdateOpenAICompatible) GetBaseURL() *string {
	if d == nil {
		return nil
	}
	return d.BaseURL
}

func (d *DestinationChromaUpdateOpenAICompatible) GetDimensions() *int64 {
	if d == nil {
		return nil
	}
	return d.Dimensions
}

func (d *DestinationChromaUpdateOpenAICompatible) GetMode() *DestinationChromaUpdateSchemasEmbeddingEmbedding6Mode {
	return DestinationChromaUpdateSchemasEmbeddingEmbedding6ModeOpenaiCompatible.ToPointer()
}

func (d *DestinationChromaUpdateOpenAICompatible) GetModelName() *string {
	if d == nil {
		return nil
	}
	return d.ModelName
}

type DestinationChromaUpdateSchemasEmbeddingEmbedding5Mode string

const (
	DestinationChromaUpdateSchemasEmbeddingEmbedding5ModeFake DestinationChromaUpdateSchemasEmbeddingEmbedding5Mode = "fake"
)

func (e DestinationChromaUpdateSchemasEmbeddingEmbedding5Mode) ToPointer() *DestinationChromaUpdateSchemasEmbeddingEmbedding5Mode {
	return &e
}
func (e *DestinationChromaUpdateSchemasEmbeddingEmbedding5Mode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "fake":
		*e = DestinationChromaUpdateSchemasEmbeddingEmbedding5Mode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationChromaUpdateSchemasEmbeddingEmbedding5Mode: %v", v)
	}
}

// DestinationChromaUpdateFake - Use a fake embedding made out of random vectors with 1536 embedding dimensions. This is useful for testing the data pipeline without incurring any costs.
type DestinationChromaUpdateFake struct {
	mode *DestinationChromaUpdateSchemasEmbeddingEmbedding5Mode `const:"fake" json:"mode"`
}

func (d DestinationChromaUpdateFake) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationChromaUpdateFake) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationChromaUpdateFake) GetMode() *DestinationChromaUpdateSchemasEmbeddingEmbedding5Mode {
	return DestinationChromaUpdateSchemasEmbeddingEmbedding5ModeFake.ToPointer()
}

type DestinationChromaUpdateSchemasEmbeddingEmbeddingMode string

const (
	DestinationChromaUpdateSchemasEmbeddingEmbeddingModeFromField DestinationChromaUpdateSchemasEmbeddingEmbeddingMode = "from_field"
)

func (e DestinationChromaUpdateSchemasEmbeddingEmbeddingMode) ToPointer() *DestinationChromaUpdateSchemasEmbeddingEmbeddingMode {
	return &e
}
func (e *DestinationChromaUpdateSchemasEmbeddingEmbeddingMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "from_field":
		*e = DestinationChromaUpdateSchemasEmbeddingEmbeddingMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationChromaUpdateSchemasEmbeddingEmbeddingMode: %v", v)
	}
}

// DestinationChromaUpdateFromField - Use a field in the record as the embedding. This is useful if you already have an embedding for your data and want to store it in the vector store.
type DestinationChromaUpdateFromField struct {
	// The number of dimensions the embedding model is generating
	Dimensions *int64 `json:"dimensions,omitempty"`
	// Name of the field in the record that contains the embedding
	FieldName *string                                               `json:"field_name,omitempty"`
	mode      *DestinationChromaUpdateSchemasEmbeddingEmbeddingMode `const:"from_field" json:"mode"`
}

func (d DestinationChromaUpdateFromField) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationChromaUpdateFromField) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationChromaUpdateFromField) GetDimensions() *int64 {
	if d == nil {
		return nil
	}
	return d.Dimensions
}

func (d *DestinationChromaUpdateFromField) GetFieldName() *string {
	if d == nil {
		return nil
	}
	return d.FieldName
}

func (d *DestinationChromaUpdateFromField) GetMode() *DestinationChromaUpdateSchemasEmbeddingEmbeddingMode {
	return DestinationChromaUpdateSchemasEmbeddingEmbeddingModeFromField.ToPointer()
}

type DestinationChromaUpdateSchemasEmbeddingMode string

const (
	DestinationChromaUpdateSchemasEmbeddingModeCohere DestinationChromaUpdateSchemasEmbeddingMode = "cohere"
)

func (e DestinationChromaUpdateSchemasEmbeddingMode) ToPointer() *DestinationChromaUpdateSchemasEmbeddingMode {
	return &e
}
func (e *DestinationChromaUpdateSchemasEmbeddingMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "cohere":
		*e = DestinationChromaUpdateSchemasEmbeddingMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationChromaUpdateSchemasEmbeddingMode: %v", v)
	}
}

// DestinationChromaUpdateCohere - Use the Cohere API to embed text.
type DestinationChromaUpdateCohere struct {
	CohereKey *string                                      `json:"cohere_key,omitempty"`
	mode      *DestinationChromaUpdateSchemasEmbeddingMode `const:"cohere" json:"mode"`
}

func (d DestinationChromaUpdateCohere) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationChromaUpdateCohere) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationChromaUpdateCohere) GetCohereKey() *string {
	if d == nil {
		return nil
	}
	return d.CohereKey
}

func (d *DestinationChromaUpdateCohere) GetMode() *DestinationChromaUpdateSchemasEmbeddingMode {
	return DestinationChromaUpdateSchemasEmbeddingModeCohere.ToPointer()
}

type DestinationChromaUpdateSchemasMode string

const (
	DestinationChromaUpdateSchemasModeOpenai DestinationChromaUpdateSchemasMode = "openai"
)

func (e DestinationChromaUpdateSchemasMode) ToPointer() *DestinationChromaUpdateSchemasMode {
	return &e
}
func (e *DestinationChromaUpdateSchemasMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "openai":
		*e = DestinationChromaUpdateSchemasMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationChromaUpdateSchemasMode: %v", v)
	}
}

// DestinationChromaUpdateOpenAI - Use the OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
type DestinationChromaUpdateOpenAI struct {
	mode      *DestinationChromaUpdateSchemasMode `const:"openai" json:"mode"`
	OpenaiKey *string                             `json:"openai_key,omitempty"`
}

func (d DestinationChromaUpdateOpenAI) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationChromaUpdateOpenAI) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationChromaUpdateOpenAI) GetMode() *DestinationChromaUpdateSchemasMode {
	return DestinationChromaUpdateSchemasModeOpenai.ToPointer()
}

func (d *DestinationChromaUpdateOpenAI) GetOpenaiKey() *string {
	if d == nil {
		return nil
	}
	return d.OpenaiKey
}

type DestinationChromaUpdateMode string

const (
	DestinationChromaUpdateModeAzureOpenai DestinationChromaUpdateMode = "azure_openai"
)

func (e DestinationChromaUpdateMode) ToPointer() *DestinationChromaUpdateMode {
	return &e
}
func (e *DestinationChromaUpdateMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "azure_openai":
		*e = DestinationChromaUpdateMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationChromaUpdateMode: %v", v)
	}
}

// DestinationChromaUpdateAzureOpenAI - Use the Azure-hosted OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
type DestinationChromaUpdateAzureOpenAI struct {
	// The base URL for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
	APIBase *string `json:"api_base,omitempty"`
	// The deployment for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
	Deployment *string                      `json:"deployment,omitempty"`
	mode       *DestinationChromaUpdateMode `const:"azure_openai" json:"mode"`
	// The API key for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
	OpenaiKey *string `json:"openai_key,omitempty"`
}

func (d DestinationChromaUpdateAzureOpenAI) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationChromaUpdateAzureOpenAI) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationChromaUpdateAzureOpenAI) GetAPIBase() *string {
	if d == nil {
		return nil
	}
	return d.APIBase
}

func (d *DestinationChromaUpdateAzureOpenAI) GetDeployment() *string {
	if d == nil {
		return nil
	}
	return d.Deployment
}

func (d *DestinationChromaUpdateAzureOpenAI) GetMode() *DestinationChromaUpdateMode {
	return DestinationChromaUpdateModeAzureOpenai.ToPointer()
}

func (d *DestinationChromaUpdateAzureOpenAI) GetOpenaiKey() *string {
	if d == nil {
		return nil
	}
	return d.OpenaiKey
}

type DestinationChromaUpdateEmbeddingType string

const (
	DestinationChromaUpdateEmbeddingTypeDestinationChromaUpdateAzureOpenAI                    DestinationChromaUpdateEmbeddingType = "destination-chroma-update_Azure OpenAI"
	DestinationChromaUpdateEmbeddingTypeDestinationChromaUpdateOpenAI                         DestinationChromaUpdateEmbeddingType = "destination-chroma-update_OpenAI"
	DestinationChromaUpdateEmbeddingTypeDestinationChromaUpdateCohere                         DestinationChromaUpdateEmbeddingType = "destination-chroma-update_Cohere"
	DestinationChromaUpdateEmbeddingTypeDestinationChromaUpdateFromField                      DestinationChromaUpdateEmbeddingType = "destination-chroma-update_From Field"
	DestinationChromaUpdateEmbeddingTypeDestinationChromaUpdateFake                           DestinationChromaUpdateEmbeddingType = "destination-chroma-update_Fake"
	DestinationChromaUpdateEmbeddingTypeDestinationChromaUpdateOpenAICompatible               DestinationChromaUpdateEmbeddingType = "destination-chroma-update_OpenAI-compatible"
	DestinationChromaUpdateEmbeddingTypeDestinationChromaUpdateChromaDefaultEmbeddingFunction DestinationChromaUpdateEmbeddingType = "destination-chroma-update_Chroma Default Embedding Function"
)

// DestinationChromaUpdateEmbedding - Embedding configuration
type DestinationChromaUpdateEmbedding struct {
	DestinationChromaUpdateAzureOpenAI                    *DestinationChromaUpdateAzureOpenAI                    `queryParam:"inline" union:"member"`
	DestinationChromaUpdateOpenAI                         *DestinationChromaUpdateOpenAI                         `queryParam:"inline" union:"member"`
	DestinationChromaUpdateCohere                         *DestinationChromaUpdateCohere                         `queryParam:"inline" union:"member"`
	DestinationChromaUpdateFromField                      *DestinationChromaUpdateFromField                      `queryParam:"inline" union:"member"`
	DestinationChromaUpdateFake                           *DestinationChromaUpdateFake                           `queryParam:"inline" union:"member"`
	DestinationChromaUpdateOpenAICompatible               *DestinationChromaUpdateOpenAICompatible               `queryParam:"inline" union:"member"`
	DestinationChromaUpdateChromaDefaultEmbeddingFunction *DestinationChromaUpdateChromaDefaultEmbeddingFunction `queryParam:"inline" union:"member"`

	Type DestinationChromaUpdateEmbeddingType
}

func CreateDestinationChromaUpdateEmbeddingDestinationChromaUpdateAzureOpenAI(destinationChromaUpdateAzureOpenAI DestinationChromaUpdateAzureOpenAI) DestinationChromaUpdateEmbedding {
	typ := DestinationChromaUpdateEmbeddingTypeDestinationChromaUpdateAzureOpenAI

	return DestinationChromaUpdateEmbedding{
		DestinationChromaUpdateAzureOpenAI: &destinationChromaUpdateAzureOpenAI,
		Type:                               typ,
	}
}

func CreateDestinationChromaUpdateEmbeddingDestinationChromaUpdateOpenAI(destinationChromaUpdateOpenAI DestinationChromaUpdateOpenAI) DestinationChromaUpdateEmbedding {
	typ := DestinationChromaUpdateEmbeddingTypeDestinationChromaUpdateOpenAI

	return DestinationChromaUpdateEmbedding{
		DestinationChromaUpdateOpenAI: &destinationChromaUpdateOpenAI,
		Type:                          typ,
	}
}

func CreateDestinationChromaUpdateEmbeddingDestinationChromaUpdateCohere(destinationChromaUpdateCohere DestinationChromaUpdateCohere) DestinationChromaUpdateEmbedding {
	typ := DestinationChromaUpdateEmbeddingTypeDestinationChromaUpdateCohere

	return DestinationChromaUpdateEmbedding{
		DestinationChromaUpdateCohere: &destinationChromaUpdateCohere,
		Type:                          typ,
	}
}

func CreateDestinationChromaUpdateEmbeddingDestinationChromaUpdateFromField(destinationChromaUpdateFromField DestinationChromaUpdateFromField) DestinationChromaUpdateEmbedding {
	typ := DestinationChromaUpdateEmbeddingTypeDestinationChromaUpdateFromField

	return DestinationChromaUpdateEmbedding{
		DestinationChromaUpdateFromField: &destinationChromaUpdateFromField,
		Type:                             typ,
	}
}

func CreateDestinationChromaUpdateEmbeddingDestinationChromaUpdateFake(destinationChromaUpdateFake DestinationChromaUpdateFake) DestinationChromaUpdateEmbedding {
	typ := DestinationChromaUpdateEmbeddingTypeDestinationChromaUpdateFake

	return DestinationChromaUpdateEmbedding{
		DestinationChromaUpdateFake: &destinationChromaUpdateFake,
		Type:                        typ,
	}
}

func CreateDestinationChromaUpdateEmbeddingDestinationChromaUpdateOpenAICompatible(destinationChromaUpdateOpenAICompatible DestinationChromaUpdateOpenAICompatible) DestinationChromaUpdateEmbedding {
	typ := DestinationChromaUpdateEmbeddingTypeDestinationChromaUpdateOpenAICompatible

	return DestinationChromaUpdateEmbedding{
		DestinationChromaUpdateOpenAICompatible: &destinationChromaUpdateOpenAICompatible,
		Type:                                    typ,
	}
}

func CreateDestinationChromaUpdateEmbeddingDestinationChromaUpdateChromaDefaultEmbeddingFunction(destinationChromaUpdateChromaDefaultEmbeddingFunction DestinationChromaUpdateChromaDefaultEmbeddingFunction) DestinationChromaUpdateEmbedding {
	typ := DestinationChromaUpdateEmbeddingTypeDestinationChromaUpdateChromaDefaultEmbeddingFunction

	return DestinationChromaUpdateEmbedding{
		DestinationChromaUpdateChromaDefaultEmbeddingFunction: &destinationChromaUpdateChromaDefaultEmbeddingFunction,
		Type: typ,
	}
}

func (u *DestinationChromaUpdateEmbedding) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var destinationChromaUpdateAzureOpenAI DestinationChromaUpdateAzureOpenAI = DestinationChromaUpdateAzureOpenAI{}
	if err := utils.UnmarshalJSON(data, &destinationChromaUpdateAzureOpenAI, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationChromaUpdateEmbeddingTypeDestinationChromaUpdateAzureOpenAI,
			Value: &destinationChromaUpdateAzureOpenAI,
		})
	}

	var destinationChromaUpdateOpenAI DestinationChromaUpdateOpenAI = DestinationChromaUpdateOpenAI{}
	if err := utils.UnmarshalJSON(data, &destinationChromaUpdateOpenAI, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationChromaUpdateEmbeddingTypeDestinationChromaUpdateOpenAI,
			Value: &destinationChromaUpdateOpenAI,
		})
	}

	var destinationChromaUpdateCohere DestinationChromaUpdateCohere = DestinationChromaUpdateCohere{}
	if err := utils.UnmarshalJSON(data, &destinationChromaUpdateCohere, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationChromaUpdateEmbeddingTypeDestinationChromaUpdateCohere,
			Value: &destinationChromaUpdateCohere,
		})
	}

	var destinationChromaUpdateFromField DestinationChromaUpdateFromField = DestinationChromaUpdateFromField{}
	if err := utils.UnmarshalJSON(data, &destinationChromaUpdateFromField, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationChromaUpdateEmbeddingTypeDestinationChromaUpdateFromField,
			Value: &destinationChromaUpdateFromField,
		})
	}

	var destinationChromaUpdateFake DestinationChromaUpdateFake = DestinationChromaUpdateFake{}
	if err := utils.UnmarshalJSON(data, &destinationChromaUpdateFake, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationChromaUpdateEmbeddingTypeDestinationChromaUpdateFake,
			Value: &destinationChromaUpdateFake,
		})
	}

	var destinationChromaUpdateOpenAICompatible DestinationChromaUpdateOpenAICompatible = DestinationChromaUpdateOpenAICompatible{}
	if err := utils.UnmarshalJSON(data, &destinationChromaUpdateOpenAICompatible, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationChromaUpdateEmbeddingTypeDestinationChromaUpdateOpenAICompatible,
			Value: &destinationChromaUpdateOpenAICompatible,
		})
	}

	var destinationChromaUpdateChromaDefaultEmbeddingFunction DestinationChromaUpdateChromaDefaultEmbeddingFunction = DestinationChromaUpdateChromaDefaultEmbeddingFunction{}
	if err := utils.UnmarshalJSON(data, &destinationChromaUpdateChromaDefaultEmbeddingFunction, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationChromaUpdateEmbeddingTypeDestinationChromaUpdateChromaDefaultEmbeddingFunction,
			Value: &destinationChromaUpdateChromaDefaultEmbeddingFunction,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationChromaUpdateEmbedding", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationChromaUpdateEmbedding", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(DestinationChromaUpdateEmbeddingType)
	switch best.Type {
	case DestinationChromaUpdateEmbeddingTypeDestinationChromaUpdateAzureOpenAI:
		u.DestinationChromaUpdateAzureOpenAI = best.Value.(*DestinationChromaUpdateAzureOpenAI)
		return nil
	case DestinationChromaUpdateEmbeddingTypeDestinationChromaUpdateOpenAI:
		u.DestinationChromaUpdateOpenAI = best.Value.(*DestinationChromaUpdateOpenAI)
		return nil
	case DestinationChromaUpdateEmbeddingTypeDestinationChromaUpdateCohere:
		u.DestinationChromaUpdateCohere = best.Value.(*DestinationChromaUpdateCohere)
		return nil
	case DestinationChromaUpdateEmbeddingTypeDestinationChromaUpdateFromField:
		u.DestinationChromaUpdateFromField = best.Value.(*DestinationChromaUpdateFromField)
		return nil
	case DestinationChromaUpdateEmbeddingTypeDestinationChromaUpdateFake:
		u.DestinationChromaUpdateFake = best.Value.(*DestinationChromaUpdateFake)
		return nil
	case DestinationChromaUpdateEmbeddingTypeDestinationChromaUpdateOpenAICompatible:
		u.DestinationChromaUpdateOpenAICompatible = best.Value.(*DestinationChromaUpdateOpenAICompatible)
		return nil
	case DestinationChromaUpdateEmbeddingTypeDestinationChromaUpdateChromaDefaultEmbeddingFunction:
		u.DestinationChromaUpdateChromaDefaultEmbeddingFunction = best.Value.(*DestinationChromaUpdateChromaDefaultEmbeddingFunction)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationChromaUpdateEmbedding", string(data))
}

func (u DestinationChromaUpdateEmbedding) MarshalJSON() ([]byte, error) {
	if u.DestinationChromaUpdateAzureOpenAI != nil {
		return utils.MarshalJSON(u.DestinationChromaUpdateAzureOpenAI, "", true)
	}

	if u.DestinationChromaUpdateOpenAI != nil {
		return utils.MarshalJSON(u.DestinationChromaUpdateOpenAI, "", true)
	}

	if u.DestinationChromaUpdateCohere != nil {
		return utils.MarshalJSON(u.DestinationChromaUpdateCohere, "", true)
	}

	if u.DestinationChromaUpdateFromField != nil {
		return utils.MarshalJSON(u.DestinationChromaUpdateFromField, "", true)
	}

	if u.DestinationChromaUpdateFake != nil {
		return utils.MarshalJSON(u.DestinationChromaUpdateFake, "", true)
	}

	if u.DestinationChromaUpdateOpenAICompatible != nil {
		return utils.MarshalJSON(u.DestinationChromaUpdateOpenAICompatible, "", true)
	}

	if u.DestinationChromaUpdateChromaDefaultEmbeddingFunction != nil {
		return utils.MarshalJSON(u.DestinationChromaUpdateChromaDefaultEmbeddingFunction, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationChromaUpdateEmbedding: all fields are null")
}

type DestinationChromaUpdateSchemasIndexingAuthMethodMode string

const (
	DestinationChromaUpdateSchemasIndexingAuthMethodModeHTTPClient DestinationChromaUpdateSchemasIndexingAuthMethodMode = "http_client"
)

func (e DestinationChromaUpdateSchemasIndexingAuthMethodMode) ToPointer() *DestinationChromaUpdateSchemasIndexingAuthMethodMode {
	return &e
}
func (e *DestinationChromaUpdateSchemasIndexingAuthMethodMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "http_client":
		*e = DestinationChromaUpdateSchemasIndexingAuthMethodMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationChromaUpdateSchemasIndexingAuthMethodMode: %v", v)
	}
}

// DestinationChromaUpdateClientServerMode - Authenticate using username and password (suitable for self-managed Chroma clusters)
type DestinationChromaUpdateClientServerMode struct {
	// The URL to the chromadb instance
	Host *string                                               `json:"host,omitempty"`
	mode *DestinationChromaUpdateSchemasIndexingAuthMethodMode `const:"http_client" json:"mode"`
	// Password used in server/client mode only
	Password *string `default:"" json:"password"`
	// The port to the chromadb instance
	Port *int64 `json:"port,omitempty"`
	// Whether to use SSL to connect to the Chroma server
	Ssl *bool `json:"ssl,omitempty"`
	// Username used in server/client mode only
	Username *string `default:"" json:"username"`
}

func (d DestinationChromaUpdateClientServerMode) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationChromaUpdateClientServerMode) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationChromaUpdateClientServerMode) GetHost() *string {
	if d == nil {
		return nil
	}
	return d.Host
}

func (d *DestinationChromaUpdateClientServerMode) GetMode() *DestinationChromaUpdateSchemasIndexingAuthMethodMode {
	return DestinationChromaUpdateSchemasIndexingAuthMethodModeHTTPClient.ToPointer()
}

func (d *DestinationChromaUpdateClientServerMode) GetPassword() *string {
	if d == nil {
		return nil
	}
	return d.Password
}

func (d *DestinationChromaUpdateClientServerMode) GetPort() *int64 {
	if d == nil {
		return nil
	}
	return d.Port
}

func (d *DestinationChromaUpdateClientServerMode) GetSsl() *bool {
	if d == nil {
		return nil
	}
	return d.Ssl
}

func (d *DestinationChromaUpdateClientServerMode) GetUsername() *string {
	if d == nil {
		return nil
	}
	return d.Username
}

type DestinationChromaUpdateSchemasIndexingMode string

const (
	DestinationChromaUpdateSchemasIndexingModePersistentClient DestinationChromaUpdateSchemasIndexingMode = "persistent_client"
)

func (e DestinationChromaUpdateSchemasIndexingMode) ToPointer() *DestinationChromaUpdateSchemasIndexingMode {
	return &e
}
func (e *DestinationChromaUpdateSchemasIndexingMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "persistent_client":
		*e = DestinationChromaUpdateSchemasIndexingMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationChromaUpdateSchemasIndexingMode: %v", v)
	}
}

// DestinationChromaUpdatePersistentClientMode - Configure Chroma to save and load from your local machine
type DestinationChromaUpdatePersistentClientMode struct {
	mode *DestinationChromaUpdateSchemasIndexingMode `const:"persistent_client" json:"mode"`
	// Where Chroma will store its database files on disk, and load them on start.
	Path *string `json:"path,omitempty"`
}

func (d DestinationChromaUpdatePersistentClientMode) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationChromaUpdatePersistentClientMode) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationChromaUpdatePersistentClientMode) GetMode() *DestinationChromaUpdateSchemasIndexingMode {
	return DestinationChromaUpdateSchemasIndexingModePersistentClient.ToPointer()
}

func (d *DestinationChromaUpdatePersistentClientMode) GetPath() *string {
	if d == nil {
		return nil
	}
	return d.Path
}

type DestinationChromaUpdateConnectionModeType string

const (
	DestinationChromaUpdateConnectionModeTypeDestinationChromaUpdatePersistentClientMode DestinationChromaUpdateConnectionModeType = "destination-chroma-update_Persistent Client Mode"
	DestinationChromaUpdateConnectionModeTypeDestinationChromaUpdateClientServerMode     DestinationChromaUpdateConnectionModeType = "destination-chroma-update_Client/Server Mode"
)

// DestinationChromaUpdateConnectionMode - Mode how to connect to Chroma
type DestinationChromaUpdateConnectionMode struct {
	DestinationChromaUpdatePersistentClientMode *DestinationChromaUpdatePersistentClientMode `queryParam:"inline" union:"member"`
	DestinationChromaUpdateClientServerMode     *DestinationChromaUpdateClientServerMode     `queryParam:"inline" union:"member"`

	Type DestinationChromaUpdateConnectionModeType
}

func CreateDestinationChromaUpdateConnectionModeDestinationChromaUpdatePersistentClientMode(destinationChromaUpdatePersistentClientMode DestinationChromaUpdatePersistentClientMode) DestinationChromaUpdateConnectionMode {
	typ := DestinationChromaUpdateConnectionModeTypeDestinationChromaUpdatePersistentClientMode

	return DestinationChromaUpdateConnectionMode{
		DestinationChromaUpdatePersistentClientMode: &destinationChromaUpdatePersistentClientMode,
		Type: typ,
	}
}

func CreateDestinationChromaUpdateConnectionModeDestinationChromaUpdateClientServerMode(destinationChromaUpdateClientServerMode DestinationChromaUpdateClientServerMode) DestinationChromaUpdateConnectionMode {
	typ := DestinationChromaUpdateConnectionModeTypeDestinationChromaUpdateClientServerMode

	return DestinationChromaUpdateConnectionMode{
		DestinationChromaUpdateClientServerMode: &destinationChromaUpdateClientServerMode,
		Type:                                    typ,
	}
}

func (u *DestinationChromaUpdateConnectionMode) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var destinationChromaUpdatePersistentClientMode DestinationChromaUpdatePersistentClientMode = DestinationChromaUpdatePersistentClientMode{}
	if err := utils.UnmarshalJSON(data, &destinationChromaUpdatePersistentClientMode, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationChromaUpdateConnectionModeTypeDestinationChromaUpdatePersistentClientMode,
			Value: &destinationChromaUpdatePersistentClientMode,
		})
	}

	var destinationChromaUpdateClientServerMode DestinationChromaUpdateClientServerMode = DestinationChromaUpdateClientServerMode{}
	if err := utils.UnmarshalJSON(data, &destinationChromaUpdateClientServerMode, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationChromaUpdateConnectionModeTypeDestinationChromaUpdateClientServerMode,
			Value: &destinationChromaUpdateClientServerMode,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationChromaUpdateConnectionMode", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationChromaUpdateConnectionMode", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(DestinationChromaUpdateConnectionModeType)
	switch best.Type {
	case DestinationChromaUpdateConnectionModeTypeDestinationChromaUpdatePersistentClientMode:
		u.DestinationChromaUpdatePersistentClientMode = best.Value.(*DestinationChromaUpdatePersistentClientMode)
		return nil
	case DestinationChromaUpdateConnectionModeTypeDestinationChromaUpdateClientServerMode:
		u.DestinationChromaUpdateClientServerMode = best.Value.(*DestinationChromaUpdateClientServerMode)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationChromaUpdateConnectionMode", string(data))
}

func (u DestinationChromaUpdateConnectionMode) MarshalJSON() ([]byte, error) {
	if u.DestinationChromaUpdatePersistentClientMode != nil {
		return utils.MarshalJSON(u.DestinationChromaUpdatePersistentClientMode, "", true)
	}

	if u.DestinationChromaUpdateClientServerMode != nil {
		return utils.MarshalJSON(u.DestinationChromaUpdateClientServerMode, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationChromaUpdateConnectionMode: all fields are null")
}

// DestinationChromaUpdateIndexing - Indexing configuration
type DestinationChromaUpdateIndexing struct {
	// Mode how to connect to Chroma
	AuthMethod *DestinationChromaUpdateConnectionMode `json:"auth_method,omitempty"`
	// The collection to load data into
	CollectionName *string `json:"collection_name,omitempty"`
}

func (d *DestinationChromaUpdateIndexing) GetAuthMethod() *DestinationChromaUpdateConnectionMode {
	if d == nil {
		return nil
	}
	return d.AuthMethod
}

func (d *DestinationChromaUpdateIndexing) GetCollectionName() *string {
	if d == nil {
		return nil
	}
	return d.CollectionName
}

type DestinationChromaUpdateFieldNameMappingConfigModel struct {
	// The field name in the source
	FromField *string `json:"from_field,omitempty"`
	// The field name to use in the destination
	ToField *string `json:"to_field,omitempty"`
}

func (d *DestinationChromaUpdateFieldNameMappingConfigModel) GetFromField() *string {
	if d == nil {
		return nil
	}
	return d.FromField
}

func (d *DestinationChromaUpdateFieldNameMappingConfigModel) GetToField() *string {
	if d == nil {
		return nil
	}
	return d.ToField
}

// DestinationChromaUpdateLanguage - Split code in suitable places based on the programming language
type DestinationChromaUpdateLanguage string

const (
	DestinationChromaUpdateLanguageCpp      DestinationChromaUpdateLanguage = "cpp"
	DestinationChromaUpdateLanguageGo       DestinationChromaUpdateLanguage = "go"
	DestinationChromaUpdateLanguageJava     DestinationChromaUpdateLanguage = "java"
	DestinationChromaUpdateLanguageJs       DestinationChromaUpdateLanguage = "js"
	DestinationChromaUpdateLanguagePhp      DestinationChromaUpdateLanguage = "php"
	DestinationChromaUpdateLanguageProto    DestinationChromaUpdateLanguage = "proto"
	DestinationChromaUpdateLanguagePython   DestinationChromaUpdateLanguage = "python"
	DestinationChromaUpdateLanguageRst      DestinationChromaUpdateLanguage = "rst"
	DestinationChromaUpdateLanguageRuby     DestinationChromaUpdateLanguage = "ruby"
	DestinationChromaUpdateLanguageRust     DestinationChromaUpdateLanguage = "rust"
	DestinationChromaUpdateLanguageScala    DestinationChromaUpdateLanguage = "scala"
	DestinationChromaUpdateLanguageSwift    DestinationChromaUpdateLanguage = "swift"
	DestinationChromaUpdateLanguageMarkdown DestinationChromaUpdateLanguage = "markdown"
	DestinationChromaUpdateLanguageLatex    DestinationChromaUpdateLanguage = "latex"
	DestinationChromaUpdateLanguageHTML     DestinationChromaUpdateLanguage = "html"
	DestinationChromaUpdateLanguageSol      DestinationChromaUpdateLanguage = "sol"
)

func (e DestinationChromaUpdateLanguage) ToPointer() *DestinationChromaUpdateLanguage {
	return &e
}
func (e *DestinationChromaUpdateLanguage) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "cpp":
		fallthrough
	case "go":
		fallthrough
	case "java":
		fallthrough
	case "js":
		fallthrough
	case "php":
		fallthrough
	case "proto":
		fallthrough
	case "python":
		fallthrough
	case "rst":
		fallthrough
	case "ruby":
		fallthrough
	case "rust":
		fallthrough
	case "scala":
		fallthrough
	case "swift":
		fallthrough
	case "markdown":
		fallthrough
	case "latex":
		fallthrough
	case "html":
		fallthrough
	case "sol":
		*e = DestinationChromaUpdateLanguage(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationChromaUpdateLanguage: %v", v)
	}
}

type DestinationChromaUpdateSchemasProcessingTextSplitterTextSplitterMode string

const (
	DestinationChromaUpdateSchemasProcessingTextSplitterTextSplitterModeCode DestinationChromaUpdateSchemasProcessingTextSplitterTextSplitterMode = "code"
)

func (e DestinationChromaUpdateSchemasProcessingTextSplitterTextSplitterMode) ToPointer() *DestinationChromaUpdateSchemasProcessingTextSplitterTextSplitterMode {
	return &e
}
func (e *DestinationChromaUpdateSchemasProcessingTextSplitterTextSplitterMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "code":
		*e = DestinationChromaUpdateSchemasProcessingTextSplitterTextSplitterMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationChromaUpdateSchemasProcessingTextSplitterTextSplitterMode: %v", v)
	}
}

// DestinationChromaUpdateByProgrammingLanguage - Split the text by suitable delimiters based on the programming language. This is useful for splitting code into chunks.
type DestinationChromaUpdateByProgrammingLanguage struct {
	// Split code in suitable places based on the programming language
	Language *DestinationChromaUpdateLanguage                                      `json:"language,omitempty"`
	mode     *DestinationChromaUpdateSchemasProcessingTextSplitterTextSplitterMode `const:"code" json:"mode"`
}

func (d DestinationChromaUpdateByProgrammingLanguage) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationChromaUpdateByProgrammingLanguage) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationChromaUpdateByProgrammingLanguage) GetLanguage() *DestinationChromaUpdateLanguage {
	if d == nil {
		return nil
	}
	return d.Language
}

func (d *DestinationChromaUpdateByProgrammingLanguage) GetMode() *DestinationChromaUpdateSchemasProcessingTextSplitterTextSplitterMode {
	return DestinationChromaUpdateSchemasProcessingTextSplitterTextSplitterModeCode.ToPointer()
}

type DestinationChromaUpdateSchemasProcessingTextSplitterMode string

const (
	DestinationChromaUpdateSchemasProcessingTextSplitterModeMarkdown DestinationChromaUpdateSchemasProcessingTextSplitterMode = "markdown"
)

func (e DestinationChromaUpdateSchemasProcessingTextSplitterMode) ToPointer() *DestinationChromaUpdateSchemasProcessingTextSplitterMode {
	return &e
}
func (e *DestinationChromaUpdateSchemasProcessingTextSplitterMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "markdown":
		*e = DestinationChromaUpdateSchemasProcessingTextSplitterMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationChromaUpdateSchemasProcessingTextSplitterMode: %v", v)
	}
}

// DestinationChromaUpdateByMarkdownHeader - Split the text by Markdown headers down to the specified header level. If the chunk size fits multiple sections, they will be combined into a single chunk.
type DestinationChromaUpdateByMarkdownHeader struct {
	mode *DestinationChromaUpdateSchemasProcessingTextSplitterMode `const:"markdown" json:"mode"`
	// Level of markdown headers to split text fields by. Headings down to the specified level will be used as split points
	SplitLevel *int64 `default:"1" json:"split_level"`
}

func (d DestinationChromaUpdateByMarkdownHeader) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationChromaUpdateByMarkdownHeader) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationChromaUpdateByMarkdownHeader) GetMode() *DestinationChromaUpdateSchemasProcessingTextSplitterMode {
	return DestinationChromaUpdateSchemasProcessingTextSplitterModeMarkdown.ToPointer()
}

func (d *DestinationChromaUpdateByMarkdownHeader) GetSplitLevel() *int64 {
	if d == nil {
		return nil
	}
	return d.SplitLevel
}

type DestinationChromaUpdateSchemasProcessingMode string

const (
	DestinationChromaUpdateSchemasProcessingModeSeparator DestinationChromaUpdateSchemasProcessingMode = "separator"
)

func (e DestinationChromaUpdateSchemasProcessingMode) ToPointer() *DestinationChromaUpdateSchemasProcessingMode {
	return &e
}
func (e *DestinationChromaUpdateSchemasProcessingMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "separator":
		*e = DestinationChromaUpdateSchemasProcessingMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationChromaUpdateSchemasProcessingMode: %v", v)
	}
}

// DestinationChromaUpdateBySeparator - Split the text by the list of separators until the chunk size is reached, using the earlier mentioned separators where possible. This is useful for splitting text fields by paragraphs, sentences, words, etc.
type DestinationChromaUpdateBySeparator struct {
	// Whether to keep the separator in the resulting chunks
	KeepSeparator *bool                                         `default:"false" json:"keep_separator"`
	mode          *DestinationChromaUpdateSchemasProcessingMode `const:"separator" json:"mode"`
	// List of separator strings to split text fields by. The separator itself needs to be wrapped in double quotes, e.g. to split by the dot character, use ".". To split by a newline, use "\n".
	Separators []string `json:"separators,omitempty"`
}

func (d DestinationChromaUpdateBySeparator) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationChromaUpdateBySeparator) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationChromaUpdateBySeparator) GetKeepSeparator() *bool {
	if d == nil {
		return nil
	}
	return d.KeepSeparator
}

func (d *DestinationChromaUpdateBySeparator) GetMode() *DestinationChromaUpdateSchemasProcessingMode {
	return DestinationChromaUpdateSchemasProcessingModeSeparator.ToPointer()
}

func (d *DestinationChromaUpdateBySeparator) GetSeparators() []string {
	if d == nil {
		return nil
	}
	return d.Separators
}

type DestinationChromaUpdateTextSplitterType string

const (
	DestinationChromaUpdateTextSplitterTypeDestinationChromaUpdateBySeparator           DestinationChromaUpdateTextSplitterType = "destination-chroma-update_By Separator"
	DestinationChromaUpdateTextSplitterTypeDestinationChromaUpdateByMarkdownHeader      DestinationChromaUpdateTextSplitterType = "destination-chroma-update_By Markdown header"
	DestinationChromaUpdateTextSplitterTypeDestinationChromaUpdateByProgrammingLanguage DestinationChromaUpdateTextSplitterType = "destination-chroma-update_By Programming Language"
)

// DestinationChromaUpdateTextSplitter - Split text fields into chunks based on the specified method.
type DestinationChromaUpdateTextSplitter struct {
	DestinationChromaUpdateBySeparator           *DestinationChromaUpdateBySeparator           `queryParam:"inline" union:"member"`
	DestinationChromaUpdateByMarkdownHeader      *DestinationChromaUpdateByMarkdownHeader      `queryParam:"inline" union:"member"`
	DestinationChromaUpdateByProgrammingLanguage *DestinationChromaUpdateByProgrammingLanguage `queryParam:"inline" union:"member"`

	Type DestinationChromaUpdateTextSplitterType
}

func CreateDestinationChromaUpdateTextSplitterDestinationChromaUpdateBySeparator(destinationChromaUpdateBySeparator DestinationChromaUpdateBySeparator) DestinationChromaUpdateTextSplitter {
	typ := DestinationChromaUpdateTextSplitterTypeDestinationChromaUpdateBySeparator

	return DestinationChromaUpdateTextSplitter{
		DestinationChromaUpdateBySeparator: &destinationChromaUpdateBySeparator,
		Type:                               typ,
	}
}

func CreateDestinationChromaUpdateTextSplitterDestinationChromaUpdateByMarkdownHeader(destinationChromaUpdateByMarkdownHeader DestinationChromaUpdateByMarkdownHeader) DestinationChromaUpdateTextSplitter {
	typ := DestinationChromaUpdateTextSplitterTypeDestinationChromaUpdateByMarkdownHeader

	return DestinationChromaUpdateTextSplitter{
		DestinationChromaUpdateByMarkdownHeader: &destinationChromaUpdateByMarkdownHeader,
		Type:                                    typ,
	}
}

func CreateDestinationChromaUpdateTextSplitterDestinationChromaUpdateByProgrammingLanguage(destinationChromaUpdateByProgrammingLanguage DestinationChromaUpdateByProgrammingLanguage) DestinationChromaUpdateTextSplitter {
	typ := DestinationChromaUpdateTextSplitterTypeDestinationChromaUpdateByProgrammingLanguage

	return DestinationChromaUpdateTextSplitter{
		DestinationChromaUpdateByProgrammingLanguage: &destinationChromaUpdateByProgrammingLanguage,
		Type: typ,
	}
}

func (u *DestinationChromaUpdateTextSplitter) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var destinationChromaUpdateBySeparator DestinationChromaUpdateBySeparator = DestinationChromaUpdateBySeparator{}
	if err := utils.UnmarshalJSON(data, &destinationChromaUpdateBySeparator, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationChromaUpdateTextSplitterTypeDestinationChromaUpdateBySeparator,
			Value: &destinationChromaUpdateBySeparator,
		})
	}

	var destinationChromaUpdateByMarkdownHeader DestinationChromaUpdateByMarkdownHeader = DestinationChromaUpdateByMarkdownHeader{}
	if err := utils.UnmarshalJSON(data, &destinationChromaUpdateByMarkdownHeader, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationChromaUpdateTextSplitterTypeDestinationChromaUpdateByMarkdownHeader,
			Value: &destinationChromaUpdateByMarkdownHeader,
		})
	}

	var destinationChromaUpdateByProgrammingLanguage DestinationChromaUpdateByProgrammingLanguage = DestinationChromaUpdateByProgrammingLanguage{}
	if err := utils.UnmarshalJSON(data, &destinationChromaUpdateByProgrammingLanguage, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationChromaUpdateTextSplitterTypeDestinationChromaUpdateByProgrammingLanguage,
			Value: &destinationChromaUpdateByProgrammingLanguage,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationChromaUpdateTextSplitter", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationChromaUpdateTextSplitter", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(DestinationChromaUpdateTextSplitterType)
	switch best.Type {
	case DestinationChromaUpdateTextSplitterTypeDestinationChromaUpdateBySeparator:
		u.DestinationChromaUpdateBySeparator = best.Value.(*DestinationChromaUpdateBySeparator)
		return nil
	case DestinationChromaUpdateTextSplitterTypeDestinationChromaUpdateByMarkdownHeader:
		u.DestinationChromaUpdateByMarkdownHeader = best.Value.(*DestinationChromaUpdateByMarkdownHeader)
		return nil
	case DestinationChromaUpdateTextSplitterTypeDestinationChromaUpdateByProgrammingLanguage:
		u.DestinationChromaUpdateByProgrammingLanguage = best.Value.(*DestinationChromaUpdateByProgrammingLanguage)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationChromaUpdateTextSplitter", string(data))
}

func (u DestinationChromaUpdateTextSplitter) MarshalJSON() ([]byte, error) {
	if u.DestinationChromaUpdateBySeparator != nil {
		return utils.MarshalJSON(u.DestinationChromaUpdateBySeparator, "", true)
	}

	if u.DestinationChromaUpdateByMarkdownHeader != nil {
		return utils.MarshalJSON(u.DestinationChromaUpdateByMarkdownHeader, "", true)
	}

	if u.DestinationChromaUpdateByProgrammingLanguage != nil {
		return utils.MarshalJSON(u.DestinationChromaUpdateByProgrammingLanguage, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationChromaUpdateTextSplitter: all fields are null")
}

type DestinationChromaUpdateProcessingConfigModel struct {
	// Size of overlap between chunks in tokens to store in vector store to better capture relevant context
	ChunkOverlap *int64 `default:"0" json:"chunk_overlap"`
	// Size of chunks in tokens to store in vector store (make sure it is not too big for the context if your LLM)
	ChunkSize *int64 `json:"chunk_size,omitempty"`
	// List of fields to rename. Not applicable for nested fields, but can be used to rename fields already flattened via dot notation.
	FieldNameMappings []DestinationChromaUpdateFieldNameMappingConfigModel `json:"field_name_mappings,omitempty"`
	// List of fields in the record that should be stored as metadata. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered metadata fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array. When specifying nested paths, all matching values are flattened into an array set to a field named by the path.
	MetadataFields []string `json:"metadata_fields,omitempty"`
	// List of fields in the record that should be used to calculate the embedding. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered text fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array.
	TextFields []string `json:"text_fields,omitempty"`
	// Split text fields into chunks based on the specified method.
	TextSplitter *DestinationChromaUpdateTextSplitter `json:"text_splitter,omitempty"`
}

func (d DestinationChromaUpdateProcessingConfigModel) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationChromaUpdateProcessingConfigModel) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationChromaUpdateProcessingConfigModel) GetChunkOverlap() *int64 {
	if d == nil {
		return nil
	}
	return d.ChunkOverlap
}

func (d *DestinationChromaUpdateProcessingConfigModel) GetChunkSize() *int64 {
	if d == nil {
		return nil
	}
	return d.ChunkSize
}

func (d *DestinationChromaUpdateProcessingConfigModel) GetFieldNameMappings() []DestinationChromaUpdateFieldNameMappingConfigModel {
	if d == nil {
		return nil
	}
	return d.FieldNameMappings
}

func (d *DestinationChromaUpdateProcessingConfigModel) GetMetadataFields() []string {
	if d == nil {
		return nil
	}
	return d.MetadataFields
}

func (d *DestinationChromaUpdateProcessingConfigModel) GetTextFields() []string {
	if d == nil {
		return nil
	}
	return d.TextFields
}

func (d *DestinationChromaUpdateProcessingConfigModel) GetTextSplitter() *DestinationChromaUpdateTextSplitter {
	if d == nil {
		return nil
	}
	return d.TextSplitter
}

type DestinationChromaUpdateDestinationType string

const (
	DestinationChromaUpdateDestinationTypeChroma DestinationChromaUpdateDestinationType = "chroma"
)

func (e DestinationChromaUpdateDestinationType) ToPointer() *DestinationChromaUpdateDestinationType {
	return &e
}
func (e *DestinationChromaUpdateDestinationType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "chroma":
		*e = DestinationChromaUpdateDestinationType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationChromaUpdateDestinationType: %v", v)
	}
}

// DestinationChromaUpdate - The configuration model for the Vector DB based destinations. This model is used to generate the UI for the destination configuration, as well as to provide type safety for the configuration passed to the destination. The configuration model is composed of four parts: * Processing configuration * Embedding configuration * Indexing configuration * Advanced configuration Processing, embedding and advanced configuration are provided by this base class, while the indexing configuration is provided by the destination connector in the sub class.
type DestinationChromaUpdate struct {
	// Embedding configuration
	Embedding *DestinationChromaUpdateEmbedding `json:"embedding,omitempty"`
	// Indexing configuration
	Indexing *DestinationChromaUpdateIndexing `json:"indexing,omitempty"`
	// Do not store the text that gets embedded along with the vector and the metadata in the destination. If set to true, only the vector and the metadata will be stored - in this case raw text for LLM use cases needs to be retrieved from another source.
	OmitRawText     *bool                                         `default:"false" json:"omit_raw_text"`
	Processing      *DestinationChromaUpdateProcessingConfigModel `json:"processing,omitempty"`
	destinationType *DestinationChromaUpdateDestinationType       `const:"chroma" json:"destinationType"`
}

func (d DestinationChromaUpdate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationChromaUpdate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationChromaUpdate) GetEmbedding() *DestinationChromaUpdateEmbedding {
	if d == nil {
		return nil
	}
	return d.Embedding
}

func (d *DestinationChromaUpdate) GetIndexing() *DestinationChromaUpdateIndexing {
	if d == nil {
		return nil
	}
	return d.Indexing
}

func (d *DestinationChromaUpdate) GetOmitRawText() *bool {
	if d == nil {
		return nil
	}
	return d.OmitRawText
}

func (d *DestinationChromaUpdate) GetProcessing() *DestinationChromaUpdateProcessingConfigModel {
	if d == nil {
		return nil
	}
	return d.Processing
}

func (d *DestinationChromaUpdate) GetDestinationType() *DestinationChromaUpdateDestinationType {
	return DestinationChromaUpdateDestinationTypeChroma.ToPointer()
}
