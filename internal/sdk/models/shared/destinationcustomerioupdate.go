// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

// DestinationCustomerIoUpdateCredentials - Enter the site ID and API key to authenticate.
type DestinationCustomerIoUpdateCredentials struct {
	// Enter your Customer IO <a href="https://docs.customer.io/integrations/sdk/ios/getting-started/auth/#get-your-api-key">API Key</a>.
	APIKey *string `json:"apiKey,omitempty"`
	// Enter your Customer IO <a href="https://docs.customer.io/integrations/sdk/ios/getting-started/auth/#get-your-api-key">Site ID</a>.
	SiteID               *string `json:"siteId,omitempty"`
	AdditionalProperties any     `additionalProperties:"true" json:"-"`
}

func (d DestinationCustomerIoUpdateCredentials) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationCustomerIoUpdateCredentials) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationCustomerIoUpdateCredentials) GetAPIKey() *string {
	if d == nil {
		return nil
	}
	return d.APIKey
}

func (d *DestinationCustomerIoUpdateCredentials) GetSiteID() *string {
	if d == nil {
		return nil
	}
	return d.SiteID
}

func (d *DestinationCustomerIoUpdateCredentials) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationCustomerIoUpdateSchemasCompressionType string

const (
	DestinationCustomerIoUpdateSchemasCompressionTypeGzip DestinationCustomerIoUpdateSchemasCompressionType = "GZIP"
)

func (e DestinationCustomerIoUpdateSchemasCompressionType) ToPointer() *DestinationCustomerIoUpdateSchemasCompressionType {
	return &e
}
func (e *DestinationCustomerIoUpdateSchemasCompressionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "GZIP":
		*e = DestinationCustomerIoUpdateSchemasCompressionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationCustomerIoUpdateSchemasCompressionType: %v", v)
	}
}

type DestinationCustomerIoUpdateGZIP struct {
	CompressionType      *DestinationCustomerIoUpdateSchemasCompressionType `default:"GZIP" json:"compression_type"`
	AdditionalProperties any                                                `additionalProperties:"true" json:"-"`
}

func (d DestinationCustomerIoUpdateGZIP) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationCustomerIoUpdateGZIP) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationCustomerIoUpdateGZIP) GetCompressionType() *DestinationCustomerIoUpdateSchemasCompressionType {
	if d == nil {
		return nil
	}
	return d.CompressionType
}

func (d *DestinationCustomerIoUpdateGZIP) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationCustomerIoUpdateCompressionType string

const (
	DestinationCustomerIoUpdateCompressionTypeNoCompression DestinationCustomerIoUpdateCompressionType = "No Compression"
)

func (e DestinationCustomerIoUpdateCompressionType) ToPointer() *DestinationCustomerIoUpdateCompressionType {
	return &e
}
func (e *DestinationCustomerIoUpdateCompressionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "No Compression":
		*e = DestinationCustomerIoUpdateCompressionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationCustomerIoUpdateCompressionType: %v", v)
	}
}

type DestinationCustomerIoUpdateNoCompression struct {
	CompressionType      *DestinationCustomerIoUpdateCompressionType `default:"No Compression" json:"compression_type"`
	AdditionalProperties any                                         `additionalProperties:"true" json:"-"`
}

func (d DestinationCustomerIoUpdateNoCompression) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationCustomerIoUpdateNoCompression) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationCustomerIoUpdateNoCompression) GetCompressionType() *DestinationCustomerIoUpdateCompressionType {
	if d == nil {
		return nil
	}
	return d.CompressionType
}

func (d *DestinationCustomerIoUpdateNoCompression) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationCustomerIoUpdateCompressionUnionType string

const (
	DestinationCustomerIoUpdateCompressionUnionTypeDestinationCustomerIoUpdateNoCompression DestinationCustomerIoUpdateCompressionUnionType = "destination-customer-io-update_No Compression"
	DestinationCustomerIoUpdateCompressionUnionTypeDestinationCustomerIoUpdateGZIP          DestinationCustomerIoUpdateCompressionUnionType = "destination-customer-io-update_GZIP"
)

// DestinationCustomerIoUpdateCompression - Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").
type DestinationCustomerIoUpdateCompression struct {
	DestinationCustomerIoUpdateNoCompression *DestinationCustomerIoUpdateNoCompression `queryParam:"inline" union:"member"`
	DestinationCustomerIoUpdateGZIP          *DestinationCustomerIoUpdateGZIP          `queryParam:"inline" union:"member"`

	Type DestinationCustomerIoUpdateCompressionUnionType
}

func CreateDestinationCustomerIoUpdateCompressionDestinationCustomerIoUpdateNoCompression(destinationCustomerIoUpdateNoCompression DestinationCustomerIoUpdateNoCompression) DestinationCustomerIoUpdateCompression {
	typ := DestinationCustomerIoUpdateCompressionUnionTypeDestinationCustomerIoUpdateNoCompression

	return DestinationCustomerIoUpdateCompression{
		DestinationCustomerIoUpdateNoCompression: &destinationCustomerIoUpdateNoCompression,
		Type:                                     typ,
	}
}

func CreateDestinationCustomerIoUpdateCompressionDestinationCustomerIoUpdateGZIP(destinationCustomerIoUpdateGZIP DestinationCustomerIoUpdateGZIP) DestinationCustomerIoUpdateCompression {
	typ := DestinationCustomerIoUpdateCompressionUnionTypeDestinationCustomerIoUpdateGZIP

	return DestinationCustomerIoUpdateCompression{
		DestinationCustomerIoUpdateGZIP: &destinationCustomerIoUpdateGZIP,
		Type:                            typ,
	}
}

func (u *DestinationCustomerIoUpdateCompression) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var destinationCustomerIoUpdateNoCompression DestinationCustomerIoUpdateNoCompression = DestinationCustomerIoUpdateNoCompression{}
	if err := utils.UnmarshalJSON(data, &destinationCustomerIoUpdateNoCompression, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationCustomerIoUpdateCompressionUnionTypeDestinationCustomerIoUpdateNoCompression,
			Value: &destinationCustomerIoUpdateNoCompression,
		})
	}

	var destinationCustomerIoUpdateGZIP DestinationCustomerIoUpdateGZIP = DestinationCustomerIoUpdateGZIP{}
	if err := utils.UnmarshalJSON(data, &destinationCustomerIoUpdateGZIP, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationCustomerIoUpdateCompressionUnionTypeDestinationCustomerIoUpdateGZIP,
			Value: &destinationCustomerIoUpdateGZIP,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationCustomerIoUpdateCompression", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationCustomerIoUpdateCompression", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(DestinationCustomerIoUpdateCompressionUnionType)
	switch best.Type {
	case DestinationCustomerIoUpdateCompressionUnionTypeDestinationCustomerIoUpdateNoCompression:
		u.DestinationCustomerIoUpdateNoCompression = best.Value.(*DestinationCustomerIoUpdateNoCompression)
		return nil
	case DestinationCustomerIoUpdateCompressionUnionTypeDestinationCustomerIoUpdateGZIP:
		u.DestinationCustomerIoUpdateGZIP = best.Value.(*DestinationCustomerIoUpdateGZIP)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationCustomerIoUpdateCompression", string(data))
}

func (u DestinationCustomerIoUpdateCompression) MarshalJSON() ([]byte, error) {
	if u.DestinationCustomerIoUpdateNoCompression != nil {
		return utils.MarshalJSON(u.DestinationCustomerIoUpdateNoCompression, "", true)
	}

	if u.DestinationCustomerIoUpdateGZIP != nil {
		return utils.MarshalJSON(u.DestinationCustomerIoUpdateGZIP, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationCustomerIoUpdateCompression: all fields are null")
}

type DestinationCustomerIoUpdateSchemasFlattening string

const (
	DestinationCustomerIoUpdateSchemasFlatteningNoFlattening        DestinationCustomerIoUpdateSchemasFlattening = "No flattening"
	DestinationCustomerIoUpdateSchemasFlatteningRootLevelFlattening DestinationCustomerIoUpdateSchemasFlattening = "Root level flattening"
)

func (e DestinationCustomerIoUpdateSchemasFlattening) ToPointer() *DestinationCustomerIoUpdateSchemasFlattening {
	return &e
}
func (e *DestinationCustomerIoUpdateSchemasFlattening) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "No flattening":
		fallthrough
	case "Root level flattening":
		*e = DestinationCustomerIoUpdateSchemasFlattening(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationCustomerIoUpdateSchemasFlattening: %v", v)
	}
}

type DestinationCustomerIoUpdateSchemasFormatType string

const (
	DestinationCustomerIoUpdateSchemasFormatTypeJsonl DestinationCustomerIoUpdateSchemasFormatType = "JSONL"
)

func (e DestinationCustomerIoUpdateSchemasFormatType) ToPointer() *DestinationCustomerIoUpdateSchemasFormatType {
	return &e
}
func (e *DestinationCustomerIoUpdateSchemasFormatType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "JSONL":
		*e = DestinationCustomerIoUpdateSchemasFormatType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationCustomerIoUpdateSchemasFormatType: %v", v)
	}
}

type DestinationCustomerIoUpdateJSONLinesNewlineDelimitedJSON struct {
	Flattening           *DestinationCustomerIoUpdateSchemasFlattening `default:"No flattening" json:"flattening"`
	FormatType           *DestinationCustomerIoUpdateSchemasFormatType `default:"JSONL" json:"format_type"`
	AdditionalProperties any                                           `additionalProperties:"true" json:"-"`
}

func (d DestinationCustomerIoUpdateJSONLinesNewlineDelimitedJSON) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationCustomerIoUpdateJSONLinesNewlineDelimitedJSON) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationCustomerIoUpdateJSONLinesNewlineDelimitedJSON) GetFlattening() *DestinationCustomerIoUpdateSchemasFlattening {
	if d == nil {
		return nil
	}
	return d.Flattening
}

func (d *DestinationCustomerIoUpdateJSONLinesNewlineDelimitedJSON) GetFormatType() *DestinationCustomerIoUpdateSchemasFormatType {
	if d == nil {
		return nil
	}
	return d.FormatType
}

func (d *DestinationCustomerIoUpdateJSONLinesNewlineDelimitedJSON) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationCustomerIoUpdateFlattening string

const (
	DestinationCustomerIoUpdateFlatteningNoFlattening        DestinationCustomerIoUpdateFlattening = "No flattening"
	DestinationCustomerIoUpdateFlatteningRootLevelFlattening DestinationCustomerIoUpdateFlattening = "Root level flattening"
)

func (e DestinationCustomerIoUpdateFlattening) ToPointer() *DestinationCustomerIoUpdateFlattening {
	return &e
}
func (e *DestinationCustomerIoUpdateFlattening) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "No flattening":
		fallthrough
	case "Root level flattening":
		*e = DestinationCustomerIoUpdateFlattening(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationCustomerIoUpdateFlattening: %v", v)
	}
}

type DestinationCustomerIoUpdateFormatType string

const (
	DestinationCustomerIoUpdateFormatTypeCsv DestinationCustomerIoUpdateFormatType = "CSV"
)

func (e DestinationCustomerIoUpdateFormatType) ToPointer() *DestinationCustomerIoUpdateFormatType {
	return &e
}
func (e *DestinationCustomerIoUpdateFormatType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CSV":
		*e = DestinationCustomerIoUpdateFormatType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationCustomerIoUpdateFormatType: %v", v)
	}
}

type DestinationCustomerIoUpdateCSVCommaSeparatedValues struct {
	Flattening           *DestinationCustomerIoUpdateFlattening `default:"No flattening" json:"flattening"`
	FormatType           *DestinationCustomerIoUpdateFormatType `default:"CSV" json:"format_type"`
	AdditionalProperties any                                    `additionalProperties:"true" json:"-"`
}

func (d DestinationCustomerIoUpdateCSVCommaSeparatedValues) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationCustomerIoUpdateCSVCommaSeparatedValues) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationCustomerIoUpdateCSVCommaSeparatedValues) GetFlattening() *DestinationCustomerIoUpdateFlattening {
	if d == nil {
		return nil
	}
	return d.Flattening
}

func (d *DestinationCustomerIoUpdateCSVCommaSeparatedValues) GetFormatType() *DestinationCustomerIoUpdateFormatType {
	if d == nil {
		return nil
	}
	return d.FormatType
}

func (d *DestinationCustomerIoUpdateCSVCommaSeparatedValues) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationCustomerIoUpdateOutputFormatType string

const (
	DestinationCustomerIoUpdateOutputFormatTypeDestinationCustomerIoUpdateCSVCommaSeparatedValues       DestinationCustomerIoUpdateOutputFormatType = "destination-customer-io-update_CSV: Comma-Separated Values"
	DestinationCustomerIoUpdateOutputFormatTypeDestinationCustomerIoUpdateJSONLinesNewlineDelimitedJSON DestinationCustomerIoUpdateOutputFormatType = "destination-customer-io-update_JSON Lines: Newline-delimited JSON"
)

// DestinationCustomerIoUpdateOutputFormat - Format of the data output.
type DestinationCustomerIoUpdateOutputFormat struct {
	DestinationCustomerIoUpdateCSVCommaSeparatedValues       *DestinationCustomerIoUpdateCSVCommaSeparatedValues       `queryParam:"inline" union:"member"`
	DestinationCustomerIoUpdateJSONLinesNewlineDelimitedJSON *DestinationCustomerIoUpdateJSONLinesNewlineDelimitedJSON `queryParam:"inline" union:"member"`

	Type DestinationCustomerIoUpdateOutputFormatType
}

func CreateDestinationCustomerIoUpdateOutputFormatDestinationCustomerIoUpdateCSVCommaSeparatedValues(destinationCustomerIoUpdateCSVCommaSeparatedValues DestinationCustomerIoUpdateCSVCommaSeparatedValues) DestinationCustomerIoUpdateOutputFormat {
	typ := DestinationCustomerIoUpdateOutputFormatTypeDestinationCustomerIoUpdateCSVCommaSeparatedValues

	return DestinationCustomerIoUpdateOutputFormat{
		DestinationCustomerIoUpdateCSVCommaSeparatedValues: &destinationCustomerIoUpdateCSVCommaSeparatedValues,
		Type: typ,
	}
}

func CreateDestinationCustomerIoUpdateOutputFormatDestinationCustomerIoUpdateJSONLinesNewlineDelimitedJSON(destinationCustomerIoUpdateJSONLinesNewlineDelimitedJSON DestinationCustomerIoUpdateJSONLinesNewlineDelimitedJSON) DestinationCustomerIoUpdateOutputFormat {
	typ := DestinationCustomerIoUpdateOutputFormatTypeDestinationCustomerIoUpdateJSONLinesNewlineDelimitedJSON

	return DestinationCustomerIoUpdateOutputFormat{
		DestinationCustomerIoUpdateJSONLinesNewlineDelimitedJSON: &destinationCustomerIoUpdateJSONLinesNewlineDelimitedJSON,
		Type: typ,
	}
}

func (u *DestinationCustomerIoUpdateOutputFormat) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var destinationCustomerIoUpdateCSVCommaSeparatedValues DestinationCustomerIoUpdateCSVCommaSeparatedValues = DestinationCustomerIoUpdateCSVCommaSeparatedValues{}
	if err := utils.UnmarshalJSON(data, &destinationCustomerIoUpdateCSVCommaSeparatedValues, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationCustomerIoUpdateOutputFormatTypeDestinationCustomerIoUpdateCSVCommaSeparatedValues,
			Value: &destinationCustomerIoUpdateCSVCommaSeparatedValues,
		})
	}

	var destinationCustomerIoUpdateJSONLinesNewlineDelimitedJSON DestinationCustomerIoUpdateJSONLinesNewlineDelimitedJSON = DestinationCustomerIoUpdateJSONLinesNewlineDelimitedJSON{}
	if err := utils.UnmarshalJSON(data, &destinationCustomerIoUpdateJSONLinesNewlineDelimitedJSON, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationCustomerIoUpdateOutputFormatTypeDestinationCustomerIoUpdateJSONLinesNewlineDelimitedJSON,
			Value: &destinationCustomerIoUpdateJSONLinesNewlineDelimitedJSON,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationCustomerIoUpdateOutputFormat", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationCustomerIoUpdateOutputFormat", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(DestinationCustomerIoUpdateOutputFormatType)
	switch best.Type {
	case DestinationCustomerIoUpdateOutputFormatTypeDestinationCustomerIoUpdateCSVCommaSeparatedValues:
		u.DestinationCustomerIoUpdateCSVCommaSeparatedValues = best.Value.(*DestinationCustomerIoUpdateCSVCommaSeparatedValues)
		return nil
	case DestinationCustomerIoUpdateOutputFormatTypeDestinationCustomerIoUpdateJSONLinesNewlineDelimitedJSON:
		u.DestinationCustomerIoUpdateJSONLinesNewlineDelimitedJSON = best.Value.(*DestinationCustomerIoUpdateJSONLinesNewlineDelimitedJSON)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationCustomerIoUpdateOutputFormat", string(data))
}

func (u DestinationCustomerIoUpdateOutputFormat) MarshalJSON() ([]byte, error) {
	if u.DestinationCustomerIoUpdateCSVCommaSeparatedValues != nil {
		return utils.MarshalJSON(u.DestinationCustomerIoUpdateCSVCommaSeparatedValues, "", true)
	}

	if u.DestinationCustomerIoUpdateJSONLinesNewlineDelimitedJSON != nil {
		return utils.MarshalJSON(u.DestinationCustomerIoUpdateJSONLinesNewlineDelimitedJSON, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationCustomerIoUpdateOutputFormat: all fields are null")
}

// DestinationCustomerIoUpdateS3BucketRegion - The region of the S3 bucket. See <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-available-regions">here</a> for all region codes.
type DestinationCustomerIoUpdateS3BucketRegion string

const (
	DestinationCustomerIoUpdateS3BucketRegionUnknown      DestinationCustomerIoUpdateS3BucketRegion = ""
	DestinationCustomerIoUpdateS3BucketRegionAfSouth1     DestinationCustomerIoUpdateS3BucketRegion = "af-south-1"
	DestinationCustomerIoUpdateS3BucketRegionApEast1      DestinationCustomerIoUpdateS3BucketRegion = "ap-east-1"
	DestinationCustomerIoUpdateS3BucketRegionApNortheast1 DestinationCustomerIoUpdateS3BucketRegion = "ap-northeast-1"
	DestinationCustomerIoUpdateS3BucketRegionApNortheast2 DestinationCustomerIoUpdateS3BucketRegion = "ap-northeast-2"
	DestinationCustomerIoUpdateS3BucketRegionApNortheast3 DestinationCustomerIoUpdateS3BucketRegion = "ap-northeast-3"
	DestinationCustomerIoUpdateS3BucketRegionApSouth1     DestinationCustomerIoUpdateS3BucketRegion = "ap-south-1"
	DestinationCustomerIoUpdateS3BucketRegionApSouth2     DestinationCustomerIoUpdateS3BucketRegion = "ap-south-2"
	DestinationCustomerIoUpdateS3BucketRegionApSoutheast1 DestinationCustomerIoUpdateS3BucketRegion = "ap-southeast-1"
	DestinationCustomerIoUpdateS3BucketRegionApSoutheast2 DestinationCustomerIoUpdateS3BucketRegion = "ap-southeast-2"
	DestinationCustomerIoUpdateS3BucketRegionApSoutheast3 DestinationCustomerIoUpdateS3BucketRegion = "ap-southeast-3"
	DestinationCustomerIoUpdateS3BucketRegionApSoutheast4 DestinationCustomerIoUpdateS3BucketRegion = "ap-southeast-4"
	DestinationCustomerIoUpdateS3BucketRegionCaCentral1   DestinationCustomerIoUpdateS3BucketRegion = "ca-central-1"
	DestinationCustomerIoUpdateS3BucketRegionCaWest1      DestinationCustomerIoUpdateS3BucketRegion = "ca-west-1"
	DestinationCustomerIoUpdateS3BucketRegionCnNorth1     DestinationCustomerIoUpdateS3BucketRegion = "cn-north-1"
	DestinationCustomerIoUpdateS3BucketRegionCnNorthwest1 DestinationCustomerIoUpdateS3BucketRegion = "cn-northwest-1"
	DestinationCustomerIoUpdateS3BucketRegionEuCentral1   DestinationCustomerIoUpdateS3BucketRegion = "eu-central-1"
	DestinationCustomerIoUpdateS3BucketRegionEuCentral2   DestinationCustomerIoUpdateS3BucketRegion = "eu-central-2"
	DestinationCustomerIoUpdateS3BucketRegionEuNorth1     DestinationCustomerIoUpdateS3BucketRegion = "eu-north-1"
	DestinationCustomerIoUpdateS3BucketRegionEuSouth1     DestinationCustomerIoUpdateS3BucketRegion = "eu-south-1"
	DestinationCustomerIoUpdateS3BucketRegionEuSouth2     DestinationCustomerIoUpdateS3BucketRegion = "eu-south-2"
	DestinationCustomerIoUpdateS3BucketRegionEuWest1      DestinationCustomerIoUpdateS3BucketRegion = "eu-west-1"
	DestinationCustomerIoUpdateS3BucketRegionEuWest2      DestinationCustomerIoUpdateS3BucketRegion = "eu-west-2"
	DestinationCustomerIoUpdateS3BucketRegionEuWest3      DestinationCustomerIoUpdateS3BucketRegion = "eu-west-3"
	DestinationCustomerIoUpdateS3BucketRegionIlCentral1   DestinationCustomerIoUpdateS3BucketRegion = "il-central-1"
	DestinationCustomerIoUpdateS3BucketRegionMeCentral1   DestinationCustomerIoUpdateS3BucketRegion = "me-central-1"
	DestinationCustomerIoUpdateS3BucketRegionMeSouth1     DestinationCustomerIoUpdateS3BucketRegion = "me-south-1"
	DestinationCustomerIoUpdateS3BucketRegionSaEast1      DestinationCustomerIoUpdateS3BucketRegion = "sa-east-1"
	DestinationCustomerIoUpdateS3BucketRegionUsEast1      DestinationCustomerIoUpdateS3BucketRegion = "us-east-1"
	DestinationCustomerIoUpdateS3BucketRegionUsEast2      DestinationCustomerIoUpdateS3BucketRegion = "us-east-2"
	DestinationCustomerIoUpdateS3BucketRegionUsGovEast1   DestinationCustomerIoUpdateS3BucketRegion = "us-gov-east-1"
	DestinationCustomerIoUpdateS3BucketRegionUsGovWest1   DestinationCustomerIoUpdateS3BucketRegion = "us-gov-west-1"
	DestinationCustomerIoUpdateS3BucketRegionUsWest1      DestinationCustomerIoUpdateS3BucketRegion = "us-west-1"
	DestinationCustomerIoUpdateS3BucketRegionUsWest2      DestinationCustomerIoUpdateS3BucketRegion = "us-west-2"
)

func (e DestinationCustomerIoUpdateS3BucketRegion) ToPointer() *DestinationCustomerIoUpdateS3BucketRegion {
	return &e
}
func (e *DestinationCustomerIoUpdateS3BucketRegion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "":
		fallthrough
	case "af-south-1":
		fallthrough
	case "ap-east-1":
		fallthrough
	case "ap-northeast-1":
		fallthrough
	case "ap-northeast-2":
		fallthrough
	case "ap-northeast-3":
		fallthrough
	case "ap-south-1":
		fallthrough
	case "ap-south-2":
		fallthrough
	case "ap-southeast-1":
		fallthrough
	case "ap-southeast-2":
		fallthrough
	case "ap-southeast-3":
		fallthrough
	case "ap-southeast-4":
		fallthrough
	case "ca-central-1":
		fallthrough
	case "ca-west-1":
		fallthrough
	case "cn-north-1":
		fallthrough
	case "cn-northwest-1":
		fallthrough
	case "eu-central-1":
		fallthrough
	case "eu-central-2":
		fallthrough
	case "eu-north-1":
		fallthrough
	case "eu-south-1":
		fallthrough
	case "eu-south-2":
		fallthrough
	case "eu-west-1":
		fallthrough
	case "eu-west-2":
		fallthrough
	case "eu-west-3":
		fallthrough
	case "il-central-1":
		fallthrough
	case "me-central-1":
		fallthrough
	case "me-south-1":
		fallthrough
	case "sa-east-1":
		fallthrough
	case "us-east-1":
		fallthrough
	case "us-east-2":
		fallthrough
	case "us-gov-east-1":
		fallthrough
	case "us-gov-west-1":
		fallthrough
	case "us-west-1":
		fallthrough
	case "us-west-2":
		*e = DestinationCustomerIoUpdateS3BucketRegion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationCustomerIoUpdateS3BucketRegion: %v", v)
	}
}

type DestinationCustomerIoUpdateSchemasStorageType string

const (
	DestinationCustomerIoUpdateSchemasStorageTypeS3 DestinationCustomerIoUpdateSchemasStorageType = "S3"
)

func (e DestinationCustomerIoUpdateSchemasStorageType) ToPointer() *DestinationCustomerIoUpdateSchemasStorageType {
	return &e
}
func (e *DestinationCustomerIoUpdateSchemasStorageType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "S3":
		*e = DestinationCustomerIoUpdateSchemasStorageType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationCustomerIoUpdateSchemasStorageType: %v", v)
	}
}

type DestinationCustomerIoUpdateS3 struct {
	// The access key ID to access the S3 bucket. Airbyte requires Read and Write permissions to the given bucket. Read more <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">here</a>.
	AccessKeyID *string `json:"access_key_id,omitempty"`
	// All files in the bucket will be prefixed by this.
	BucketPath *string `json:"bucket_path,omitempty"`
	// Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").
	Compression    *DestinationCustomerIoUpdateCompression `json:"compression,omitempty"`
	FileNameFormat *string                                 `json:"file_name_format,omitempty"`
	// Format of the data output.
	Format     *DestinationCustomerIoUpdateOutputFormat `json:"format,omitempty"`
	PathFormat *string                                  `json:"path_format,omitempty"`
	// The ARN of the AWS role to assume. Only usable in Airbyte Cloud.
	RoleArn *string `json:"role_arn,omitempty"`
	// The name of the S3 bucket. Read more <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/create-bucket-overview.html">here</a>.
	S3BucketName *string `json:"s3_bucket_name,omitempty"`
	// The region of the S3 bucket. See <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-available-regions">here</a> for all region codes.
	S3BucketRegion *DestinationCustomerIoUpdateS3BucketRegion `default:"" json:"s3_bucket_region"`
	// Your S3 endpoint url. Read more <a href="https://docs.aws.amazon.com/general/latest/gr/s3.html#:~:text=Service%20endpoints-,Amazon%20S3%20endpoints,-When%20you%20use">here</a>
	S3Endpoint *string `json:"s3_endpoint,omitempty"`
	// The corresponding secret to the access key ID. Read more <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">here</a>
	SecretAccessKey      *string                                        `json:"secret_access_key,omitempty"`
	StorageType          *DestinationCustomerIoUpdateSchemasStorageType `default:"S3" json:"storage_type"`
	AdditionalProperties any                                            `additionalProperties:"true" json:"-"`
}

func (d DestinationCustomerIoUpdateS3) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationCustomerIoUpdateS3) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationCustomerIoUpdateS3) GetAccessKeyID() *string {
	if d == nil {
		return nil
	}
	return d.AccessKeyID
}

func (d *DestinationCustomerIoUpdateS3) GetBucketPath() *string {
	if d == nil {
		return nil
	}
	return d.BucketPath
}

func (d *DestinationCustomerIoUpdateS3) GetCompression() *DestinationCustomerIoUpdateCompression {
	if d == nil {
		return nil
	}
	return d.Compression
}

func (d *DestinationCustomerIoUpdateS3) GetFileNameFormat() *string {
	if d == nil {
		return nil
	}
	return d.FileNameFormat
}

func (d *DestinationCustomerIoUpdateS3) GetFormat() *DestinationCustomerIoUpdateOutputFormat {
	if d == nil {
		return nil
	}
	return d.Format
}

func (d *DestinationCustomerIoUpdateS3) GetPathFormat() *string {
	if d == nil {
		return nil
	}
	return d.PathFormat
}

func (d *DestinationCustomerIoUpdateS3) GetRoleArn() *string {
	if d == nil {
		return nil
	}
	return d.RoleArn
}

func (d *DestinationCustomerIoUpdateS3) GetS3BucketName() *string {
	if d == nil {
		return nil
	}
	return d.S3BucketName
}

func (d *DestinationCustomerIoUpdateS3) GetS3BucketRegion() *DestinationCustomerIoUpdateS3BucketRegion {
	if d == nil {
		return nil
	}
	return d.S3BucketRegion
}

func (d *DestinationCustomerIoUpdateS3) GetS3Endpoint() *string {
	if d == nil {
		return nil
	}
	return d.S3Endpoint
}

func (d *DestinationCustomerIoUpdateS3) GetSecretAccessKey() *string {
	if d == nil {
		return nil
	}
	return d.SecretAccessKey
}

func (d *DestinationCustomerIoUpdateS3) GetStorageType() *DestinationCustomerIoUpdateSchemasStorageType {
	if d == nil {
		return nil
	}
	return d.StorageType
}

func (d *DestinationCustomerIoUpdateS3) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationCustomerIoUpdateStorageType string

const (
	DestinationCustomerIoUpdateStorageTypeNone DestinationCustomerIoUpdateStorageType = "None"
)

func (e DestinationCustomerIoUpdateStorageType) ToPointer() *DestinationCustomerIoUpdateStorageType {
	return &e
}
func (e *DestinationCustomerIoUpdateStorageType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "None":
		*e = DestinationCustomerIoUpdateStorageType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationCustomerIoUpdateStorageType: %v", v)
	}
}

type DestinationCustomerIoUpdateNone struct {
	StorageType          *DestinationCustomerIoUpdateStorageType `default:"None" json:"storage_type"`
	AdditionalProperties any                                     `additionalProperties:"true" json:"-"`
}

func (d DestinationCustomerIoUpdateNone) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationCustomerIoUpdateNone) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationCustomerIoUpdateNone) GetStorageType() *DestinationCustomerIoUpdateStorageType {
	if d == nil {
		return nil
	}
	return d.StorageType
}

func (d *DestinationCustomerIoUpdateNone) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationCustomerIoUpdateObjectStorageSpecType string

const (
	DestinationCustomerIoUpdateObjectStorageSpecTypeDestinationCustomerIoUpdateNone DestinationCustomerIoUpdateObjectStorageSpecType = "destination-customer-io-update_None"
	DestinationCustomerIoUpdateObjectStorageSpecTypeDestinationCustomerIoUpdateS3   DestinationCustomerIoUpdateObjectStorageSpecType = "destination-customer-io-update_S3"
)

type DestinationCustomerIoUpdateObjectStorageSpec struct {
	DestinationCustomerIoUpdateNone *DestinationCustomerIoUpdateNone `queryParam:"inline" union:"member"`
	DestinationCustomerIoUpdateS3   *DestinationCustomerIoUpdateS3   `queryParam:"inline" union:"member"`

	Type DestinationCustomerIoUpdateObjectStorageSpecType
}

func CreateDestinationCustomerIoUpdateObjectStorageSpecDestinationCustomerIoUpdateNone(destinationCustomerIoUpdateNone DestinationCustomerIoUpdateNone) DestinationCustomerIoUpdateObjectStorageSpec {
	typ := DestinationCustomerIoUpdateObjectStorageSpecTypeDestinationCustomerIoUpdateNone

	return DestinationCustomerIoUpdateObjectStorageSpec{
		DestinationCustomerIoUpdateNone: &destinationCustomerIoUpdateNone,
		Type:                            typ,
	}
}

func CreateDestinationCustomerIoUpdateObjectStorageSpecDestinationCustomerIoUpdateS3(destinationCustomerIoUpdateS3 DestinationCustomerIoUpdateS3) DestinationCustomerIoUpdateObjectStorageSpec {
	typ := DestinationCustomerIoUpdateObjectStorageSpecTypeDestinationCustomerIoUpdateS3

	return DestinationCustomerIoUpdateObjectStorageSpec{
		DestinationCustomerIoUpdateS3: &destinationCustomerIoUpdateS3,
		Type:                          typ,
	}
}

func (u *DestinationCustomerIoUpdateObjectStorageSpec) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var destinationCustomerIoUpdateNone DestinationCustomerIoUpdateNone = DestinationCustomerIoUpdateNone{}
	if err := utils.UnmarshalJSON(data, &destinationCustomerIoUpdateNone, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationCustomerIoUpdateObjectStorageSpecTypeDestinationCustomerIoUpdateNone,
			Value: &destinationCustomerIoUpdateNone,
		})
	}

	var destinationCustomerIoUpdateS3 DestinationCustomerIoUpdateS3 = DestinationCustomerIoUpdateS3{}
	if err := utils.UnmarshalJSON(data, &destinationCustomerIoUpdateS3, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationCustomerIoUpdateObjectStorageSpecTypeDestinationCustomerIoUpdateS3,
			Value: &destinationCustomerIoUpdateS3,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationCustomerIoUpdateObjectStorageSpec", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationCustomerIoUpdateObjectStorageSpec", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(DestinationCustomerIoUpdateObjectStorageSpecType)
	switch best.Type {
	case DestinationCustomerIoUpdateObjectStorageSpecTypeDestinationCustomerIoUpdateNone:
		u.DestinationCustomerIoUpdateNone = best.Value.(*DestinationCustomerIoUpdateNone)
		return nil
	case DestinationCustomerIoUpdateObjectStorageSpecTypeDestinationCustomerIoUpdateS3:
		u.DestinationCustomerIoUpdateS3 = best.Value.(*DestinationCustomerIoUpdateS3)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationCustomerIoUpdateObjectStorageSpec", string(data))
}

func (u DestinationCustomerIoUpdateObjectStorageSpec) MarshalJSON() ([]byte, error) {
	if u.DestinationCustomerIoUpdateNone != nil {
		return utils.MarshalJSON(u.DestinationCustomerIoUpdateNone, "", true)
	}

	if u.DestinationCustomerIoUpdateS3 != nil {
		return utils.MarshalJSON(u.DestinationCustomerIoUpdateS3, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationCustomerIoUpdateObjectStorageSpec: all fields are null")
}

type DestinationCustomerIoUpdateDestinationType string

const (
	DestinationCustomerIoUpdateDestinationTypeCustomerIo DestinationCustomerIoUpdateDestinationType = "customer-io"
)

func (e DestinationCustomerIoUpdateDestinationType) ToPointer() *DestinationCustomerIoUpdateDestinationType {
	return &e
}
func (e *DestinationCustomerIoUpdateDestinationType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "customer-io":
		*e = DestinationCustomerIoUpdateDestinationType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationCustomerIoUpdateDestinationType: %v", v)
	}
}

type DestinationCustomerIoUpdate struct {
	// Enter the site ID and API key to authenticate.
	Credentials          *DestinationCustomerIoUpdateCredentials       `json:"credentials,omitempty"`
	ObjectStorageConfig  *DestinationCustomerIoUpdateObjectStorageSpec `json:"object_storage_config,omitempty"`
	destinationType      *DestinationCustomerIoUpdateDestinationType   `const:"customer-io" json:"destinationType"`
	AdditionalProperties any                                           `additionalProperties:"true" json:"-"`
}

func (d DestinationCustomerIoUpdate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationCustomerIoUpdate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationCustomerIoUpdate) GetCredentials() *DestinationCustomerIoUpdateCredentials {
	if d == nil {
		return nil
	}
	return d.Credentials
}

func (d *DestinationCustomerIoUpdate) GetObjectStorageConfig() *DestinationCustomerIoUpdateObjectStorageSpec {
	if d == nil {
		return nil
	}
	return d.ObjectStorageConfig
}

func (d *DestinationCustomerIoUpdate) GetDestinationType() *DestinationCustomerIoUpdateDestinationType {
	return DestinationCustomerIoUpdateDestinationTypeCustomerIo.ToPointer()
}

func (d *DestinationCustomerIoUpdate) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}
