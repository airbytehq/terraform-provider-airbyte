// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
	"time"
)

type SourceMailchimpAPIKey struct {
	// Mailchimp API Key. See the <a href="https://docs.airbyte.com/integrations/sources/mailchimp">docs</a> for information on how to generate this key.
	Apikey   string `json:"apikey"`
	authType string `const:"apikey" json:"auth_type"`
}

func (s SourceMailchimpAPIKey) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMailchimpAPIKey) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceMailchimpAPIKey) GetApikey() string {
	if s == nil {
		return ""
	}
	return s.Apikey
}

func (s *SourceMailchimpAPIKey) GetAuthType() string {
	return "apikey"
}

type SourceMailchimpOAuth20 struct {
	// An access token generated using the above client ID and secret.
	AccessToken string `json:"access_token"`
	authType    string `const:"oauth2.0" json:"auth_type"`
	// The Client ID of your OAuth application.
	ClientID *string `json:"client_id,omitempty"`
	// The Client Secret of your OAuth application.
	ClientSecret *string `json:"client_secret,omitempty"`
}

func (s SourceMailchimpOAuth20) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMailchimpOAuth20) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceMailchimpOAuth20) GetAccessToken() string {
	if s == nil {
		return ""
	}
	return s.AccessToken
}

func (s *SourceMailchimpOAuth20) GetAuthType() string {
	return "oauth2.0"
}

func (s *SourceMailchimpOAuth20) GetClientID() *string {
	if s == nil {
		return nil
	}
	return s.ClientID
}

func (s *SourceMailchimpOAuth20) GetClientSecret() *string {
	if s == nil {
		return nil
	}
	return s.ClientSecret
}

type SourceMailchimpAuthenticationType string

const (
	SourceMailchimpAuthenticationTypeSourceMailchimpOAuth20 SourceMailchimpAuthenticationType = "source-mailchimp_OAuth2.0"
	SourceMailchimpAuthenticationTypeSourceMailchimpAPIKey  SourceMailchimpAuthenticationType = "source-mailchimp_API Key"
)

type SourceMailchimpAuthentication struct {
	SourceMailchimpOAuth20 *SourceMailchimpOAuth20 `queryParam:"inline" union:"member"`
	SourceMailchimpAPIKey  *SourceMailchimpAPIKey  `queryParam:"inline" union:"member"`

	Type SourceMailchimpAuthenticationType
}

func CreateSourceMailchimpAuthenticationSourceMailchimpOAuth20(sourceMailchimpOAuth20 SourceMailchimpOAuth20) SourceMailchimpAuthentication {
	typ := SourceMailchimpAuthenticationTypeSourceMailchimpOAuth20

	return SourceMailchimpAuthentication{
		SourceMailchimpOAuth20: &sourceMailchimpOAuth20,
		Type:                   typ,
	}
}

func CreateSourceMailchimpAuthenticationSourceMailchimpAPIKey(sourceMailchimpAPIKey SourceMailchimpAPIKey) SourceMailchimpAuthentication {
	typ := SourceMailchimpAuthenticationTypeSourceMailchimpAPIKey

	return SourceMailchimpAuthentication{
		SourceMailchimpAPIKey: &sourceMailchimpAPIKey,
		Type:                  typ,
	}
}

func (u *SourceMailchimpAuthentication) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var sourceMailchimpOAuth20 SourceMailchimpOAuth20 = SourceMailchimpOAuth20{}
	if err := utils.UnmarshalJSON(data, &sourceMailchimpOAuth20, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceMailchimpAuthenticationTypeSourceMailchimpOAuth20,
			Value: &sourceMailchimpOAuth20,
		})
	}

	var sourceMailchimpAPIKey SourceMailchimpAPIKey = SourceMailchimpAPIKey{}
	if err := utils.UnmarshalJSON(data, &sourceMailchimpAPIKey, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceMailchimpAuthenticationTypeSourceMailchimpAPIKey,
			Value: &sourceMailchimpAPIKey,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMailchimpAuthentication", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMailchimpAuthentication", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceMailchimpAuthenticationType)
	switch best.Type {
	case SourceMailchimpAuthenticationTypeSourceMailchimpOAuth20:
		u.SourceMailchimpOAuth20 = best.Value.(*SourceMailchimpOAuth20)
		return nil
	case SourceMailchimpAuthenticationTypeSourceMailchimpAPIKey:
		u.SourceMailchimpAPIKey = best.Value.(*SourceMailchimpAPIKey)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMailchimpAuthentication", string(data))
}

func (u SourceMailchimpAuthentication) MarshalJSON() ([]byte, error) {
	if u.SourceMailchimpOAuth20 != nil {
		return utils.MarshalJSON(u.SourceMailchimpOAuth20, "", true)
	}

	if u.SourceMailchimpAPIKey != nil {
		return utils.MarshalJSON(u.SourceMailchimpAPIKey, "", true)
	}

	return nil, errors.New("could not marshal union type SourceMailchimpAuthentication: all fields are null")
}

type SourceMailchimpSourceType string

const (
	SourceMailchimpSourceTypeMailchimp SourceMailchimpSourceType = "mailchimp"
)

func (e SourceMailchimpSourceType) ToPointer() *SourceMailchimpSourceType {
	return &e
}
func (e *SourceMailchimpSourceType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "mailchimp":
		*e = SourceMailchimpSourceType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMailchimpSourceType: %v", v)
	}
}

type SourceMailchimp struct {
	Credentials *SourceMailchimpAuthentication `json:"credentials,omitempty"`
	// Technical fields used to identify datacenter to send request to
	DataCenter *string `json:"data_center,omitempty"`
	// The date from which you want to start syncing data for Incremental streams. Only records that have been created or modified since this date will be synced. If left blank, all data will by synced.
	StartDate            *time.Time                 `json:"start_date,omitempty"`
	sourceType           *SourceMailchimpSourceType `const:"mailchimp" json:"sourceType"`
	AdditionalProperties any                        `additionalProperties:"true" json:"-"`
}

func (s SourceMailchimp) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMailchimp) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceMailchimp) GetCredentials() *SourceMailchimpAuthentication {
	if s == nil {
		return nil
	}
	return s.Credentials
}

func (s *SourceMailchimp) GetDataCenter() *string {
	if s == nil {
		return nil
	}
	return s.DataCenter
}

func (s *SourceMailchimp) GetStartDate() *time.Time {
	if s == nil {
		return nil
	}
	return s.StartDate
}

func (s *SourceMailchimp) GetSourceType() *SourceMailchimpSourceType {
	return SourceMailchimpSourceTypeMailchimp.ToPointer()
}

func (s *SourceMailchimp) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}
