// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/types"
)

// DestinationElasticsearchUpdateUsernamePassword - Basic auth header with a username and password
type DestinationElasticsearchUpdateUsernamePassword struct {
	method *string `const:"basic" json:"method,omitempty"`
	// Basic auth password to access a secure Elasticsearch server
	Password *string `json:"password,omitempty"`
	// Basic auth username to access a secure Elasticsearch server
	Username *string `json:"username,omitempty"`
}

func (d DestinationElasticsearchUpdateUsernamePassword) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationElasticsearchUpdateUsernamePassword) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationElasticsearchUpdateUsernamePassword) GetMethod() *string {
	return types.Pointer("basic")
}

func (d *DestinationElasticsearchUpdateUsernamePassword) GetPassword() *string {
	if d == nil {
		return nil
	}
	return d.Password
}

func (d *DestinationElasticsearchUpdateUsernamePassword) GetUsername() *string {
	if d == nil {
		return nil
	}
	return d.Username
}

// DestinationElasticsearchUpdateAPIKeySecret - Use a api key and secret combination to authenticate
type DestinationElasticsearchUpdateAPIKeySecret struct {
	// The Key ID to used when accessing an enterprise Elasticsearch instance.
	APIKeyID *string `json:"apiKeyId,omitempty"`
	// The secret associated with the API Key ID.
	APIKeySecret *string `json:"apiKeySecret,omitempty"`
	method       *string `const:"secret" json:"method,omitempty"`
}

func (d DestinationElasticsearchUpdateAPIKeySecret) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationElasticsearchUpdateAPIKeySecret) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationElasticsearchUpdateAPIKeySecret) GetAPIKeyID() *string {
	if d == nil {
		return nil
	}
	return d.APIKeyID
}

func (d *DestinationElasticsearchUpdateAPIKeySecret) GetAPIKeySecret() *string {
	if d == nil {
		return nil
	}
	return d.APIKeySecret
}

func (d *DestinationElasticsearchUpdateAPIKeySecret) GetMethod() *string {
	return types.Pointer("secret")
}

type DestinationElasticsearchUpdateAuthenticationMethodType string

const (
	DestinationElasticsearchUpdateAuthenticationMethodTypeDestinationElasticsearchUpdateAPIKeySecret     DestinationElasticsearchUpdateAuthenticationMethodType = "destination-elasticsearch-update_Api Key/Secret"
	DestinationElasticsearchUpdateAuthenticationMethodTypeDestinationElasticsearchUpdateUsernamePassword DestinationElasticsearchUpdateAuthenticationMethodType = "destination-elasticsearch-update_Username/Password"
)

// DestinationElasticsearchUpdateAuthenticationMethod - The type of authentication to be used
type DestinationElasticsearchUpdateAuthenticationMethod struct {
	DestinationElasticsearchUpdateAPIKeySecret     *DestinationElasticsearchUpdateAPIKeySecret     `queryParam:"inline" union:"member"`
	DestinationElasticsearchUpdateUsernamePassword *DestinationElasticsearchUpdateUsernamePassword `queryParam:"inline" union:"member"`

	Type DestinationElasticsearchUpdateAuthenticationMethodType
}

func CreateDestinationElasticsearchUpdateAuthenticationMethodDestinationElasticsearchUpdateAPIKeySecret(destinationElasticsearchUpdateAPIKeySecret DestinationElasticsearchUpdateAPIKeySecret) DestinationElasticsearchUpdateAuthenticationMethod {
	typ := DestinationElasticsearchUpdateAuthenticationMethodTypeDestinationElasticsearchUpdateAPIKeySecret

	return DestinationElasticsearchUpdateAuthenticationMethod{
		DestinationElasticsearchUpdateAPIKeySecret: &destinationElasticsearchUpdateAPIKeySecret,
		Type: typ,
	}
}

func CreateDestinationElasticsearchUpdateAuthenticationMethodDestinationElasticsearchUpdateUsernamePassword(destinationElasticsearchUpdateUsernamePassword DestinationElasticsearchUpdateUsernamePassword) DestinationElasticsearchUpdateAuthenticationMethod {
	typ := DestinationElasticsearchUpdateAuthenticationMethodTypeDestinationElasticsearchUpdateUsernamePassword

	return DestinationElasticsearchUpdateAuthenticationMethod{
		DestinationElasticsearchUpdateUsernamePassword: &destinationElasticsearchUpdateUsernamePassword,
		Type: typ,
	}
}

func (u *DestinationElasticsearchUpdateAuthenticationMethod) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var destinationElasticsearchUpdateAPIKeySecret DestinationElasticsearchUpdateAPIKeySecret = DestinationElasticsearchUpdateAPIKeySecret{}
	if err := utils.UnmarshalJSON(data, &destinationElasticsearchUpdateAPIKeySecret, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationElasticsearchUpdateAuthenticationMethodTypeDestinationElasticsearchUpdateAPIKeySecret,
			Value: &destinationElasticsearchUpdateAPIKeySecret,
		})
	}

	var destinationElasticsearchUpdateUsernamePassword DestinationElasticsearchUpdateUsernamePassword = DestinationElasticsearchUpdateUsernamePassword{}
	if err := utils.UnmarshalJSON(data, &destinationElasticsearchUpdateUsernamePassword, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationElasticsearchUpdateAuthenticationMethodTypeDestinationElasticsearchUpdateUsernamePassword,
			Value: &destinationElasticsearchUpdateUsernamePassword,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationElasticsearchUpdateAuthenticationMethod", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationElasticsearchUpdateAuthenticationMethod", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(DestinationElasticsearchUpdateAuthenticationMethodType)
	switch best.Type {
	case DestinationElasticsearchUpdateAuthenticationMethodTypeDestinationElasticsearchUpdateAPIKeySecret:
		u.DestinationElasticsearchUpdateAPIKeySecret = best.Value.(*DestinationElasticsearchUpdateAPIKeySecret)
		return nil
	case DestinationElasticsearchUpdateAuthenticationMethodTypeDestinationElasticsearchUpdateUsernamePassword:
		u.DestinationElasticsearchUpdateUsernamePassword = best.Value.(*DestinationElasticsearchUpdateUsernamePassword)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationElasticsearchUpdateAuthenticationMethod", string(data))
}

func (u DestinationElasticsearchUpdateAuthenticationMethod) MarshalJSON() ([]byte, error) {
	if u.DestinationElasticsearchUpdateAPIKeySecret != nil {
		return utils.MarshalJSON(u.DestinationElasticsearchUpdateAPIKeySecret, "", true)
	}

	if u.DestinationElasticsearchUpdateUsernamePassword != nil {
		return utils.MarshalJSON(u.DestinationElasticsearchUpdateUsernamePassword, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationElasticsearchUpdateAuthenticationMethod: all fields are null")
}

type DestinationElasticsearchUpdateDestinationType string

const (
	DestinationElasticsearchUpdateDestinationTypeElasticsearch DestinationElasticsearchUpdateDestinationType = "elasticsearch"
)

func (e DestinationElasticsearchUpdateDestinationType) ToPointer() *DestinationElasticsearchUpdateDestinationType {
	return &e
}
func (e *DestinationElasticsearchUpdateDestinationType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "elasticsearch":
		*e = DestinationElasticsearchUpdateDestinationType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationElasticsearchUpdateDestinationType: %v", v)
	}
}

type DestinationElasticsearchUpdate struct {
	// The type of authentication to be used
	AuthenticationMethod *DestinationElasticsearchUpdateAuthenticationMethod `json:"authenticationMethod,omitempty"`
	// CA certificate
	CaCertificate *string `json:"ca_certificate,omitempty"`
	// The full url of the Elasticsearch server
	Endpoint *string `json:"endpoint,omitempty"`
	// If a primary key identifier is defined in the source, an upsert will be performed using the primary key value as the elasticsearch doc id. Does not support composite primary keys.
	Upsert          *bool                                          `default:"true" json:"upsert"`
	destinationType *DestinationElasticsearchUpdateDestinationType `const:"elasticsearch" json:"destinationType"`
}

func (d DestinationElasticsearchUpdate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationElasticsearchUpdate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationElasticsearchUpdate) GetAuthenticationMethod() *DestinationElasticsearchUpdateAuthenticationMethod {
	if d == nil {
		return nil
	}
	return d.AuthenticationMethod
}

func (d *DestinationElasticsearchUpdate) GetCaCertificate() *string {
	if d == nil {
		return nil
	}
	return d.CaCertificate
}

func (d *DestinationElasticsearchUpdate) GetEndpoint() *string {
	if d == nil {
		return nil
	}
	return d.Endpoint
}

func (d *DestinationElasticsearchUpdate) GetUpsert() *bool {
	if d == nil {
		return nil
	}
	return d.Upsert
}

func (d *DestinationElasticsearchUpdate) GetDestinationType() *DestinationElasticsearchUpdateDestinationType {
	return DestinationElasticsearchUpdateDestinationTypeElasticsearch.ToPointer()
}
