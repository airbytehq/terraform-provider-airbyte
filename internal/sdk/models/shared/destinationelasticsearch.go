// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

// DestinationElasticsearchUsernamePassword - Basic auth header with a username and password
type DestinationElasticsearchUsernamePassword struct {
	method string `const:"basic" json:"method"`
	// Basic auth password to access a secure Elasticsearch server
	Password string `json:"password"`
	// Basic auth username to access a secure Elasticsearch server
	Username string `json:"username"`
}

func (d DestinationElasticsearchUsernamePassword) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationElasticsearchUsernamePassword) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationElasticsearchUsernamePassword) GetMethod() string {
	return "basic"
}

func (d *DestinationElasticsearchUsernamePassword) GetPassword() string {
	if d == nil {
		return ""
	}
	return d.Password
}

func (d *DestinationElasticsearchUsernamePassword) GetUsername() string {
	if d == nil {
		return ""
	}
	return d.Username
}

// APIKeySecret - Use a api key and secret combination to authenticate
type APIKeySecret struct {
	// The Key ID to used when accessing an enterprise Elasticsearch instance.
	APIKeyID string `json:"apiKeyId"`
	// The secret associated with the API Key ID.
	APIKeySecret string `json:"apiKeySecret"`
	method       string `const:"secret" json:"method"`
}

func (a APIKeySecret) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *APIKeySecret) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (a *APIKeySecret) GetAPIKeyID() string {
	if a == nil {
		return ""
	}
	return a.APIKeyID
}

func (a *APIKeySecret) GetAPIKeySecret() string {
	if a == nil {
		return ""
	}
	return a.APIKeySecret
}

func (a *APIKeySecret) GetMethod() string {
	return "secret"
}

type DestinationElasticsearchAuthenticationMethodType string

const (
	DestinationElasticsearchAuthenticationMethodTypeAPIKeySecret                             DestinationElasticsearchAuthenticationMethodType = "Api Key/Secret"
	DestinationElasticsearchAuthenticationMethodTypeDestinationElasticsearchUsernamePassword DestinationElasticsearchAuthenticationMethodType = "destination-elasticsearch_Username/Password"
)

// DestinationElasticsearchAuthenticationMethod - The type of authentication to be used
type DestinationElasticsearchAuthenticationMethod struct {
	APIKeySecret                             *APIKeySecret                             `queryParam:"inline" union:"member"`
	DestinationElasticsearchUsernamePassword *DestinationElasticsearchUsernamePassword `queryParam:"inline" union:"member"`

	Type DestinationElasticsearchAuthenticationMethodType
}

func CreateDestinationElasticsearchAuthenticationMethodAPIKeySecret(apiKeySecret APIKeySecret) DestinationElasticsearchAuthenticationMethod {
	typ := DestinationElasticsearchAuthenticationMethodTypeAPIKeySecret

	return DestinationElasticsearchAuthenticationMethod{
		APIKeySecret: &apiKeySecret,
		Type:         typ,
	}
}

func CreateDestinationElasticsearchAuthenticationMethodDestinationElasticsearchUsernamePassword(destinationElasticsearchUsernamePassword DestinationElasticsearchUsernamePassword) DestinationElasticsearchAuthenticationMethod {
	typ := DestinationElasticsearchAuthenticationMethodTypeDestinationElasticsearchUsernamePassword

	return DestinationElasticsearchAuthenticationMethod{
		DestinationElasticsearchUsernamePassword: &destinationElasticsearchUsernamePassword,
		Type:                                     typ,
	}
}

func (u *DestinationElasticsearchAuthenticationMethod) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var apiKeySecret APIKeySecret = APIKeySecret{}
	if err := utils.UnmarshalJSON(data, &apiKeySecret, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationElasticsearchAuthenticationMethodTypeAPIKeySecret,
			Value: &apiKeySecret,
		})
	}

	var destinationElasticsearchUsernamePassword DestinationElasticsearchUsernamePassword = DestinationElasticsearchUsernamePassword{}
	if err := utils.UnmarshalJSON(data, &destinationElasticsearchUsernamePassword, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationElasticsearchAuthenticationMethodTypeDestinationElasticsearchUsernamePassword,
			Value: &destinationElasticsearchUsernamePassword,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationElasticsearchAuthenticationMethod", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationElasticsearchAuthenticationMethod", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(DestinationElasticsearchAuthenticationMethodType)
	switch best.Type {
	case DestinationElasticsearchAuthenticationMethodTypeAPIKeySecret:
		u.APIKeySecret = best.Value.(*APIKeySecret)
		return nil
	case DestinationElasticsearchAuthenticationMethodTypeDestinationElasticsearchUsernamePassword:
		u.DestinationElasticsearchUsernamePassword = best.Value.(*DestinationElasticsearchUsernamePassword)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationElasticsearchAuthenticationMethod", string(data))
}

func (u DestinationElasticsearchAuthenticationMethod) MarshalJSON() ([]byte, error) {
	if u.APIKeySecret != nil {
		return utils.MarshalJSON(u.APIKeySecret, "", true)
	}

	if u.DestinationElasticsearchUsernamePassword != nil {
		return utils.MarshalJSON(u.DestinationElasticsearchUsernamePassword, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationElasticsearchAuthenticationMethod: all fields are null")
}

type DestinationElasticsearchDestinationType string

const (
	DestinationElasticsearchDestinationTypeElasticsearch DestinationElasticsearchDestinationType = "elasticsearch"
)

func (e DestinationElasticsearchDestinationType) ToPointer() *DestinationElasticsearchDestinationType {
	return &e
}
func (e *DestinationElasticsearchDestinationType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "elasticsearch":
		*e = DestinationElasticsearchDestinationType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationElasticsearchDestinationType: %v", v)
	}
}

type DestinationElasticsearch struct {
	// The type of authentication to be used
	AuthenticationMethod *DestinationElasticsearchAuthenticationMethod `json:"authenticationMethod,omitempty"`
	// CA certificate
	CaCertificate *string `json:"ca_certificate,omitempty"`
	// The full url of the Elasticsearch server
	Endpoint string `json:"endpoint"`
	// If a primary key identifier is defined in the source, an upsert will be performed using the primary key value as the elasticsearch doc id. Does not support composite primary keys.
	Upsert          *bool                                    `default:"true" json:"upsert"`
	destinationType *DestinationElasticsearchDestinationType `const:"elasticsearch" json:"destinationType"`
}

func (d DestinationElasticsearch) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationElasticsearch) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationElasticsearch) GetAuthenticationMethod() *DestinationElasticsearchAuthenticationMethod {
	if d == nil {
		return nil
	}
	return d.AuthenticationMethod
}

func (d *DestinationElasticsearch) GetCaCertificate() *string {
	if d == nil {
		return nil
	}
	return d.CaCertificate
}

func (d *DestinationElasticsearch) GetEndpoint() string {
	if d == nil {
		return ""
	}
	return d.Endpoint
}

func (d *DestinationElasticsearch) GetUpsert() *bool {
	if d == nil {
		return nil
	}
	return d.Upsert
}

func (d *DestinationElasticsearch) GetDestinationType() *DestinationElasticsearchDestinationType {
	return DestinationElasticsearchDestinationTypeElasticsearch.ToPointer()
}
