// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/types"
	"time"
)

type SourceAirtableUpdatePersonalAccessToken struct {
	// The Personal Access Token for the Airtable account. See the <a href="https://airtable.com/developers/web/guides/personal-access-tokens">Support Guide</a> for more information on how to obtain this token.
	APIKey     *string `json:"api_key,omitempty"`
	authMethod *string `const:"api_key" json:"auth_method,omitempty"`
}

func (s SourceAirtableUpdatePersonalAccessToken) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceAirtableUpdatePersonalAccessToken) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceAirtableUpdatePersonalAccessToken) GetAPIKey() *string {
	if s == nil {
		return nil
	}
	return s.APIKey
}

func (s *SourceAirtableUpdatePersonalAccessToken) GetAuthMethod() *string {
	return types.Pointer("api_key")
}

type SourceAirtableUpdateOAuth20 struct {
	// Access Token for making authenticated requests.
	AccessToken *string `json:"access_token,omitempty"`
	authMethod  *string `const:"oauth2.0" json:"auth_method,omitempty"`
	// The client ID of the Airtable developer application.
	ClientID *string `json:"client_id,omitempty"`
	// The client secret of the Airtable developer application.
	ClientSecret *string `json:"client_secret,omitempty"`
	// The key to refresh the expired access token.
	RefreshToken *string `json:"refresh_token,omitempty"`
	// The date-time when the access token should be refreshed.
	TokenExpiryDate *time.Time `json:"token_expiry_date,omitempty"`
}

func (s SourceAirtableUpdateOAuth20) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceAirtableUpdateOAuth20) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceAirtableUpdateOAuth20) GetAccessToken() *string {
	if s == nil {
		return nil
	}
	return s.AccessToken
}

func (s *SourceAirtableUpdateOAuth20) GetAuthMethod() *string {
	return types.Pointer("oauth2.0")
}

func (s *SourceAirtableUpdateOAuth20) GetClientID() *string {
	if s == nil {
		return nil
	}
	return s.ClientID
}

func (s *SourceAirtableUpdateOAuth20) GetClientSecret() *string {
	if s == nil {
		return nil
	}
	return s.ClientSecret
}

func (s *SourceAirtableUpdateOAuth20) GetRefreshToken() *string {
	if s == nil {
		return nil
	}
	return s.RefreshToken
}

func (s *SourceAirtableUpdateOAuth20) GetTokenExpiryDate() *time.Time {
	if s == nil {
		return nil
	}
	return s.TokenExpiryDate
}

type SourceAirtableUpdateAuthenticationType string

const (
	SourceAirtableUpdateAuthenticationTypeSourceAirtableUpdateOAuth20             SourceAirtableUpdateAuthenticationType = "source-airtable-update_OAuth2.0"
	SourceAirtableUpdateAuthenticationTypeSourceAirtableUpdatePersonalAccessToken SourceAirtableUpdateAuthenticationType = "source-airtable-update_Personal Access Token"
)

type SourceAirtableUpdateAuthentication struct {
	SourceAirtableUpdateOAuth20             *SourceAirtableUpdateOAuth20             `queryParam:"inline" union:"member"`
	SourceAirtableUpdatePersonalAccessToken *SourceAirtableUpdatePersonalAccessToken `queryParam:"inline" union:"member"`

	Type SourceAirtableUpdateAuthenticationType
}

func CreateSourceAirtableUpdateAuthenticationSourceAirtableUpdateOAuth20(sourceAirtableUpdateOAuth20 SourceAirtableUpdateOAuth20) SourceAirtableUpdateAuthentication {
	typ := SourceAirtableUpdateAuthenticationTypeSourceAirtableUpdateOAuth20

	return SourceAirtableUpdateAuthentication{
		SourceAirtableUpdateOAuth20: &sourceAirtableUpdateOAuth20,
		Type:                        typ,
	}
}

func CreateSourceAirtableUpdateAuthenticationSourceAirtableUpdatePersonalAccessToken(sourceAirtableUpdatePersonalAccessToken SourceAirtableUpdatePersonalAccessToken) SourceAirtableUpdateAuthentication {
	typ := SourceAirtableUpdateAuthenticationTypeSourceAirtableUpdatePersonalAccessToken

	return SourceAirtableUpdateAuthentication{
		SourceAirtableUpdatePersonalAccessToken: &sourceAirtableUpdatePersonalAccessToken,
		Type:                                    typ,
	}
}

func (u *SourceAirtableUpdateAuthentication) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var sourceAirtableUpdateOAuth20 SourceAirtableUpdateOAuth20 = SourceAirtableUpdateOAuth20{}
	if err := utils.UnmarshalJSON(data, &sourceAirtableUpdateOAuth20, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceAirtableUpdateAuthenticationTypeSourceAirtableUpdateOAuth20,
			Value: &sourceAirtableUpdateOAuth20,
		})
	}

	var sourceAirtableUpdatePersonalAccessToken SourceAirtableUpdatePersonalAccessToken = SourceAirtableUpdatePersonalAccessToken{}
	if err := utils.UnmarshalJSON(data, &sourceAirtableUpdatePersonalAccessToken, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceAirtableUpdateAuthenticationTypeSourceAirtableUpdatePersonalAccessToken,
			Value: &sourceAirtableUpdatePersonalAccessToken,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceAirtableUpdateAuthentication", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceAirtableUpdateAuthentication", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceAirtableUpdateAuthenticationType)
	switch best.Type {
	case SourceAirtableUpdateAuthenticationTypeSourceAirtableUpdateOAuth20:
		u.SourceAirtableUpdateOAuth20 = best.Value.(*SourceAirtableUpdateOAuth20)
		return nil
	case SourceAirtableUpdateAuthenticationTypeSourceAirtableUpdatePersonalAccessToken:
		u.SourceAirtableUpdatePersonalAccessToken = best.Value.(*SourceAirtableUpdatePersonalAccessToken)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceAirtableUpdateAuthentication", string(data))
}

func (u SourceAirtableUpdateAuthentication) MarshalJSON() ([]byte, error) {
	if u.SourceAirtableUpdateOAuth20 != nil {
		return utils.MarshalJSON(u.SourceAirtableUpdateOAuth20, "", true)
	}

	if u.SourceAirtableUpdatePersonalAccessToken != nil {
		return utils.MarshalJSON(u.SourceAirtableUpdatePersonalAccessToken, "", true)
	}

	return nil, errors.New("could not marshal union type SourceAirtableUpdateAuthentication: all fields are null")
}

type SourceAirtableUpdateSourceType string

const (
	SourceAirtableUpdateSourceTypeAirtable SourceAirtableUpdateSourceType = "airtable"
)

func (e SourceAirtableUpdateSourceType) ToPointer() *SourceAirtableUpdateSourceType {
	return &e
}
func (e *SourceAirtableUpdateSourceType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "airtable":
		*e = SourceAirtableUpdateSourceType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceAirtableUpdateSourceType: %v", v)
	}
}

type SourceAirtableUpdate struct {
	// When enabled, includes the base ID in stream names to ensure uniqueness. Use this if you have cloned Airtable bases with duplicate table names. Note that enabling this will change stream names and require a full refresh.
	AddBaseIDToStreamName *bool                               `default:"false" json:"add_base_id_to_stream_name"`
	Credentials           *SourceAirtableUpdateAuthentication `json:"credentials,omitempty"`
	// Number of concurrent threads for syncing. Higher values can speed up syncs but may hit rate limits. Airtable limits to 5 requests per second per base.
	NumWorkers           *int64                          `default:"5" json:"num_workers"`
	sourceType           *SourceAirtableUpdateSourceType `const:"airtable" json:"sourceType"`
	AdditionalProperties any                             `additionalProperties:"true" json:"-"`
}

func (s SourceAirtableUpdate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceAirtableUpdate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceAirtableUpdate) GetAddBaseIDToStreamName() *bool {
	if s == nil {
		return nil
	}
	return s.AddBaseIDToStreamName
}

func (s *SourceAirtableUpdate) GetCredentials() *SourceAirtableUpdateAuthentication {
	if s == nil {
		return nil
	}
	return s.Credentials
}

func (s *SourceAirtableUpdate) GetNumWorkers() *int64 {
	if s == nil {
		return nil
	}
	return s.NumWorkers
}

func (s *SourceAirtableUpdate) GetSourceType() *SourceAirtableUpdateSourceType {
	return SourceAirtableUpdateSourceTypeAirtable.ToPointer()
}

func (s *SourceAirtableUpdate) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}
