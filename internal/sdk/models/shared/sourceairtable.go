// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/types"
	"time"
)

type PersonalAccessToken struct {
	// The Personal Access Token for the Airtable account. See the <a href="https://airtable.com/developers/web/guides/personal-access-tokens">Support Guide</a> for more information on how to obtain this token.
	APIKey     string  `json:"api_key"`
	authMethod *string `const:"api_key" json:"auth_method,omitempty"`
}

func (p PersonalAccessToken) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *PersonalAccessToken) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (p *PersonalAccessToken) GetAPIKey() string {
	if p == nil {
		return ""
	}
	return p.APIKey
}

func (p *PersonalAccessToken) GetAuthMethod() *string {
	return types.Pointer("api_key")
}

type SourceAirtableOAuth20 struct {
	// Access Token for making authenticated requests.
	AccessToken *string `json:"access_token,omitempty"`
	authMethod  *string `const:"oauth2.0" json:"auth_method,omitempty"`
	// The client ID of the Airtable developer application.
	ClientID string `json:"client_id"`
	// The client secret of the Airtable developer application.
	ClientSecret string `json:"client_secret"`
	// The key to refresh the expired access token.
	RefreshToken string `json:"refresh_token"`
	// The date-time when the access token should be refreshed.
	TokenExpiryDate *time.Time `json:"token_expiry_date,omitempty"`
}

func (s SourceAirtableOAuth20) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceAirtableOAuth20) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceAirtableOAuth20) GetAccessToken() *string {
	if s == nil {
		return nil
	}
	return s.AccessToken
}

func (s *SourceAirtableOAuth20) GetAuthMethod() *string {
	return types.Pointer("oauth2.0")
}

func (s *SourceAirtableOAuth20) GetClientID() string {
	if s == nil {
		return ""
	}
	return s.ClientID
}

func (s *SourceAirtableOAuth20) GetClientSecret() string {
	if s == nil {
		return ""
	}
	return s.ClientSecret
}

func (s *SourceAirtableOAuth20) GetRefreshToken() string {
	if s == nil {
		return ""
	}
	return s.RefreshToken
}

func (s *SourceAirtableOAuth20) GetTokenExpiryDate() *time.Time {
	if s == nil {
		return nil
	}
	return s.TokenExpiryDate
}

type AuthenticationUnionType string

const (
	AuthenticationUnionTypeSourceAirtableOAuth20 AuthenticationUnionType = "source-airtable_OAuth2.0"
	AuthenticationUnionTypePersonalAccessToken   AuthenticationUnionType = "Personal Access Token"
)

type Authentication struct {
	SourceAirtableOAuth20 *SourceAirtableOAuth20 `queryParam:"inline" union:"member"`
	PersonalAccessToken   *PersonalAccessToken   `queryParam:"inline" union:"member"`

	Type AuthenticationUnionType
}

func CreateAuthenticationSourceAirtableOAuth20(sourceAirtableOAuth20 SourceAirtableOAuth20) Authentication {
	typ := AuthenticationUnionTypeSourceAirtableOAuth20

	return Authentication{
		SourceAirtableOAuth20: &sourceAirtableOAuth20,
		Type:                  typ,
	}
}

func CreateAuthenticationPersonalAccessToken(personalAccessToken PersonalAccessToken) Authentication {
	typ := AuthenticationUnionTypePersonalAccessToken

	return Authentication{
		PersonalAccessToken: &personalAccessToken,
		Type:                typ,
	}
}

func (u *Authentication) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var sourceAirtableOAuth20 SourceAirtableOAuth20 = SourceAirtableOAuth20{}
	if err := utils.UnmarshalJSON(data, &sourceAirtableOAuth20, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  AuthenticationUnionTypeSourceAirtableOAuth20,
			Value: &sourceAirtableOAuth20,
		})
	}

	var personalAccessToken PersonalAccessToken = PersonalAccessToken{}
	if err := utils.UnmarshalJSON(data, &personalAccessToken, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  AuthenticationUnionTypePersonalAccessToken,
			Value: &personalAccessToken,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for Authentication", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for Authentication", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(AuthenticationUnionType)
	switch best.Type {
	case AuthenticationUnionTypeSourceAirtableOAuth20:
		u.SourceAirtableOAuth20 = best.Value.(*SourceAirtableOAuth20)
		return nil
	case AuthenticationUnionTypePersonalAccessToken:
		u.PersonalAccessToken = best.Value.(*PersonalAccessToken)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Authentication", string(data))
}

func (u Authentication) MarshalJSON() ([]byte, error) {
	if u.SourceAirtableOAuth20 != nil {
		return utils.MarshalJSON(u.SourceAirtableOAuth20, "", true)
	}

	if u.PersonalAccessToken != nil {
		return utils.MarshalJSON(u.PersonalAccessToken, "", true)
	}

	return nil, errors.New("could not marshal union type Authentication: all fields are null")
}

type SourceAirtableSourceType string

const (
	SourceAirtableSourceTypeAirtable SourceAirtableSourceType = "airtable"
)

func (e SourceAirtableSourceType) ToPointer() *SourceAirtableSourceType {
	return &e
}
func (e *SourceAirtableSourceType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "airtable":
		*e = SourceAirtableSourceType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceAirtableSourceType: %v", v)
	}
}

type SourceAirtable struct {
	// When enabled, includes the base ID in stream names to ensure uniqueness. Use this if you have cloned Airtable bases with duplicate table names. Note that enabling this will change stream names and require a full refresh.
	AddBaseIDToStreamName *bool           `default:"false" json:"add_base_id_to_stream_name"`
	Credentials           *Authentication `json:"credentials,omitempty"`
	// Number of concurrent threads for syncing. Higher values can speed up syncs but may hit rate limits. Airtable limits to 5 requests per second per base.
	NumWorkers           *int64                    `default:"5" json:"num_workers"`
	sourceType           *SourceAirtableSourceType `const:"airtable" json:"sourceType"`
	AdditionalProperties any                       `additionalProperties:"true" json:"-"`
}

func (s SourceAirtable) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceAirtable) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceAirtable) GetAddBaseIDToStreamName() *bool {
	if s == nil {
		return nil
	}
	return s.AddBaseIDToStreamName
}

func (s *SourceAirtable) GetCredentials() *Authentication {
	if s == nil {
		return nil
	}
	return s.Credentials
}

func (s *SourceAirtable) GetNumWorkers() *int64 {
	if s == nil {
		return nil
	}
	return s.NumWorkers
}

func (s *SourceAirtable) GetSourceType() *SourceAirtableSourceType {
	return SourceAirtableSourceTypeAirtable.ToPointer()
}

func (s *SourceAirtable) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}
