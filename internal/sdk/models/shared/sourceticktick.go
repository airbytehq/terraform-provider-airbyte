// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

type BearerTokenFromOauth2 struct {
	authType string `const:"Token" json:"auth_type"`
	// Access token for making authenticated requests; filled after complete oauth2 flow.
	BearerToken string `json:"bearer_token"`
}

func (b BearerTokenFromOauth2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(b, "", false)
}

func (b *BearerTokenFromOauth2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &b, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (b *BearerTokenFromOauth2) GetAuthType() string {
	return "Token"
}

func (b *BearerTokenFromOauth2) GetBearerToken() string {
	if b == nil {
		return ""
	}
	return b.BearerToken
}

type OAuth2 struct {
	authType string `const:"Oauth" json:"auth_type"`
	// Access token for making authenticated requests; filled after complete oauth2 flow.
	ClientAccessToken *string `json:"client_access_token,omitempty"`
	// The client ID of your Ticktick application. Read more <a href="https://developer.ticktick.com/api#/openapi?id=getting-started">here</a>.
	ClientID string `json:"client_id"`
	// The client secret of of your Ticktick application. application. Read more <a href="https://developer.ticktick.com/api#/openapi?id=getting-started">here</a>.
	ClientSecret string `json:"client_secret"`
}

func (o OAuth2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(o, "", false)
}

func (o *OAuth2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &o, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *OAuth2) GetAuthType() string {
	return "Oauth"
}

func (o *OAuth2) GetClientAccessToken() *string {
	if o == nil {
		return nil
	}
	return o.ClientAccessToken
}

func (o *OAuth2) GetClientID() string {
	if o == nil {
		return ""
	}
	return o.ClientID
}

func (o *OAuth2) GetClientSecret() string {
	if o == nil {
		return ""
	}
	return o.ClientSecret
}

type SourceTicktickAuthenticationTypeType string

const (
	SourceTicktickAuthenticationTypeTypeOAuth2                SourceTicktickAuthenticationTypeType = "OAuth2"
	SourceTicktickAuthenticationTypeTypeBearerTokenFromOauth2 SourceTicktickAuthenticationTypeType = "Bearer Token (from Oauth2)"
)

type SourceTicktickAuthenticationType struct {
	OAuth2                *OAuth2                `queryParam:"inline" union:"member"`
	BearerTokenFromOauth2 *BearerTokenFromOauth2 `queryParam:"inline" union:"member"`

	Type SourceTicktickAuthenticationTypeType
}

func CreateSourceTicktickAuthenticationTypeOAuth2(oAuth2 OAuth2) SourceTicktickAuthenticationType {
	typ := SourceTicktickAuthenticationTypeTypeOAuth2

	return SourceTicktickAuthenticationType{
		OAuth2: &oAuth2,
		Type:   typ,
	}
}

func CreateSourceTicktickAuthenticationTypeBearerTokenFromOauth2(bearerTokenFromOauth2 BearerTokenFromOauth2) SourceTicktickAuthenticationType {
	typ := SourceTicktickAuthenticationTypeTypeBearerTokenFromOauth2

	return SourceTicktickAuthenticationType{
		BearerTokenFromOauth2: &bearerTokenFromOauth2,
		Type:                  typ,
	}
}

func (u *SourceTicktickAuthenticationType) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var oAuth2 OAuth2 = OAuth2{}
	if err := utils.UnmarshalJSON(data, &oAuth2, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceTicktickAuthenticationTypeTypeOAuth2,
			Value: &oAuth2,
		})
	}

	var bearerTokenFromOauth2 BearerTokenFromOauth2 = BearerTokenFromOauth2{}
	if err := utils.UnmarshalJSON(data, &bearerTokenFromOauth2, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceTicktickAuthenticationTypeTypeBearerTokenFromOauth2,
			Value: &bearerTokenFromOauth2,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceTicktickAuthenticationType", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceTicktickAuthenticationType", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceTicktickAuthenticationTypeType)
	switch best.Type {
	case SourceTicktickAuthenticationTypeTypeOAuth2:
		u.OAuth2 = best.Value.(*OAuth2)
		return nil
	case SourceTicktickAuthenticationTypeTypeBearerTokenFromOauth2:
		u.BearerTokenFromOauth2 = best.Value.(*BearerTokenFromOauth2)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceTicktickAuthenticationType", string(data))
}

func (u SourceTicktickAuthenticationType) MarshalJSON() ([]byte, error) {
	if u.OAuth2 != nil {
		return utils.MarshalJSON(u.OAuth2, "", true)
	}

	if u.BearerTokenFromOauth2 != nil {
		return utils.MarshalJSON(u.BearerTokenFromOauth2, "", true)
	}

	return nil, errors.New("could not marshal union type SourceTicktickAuthenticationType: all fields are null")
}

type SourceTicktickSourceType string

const (
	SourceTicktickSourceTypeTicktick SourceTicktickSourceType = "ticktick"
)

func (e SourceTicktickSourceType) ToPointer() *SourceTicktickSourceType {
	return &e
}
func (e *SourceTicktickSourceType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "ticktick":
		*e = SourceTicktickSourceType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceTicktickSourceType: %v", v)
	}
}

type SourceTicktick struct {
	Authorization        *SourceTicktickAuthenticationType `json:"authorization,omitempty"`
	sourceType           *SourceTicktickSourceType         `const:"ticktick" json:"sourceType"`
	AdditionalProperties any                               `additionalProperties:"true" json:"-"`
}

func (s SourceTicktick) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceTicktick) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceTicktick) GetAuthorization() *SourceTicktickAuthenticationType {
	if s == nil {
		return nil
	}
	return s.Authorization
}

func (s *SourceTicktick) GetSourceType() *SourceTicktickSourceType {
	return SourceTicktickSourceTypeTicktick.ToPointer()
}

func (s *SourceTicktick) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}
