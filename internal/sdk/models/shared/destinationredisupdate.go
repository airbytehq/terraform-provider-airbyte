// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

type DestinationRedisUpdateSchemasMode string

const (
	DestinationRedisUpdateSchemasModeVerifyFull DestinationRedisUpdateSchemasMode = "verify-full"
)

func (e DestinationRedisUpdateSchemasMode) ToPointer() *DestinationRedisUpdateSchemasMode {
	return &e
}
func (e *DestinationRedisUpdateSchemasMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "verify-full":
		*e = DestinationRedisUpdateSchemasMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationRedisUpdateSchemasMode: %v", v)
	}
}

// DestinationRedisUpdateVerifyFull - Verify-full SSL mode.
type DestinationRedisUpdateVerifyFull struct {
	mode *DestinationRedisUpdateSchemasMode `const:"verify-full" json:"mode"`
	// CA certificate
	CaCertificate string `json:"ca_certificate"`
	// Client certificate
	ClientCertificate string `json:"client_certificate"`
	// Client key
	ClientKey string `json:"client_key"`
	// Password for keystorage. If you do not add it - the password will be generated automatically.
	ClientKeyPassword *string `json:"client_key_password,omitempty"`
}

func (d DestinationRedisUpdateVerifyFull) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationRedisUpdateVerifyFull) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationRedisUpdateVerifyFull) GetMode() *DestinationRedisUpdateSchemasMode {
	return DestinationRedisUpdateSchemasModeVerifyFull.ToPointer()
}

func (o *DestinationRedisUpdateVerifyFull) GetCaCertificate() string {
	if o == nil {
		return ""
	}
	return o.CaCertificate
}

func (o *DestinationRedisUpdateVerifyFull) GetClientCertificate() string {
	if o == nil {
		return ""
	}
	return o.ClientCertificate
}

func (o *DestinationRedisUpdateVerifyFull) GetClientKey() string {
	if o == nil {
		return ""
	}
	return o.ClientKey
}

func (o *DestinationRedisUpdateVerifyFull) GetClientKeyPassword() *string {
	if o == nil {
		return nil
	}
	return o.ClientKeyPassword
}

type DestinationRedisUpdateMode string

const (
	DestinationRedisUpdateModeDisable DestinationRedisUpdateMode = "disable"
)

func (e DestinationRedisUpdateMode) ToPointer() *DestinationRedisUpdateMode {
	return &e
}
func (e *DestinationRedisUpdateMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "disable":
		*e = DestinationRedisUpdateMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationRedisUpdateMode: %v", v)
	}
}

// DestinationRedisUpdateDisable - Disable SSL.
type DestinationRedisUpdateDisable struct {
	mode *DestinationRedisUpdateMode `const:"disable" json:"mode"`
}

func (d DestinationRedisUpdateDisable) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationRedisUpdateDisable) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationRedisUpdateDisable) GetMode() *DestinationRedisUpdateMode {
	return DestinationRedisUpdateModeDisable.ToPointer()
}

type DestinationRedisUpdateSSLModesType string

const (
	DestinationRedisUpdateSSLModesTypeDestinationRedisUpdateDisable    DestinationRedisUpdateSSLModesType = "destination-redis-update_disable"
	DestinationRedisUpdateSSLModesTypeDestinationRedisUpdateVerifyFull DestinationRedisUpdateSSLModesType = "destination-redis-update_verify-full"
)

// DestinationRedisUpdateSSLModes - SSL connection modes.
//
//	<li><b>verify-full</b> - This is the most secure mode. Always require encryption and verifies the identity of the source database server
type DestinationRedisUpdateSSLModes struct {
	DestinationRedisUpdateDisable    *DestinationRedisUpdateDisable    `queryParam:"inline"`
	DestinationRedisUpdateVerifyFull *DestinationRedisUpdateVerifyFull `queryParam:"inline"`

	Type DestinationRedisUpdateSSLModesType
}

func CreateDestinationRedisUpdateSSLModesDestinationRedisUpdateDisable(destinationRedisUpdateDisable DestinationRedisUpdateDisable) DestinationRedisUpdateSSLModes {
	typ := DestinationRedisUpdateSSLModesTypeDestinationRedisUpdateDisable

	return DestinationRedisUpdateSSLModes{
		DestinationRedisUpdateDisable: &destinationRedisUpdateDisable,
		Type:                          typ,
	}
}

func CreateDestinationRedisUpdateSSLModesDestinationRedisUpdateVerifyFull(destinationRedisUpdateVerifyFull DestinationRedisUpdateVerifyFull) DestinationRedisUpdateSSLModes {
	typ := DestinationRedisUpdateSSLModesTypeDestinationRedisUpdateVerifyFull

	return DestinationRedisUpdateSSLModes{
		DestinationRedisUpdateVerifyFull: &destinationRedisUpdateVerifyFull,
		Type:                             typ,
	}
}

func (u *DestinationRedisUpdateSSLModes) UnmarshalJSON(data []byte) error {

	var destinationRedisUpdateDisable DestinationRedisUpdateDisable = DestinationRedisUpdateDisable{}
	if err := utils.UnmarshalJSON(data, &destinationRedisUpdateDisable, "", true, true); err == nil {
		u.DestinationRedisUpdateDisable = &destinationRedisUpdateDisable
		u.Type = DestinationRedisUpdateSSLModesTypeDestinationRedisUpdateDisable
		return nil
	}

	var destinationRedisUpdateVerifyFull DestinationRedisUpdateVerifyFull = DestinationRedisUpdateVerifyFull{}
	if err := utils.UnmarshalJSON(data, &destinationRedisUpdateVerifyFull, "", true, true); err == nil {
		u.DestinationRedisUpdateVerifyFull = &destinationRedisUpdateVerifyFull
		u.Type = DestinationRedisUpdateSSLModesTypeDestinationRedisUpdateVerifyFull
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationRedisUpdateSSLModes", string(data))
}

func (u DestinationRedisUpdateSSLModes) MarshalJSON() ([]byte, error) {
	if u.DestinationRedisUpdateDisable != nil {
		return utils.MarshalJSON(u.DestinationRedisUpdateDisable, "", true)
	}

	if u.DestinationRedisUpdateVerifyFull != nil {
		return utils.MarshalJSON(u.DestinationRedisUpdateVerifyFull, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationRedisUpdateSSLModes: all fields are null")
}

// DestinationRedisUpdateCacheType - Redis cache type to store data in.
type DestinationRedisUpdateCacheType string

const (
	DestinationRedisUpdateCacheTypeHash DestinationRedisUpdateCacheType = "hash"
)

func (e DestinationRedisUpdateCacheType) ToPointer() *DestinationRedisUpdateCacheType {
	return &e
}
func (e *DestinationRedisUpdateCacheType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "hash":
		*e = DestinationRedisUpdateCacheType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationRedisUpdateCacheType: %v", v)
	}
}

// DestinationRedisUpdateSchemasTunnelMethodTunnelMethod - Connect through a jump server tunnel host using username and password authentication
type DestinationRedisUpdateSchemasTunnelMethodTunnelMethod string

const (
	DestinationRedisUpdateSchemasTunnelMethodTunnelMethodSSHPasswordAuth DestinationRedisUpdateSchemasTunnelMethodTunnelMethod = "SSH_PASSWORD_AUTH"
)

func (e DestinationRedisUpdateSchemasTunnelMethodTunnelMethod) ToPointer() *DestinationRedisUpdateSchemasTunnelMethodTunnelMethod {
	return &e
}
func (e *DestinationRedisUpdateSchemasTunnelMethodTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_PASSWORD_AUTH":
		*e = DestinationRedisUpdateSchemasTunnelMethodTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationRedisUpdateSchemasTunnelMethodTunnelMethod: %v", v)
	}
}

type DestinationRedisUpdatePasswordAuthentication struct {
	// Connect through a jump server tunnel host using username and password authentication
	tunnelMethod DestinationRedisUpdateSchemasTunnelMethodTunnelMethod `const:"SSH_PASSWORD_AUTH" json:"tunnel_method"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser string `json:"tunnel_user"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword string `json:"tunnel_user_password"`
}

func (d DestinationRedisUpdatePasswordAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationRedisUpdatePasswordAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationRedisUpdatePasswordAuthentication) GetTunnelMethod() DestinationRedisUpdateSchemasTunnelMethodTunnelMethod {
	return DestinationRedisUpdateSchemasTunnelMethodTunnelMethodSSHPasswordAuth
}

func (o *DestinationRedisUpdatePasswordAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *DestinationRedisUpdatePasswordAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *DestinationRedisUpdatePasswordAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

func (o *DestinationRedisUpdatePasswordAuthentication) GetTunnelUserPassword() string {
	if o == nil {
		return ""
	}
	return o.TunnelUserPassword
}

// DestinationRedisUpdateSchemasTunnelMethod - Connect through a jump server tunnel host using username and ssh key
type DestinationRedisUpdateSchemasTunnelMethod string

const (
	DestinationRedisUpdateSchemasTunnelMethodSSHKeyAuth DestinationRedisUpdateSchemasTunnelMethod = "SSH_KEY_AUTH"
)

func (e DestinationRedisUpdateSchemasTunnelMethod) ToPointer() *DestinationRedisUpdateSchemasTunnelMethod {
	return &e
}
func (e *DestinationRedisUpdateSchemasTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_KEY_AUTH":
		*e = DestinationRedisUpdateSchemasTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationRedisUpdateSchemasTunnelMethod: %v", v)
	}
}

type DestinationRedisUpdateSSHKeyAuthentication struct {
	// Connect through a jump server tunnel host using username and ssh key
	tunnelMethod DestinationRedisUpdateSchemasTunnelMethod `const:"SSH_KEY_AUTH" json:"tunnel_method"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host.
	TunnelUser string `json:"tunnel_user"`
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey string `json:"ssh_key"`
}

func (d DestinationRedisUpdateSSHKeyAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationRedisUpdateSSHKeyAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationRedisUpdateSSHKeyAuthentication) GetTunnelMethod() DestinationRedisUpdateSchemasTunnelMethod {
	return DestinationRedisUpdateSchemasTunnelMethodSSHKeyAuth
}

func (o *DestinationRedisUpdateSSHKeyAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *DestinationRedisUpdateSSHKeyAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *DestinationRedisUpdateSSHKeyAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

func (o *DestinationRedisUpdateSSHKeyAuthentication) GetSSHKey() string {
	if o == nil {
		return ""
	}
	return o.SSHKey
}

// DestinationRedisUpdateTunnelMethod - No ssh tunnel needed to connect to database
type DestinationRedisUpdateTunnelMethod string

const (
	DestinationRedisUpdateTunnelMethodNoTunnel DestinationRedisUpdateTunnelMethod = "NO_TUNNEL"
)

func (e DestinationRedisUpdateTunnelMethod) ToPointer() *DestinationRedisUpdateTunnelMethod {
	return &e
}
func (e *DestinationRedisUpdateTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NO_TUNNEL":
		*e = DestinationRedisUpdateTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationRedisUpdateTunnelMethod: %v", v)
	}
}

type DestinationRedisUpdateNoTunnel struct {
	// No ssh tunnel needed to connect to database
	tunnelMethod DestinationRedisUpdateTunnelMethod `const:"NO_TUNNEL" json:"tunnel_method"`
}

func (d DestinationRedisUpdateNoTunnel) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationRedisUpdateNoTunnel) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationRedisUpdateNoTunnel) GetTunnelMethod() DestinationRedisUpdateTunnelMethod {
	return DestinationRedisUpdateTunnelMethodNoTunnel
}

type DestinationRedisUpdateSSHTunnelMethodType string

const (
	DestinationRedisUpdateSSHTunnelMethodTypeDestinationRedisUpdateNoTunnel               DestinationRedisUpdateSSHTunnelMethodType = "destination-redis-update_No Tunnel"
	DestinationRedisUpdateSSHTunnelMethodTypeDestinationRedisUpdateSSHKeyAuthentication   DestinationRedisUpdateSSHTunnelMethodType = "destination-redis-update_SSH Key Authentication"
	DestinationRedisUpdateSSHTunnelMethodTypeDestinationRedisUpdatePasswordAuthentication DestinationRedisUpdateSSHTunnelMethodType = "destination-redis-update_Password Authentication"
)

// DestinationRedisUpdateSSHTunnelMethod - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type DestinationRedisUpdateSSHTunnelMethod struct {
	DestinationRedisUpdateNoTunnel               *DestinationRedisUpdateNoTunnel               `queryParam:"inline"`
	DestinationRedisUpdateSSHKeyAuthentication   *DestinationRedisUpdateSSHKeyAuthentication   `queryParam:"inline"`
	DestinationRedisUpdatePasswordAuthentication *DestinationRedisUpdatePasswordAuthentication `queryParam:"inline"`

	Type DestinationRedisUpdateSSHTunnelMethodType
}

func CreateDestinationRedisUpdateSSHTunnelMethodDestinationRedisUpdateNoTunnel(destinationRedisUpdateNoTunnel DestinationRedisUpdateNoTunnel) DestinationRedisUpdateSSHTunnelMethod {
	typ := DestinationRedisUpdateSSHTunnelMethodTypeDestinationRedisUpdateNoTunnel

	return DestinationRedisUpdateSSHTunnelMethod{
		DestinationRedisUpdateNoTunnel: &destinationRedisUpdateNoTunnel,
		Type:                           typ,
	}
}

func CreateDestinationRedisUpdateSSHTunnelMethodDestinationRedisUpdateSSHKeyAuthentication(destinationRedisUpdateSSHKeyAuthentication DestinationRedisUpdateSSHKeyAuthentication) DestinationRedisUpdateSSHTunnelMethod {
	typ := DestinationRedisUpdateSSHTunnelMethodTypeDestinationRedisUpdateSSHKeyAuthentication

	return DestinationRedisUpdateSSHTunnelMethod{
		DestinationRedisUpdateSSHKeyAuthentication: &destinationRedisUpdateSSHKeyAuthentication,
		Type: typ,
	}
}

func CreateDestinationRedisUpdateSSHTunnelMethodDestinationRedisUpdatePasswordAuthentication(destinationRedisUpdatePasswordAuthentication DestinationRedisUpdatePasswordAuthentication) DestinationRedisUpdateSSHTunnelMethod {
	typ := DestinationRedisUpdateSSHTunnelMethodTypeDestinationRedisUpdatePasswordAuthentication

	return DestinationRedisUpdateSSHTunnelMethod{
		DestinationRedisUpdatePasswordAuthentication: &destinationRedisUpdatePasswordAuthentication,
		Type: typ,
	}
}

func (u *DestinationRedisUpdateSSHTunnelMethod) UnmarshalJSON(data []byte) error {

	var destinationRedisUpdateNoTunnel DestinationRedisUpdateNoTunnel = DestinationRedisUpdateNoTunnel{}
	if err := utils.UnmarshalJSON(data, &destinationRedisUpdateNoTunnel, "", true, true); err == nil {
		u.DestinationRedisUpdateNoTunnel = &destinationRedisUpdateNoTunnel
		u.Type = DestinationRedisUpdateSSHTunnelMethodTypeDestinationRedisUpdateNoTunnel
		return nil
	}

	var destinationRedisUpdateSSHKeyAuthentication DestinationRedisUpdateSSHKeyAuthentication = DestinationRedisUpdateSSHKeyAuthentication{}
	if err := utils.UnmarshalJSON(data, &destinationRedisUpdateSSHKeyAuthentication, "", true, true); err == nil {
		u.DestinationRedisUpdateSSHKeyAuthentication = &destinationRedisUpdateSSHKeyAuthentication
		u.Type = DestinationRedisUpdateSSHTunnelMethodTypeDestinationRedisUpdateSSHKeyAuthentication
		return nil
	}

	var destinationRedisUpdatePasswordAuthentication DestinationRedisUpdatePasswordAuthentication = DestinationRedisUpdatePasswordAuthentication{}
	if err := utils.UnmarshalJSON(data, &destinationRedisUpdatePasswordAuthentication, "", true, true); err == nil {
		u.DestinationRedisUpdatePasswordAuthentication = &destinationRedisUpdatePasswordAuthentication
		u.Type = DestinationRedisUpdateSSHTunnelMethodTypeDestinationRedisUpdatePasswordAuthentication
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationRedisUpdateSSHTunnelMethod", string(data))
}

func (u DestinationRedisUpdateSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.DestinationRedisUpdateNoTunnel != nil {
		return utils.MarshalJSON(u.DestinationRedisUpdateNoTunnel, "", true)
	}

	if u.DestinationRedisUpdateSSHKeyAuthentication != nil {
		return utils.MarshalJSON(u.DestinationRedisUpdateSSHKeyAuthentication, "", true)
	}

	if u.DestinationRedisUpdatePasswordAuthentication != nil {
		return utils.MarshalJSON(u.DestinationRedisUpdatePasswordAuthentication, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationRedisUpdateSSHTunnelMethod: all fields are null")
}

type DestinationRedisUpdate struct {
	// Redis host to connect to.
	Host string `json:"host"`
	// Port of Redis.
	Port *int64 `default:"6379" json:"port"`
	// Username associated with Redis.
	Username string `json:"username"`
	// Password associated with Redis.
	Password *string `json:"password,omitempty"`
	// Indicates whether SSL encryption protocol will be used to connect to Redis. It is recommended to use SSL connection if possible.
	Ssl *bool `default:"false" json:"ssl"`
	// SSL connection modes.
	//   <li><b>verify-full</b> - This is the most secure mode. Always require encryption and verifies the identity of the source database server
	SslMode *DestinationRedisUpdateSSLModes `json:"ssl_mode,omitempty"`
	// Redis cache type to store data in.
	CacheType *DestinationRedisUpdateCacheType `default:"hash" json:"cache_type"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod *DestinationRedisUpdateSSHTunnelMethod `json:"tunnel_method,omitempty"`
}

func (d DestinationRedisUpdate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationRedisUpdate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *DestinationRedisUpdate) GetHost() string {
	if o == nil {
		return ""
	}
	return o.Host
}

func (o *DestinationRedisUpdate) GetPort() *int64 {
	if o == nil {
		return nil
	}
	return o.Port
}

func (o *DestinationRedisUpdate) GetUsername() string {
	if o == nil {
		return ""
	}
	return o.Username
}

func (o *DestinationRedisUpdate) GetPassword() *string {
	if o == nil {
		return nil
	}
	return o.Password
}

func (o *DestinationRedisUpdate) GetSsl() *bool {
	if o == nil {
		return nil
	}
	return o.Ssl
}

func (o *DestinationRedisUpdate) GetSslMode() *DestinationRedisUpdateSSLModes {
	if o == nil {
		return nil
	}
	return o.SslMode
}

func (o *DestinationRedisUpdate) GetCacheType() *DestinationRedisUpdateCacheType {
	if o == nil {
		return nil
	}
	return o.CacheType
}

func (o *DestinationRedisUpdate) GetTunnelMethod() *DestinationRedisUpdateSSHTunnelMethod {
	if o == nil {
		return nil
	}
	return o.TunnelMethod
}
