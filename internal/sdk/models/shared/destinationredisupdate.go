// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/types"
)

// DestinationRedisUpdateCacheType - Redis cache type to store data in.
type DestinationRedisUpdateCacheType string

const (
	DestinationRedisUpdateCacheTypeHash DestinationRedisUpdateCacheType = "hash"
)

func (e DestinationRedisUpdateCacheType) ToPointer() *DestinationRedisUpdateCacheType {
	return &e
}
func (e *DestinationRedisUpdateCacheType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "hash":
		*e = DestinationRedisUpdateCacheType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationRedisUpdateCacheType: %v", v)
	}
}

type DestinationRedisUpdateSchemasMode string

const (
	DestinationRedisUpdateSchemasModeVerifyFull DestinationRedisUpdateSchemasMode = "verify-full"
)

func (e DestinationRedisUpdateSchemasMode) ToPointer() *DestinationRedisUpdateSchemasMode {
	return &e
}
func (e *DestinationRedisUpdateSchemasMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "verify-full":
		*e = DestinationRedisUpdateSchemasMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationRedisUpdateSchemasMode: %v", v)
	}
}

// DestinationRedisUpdateVerifyFull - Verify-full SSL mode.
type DestinationRedisUpdateVerifyFull struct {
	// CA certificate
	CaCertificate *string `json:"ca_certificate,omitempty"`
	// Client certificate
	ClientCertificate *string `json:"client_certificate,omitempty"`
	// Client key
	ClientKey *string `json:"client_key,omitempty"`
	// Password for keystorage. If you do not add it - the password will be generated automatically.
	ClientKeyPassword *string                            `json:"client_key_password,omitempty"`
	mode              *DestinationRedisUpdateSchemasMode `const:"verify-full" json:"mode"`
}

func (d DestinationRedisUpdateVerifyFull) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationRedisUpdateVerifyFull) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationRedisUpdateVerifyFull) GetCaCertificate() *string {
	if d == nil {
		return nil
	}
	return d.CaCertificate
}

func (d *DestinationRedisUpdateVerifyFull) GetClientCertificate() *string {
	if d == nil {
		return nil
	}
	return d.ClientCertificate
}

func (d *DestinationRedisUpdateVerifyFull) GetClientKey() *string {
	if d == nil {
		return nil
	}
	return d.ClientKey
}

func (d *DestinationRedisUpdateVerifyFull) GetClientKeyPassword() *string {
	if d == nil {
		return nil
	}
	return d.ClientKeyPassword
}

func (d *DestinationRedisUpdateVerifyFull) GetMode() *DestinationRedisUpdateSchemasMode {
	return DestinationRedisUpdateSchemasModeVerifyFull.ToPointer()
}

type DestinationRedisUpdateMode string

const (
	DestinationRedisUpdateModeDisable DestinationRedisUpdateMode = "disable"
)

func (e DestinationRedisUpdateMode) ToPointer() *DestinationRedisUpdateMode {
	return &e
}
func (e *DestinationRedisUpdateMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "disable":
		*e = DestinationRedisUpdateMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationRedisUpdateMode: %v", v)
	}
}

// DestinationRedisUpdateDisable - Disable SSL.
type DestinationRedisUpdateDisable struct {
	mode *DestinationRedisUpdateMode `const:"disable" json:"mode"`
}

func (d DestinationRedisUpdateDisable) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationRedisUpdateDisable) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationRedisUpdateDisable) GetMode() *DestinationRedisUpdateMode {
	return DestinationRedisUpdateModeDisable.ToPointer()
}

type DestinationRedisUpdateSSLModesType string

const (
	DestinationRedisUpdateSSLModesTypeDestinationRedisUpdateDisable    DestinationRedisUpdateSSLModesType = "destination-redis-update_disable"
	DestinationRedisUpdateSSLModesTypeDestinationRedisUpdateVerifyFull DestinationRedisUpdateSSLModesType = "destination-redis-update_verify-full"
)

// DestinationRedisUpdateSSLModes - SSL connection modes.
//
//	<li><b>verify-full</b> - This is the most secure mode. Always require encryption and verifies the identity of the source database server
type DestinationRedisUpdateSSLModes struct {
	DestinationRedisUpdateDisable    *DestinationRedisUpdateDisable    `queryParam:"inline" union:"member"`
	DestinationRedisUpdateVerifyFull *DestinationRedisUpdateVerifyFull `queryParam:"inline" union:"member"`

	Type DestinationRedisUpdateSSLModesType
}

func CreateDestinationRedisUpdateSSLModesDestinationRedisUpdateDisable(destinationRedisUpdateDisable DestinationRedisUpdateDisable) DestinationRedisUpdateSSLModes {
	typ := DestinationRedisUpdateSSLModesTypeDestinationRedisUpdateDisable

	return DestinationRedisUpdateSSLModes{
		DestinationRedisUpdateDisable: &destinationRedisUpdateDisable,
		Type:                          typ,
	}
}

func CreateDestinationRedisUpdateSSLModesDestinationRedisUpdateVerifyFull(destinationRedisUpdateVerifyFull DestinationRedisUpdateVerifyFull) DestinationRedisUpdateSSLModes {
	typ := DestinationRedisUpdateSSLModesTypeDestinationRedisUpdateVerifyFull

	return DestinationRedisUpdateSSLModes{
		DestinationRedisUpdateVerifyFull: &destinationRedisUpdateVerifyFull,
		Type:                             typ,
	}
}

func (u *DestinationRedisUpdateSSLModes) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var destinationRedisUpdateDisable DestinationRedisUpdateDisable = DestinationRedisUpdateDisable{}
	if err := utils.UnmarshalJSON(data, &destinationRedisUpdateDisable, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationRedisUpdateSSLModesTypeDestinationRedisUpdateDisable,
			Value: &destinationRedisUpdateDisable,
		})
	}

	var destinationRedisUpdateVerifyFull DestinationRedisUpdateVerifyFull = DestinationRedisUpdateVerifyFull{}
	if err := utils.UnmarshalJSON(data, &destinationRedisUpdateVerifyFull, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationRedisUpdateSSLModesTypeDestinationRedisUpdateVerifyFull,
			Value: &destinationRedisUpdateVerifyFull,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationRedisUpdateSSLModes", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationRedisUpdateSSLModes", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(DestinationRedisUpdateSSLModesType)
	switch best.Type {
	case DestinationRedisUpdateSSLModesTypeDestinationRedisUpdateDisable:
		u.DestinationRedisUpdateDisable = best.Value.(*DestinationRedisUpdateDisable)
		return nil
	case DestinationRedisUpdateSSLModesTypeDestinationRedisUpdateVerifyFull:
		u.DestinationRedisUpdateVerifyFull = best.Value.(*DestinationRedisUpdateVerifyFull)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationRedisUpdateSSLModes", string(data))
}

func (u DestinationRedisUpdateSSLModes) MarshalJSON() ([]byte, error) {
	if u.DestinationRedisUpdateDisable != nil {
		return utils.MarshalJSON(u.DestinationRedisUpdateDisable, "", true)
	}

	if u.DestinationRedisUpdateVerifyFull != nil {
		return utils.MarshalJSON(u.DestinationRedisUpdateVerifyFull, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationRedisUpdateSSLModes: all fields are null")
}

type DestinationRedisUpdatePasswordAuthentication struct {
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost *string `json:"tunnel_host,omitempty"`
	// Connect through a jump server tunnel host using username and password authentication
	tunnelMethod *string `const:"SSH_PASSWORD_AUTH" json:"tunnel_method,omitempty"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser *string `json:"tunnel_user,omitempty"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword *string `json:"tunnel_user_password,omitempty"`
}

func (d DestinationRedisUpdatePasswordAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationRedisUpdatePasswordAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationRedisUpdatePasswordAuthentication) GetTunnelHost() *string {
	if d == nil {
		return nil
	}
	return d.TunnelHost
}

func (d *DestinationRedisUpdatePasswordAuthentication) GetTunnelMethod() *string {
	return types.Pointer("SSH_PASSWORD_AUTH")
}

func (d *DestinationRedisUpdatePasswordAuthentication) GetTunnelPort() *int64 {
	if d == nil {
		return nil
	}
	return d.TunnelPort
}

func (d *DestinationRedisUpdatePasswordAuthentication) GetTunnelUser() *string {
	if d == nil {
		return nil
	}
	return d.TunnelUser
}

func (d *DestinationRedisUpdatePasswordAuthentication) GetTunnelUserPassword() *string {
	if d == nil {
		return nil
	}
	return d.TunnelUserPassword
}

type DestinationRedisUpdateSSHKeyAuthentication struct {
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey *string `json:"ssh_key,omitempty"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost *string `json:"tunnel_host,omitempty"`
	// Connect through a jump server tunnel host using username and ssh key
	tunnelMethod *string `const:"SSH_KEY_AUTH" json:"tunnel_method,omitempty"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host.
	TunnelUser *string `json:"tunnel_user,omitempty"`
}

func (d DestinationRedisUpdateSSHKeyAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationRedisUpdateSSHKeyAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationRedisUpdateSSHKeyAuthentication) GetSSHKey() *string {
	if d == nil {
		return nil
	}
	return d.SSHKey
}

func (d *DestinationRedisUpdateSSHKeyAuthentication) GetTunnelHost() *string {
	if d == nil {
		return nil
	}
	return d.TunnelHost
}

func (d *DestinationRedisUpdateSSHKeyAuthentication) GetTunnelMethod() *string {
	return types.Pointer("SSH_KEY_AUTH")
}

func (d *DestinationRedisUpdateSSHKeyAuthentication) GetTunnelPort() *int64 {
	if d == nil {
		return nil
	}
	return d.TunnelPort
}

func (d *DestinationRedisUpdateSSHKeyAuthentication) GetTunnelUser() *string {
	if d == nil {
		return nil
	}
	return d.TunnelUser
}

type DestinationRedisUpdateNoTunnel struct {
	// No ssh tunnel needed to connect to database
	tunnelMethod *string `const:"NO_TUNNEL" json:"tunnel_method,omitempty"`
}

func (d DestinationRedisUpdateNoTunnel) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationRedisUpdateNoTunnel) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationRedisUpdateNoTunnel) GetTunnelMethod() *string {
	return types.Pointer("NO_TUNNEL")
}

type DestinationRedisUpdateSSHTunnelMethodType string

const (
	DestinationRedisUpdateSSHTunnelMethodTypeDestinationRedisUpdateNoTunnel               DestinationRedisUpdateSSHTunnelMethodType = "destination-redis-update_No Tunnel"
	DestinationRedisUpdateSSHTunnelMethodTypeDestinationRedisUpdateSSHKeyAuthentication   DestinationRedisUpdateSSHTunnelMethodType = "destination-redis-update_SSH Key Authentication"
	DestinationRedisUpdateSSHTunnelMethodTypeDestinationRedisUpdatePasswordAuthentication DestinationRedisUpdateSSHTunnelMethodType = "destination-redis-update_Password Authentication"
)

// DestinationRedisUpdateSSHTunnelMethod - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type DestinationRedisUpdateSSHTunnelMethod struct {
	DestinationRedisUpdateNoTunnel               *DestinationRedisUpdateNoTunnel               `queryParam:"inline" union:"member"`
	DestinationRedisUpdateSSHKeyAuthentication   *DestinationRedisUpdateSSHKeyAuthentication   `queryParam:"inline" union:"member"`
	DestinationRedisUpdatePasswordAuthentication *DestinationRedisUpdatePasswordAuthentication `queryParam:"inline" union:"member"`

	Type DestinationRedisUpdateSSHTunnelMethodType
}

func CreateDestinationRedisUpdateSSHTunnelMethodDestinationRedisUpdateNoTunnel(destinationRedisUpdateNoTunnel DestinationRedisUpdateNoTunnel) DestinationRedisUpdateSSHTunnelMethod {
	typ := DestinationRedisUpdateSSHTunnelMethodTypeDestinationRedisUpdateNoTunnel

	return DestinationRedisUpdateSSHTunnelMethod{
		DestinationRedisUpdateNoTunnel: &destinationRedisUpdateNoTunnel,
		Type:                           typ,
	}
}

func CreateDestinationRedisUpdateSSHTunnelMethodDestinationRedisUpdateSSHKeyAuthentication(destinationRedisUpdateSSHKeyAuthentication DestinationRedisUpdateSSHKeyAuthentication) DestinationRedisUpdateSSHTunnelMethod {
	typ := DestinationRedisUpdateSSHTunnelMethodTypeDestinationRedisUpdateSSHKeyAuthentication

	return DestinationRedisUpdateSSHTunnelMethod{
		DestinationRedisUpdateSSHKeyAuthentication: &destinationRedisUpdateSSHKeyAuthentication,
		Type: typ,
	}
}

func CreateDestinationRedisUpdateSSHTunnelMethodDestinationRedisUpdatePasswordAuthentication(destinationRedisUpdatePasswordAuthentication DestinationRedisUpdatePasswordAuthentication) DestinationRedisUpdateSSHTunnelMethod {
	typ := DestinationRedisUpdateSSHTunnelMethodTypeDestinationRedisUpdatePasswordAuthentication

	return DestinationRedisUpdateSSHTunnelMethod{
		DestinationRedisUpdatePasswordAuthentication: &destinationRedisUpdatePasswordAuthentication,
		Type: typ,
	}
}

func (u *DestinationRedisUpdateSSHTunnelMethod) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var destinationRedisUpdateNoTunnel DestinationRedisUpdateNoTunnel = DestinationRedisUpdateNoTunnel{}
	if err := utils.UnmarshalJSON(data, &destinationRedisUpdateNoTunnel, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationRedisUpdateSSHTunnelMethodTypeDestinationRedisUpdateNoTunnel,
			Value: &destinationRedisUpdateNoTunnel,
		})
	}

	var destinationRedisUpdateSSHKeyAuthentication DestinationRedisUpdateSSHKeyAuthentication = DestinationRedisUpdateSSHKeyAuthentication{}
	if err := utils.UnmarshalJSON(data, &destinationRedisUpdateSSHKeyAuthentication, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationRedisUpdateSSHTunnelMethodTypeDestinationRedisUpdateSSHKeyAuthentication,
			Value: &destinationRedisUpdateSSHKeyAuthentication,
		})
	}

	var destinationRedisUpdatePasswordAuthentication DestinationRedisUpdatePasswordAuthentication = DestinationRedisUpdatePasswordAuthentication{}
	if err := utils.UnmarshalJSON(data, &destinationRedisUpdatePasswordAuthentication, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationRedisUpdateSSHTunnelMethodTypeDestinationRedisUpdatePasswordAuthentication,
			Value: &destinationRedisUpdatePasswordAuthentication,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationRedisUpdateSSHTunnelMethod", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationRedisUpdateSSHTunnelMethod", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(DestinationRedisUpdateSSHTunnelMethodType)
	switch best.Type {
	case DestinationRedisUpdateSSHTunnelMethodTypeDestinationRedisUpdateNoTunnel:
		u.DestinationRedisUpdateNoTunnel = best.Value.(*DestinationRedisUpdateNoTunnel)
		return nil
	case DestinationRedisUpdateSSHTunnelMethodTypeDestinationRedisUpdateSSHKeyAuthentication:
		u.DestinationRedisUpdateSSHKeyAuthentication = best.Value.(*DestinationRedisUpdateSSHKeyAuthentication)
		return nil
	case DestinationRedisUpdateSSHTunnelMethodTypeDestinationRedisUpdatePasswordAuthentication:
		u.DestinationRedisUpdatePasswordAuthentication = best.Value.(*DestinationRedisUpdatePasswordAuthentication)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationRedisUpdateSSHTunnelMethod", string(data))
}

func (u DestinationRedisUpdateSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.DestinationRedisUpdateNoTunnel != nil {
		return utils.MarshalJSON(u.DestinationRedisUpdateNoTunnel, "", true)
	}

	if u.DestinationRedisUpdateSSHKeyAuthentication != nil {
		return utils.MarshalJSON(u.DestinationRedisUpdateSSHKeyAuthentication, "", true)
	}

	if u.DestinationRedisUpdatePasswordAuthentication != nil {
		return utils.MarshalJSON(u.DestinationRedisUpdatePasswordAuthentication, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationRedisUpdateSSHTunnelMethod: all fields are null")
}

type DestinationRedisUpdateDestinationType string

const (
	DestinationRedisUpdateDestinationTypeRedis DestinationRedisUpdateDestinationType = "redis"
)

func (e DestinationRedisUpdateDestinationType) ToPointer() *DestinationRedisUpdateDestinationType {
	return &e
}
func (e *DestinationRedisUpdateDestinationType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "redis":
		*e = DestinationRedisUpdateDestinationType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationRedisUpdateDestinationType: %v", v)
	}
}

type DestinationRedisUpdate struct {
	// Redis cache type to store data in.
	CacheType *DestinationRedisUpdateCacheType `default:"hash" json:"cache_type"`
	// Redis host to connect to.
	Host *string `json:"host,omitempty"`
	// Password associated with Redis.
	Password *string `json:"password,omitempty"`
	// Port of Redis.
	Port *int64 `default:"6379" json:"port"`
	// Indicates whether SSL encryption protocol will be used to connect to Redis. It is recommended to use SSL connection if possible.
	Ssl *bool `default:"false" json:"ssl"`
	// SSL connection modes.
	//   <li><b>verify-full</b> - This is the most secure mode. Always require encryption and verifies the identity of the source database server
	SslMode *DestinationRedisUpdateSSLModes `json:"ssl_mode,omitempty"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod *DestinationRedisUpdateSSHTunnelMethod `json:"tunnel_method,omitempty"`
	// Username associated with Redis.
	Username        *string                                `json:"username,omitempty"`
	destinationType *DestinationRedisUpdateDestinationType `const:"redis" json:"destinationType"`
}

func (d DestinationRedisUpdate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationRedisUpdate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationRedisUpdate) GetCacheType() *DestinationRedisUpdateCacheType {
	if d == nil {
		return nil
	}
	return d.CacheType
}

func (d *DestinationRedisUpdate) GetHost() *string {
	if d == nil {
		return nil
	}
	return d.Host
}

func (d *DestinationRedisUpdate) GetPassword() *string {
	if d == nil {
		return nil
	}
	return d.Password
}

func (d *DestinationRedisUpdate) GetPort() *int64 {
	if d == nil {
		return nil
	}
	return d.Port
}

func (d *DestinationRedisUpdate) GetSsl() *bool {
	if d == nil {
		return nil
	}
	return d.Ssl
}

func (d *DestinationRedisUpdate) GetSslMode() *DestinationRedisUpdateSSLModes {
	if d == nil {
		return nil
	}
	return d.SslMode
}

func (d *DestinationRedisUpdate) GetTunnelMethod() *DestinationRedisUpdateSSHTunnelMethod {
	if d == nil {
		return nil
	}
	return d.TunnelMethod
}

func (d *DestinationRedisUpdate) GetUsername() *string {
	if d == nil {
		return nil
	}
	return d.Username
}

func (d *DestinationRedisUpdate) GetDestinationType() *DestinationRedisUpdateDestinationType {
	return DestinationRedisUpdateDestinationTypeRedis.ToPointer()
}
