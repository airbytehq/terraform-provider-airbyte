// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

// DestinationSnowflakeUpdateCDCDeletionMode - Whether to execute CDC deletions as hard deletes (i.e. propagate source deletions to the destination), or soft deletes (i.e. leave a tombstone record in the destination). Defaults to hard deletes.
type DestinationSnowflakeUpdateCDCDeletionMode string

const (
	DestinationSnowflakeUpdateCDCDeletionModeHardDelete DestinationSnowflakeUpdateCDCDeletionMode = "Hard delete"
	DestinationSnowflakeUpdateCDCDeletionModeSoftDelete DestinationSnowflakeUpdateCDCDeletionMode = "Soft delete"
)

func (e DestinationSnowflakeUpdateCDCDeletionMode) ToPointer() *DestinationSnowflakeUpdateCDCDeletionMode {
	return &e
}
func (e *DestinationSnowflakeUpdateCDCDeletionMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Hard delete":
		fallthrough
	case "Soft delete":
		*e = DestinationSnowflakeUpdateCDCDeletionMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationSnowflakeUpdateCDCDeletionMode: %v", v)
	}
}

type DestinationSnowflakeUpdateSchemasAuthType string

const (
	DestinationSnowflakeUpdateSchemasAuthTypeUsernameAndPassword DestinationSnowflakeUpdateSchemasAuthType = "Username and Password"
)

func (e DestinationSnowflakeUpdateSchemasAuthType) ToPointer() *DestinationSnowflakeUpdateSchemasAuthType {
	return &e
}
func (e *DestinationSnowflakeUpdateSchemasAuthType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Username and Password":
		*e = DestinationSnowflakeUpdateSchemasAuthType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationSnowflakeUpdateSchemasAuthType: %v", v)
	}
}

// DestinationSnowflakeUpdateUsernameAndPassword - Configuration details for the Username and Password Authentication.
type DestinationSnowflakeUpdateUsernameAndPassword struct {
	AuthType *DestinationSnowflakeUpdateSchemasAuthType `default:"Username and Password" json:"auth_type"`
	// Enter the password associated with the username.
	Password             *string `json:"password,omitempty"`
	AdditionalProperties any     `additionalProperties:"true" json:"-"`
}

func (d DestinationSnowflakeUpdateUsernameAndPassword) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationSnowflakeUpdateUsernameAndPassword) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationSnowflakeUpdateUsernameAndPassword) GetAuthType() *DestinationSnowflakeUpdateSchemasAuthType {
	if d == nil {
		return nil
	}
	return d.AuthType
}

func (d *DestinationSnowflakeUpdateUsernameAndPassword) GetPassword() *string {
	if d == nil {
		return nil
	}
	return d.Password
}

func (d *DestinationSnowflakeUpdateUsernameAndPassword) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationSnowflakeUpdateAuthType string

const (
	DestinationSnowflakeUpdateAuthTypeKeyPairAuthentication DestinationSnowflakeUpdateAuthType = "Key Pair Authentication"
)

func (e DestinationSnowflakeUpdateAuthType) ToPointer() *DestinationSnowflakeUpdateAuthType {
	return &e
}
func (e *DestinationSnowflakeUpdateAuthType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Key Pair Authentication":
		*e = DestinationSnowflakeUpdateAuthType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationSnowflakeUpdateAuthType: %v", v)
	}
}

// DestinationSnowflakeUpdateKeyPairAuthentication - Configuration details for the Key Pair Authentication.
type DestinationSnowflakeUpdateKeyPairAuthentication struct {
	AuthType *DestinationSnowflakeUpdateAuthType `default:"Key Pair Authentication" json:"auth_type"`
	// RSA Private key to use for Snowflake connection. See the <a
	//  href="https://docs.airbyte.com/integrations/destinations/snowflake">docs</a> for more
	//  information on how to obtain this key.
	PrivateKey *string `json:"private_key,omitempty"`
	// Passphrase for private key
	PrivateKeyPassword   *string `json:"private_key_password,omitempty"`
	AdditionalProperties any     `additionalProperties:"true" json:"-"`
}

func (d DestinationSnowflakeUpdateKeyPairAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationSnowflakeUpdateKeyPairAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationSnowflakeUpdateKeyPairAuthentication) GetAuthType() *DestinationSnowflakeUpdateAuthType {
	if d == nil {
		return nil
	}
	return d.AuthType
}

func (d *DestinationSnowflakeUpdateKeyPairAuthentication) GetPrivateKey() *string {
	if d == nil {
		return nil
	}
	return d.PrivateKey
}

func (d *DestinationSnowflakeUpdateKeyPairAuthentication) GetPrivateKeyPassword() *string {
	if d == nil {
		return nil
	}
	return d.PrivateKeyPassword
}

func (d *DestinationSnowflakeUpdateKeyPairAuthentication) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationSnowflakeUpdateAuthorizationMethodType string

const (
	DestinationSnowflakeUpdateAuthorizationMethodTypeDestinationSnowflakeUpdateKeyPairAuthentication DestinationSnowflakeUpdateAuthorizationMethodType = "destination-snowflake-update_Key Pair Authentication"
	DestinationSnowflakeUpdateAuthorizationMethodTypeDestinationSnowflakeUpdateUsernameAndPassword   DestinationSnowflakeUpdateAuthorizationMethodType = "destination-snowflake-update_Username and Password"
)

// DestinationSnowflakeUpdateAuthorizationMethod - Determines the type of authentication that should be used.
type DestinationSnowflakeUpdateAuthorizationMethod struct {
	DestinationSnowflakeUpdateKeyPairAuthentication *DestinationSnowflakeUpdateKeyPairAuthentication `queryParam:"inline" union:"member"`
	DestinationSnowflakeUpdateUsernameAndPassword   *DestinationSnowflakeUpdateUsernameAndPassword   `queryParam:"inline" union:"member"`

	Type DestinationSnowflakeUpdateAuthorizationMethodType
}

func CreateDestinationSnowflakeUpdateAuthorizationMethodDestinationSnowflakeUpdateKeyPairAuthentication(destinationSnowflakeUpdateKeyPairAuthentication DestinationSnowflakeUpdateKeyPairAuthentication) DestinationSnowflakeUpdateAuthorizationMethod {
	typ := DestinationSnowflakeUpdateAuthorizationMethodTypeDestinationSnowflakeUpdateKeyPairAuthentication

	return DestinationSnowflakeUpdateAuthorizationMethod{
		DestinationSnowflakeUpdateKeyPairAuthentication: &destinationSnowflakeUpdateKeyPairAuthentication,
		Type: typ,
	}
}

func CreateDestinationSnowflakeUpdateAuthorizationMethodDestinationSnowflakeUpdateUsernameAndPassword(destinationSnowflakeUpdateUsernameAndPassword DestinationSnowflakeUpdateUsernameAndPassword) DestinationSnowflakeUpdateAuthorizationMethod {
	typ := DestinationSnowflakeUpdateAuthorizationMethodTypeDestinationSnowflakeUpdateUsernameAndPassword

	return DestinationSnowflakeUpdateAuthorizationMethod{
		DestinationSnowflakeUpdateUsernameAndPassword: &destinationSnowflakeUpdateUsernameAndPassword,
		Type: typ,
	}
}

func (u *DestinationSnowflakeUpdateAuthorizationMethod) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var destinationSnowflakeUpdateKeyPairAuthentication DestinationSnowflakeUpdateKeyPairAuthentication = DestinationSnowflakeUpdateKeyPairAuthentication{}
	if err := utils.UnmarshalJSON(data, &destinationSnowflakeUpdateKeyPairAuthentication, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationSnowflakeUpdateAuthorizationMethodTypeDestinationSnowflakeUpdateKeyPairAuthentication,
			Value: &destinationSnowflakeUpdateKeyPairAuthentication,
		})
	}

	var destinationSnowflakeUpdateUsernameAndPassword DestinationSnowflakeUpdateUsernameAndPassword = DestinationSnowflakeUpdateUsernameAndPassword{}
	if err := utils.UnmarshalJSON(data, &destinationSnowflakeUpdateUsernameAndPassword, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationSnowflakeUpdateAuthorizationMethodTypeDestinationSnowflakeUpdateUsernameAndPassword,
			Value: &destinationSnowflakeUpdateUsernameAndPassword,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationSnowflakeUpdateAuthorizationMethod", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationSnowflakeUpdateAuthorizationMethod", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(DestinationSnowflakeUpdateAuthorizationMethodType)
	switch best.Type {
	case DestinationSnowflakeUpdateAuthorizationMethodTypeDestinationSnowflakeUpdateKeyPairAuthentication:
		u.DestinationSnowflakeUpdateKeyPairAuthentication = best.Value.(*DestinationSnowflakeUpdateKeyPairAuthentication)
		return nil
	case DestinationSnowflakeUpdateAuthorizationMethodTypeDestinationSnowflakeUpdateUsernameAndPassword:
		u.DestinationSnowflakeUpdateUsernameAndPassword = best.Value.(*DestinationSnowflakeUpdateUsernameAndPassword)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationSnowflakeUpdateAuthorizationMethod", string(data))
}

func (u DestinationSnowflakeUpdateAuthorizationMethod) MarshalJSON() ([]byte, error) {
	if u.DestinationSnowflakeUpdateKeyPairAuthentication != nil {
		return utils.MarshalJSON(u.DestinationSnowflakeUpdateKeyPairAuthentication, "", true)
	}

	if u.DestinationSnowflakeUpdateUsernameAndPassword != nil {
		return utils.MarshalJSON(u.DestinationSnowflakeUpdateUsernameAndPassword, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationSnowflakeUpdateAuthorizationMethod: all fields are null")
}

type DestinationSnowflakeUpdateDestinationType string

const (
	DestinationSnowflakeUpdateDestinationTypeSnowflake DestinationSnowflakeUpdateDestinationType = "snowflake"
)

func (e DestinationSnowflakeUpdateDestinationType) ToPointer() *DestinationSnowflakeUpdateDestinationType {
	return &e
}
func (e *DestinationSnowflakeUpdateDestinationType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "snowflake":
		*e = DestinationSnowflakeUpdateDestinationType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationSnowflakeUpdateDestinationType: %v", v)
	}
}

type DestinationSnowflakeUpdate struct {
	// Whether to execute CDC deletions as hard deletes (i.e. propagate source deletions to the destination), or soft deletes (i.e. leave a tombstone record in the destination). Defaults to hard deletes.
	CdcDeletionMode *DestinationSnowflakeUpdateCDCDeletionMode `default:"Hard delete" json:"cdc_deletion_mode"`
	// Determines the type of authentication that should be used.
	Credentials *DestinationSnowflakeUpdateAuthorizationMethod `json:"credentials,omitempty"`
	// Enter the name of the <a href="https://docs.snowflake.com/en/sql-reference/ddl-database.html#database-schema-share-ddl">database</a> you want to sync data into
	Database *string `json:"database,omitempty"`
	// Write the legacy "raw tables" format, to enable backwards compatibility with older versions of this connector.
	DisableTypeDedupe *bool `json:"disable_type_dedupe,omitempty"`
	// Enter your Snowflake account's <a href="https://docs.snowflake.com/en/user-guide/admin-account-identifier.html#using-an-account-locator-as-an-identifier">locator</a> (in the format <account_locator>.<region>.<cloud>.snowflakecomputing.com)
	Host *string `json:"host,omitempty"`
	// Enter the additional properties to pass to the JDBC URL string when connecting to the database (formatted as key=value pairs separated by the symbol &). Example: key1=value1&key2=value2&key3=value3
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// Airbyte will use this dataset for various internal tables. In legacy raw tables mode, the raw tables will be stored in this dataset. Defaults to "airbyte_internal".
	RawDataSchema *string `json:"raw_data_schema,omitempty"`
	// The number of days of Snowflake Time Travel to enable on the tables. See <a href="https://docs.snowflake.com/en/user-guide/data-time-travel#data-retention-period">Snowflake's documentation</a> for more information. Setting a nonzero value will incur increased storage costs in your Snowflake instance.
	RetentionPeriodDays *int64 `json:"retention_period_days,omitempty"`
	// Enter the <a href="https://docs.snowflake.com/en/user-guide/security-access-control-overview.html#roles">role</a> that you want to use to access Snowflake
	Role *string `json:"role,omitempty"`
	// Enter the name of the default <a href="https://docs.snowflake.com/en/sql-reference/ddl-database.html#database-schema-share-ddl">schema</a>
	Schema *string `json:"schema,omitempty"`
	// Enter the name of the user you want to use to access the database
	Username *string `json:"username,omitempty"`
	// Enter the name of the <a href="https://docs.snowflake.com/en/user-guide/warehouses-overview.html#overview-of-warehouses">warehouse</a> that you want to use as a compute cluster
	Warehouse            *string                                    `json:"warehouse,omitempty"`
	destinationType      *DestinationSnowflakeUpdateDestinationType `const:"snowflake" json:"destinationType"`
	AdditionalProperties any                                        `additionalProperties:"true" json:"-"`
}

func (d DestinationSnowflakeUpdate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationSnowflakeUpdate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationSnowflakeUpdate) GetCdcDeletionMode() *DestinationSnowflakeUpdateCDCDeletionMode {
	if d == nil {
		return nil
	}
	return d.CdcDeletionMode
}

func (d *DestinationSnowflakeUpdate) GetCredentials() *DestinationSnowflakeUpdateAuthorizationMethod {
	if d == nil {
		return nil
	}
	return d.Credentials
}

func (d *DestinationSnowflakeUpdate) GetDatabase() *string {
	if d == nil {
		return nil
	}
	return d.Database
}

func (d *DestinationSnowflakeUpdate) GetDisableTypeDedupe() *bool {
	if d == nil {
		return nil
	}
	return d.DisableTypeDedupe
}

func (d *DestinationSnowflakeUpdate) GetHost() *string {
	if d == nil {
		return nil
	}
	return d.Host
}

func (d *DestinationSnowflakeUpdate) GetJdbcURLParams() *string {
	if d == nil {
		return nil
	}
	return d.JdbcURLParams
}

func (d *DestinationSnowflakeUpdate) GetRawDataSchema() *string {
	if d == nil {
		return nil
	}
	return d.RawDataSchema
}

func (d *DestinationSnowflakeUpdate) GetRetentionPeriodDays() *int64 {
	if d == nil {
		return nil
	}
	return d.RetentionPeriodDays
}

func (d *DestinationSnowflakeUpdate) GetRole() *string {
	if d == nil {
		return nil
	}
	return d.Role
}

func (d *DestinationSnowflakeUpdate) GetSchema() *string {
	if d == nil {
		return nil
	}
	return d.Schema
}

func (d *DestinationSnowflakeUpdate) GetUsername() *string {
	if d == nil {
		return nil
	}
	return d.Username
}

func (d *DestinationSnowflakeUpdate) GetWarehouse() *string {
	if d == nil {
		return nil
	}
	return d.Warehouse
}

func (d *DestinationSnowflakeUpdate) GetDestinationType() *DestinationSnowflakeUpdateDestinationType {
	return DestinationSnowflakeUpdateDestinationTypeSnowflake.ToPointer()
}

func (d *DestinationSnowflakeUpdate) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}
