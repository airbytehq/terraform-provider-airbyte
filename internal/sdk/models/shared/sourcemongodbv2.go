// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

// SelfManagedReplicaSet - MongoDB self-hosted cluster configured as a replica set
type SelfManagedReplicaSet struct {
	// The authentication source where the user information is stored.
	AuthSource  *string `default:"admin" json:"auth_source"`
	clusterType string  `const:"SELF_MANAGED_REPLICA_SET" json:"cluster_type"`
	// The connection string of the cluster that you want to replicate.  https://www.mongodb.com/docs/manual/reference/connection-string/#find-your-self-hosted-deployment-s-connection-string for more information.
	ConnectionString string `json:"connection_string"`
	// The names of the MongoDB databases that contain the collection(s) to replicate.
	Databases []string `json:"databases"`
	// The password associated with this username.
	Password *string `json:"password,omitempty"`
	// When enabled, syncs will validate and structure records against the stream's schema.
	SchemaEnforced *bool `default:"true" json:"schema_enforced"`
	// The username which is used to access the database.
	Username             *string `json:"username,omitempty"`
	AdditionalProperties any     `additionalProperties:"true" json:"-"`
}

func (s SelfManagedReplicaSet) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SelfManagedReplicaSet) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SelfManagedReplicaSet) GetAuthSource() *string {
	if s == nil {
		return nil
	}
	return s.AuthSource
}

func (s *SelfManagedReplicaSet) GetClusterType() string {
	return "SELF_MANAGED_REPLICA_SET"
}

func (s *SelfManagedReplicaSet) GetConnectionString() string {
	if s == nil {
		return ""
	}
	return s.ConnectionString
}

func (s *SelfManagedReplicaSet) GetDatabases() []string {
	if s == nil {
		return []string{}
	}
	return s.Databases
}

func (s *SelfManagedReplicaSet) GetPassword() *string {
	if s == nil {
		return nil
	}
	return s.Password
}

func (s *SelfManagedReplicaSet) GetSchemaEnforced() *bool {
	if s == nil {
		return nil
	}
	return s.SchemaEnforced
}

func (s *SelfManagedReplicaSet) GetUsername() *string {
	if s == nil {
		return nil
	}
	return s.Username
}

func (s *SelfManagedReplicaSet) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

// MongoDBAtlasReplicaSet - MongoDB Atlas-hosted cluster configured as a replica set
type MongoDBAtlasReplicaSet struct {
	// The authentication source where the user information is stored.  See https://www.mongodb.com/docs/manual/reference/connection-string/#mongodb-urioption-urioption.authSource for more details.
	AuthSource  *string `default:"admin" json:"auth_source"`
	clusterType string  `const:"ATLAS_REPLICA_SET" json:"cluster_type"`
	// The connection string of the cluster that you want to replicate.
	ConnectionString string `json:"connection_string"`
	// The names of the MongoDB databases that contain the collection(s) to replicate.
	Databases []string `json:"databases"`
	// The password associated with this username.
	Password string `json:"password"`
	// When enabled, syncs will validate and structure records against the stream's schema.
	SchemaEnforced *bool `default:"true" json:"schema_enforced"`
	// The username which is used to access the database.
	Username             string `json:"username"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (m MongoDBAtlasReplicaSet) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(m, "", false)
}

func (m *MongoDBAtlasReplicaSet) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &m, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (m *MongoDBAtlasReplicaSet) GetAuthSource() *string {
	if m == nil {
		return nil
	}
	return m.AuthSource
}

func (m *MongoDBAtlasReplicaSet) GetClusterType() string {
	return "ATLAS_REPLICA_SET"
}

func (m *MongoDBAtlasReplicaSet) GetConnectionString() string {
	if m == nil {
		return ""
	}
	return m.ConnectionString
}

func (m *MongoDBAtlasReplicaSet) GetDatabases() []string {
	if m == nil {
		return []string{}
	}
	return m.Databases
}

func (m *MongoDBAtlasReplicaSet) GetPassword() string {
	if m == nil {
		return ""
	}
	return m.Password
}

func (m *MongoDBAtlasReplicaSet) GetSchemaEnforced() *bool {
	if m == nil {
		return nil
	}
	return m.SchemaEnforced
}

func (m *MongoDBAtlasReplicaSet) GetUsername() string {
	if m == nil {
		return ""
	}
	return m.Username
}

func (m *MongoDBAtlasReplicaSet) GetAdditionalProperties() any {
	if m == nil {
		return nil
	}
	return m.AdditionalProperties
}

type ClusterTypeType string

const (
	ClusterTypeTypeMongoDBAtlasReplicaSet ClusterTypeType = "MongoDB Atlas Replica Set"
	ClusterTypeTypeSelfManagedReplicaSet  ClusterTypeType = "Self-Managed Replica Set"
)

// ClusterType - Configures the MongoDB cluster type.
type ClusterType struct {
	MongoDBAtlasReplicaSet *MongoDBAtlasReplicaSet `queryParam:"inline" union:"member"`
	SelfManagedReplicaSet  *SelfManagedReplicaSet  `queryParam:"inline" union:"member"`

	Type ClusterTypeType
}

func CreateClusterTypeMongoDBAtlasReplicaSet(mongoDBAtlasReplicaSet MongoDBAtlasReplicaSet) ClusterType {
	typ := ClusterTypeTypeMongoDBAtlasReplicaSet

	return ClusterType{
		MongoDBAtlasReplicaSet: &mongoDBAtlasReplicaSet,
		Type:                   typ,
	}
}

func CreateClusterTypeSelfManagedReplicaSet(selfManagedReplicaSet SelfManagedReplicaSet) ClusterType {
	typ := ClusterTypeTypeSelfManagedReplicaSet

	return ClusterType{
		SelfManagedReplicaSet: &selfManagedReplicaSet,
		Type:                  typ,
	}
}

func (u *ClusterType) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var mongoDBAtlasReplicaSet MongoDBAtlasReplicaSet = MongoDBAtlasReplicaSet{}
	if err := utils.UnmarshalJSON(data, &mongoDBAtlasReplicaSet, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ClusterTypeTypeMongoDBAtlasReplicaSet,
			Value: &mongoDBAtlasReplicaSet,
		})
	}

	var selfManagedReplicaSet SelfManagedReplicaSet = SelfManagedReplicaSet{}
	if err := utils.UnmarshalJSON(data, &selfManagedReplicaSet, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ClusterTypeTypeSelfManagedReplicaSet,
			Value: &selfManagedReplicaSet,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for ClusterType", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for ClusterType", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(ClusterTypeType)
	switch best.Type {
	case ClusterTypeTypeMongoDBAtlasReplicaSet:
		u.MongoDBAtlasReplicaSet = best.Value.(*MongoDBAtlasReplicaSet)
		return nil
	case ClusterTypeTypeSelfManagedReplicaSet:
		u.SelfManagedReplicaSet = best.Value.(*SelfManagedReplicaSet)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ClusterType", string(data))
}

func (u ClusterType) MarshalJSON() ([]byte, error) {
	if u.MongoDBAtlasReplicaSet != nil {
		return utils.MarshalJSON(u.MongoDBAtlasReplicaSet, "", true)
	}

	if u.SelfManagedReplicaSet != nil {
		return utils.MarshalJSON(u.SelfManagedReplicaSet, "", true)
	}

	return nil, errors.New("could not marshal union type ClusterType: all fields are null")
}

// InvalidCDCPositionBehaviorAdvanced - Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value into the WAL. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss.
type InvalidCDCPositionBehaviorAdvanced string

const (
	InvalidCDCPositionBehaviorAdvancedFailSync   InvalidCDCPositionBehaviorAdvanced = "Fail sync"
	InvalidCDCPositionBehaviorAdvancedReSyncData InvalidCDCPositionBehaviorAdvanced = "Re-sync data"
)

func (e InvalidCDCPositionBehaviorAdvanced) ToPointer() *InvalidCDCPositionBehaviorAdvanced {
	return &e
}
func (e *InvalidCDCPositionBehaviorAdvanced) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Fail sync":
		fallthrough
	case "Re-sync data":
		*e = InvalidCDCPositionBehaviorAdvanced(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InvalidCDCPositionBehaviorAdvanced: %v", v)
	}
}

// CaptureModeAdvanced - Determines how Airbyte looks up the value of an updated document. If 'Lookup' is chosen, the current value of the document will be read. If 'Post Image' is chosen, then the version of the document immediately after an update will be read. WARNING : Severe data loss will occur if this option is chosen and the appropriate settings are not set on your Mongo instance : https://www.mongodb.com/docs/manual/changeStreams/#change-streams-with-document-pre-and-post-images.
type CaptureModeAdvanced string

const (
	CaptureModeAdvancedLookup    CaptureModeAdvanced = "Lookup"
	CaptureModeAdvancedPostImage CaptureModeAdvanced = "Post Image"
)

func (e CaptureModeAdvanced) ToPointer() *CaptureModeAdvanced {
	return &e
}
func (e *CaptureModeAdvanced) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Lookup":
		fallthrough
	case "Post Image":
		*e = CaptureModeAdvanced(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CaptureModeAdvanced: %v", v)
	}
}

type SourceMongodbV2SourceType string

const (
	SourceMongodbV2SourceTypeMongodbV2 SourceMongodbV2SourceType = "mongodb-v2"
)

func (e SourceMongodbV2SourceType) ToPointer() *SourceMongodbV2SourceType {
	return &e
}
func (e *SourceMongodbV2SourceType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "mongodb-v2":
		*e = SourceMongodbV2SourceType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMongodbV2SourceType: %v", v)
	}
}

type SourceMongodbV2 struct {
	// Configures the MongoDB cluster type.
	DatabaseConfig ClusterType `json:"database_config"`
	// The maximum number of documents to sample when attempting to discover the unique fields for a collection.
	DiscoverSampleSize *int64 `default:"10000" json:"discover_sample_size"`
	// The amount of time the connector will wait when it discovers a document. Defaults to 600 seconds. Valid range: 5 seconds to 1200 seconds.
	DiscoverTimeoutSeconds *int64 `default:"600" json:"discover_timeout_seconds"`
	// The amount of time an initial load is allowed to continue for before catching up on CDC logs.
	InitialLoadTimeoutHours *int64 `default:"8" json:"initial_load_timeout_hours"`
	// The amount of time the connector will wait when it launches to determine if there is new data to sync or not. Defaults to 300 seconds. Valid range: 120 seconds to 1200 seconds.
	InitialWaitingSeconds *int64 `default:"300" json:"initial_waiting_seconds"`
	// Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value into the WAL. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss.
	InvalidCdcCursorPositionBehavior *InvalidCDCPositionBehaviorAdvanced `default:"Fail sync" json:"invalid_cdc_cursor_position_behavior"`
	// The size of the internal queue. This may interfere with memory consumption and efficiency of the connector, please be careful.
	QueueSize *int64 `default:"10000" json:"queue_size"`
	// Determines how Airbyte looks up the value of an updated document. If 'Lookup' is chosen, the current value of the document will be read. If 'Post Image' is chosen, then the version of the document immediately after an update will be read. WARNING : Severe data loss will occur if this option is chosen and the appropriate settings are not set on your Mongo instance : https://www.mongodb.com/docs/manual/changeStreams/#change-streams-with-document-pre-and-post-images.
	UpdateCaptureMode    *CaptureModeAdvanced       `default:"Lookup" json:"update_capture_mode"`
	sourceType           *SourceMongodbV2SourceType `const:"mongodb-v2" json:"sourceType"`
	AdditionalProperties any                        `additionalProperties:"true" json:"-"`
}

func (s SourceMongodbV2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMongodbV2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceMongodbV2) GetDatabaseConfig() ClusterType {
	if s == nil {
		return ClusterType{}
	}
	return s.DatabaseConfig
}

func (s *SourceMongodbV2) GetDiscoverSampleSize() *int64 {
	if s == nil {
		return nil
	}
	return s.DiscoverSampleSize
}

func (s *SourceMongodbV2) GetDiscoverTimeoutSeconds() *int64 {
	if s == nil {
		return nil
	}
	return s.DiscoverTimeoutSeconds
}

func (s *SourceMongodbV2) GetInitialLoadTimeoutHours() *int64 {
	if s == nil {
		return nil
	}
	return s.InitialLoadTimeoutHours
}

func (s *SourceMongodbV2) GetInitialWaitingSeconds() *int64 {
	if s == nil {
		return nil
	}
	return s.InitialWaitingSeconds
}

func (s *SourceMongodbV2) GetInvalidCdcCursorPositionBehavior() *InvalidCDCPositionBehaviorAdvanced {
	if s == nil {
		return nil
	}
	return s.InvalidCdcCursorPositionBehavior
}

func (s *SourceMongodbV2) GetQueueSize() *int64 {
	if s == nil {
		return nil
	}
	return s.QueueSize
}

func (s *SourceMongodbV2) GetUpdateCaptureMode() *CaptureModeAdvanced {
	if s == nil {
		return nil
	}
	return s.UpdateCaptureMode
}

func (s *SourceMongodbV2) GetSourceType() *SourceMongodbV2SourceType {
	return SourceMongodbV2SourceTypeMongodbV2.ToPointer()
}

func (s *SourceMongodbV2) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}
