// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

type SourceOracleEnterpriseUpdateSchemasConnectionType string

const (
	SourceOracleEnterpriseUpdateSchemasConnectionTypeSid SourceOracleEnterpriseUpdateSchemasConnectionType = "sid"
)

func (e SourceOracleEnterpriseUpdateSchemasConnectionType) ToPointer() *SourceOracleEnterpriseUpdateSchemasConnectionType {
	return &e
}
func (e *SourceOracleEnterpriseUpdateSchemasConnectionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "sid":
		*e = SourceOracleEnterpriseUpdateSchemasConnectionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceOracleEnterpriseUpdateSchemasConnectionType: %v", v)
	}
}

// SourceOracleEnterpriseUpdateSystemIDSID - Use Oracle System Identifier.
type SourceOracleEnterpriseUpdateSystemIDSID struct {
	ConnectionType       *SourceOracleEnterpriseUpdateSchemasConnectionType `default:"sid" json:"connection_type"`
	Sid                  *string                                            `json:"sid,omitempty"`
	AdditionalProperties any                                                `additionalProperties:"true" json:"-"`
}

func (s SourceOracleEnterpriseUpdateSystemIDSID) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceOracleEnterpriseUpdateSystemIDSID) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceOracleEnterpriseUpdateSystemIDSID) GetConnectionType() *SourceOracleEnterpriseUpdateSchemasConnectionType {
	if s == nil {
		return nil
	}
	return s.ConnectionType
}

func (s *SourceOracleEnterpriseUpdateSystemIDSID) GetSid() *string {
	if s == nil {
		return nil
	}
	return s.Sid
}

func (s *SourceOracleEnterpriseUpdateSystemIDSID) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceOracleEnterpriseUpdateConnectionType string

const (
	SourceOracleEnterpriseUpdateConnectionTypeServiceName SourceOracleEnterpriseUpdateConnectionType = "service_name"
)

func (e SourceOracleEnterpriseUpdateConnectionType) ToPointer() *SourceOracleEnterpriseUpdateConnectionType {
	return &e
}
func (e *SourceOracleEnterpriseUpdateConnectionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "service_name":
		*e = SourceOracleEnterpriseUpdateConnectionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceOracleEnterpriseUpdateConnectionType: %v", v)
	}
}

// SourceOracleEnterpriseUpdateServiceName - Use service name.
type SourceOracleEnterpriseUpdateServiceName struct {
	ConnectionType       *SourceOracleEnterpriseUpdateConnectionType `default:"service_name" json:"connection_type"`
	ServiceName          *string                                     `json:"service_name,omitempty"`
	AdditionalProperties any                                         `additionalProperties:"true" json:"-"`
}

func (s SourceOracleEnterpriseUpdateServiceName) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceOracleEnterpriseUpdateServiceName) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceOracleEnterpriseUpdateServiceName) GetConnectionType() *SourceOracleEnterpriseUpdateConnectionType {
	if s == nil {
		return nil
	}
	return s.ConnectionType
}

func (s *SourceOracleEnterpriseUpdateServiceName) GetServiceName() *string {
	if s == nil {
		return nil
	}
	return s.ServiceName
}

func (s *SourceOracleEnterpriseUpdateServiceName) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceOracleEnterpriseUpdateConnectByType string

const (
	SourceOracleEnterpriseUpdateConnectByTypeSourceOracleEnterpriseUpdateServiceName SourceOracleEnterpriseUpdateConnectByType = "source-oracle-enterprise-update_Service name"
	SourceOracleEnterpriseUpdateConnectByTypeSourceOracleEnterpriseUpdateSystemIDSID SourceOracleEnterpriseUpdateConnectByType = "source-oracle-enterprise-update_System ID (SID)"
)

// SourceOracleEnterpriseUpdateConnectBy - The scheme by which to establish a database connection.
type SourceOracleEnterpriseUpdateConnectBy struct {
	SourceOracleEnterpriseUpdateServiceName *SourceOracleEnterpriseUpdateServiceName `queryParam:"inline" union:"member"`
	SourceOracleEnterpriseUpdateSystemIDSID *SourceOracleEnterpriseUpdateSystemIDSID `queryParam:"inline" union:"member"`

	Type SourceOracleEnterpriseUpdateConnectByType
}

func CreateSourceOracleEnterpriseUpdateConnectBySourceOracleEnterpriseUpdateServiceName(sourceOracleEnterpriseUpdateServiceName SourceOracleEnterpriseUpdateServiceName) SourceOracleEnterpriseUpdateConnectBy {
	typ := SourceOracleEnterpriseUpdateConnectByTypeSourceOracleEnterpriseUpdateServiceName

	return SourceOracleEnterpriseUpdateConnectBy{
		SourceOracleEnterpriseUpdateServiceName: &sourceOracleEnterpriseUpdateServiceName,
		Type:                                    typ,
	}
}

func CreateSourceOracleEnterpriseUpdateConnectBySourceOracleEnterpriseUpdateSystemIDSID(sourceOracleEnterpriseUpdateSystemIDSID SourceOracleEnterpriseUpdateSystemIDSID) SourceOracleEnterpriseUpdateConnectBy {
	typ := SourceOracleEnterpriseUpdateConnectByTypeSourceOracleEnterpriseUpdateSystemIDSID

	return SourceOracleEnterpriseUpdateConnectBy{
		SourceOracleEnterpriseUpdateSystemIDSID: &sourceOracleEnterpriseUpdateSystemIDSID,
		Type:                                    typ,
	}
}

func (u *SourceOracleEnterpriseUpdateConnectBy) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var sourceOracleEnterpriseUpdateServiceName SourceOracleEnterpriseUpdateServiceName = SourceOracleEnterpriseUpdateServiceName{}
	if err := utils.UnmarshalJSON(data, &sourceOracleEnterpriseUpdateServiceName, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceOracleEnterpriseUpdateConnectByTypeSourceOracleEnterpriseUpdateServiceName,
			Value: &sourceOracleEnterpriseUpdateServiceName,
		})
	}

	var sourceOracleEnterpriseUpdateSystemIDSID SourceOracleEnterpriseUpdateSystemIDSID = SourceOracleEnterpriseUpdateSystemIDSID{}
	if err := utils.UnmarshalJSON(data, &sourceOracleEnterpriseUpdateSystemIDSID, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceOracleEnterpriseUpdateConnectByTypeSourceOracleEnterpriseUpdateSystemIDSID,
			Value: &sourceOracleEnterpriseUpdateSystemIDSID,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceOracleEnterpriseUpdateConnectBy", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceOracleEnterpriseUpdateConnectBy", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceOracleEnterpriseUpdateConnectByType)
	switch best.Type {
	case SourceOracleEnterpriseUpdateConnectByTypeSourceOracleEnterpriseUpdateServiceName:
		u.SourceOracleEnterpriseUpdateServiceName = best.Value.(*SourceOracleEnterpriseUpdateServiceName)
		return nil
	case SourceOracleEnterpriseUpdateConnectByTypeSourceOracleEnterpriseUpdateSystemIDSID:
		u.SourceOracleEnterpriseUpdateSystemIDSID = best.Value.(*SourceOracleEnterpriseUpdateSystemIDSID)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceOracleEnterpriseUpdateConnectBy", string(data))
}

func (u SourceOracleEnterpriseUpdateConnectBy) MarshalJSON() ([]byte, error) {
	if u.SourceOracleEnterpriseUpdateServiceName != nil {
		return utils.MarshalJSON(u.SourceOracleEnterpriseUpdateServiceName, "", true)
	}

	if u.SourceOracleEnterpriseUpdateSystemIDSID != nil {
		return utils.MarshalJSON(u.SourceOracleEnterpriseUpdateSystemIDSID, "", true)
	}

	return nil, errors.New("could not marshal union type SourceOracleEnterpriseUpdateConnectBy: all fields are null")
}

type SourceOracleEnterpriseUpdateSchemasCursorMethod string

const (
	SourceOracleEnterpriseUpdateSchemasCursorMethodCdc SourceOracleEnterpriseUpdateSchemasCursorMethod = "cdc"
)

func (e SourceOracleEnterpriseUpdateSchemasCursorMethod) ToPointer() *SourceOracleEnterpriseUpdateSchemasCursorMethod {
	return &e
}
func (e *SourceOracleEnterpriseUpdateSchemasCursorMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "cdc":
		*e = SourceOracleEnterpriseUpdateSchemasCursorMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceOracleEnterpriseUpdateSchemasCursorMethod: %v", v)
	}
}

// SourceOracleEnterpriseUpdateInvalidCDCPositionBehaviorAdvanced - Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value in the mined logs. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss.
type SourceOracleEnterpriseUpdateInvalidCDCPositionBehaviorAdvanced string

const (
	SourceOracleEnterpriseUpdateInvalidCDCPositionBehaviorAdvancedFailSync   SourceOracleEnterpriseUpdateInvalidCDCPositionBehaviorAdvanced = "Fail sync"
	SourceOracleEnterpriseUpdateInvalidCDCPositionBehaviorAdvancedReSyncData SourceOracleEnterpriseUpdateInvalidCDCPositionBehaviorAdvanced = "Re-sync data"
)

func (e SourceOracleEnterpriseUpdateInvalidCDCPositionBehaviorAdvanced) ToPointer() *SourceOracleEnterpriseUpdateInvalidCDCPositionBehaviorAdvanced {
	return &e
}
func (e *SourceOracleEnterpriseUpdateInvalidCDCPositionBehaviorAdvanced) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Fail sync":
		fallthrough
	case "Re-sync data":
		*e = SourceOracleEnterpriseUpdateInvalidCDCPositionBehaviorAdvanced(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceOracleEnterpriseUpdateInvalidCDCPositionBehaviorAdvanced: %v", v)
	}
}

// SourceOracleEnterpriseUpdateReadChangesUsingChangeDataCaptureCDC - <i>Recommended</i> - Incrementally reads new inserts, updates, and deletes using Oracle's <a href="https://docs.airbyte.com/integrations/enterprise-connectors/source-oracle#getting-started"> change data capture feature</a>. This must be enabled on your database.
type SourceOracleEnterpriseUpdateReadChangesUsingChangeDataCaptureCDC struct {
	CursorMethod *SourceOracleEnterpriseUpdateSchemasCursorMethod `default:"cdc" json:"cursor_method"`
	// The amount of time to allow the Debezium Engine to shut down, in seconds.
	DebeziumShutdownTimeoutSeconds *int64 `default:"60" json:"debezium_shutdown_timeout_seconds"`
	// The amount of time an initial load is allowed to continue for before catching up on CDC events.
	InitialLoadTimeoutHours *int64 `default:"8" json:"initial_load_timeout_hours"`
	// Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value in the mined logs. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss.
	InvalidCdcCursorPositionBehavior *SourceOracleEnterpriseUpdateInvalidCDCPositionBehaviorAdvanced `default:"Fail sync" json:"invalid_cdc_cursor_position_behavior"`
	AdditionalProperties             any                                                             `additionalProperties:"true" json:"-"`
}

func (s SourceOracleEnterpriseUpdateReadChangesUsingChangeDataCaptureCDC) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceOracleEnterpriseUpdateReadChangesUsingChangeDataCaptureCDC) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceOracleEnterpriseUpdateReadChangesUsingChangeDataCaptureCDC) GetCursorMethod() *SourceOracleEnterpriseUpdateSchemasCursorMethod {
	if s == nil {
		return nil
	}
	return s.CursorMethod
}

func (s *SourceOracleEnterpriseUpdateReadChangesUsingChangeDataCaptureCDC) GetDebeziumShutdownTimeoutSeconds() *int64 {
	if s == nil {
		return nil
	}
	return s.DebeziumShutdownTimeoutSeconds
}

func (s *SourceOracleEnterpriseUpdateReadChangesUsingChangeDataCaptureCDC) GetInitialLoadTimeoutHours() *int64 {
	if s == nil {
		return nil
	}
	return s.InitialLoadTimeoutHours
}

func (s *SourceOracleEnterpriseUpdateReadChangesUsingChangeDataCaptureCDC) GetInvalidCdcCursorPositionBehavior() *SourceOracleEnterpriseUpdateInvalidCDCPositionBehaviorAdvanced {
	if s == nil {
		return nil
	}
	return s.InvalidCdcCursorPositionBehavior
}

func (s *SourceOracleEnterpriseUpdateReadChangesUsingChangeDataCaptureCDC) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceOracleEnterpriseUpdateCursorMethod string

const (
	SourceOracleEnterpriseUpdateCursorMethodUserDefined SourceOracleEnterpriseUpdateCursorMethod = "user_defined"
)

func (e SourceOracleEnterpriseUpdateCursorMethod) ToPointer() *SourceOracleEnterpriseUpdateCursorMethod {
	return &e
}
func (e *SourceOracleEnterpriseUpdateCursorMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "user_defined":
		*e = SourceOracleEnterpriseUpdateCursorMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceOracleEnterpriseUpdateCursorMethod: %v", v)
	}
}

// SourceOracleEnterpriseUpdateScanChangesWithUserDefinedCursor - Incrementally detects new inserts and updates using the <a href="https://docs.airbyte.com/understanding-airbyte/connections/incremental-append/#user-defined-cursor">cursor column</a> chosen when configuring a connection (e.g. created_at, updated_at).
type SourceOracleEnterpriseUpdateScanChangesWithUserDefinedCursor struct {
	CursorMethod         *SourceOracleEnterpriseUpdateCursorMethod `default:"user_defined" json:"cursor_method"`
	AdditionalProperties any                                       `additionalProperties:"true" json:"-"`
}

func (s SourceOracleEnterpriseUpdateScanChangesWithUserDefinedCursor) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceOracleEnterpriseUpdateScanChangesWithUserDefinedCursor) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceOracleEnterpriseUpdateScanChangesWithUserDefinedCursor) GetCursorMethod() *SourceOracleEnterpriseUpdateCursorMethod {
	if s == nil {
		return nil
	}
	return s.CursorMethod
}

func (s *SourceOracleEnterpriseUpdateScanChangesWithUserDefinedCursor) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceOracleEnterpriseUpdateUpdateMethodType string

const (
	SourceOracleEnterpriseUpdateUpdateMethodTypeSourceOracleEnterpriseUpdateScanChangesWithUserDefinedCursor     SourceOracleEnterpriseUpdateUpdateMethodType = "source-oracle-enterprise-update_Scan Changes with User Defined Cursor"
	SourceOracleEnterpriseUpdateUpdateMethodTypeSourceOracleEnterpriseUpdateReadChangesUsingChangeDataCaptureCDC SourceOracleEnterpriseUpdateUpdateMethodType = "source-oracle-enterprise-update_Read Changes using Change Data Capture (CDC)"
)

// SourceOracleEnterpriseUpdateUpdateMethod - Configures how data is extracted from the database.
type SourceOracleEnterpriseUpdateUpdateMethod struct {
	SourceOracleEnterpriseUpdateScanChangesWithUserDefinedCursor     *SourceOracleEnterpriseUpdateScanChangesWithUserDefinedCursor     `queryParam:"inline" union:"member"`
	SourceOracleEnterpriseUpdateReadChangesUsingChangeDataCaptureCDC *SourceOracleEnterpriseUpdateReadChangesUsingChangeDataCaptureCDC `queryParam:"inline" union:"member"`

	Type SourceOracleEnterpriseUpdateUpdateMethodType
}

func CreateSourceOracleEnterpriseUpdateUpdateMethodSourceOracleEnterpriseUpdateScanChangesWithUserDefinedCursor(sourceOracleEnterpriseUpdateScanChangesWithUserDefinedCursor SourceOracleEnterpriseUpdateScanChangesWithUserDefinedCursor) SourceOracleEnterpriseUpdateUpdateMethod {
	typ := SourceOracleEnterpriseUpdateUpdateMethodTypeSourceOracleEnterpriseUpdateScanChangesWithUserDefinedCursor

	return SourceOracleEnterpriseUpdateUpdateMethod{
		SourceOracleEnterpriseUpdateScanChangesWithUserDefinedCursor: &sourceOracleEnterpriseUpdateScanChangesWithUserDefinedCursor,
		Type: typ,
	}
}

func CreateSourceOracleEnterpriseUpdateUpdateMethodSourceOracleEnterpriseUpdateReadChangesUsingChangeDataCaptureCDC(sourceOracleEnterpriseUpdateReadChangesUsingChangeDataCaptureCDC SourceOracleEnterpriseUpdateReadChangesUsingChangeDataCaptureCDC) SourceOracleEnterpriseUpdateUpdateMethod {
	typ := SourceOracleEnterpriseUpdateUpdateMethodTypeSourceOracleEnterpriseUpdateReadChangesUsingChangeDataCaptureCDC

	return SourceOracleEnterpriseUpdateUpdateMethod{
		SourceOracleEnterpriseUpdateReadChangesUsingChangeDataCaptureCDC: &sourceOracleEnterpriseUpdateReadChangesUsingChangeDataCaptureCDC,
		Type: typ,
	}
}

func (u *SourceOracleEnterpriseUpdateUpdateMethod) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var sourceOracleEnterpriseUpdateScanChangesWithUserDefinedCursor SourceOracleEnterpriseUpdateScanChangesWithUserDefinedCursor = SourceOracleEnterpriseUpdateScanChangesWithUserDefinedCursor{}
	if err := utils.UnmarshalJSON(data, &sourceOracleEnterpriseUpdateScanChangesWithUserDefinedCursor, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceOracleEnterpriseUpdateUpdateMethodTypeSourceOracleEnterpriseUpdateScanChangesWithUserDefinedCursor,
			Value: &sourceOracleEnterpriseUpdateScanChangesWithUserDefinedCursor,
		})
	}

	var sourceOracleEnterpriseUpdateReadChangesUsingChangeDataCaptureCDC SourceOracleEnterpriseUpdateReadChangesUsingChangeDataCaptureCDC = SourceOracleEnterpriseUpdateReadChangesUsingChangeDataCaptureCDC{}
	if err := utils.UnmarshalJSON(data, &sourceOracleEnterpriseUpdateReadChangesUsingChangeDataCaptureCDC, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceOracleEnterpriseUpdateUpdateMethodTypeSourceOracleEnterpriseUpdateReadChangesUsingChangeDataCaptureCDC,
			Value: &sourceOracleEnterpriseUpdateReadChangesUsingChangeDataCaptureCDC,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceOracleEnterpriseUpdateUpdateMethod", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceOracleEnterpriseUpdateUpdateMethod", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceOracleEnterpriseUpdateUpdateMethodType)
	switch best.Type {
	case SourceOracleEnterpriseUpdateUpdateMethodTypeSourceOracleEnterpriseUpdateScanChangesWithUserDefinedCursor:
		u.SourceOracleEnterpriseUpdateScanChangesWithUserDefinedCursor = best.Value.(*SourceOracleEnterpriseUpdateScanChangesWithUserDefinedCursor)
		return nil
	case SourceOracleEnterpriseUpdateUpdateMethodTypeSourceOracleEnterpriseUpdateReadChangesUsingChangeDataCaptureCDC:
		u.SourceOracleEnterpriseUpdateReadChangesUsingChangeDataCaptureCDC = best.Value.(*SourceOracleEnterpriseUpdateReadChangesUsingChangeDataCaptureCDC)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceOracleEnterpriseUpdateUpdateMethod", string(data))
}

func (u SourceOracleEnterpriseUpdateUpdateMethod) MarshalJSON() ([]byte, error) {
	if u.SourceOracleEnterpriseUpdateScanChangesWithUserDefinedCursor != nil {
		return utils.MarshalJSON(u.SourceOracleEnterpriseUpdateScanChangesWithUserDefinedCursor, "", true)
	}

	if u.SourceOracleEnterpriseUpdateReadChangesUsingChangeDataCaptureCDC != nil {
		return utils.MarshalJSON(u.SourceOracleEnterpriseUpdateReadChangesUsingChangeDataCaptureCDC, "", true)
	}

	return nil, errors.New("could not marshal union type SourceOracleEnterpriseUpdateUpdateMethod: all fields are null")
}

type SourceOracleEnterpriseUpdateSchemasEncryptionEncryptionMethod string

const (
	SourceOracleEnterpriseUpdateSchemasEncryptionEncryptionMethodEncryptedVerifyCertificate SourceOracleEnterpriseUpdateSchemasEncryptionEncryptionMethod = "encrypted_verify_certificate"
)

func (e SourceOracleEnterpriseUpdateSchemasEncryptionEncryptionMethod) ToPointer() *SourceOracleEnterpriseUpdateSchemasEncryptionEncryptionMethod {
	return &e
}
func (e *SourceOracleEnterpriseUpdateSchemasEncryptionEncryptionMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "encrypted_verify_certificate":
		*e = SourceOracleEnterpriseUpdateSchemasEncryptionEncryptionMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceOracleEnterpriseUpdateSchemasEncryptionEncryptionMethod: %v", v)
	}
}

// SourceOracleEnterpriseUpdateTLSEncryptedVerifyCertificate - Verify and use the certificate provided by the server.
type SourceOracleEnterpriseUpdateTLSEncryptedVerifyCertificate struct {
	EncryptionMethod *SourceOracleEnterpriseUpdateSchemasEncryptionEncryptionMethod `default:"encrypted_verify_certificate" json:"encryption_method"`
	// Privacy Enhanced Mail (PEM) files are concatenated certificate containers frequently used in certificate installations.
	SslCertificate       *string `json:"ssl_certificate,omitempty"`
	AdditionalProperties any     `additionalProperties:"true" json:"-"`
}

func (s SourceOracleEnterpriseUpdateTLSEncryptedVerifyCertificate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceOracleEnterpriseUpdateTLSEncryptedVerifyCertificate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceOracleEnterpriseUpdateTLSEncryptedVerifyCertificate) GetEncryptionMethod() *SourceOracleEnterpriseUpdateSchemasEncryptionEncryptionMethod {
	if s == nil {
		return nil
	}
	return s.EncryptionMethod
}

func (s *SourceOracleEnterpriseUpdateTLSEncryptedVerifyCertificate) GetSslCertificate() *string {
	if s == nil {
		return nil
	}
	return s.SslCertificate
}

func (s *SourceOracleEnterpriseUpdateTLSEncryptedVerifyCertificate) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

// SourceOracleEnterpriseUpdateEncryptionAlgorithm - This parameter defines what encryption algorithm is used.
type SourceOracleEnterpriseUpdateEncryptionAlgorithm string

const (
	SourceOracleEnterpriseUpdateEncryptionAlgorithmAes256      SourceOracleEnterpriseUpdateEncryptionAlgorithm = "AES256"
	SourceOracleEnterpriseUpdateEncryptionAlgorithmAes192      SourceOracleEnterpriseUpdateEncryptionAlgorithm = "AES192"
	SourceOracleEnterpriseUpdateEncryptionAlgorithmAes128      SourceOracleEnterpriseUpdateEncryptionAlgorithm = "AES128"
	SourceOracleEnterpriseUpdateEncryptionAlgorithmThreeDes168 SourceOracleEnterpriseUpdateEncryptionAlgorithm = "3DES168"
	SourceOracleEnterpriseUpdateEncryptionAlgorithmThreeDes112 SourceOracleEnterpriseUpdateEncryptionAlgorithm = "3DES112"
	SourceOracleEnterpriseUpdateEncryptionAlgorithmDes         SourceOracleEnterpriseUpdateEncryptionAlgorithm = "DES"
)

func (e SourceOracleEnterpriseUpdateEncryptionAlgorithm) ToPointer() *SourceOracleEnterpriseUpdateEncryptionAlgorithm {
	return &e
}
func (e *SourceOracleEnterpriseUpdateEncryptionAlgorithm) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "AES256":
		fallthrough
	case "AES192":
		fallthrough
	case "AES128":
		fallthrough
	case "3DES168":
		fallthrough
	case "3DES112":
		fallthrough
	case "DES":
		*e = SourceOracleEnterpriseUpdateEncryptionAlgorithm(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceOracleEnterpriseUpdateEncryptionAlgorithm: %v", v)
	}
}

type SourceOracleEnterpriseUpdateSchemasEncryptionMethod string

const (
	SourceOracleEnterpriseUpdateSchemasEncryptionMethodClientNne SourceOracleEnterpriseUpdateSchemasEncryptionMethod = "client_nne"
)

func (e SourceOracleEnterpriseUpdateSchemasEncryptionMethod) ToPointer() *SourceOracleEnterpriseUpdateSchemasEncryptionMethod {
	return &e
}
func (e *SourceOracleEnterpriseUpdateSchemasEncryptionMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "client_nne":
		*e = SourceOracleEnterpriseUpdateSchemasEncryptionMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceOracleEnterpriseUpdateSchemasEncryptionMethod: %v", v)
	}
}

// SourceOracleEnterpriseUpdateNativeNetworkEncryptionNNE - The native network encryption gives you the ability to encrypt database connections, without the configuration overhead of TCP/IP and SSL/TLS and without the need to open and listen on different ports.
type SourceOracleEnterpriseUpdateNativeNetworkEncryptionNNE struct {
	// This parameter defines what encryption algorithm is used.
	EncryptionAlgorithm  *SourceOracleEnterpriseUpdateEncryptionAlgorithm     `default:"AES256" json:"encryption_algorithm"`
	EncryptionMethod     *SourceOracleEnterpriseUpdateSchemasEncryptionMethod `default:"client_nne" json:"encryption_method"`
	AdditionalProperties any                                                  `additionalProperties:"true" json:"-"`
}

func (s SourceOracleEnterpriseUpdateNativeNetworkEncryptionNNE) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceOracleEnterpriseUpdateNativeNetworkEncryptionNNE) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceOracleEnterpriseUpdateNativeNetworkEncryptionNNE) GetEncryptionAlgorithm() *SourceOracleEnterpriseUpdateEncryptionAlgorithm {
	if s == nil {
		return nil
	}
	return s.EncryptionAlgorithm
}

func (s *SourceOracleEnterpriseUpdateNativeNetworkEncryptionNNE) GetEncryptionMethod() *SourceOracleEnterpriseUpdateSchemasEncryptionMethod {
	if s == nil {
		return nil
	}
	return s.EncryptionMethod
}

func (s *SourceOracleEnterpriseUpdateNativeNetworkEncryptionNNE) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceOracleEnterpriseUpdateEncryptionMethod string

const (
	SourceOracleEnterpriseUpdateEncryptionMethodUnencrypted SourceOracleEnterpriseUpdateEncryptionMethod = "unencrypted"
)

func (e SourceOracleEnterpriseUpdateEncryptionMethod) ToPointer() *SourceOracleEnterpriseUpdateEncryptionMethod {
	return &e
}
func (e *SourceOracleEnterpriseUpdateEncryptionMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "unencrypted":
		*e = SourceOracleEnterpriseUpdateEncryptionMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceOracleEnterpriseUpdateEncryptionMethod: %v", v)
	}
}

// SourceOracleEnterpriseUpdateUnencrypted - Data transfer will not be encrypted.
type SourceOracleEnterpriseUpdateUnencrypted struct {
	EncryptionMethod     *SourceOracleEnterpriseUpdateEncryptionMethod `default:"unencrypted" json:"encryption_method"`
	AdditionalProperties any                                           `additionalProperties:"true" json:"-"`
}

func (s SourceOracleEnterpriseUpdateUnencrypted) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceOracleEnterpriseUpdateUnencrypted) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceOracleEnterpriseUpdateUnencrypted) GetEncryptionMethod() *SourceOracleEnterpriseUpdateEncryptionMethod {
	if s == nil {
		return nil
	}
	return s.EncryptionMethod
}

func (s *SourceOracleEnterpriseUpdateUnencrypted) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceOracleEnterpriseUpdateEncryptionType string

const (
	SourceOracleEnterpriseUpdateEncryptionTypeSourceOracleEnterpriseUpdateUnencrypted                   SourceOracleEnterpriseUpdateEncryptionType = "source-oracle-enterprise-update_Unencrypted"
	SourceOracleEnterpriseUpdateEncryptionTypeSourceOracleEnterpriseUpdateNativeNetworkEncryptionNNE    SourceOracleEnterpriseUpdateEncryptionType = "source-oracle-enterprise-update_Native Network Encryption (NNE)"
	SourceOracleEnterpriseUpdateEncryptionTypeSourceOracleEnterpriseUpdateTLSEncryptedVerifyCertificate SourceOracleEnterpriseUpdateEncryptionType = "source-oracle-enterprise-update_TLS Encrypted (verify certificate)"
)

// SourceOracleEnterpriseUpdateEncryption - The encryption method with is used when communicating with the database.
type SourceOracleEnterpriseUpdateEncryption struct {
	SourceOracleEnterpriseUpdateUnencrypted                   *SourceOracleEnterpriseUpdateUnencrypted                   `queryParam:"inline" union:"member"`
	SourceOracleEnterpriseUpdateNativeNetworkEncryptionNNE    *SourceOracleEnterpriseUpdateNativeNetworkEncryptionNNE    `queryParam:"inline" union:"member"`
	SourceOracleEnterpriseUpdateTLSEncryptedVerifyCertificate *SourceOracleEnterpriseUpdateTLSEncryptedVerifyCertificate `queryParam:"inline" union:"member"`

	Type SourceOracleEnterpriseUpdateEncryptionType
}

func CreateSourceOracleEnterpriseUpdateEncryptionSourceOracleEnterpriseUpdateUnencrypted(sourceOracleEnterpriseUpdateUnencrypted SourceOracleEnterpriseUpdateUnencrypted) SourceOracleEnterpriseUpdateEncryption {
	typ := SourceOracleEnterpriseUpdateEncryptionTypeSourceOracleEnterpriseUpdateUnencrypted

	return SourceOracleEnterpriseUpdateEncryption{
		SourceOracleEnterpriseUpdateUnencrypted: &sourceOracleEnterpriseUpdateUnencrypted,
		Type:                                    typ,
	}
}

func CreateSourceOracleEnterpriseUpdateEncryptionSourceOracleEnterpriseUpdateNativeNetworkEncryptionNNE(sourceOracleEnterpriseUpdateNativeNetworkEncryptionNNE SourceOracleEnterpriseUpdateNativeNetworkEncryptionNNE) SourceOracleEnterpriseUpdateEncryption {
	typ := SourceOracleEnterpriseUpdateEncryptionTypeSourceOracleEnterpriseUpdateNativeNetworkEncryptionNNE

	return SourceOracleEnterpriseUpdateEncryption{
		SourceOracleEnterpriseUpdateNativeNetworkEncryptionNNE: &sourceOracleEnterpriseUpdateNativeNetworkEncryptionNNE,
		Type: typ,
	}
}

func CreateSourceOracleEnterpriseUpdateEncryptionSourceOracleEnterpriseUpdateTLSEncryptedVerifyCertificate(sourceOracleEnterpriseUpdateTLSEncryptedVerifyCertificate SourceOracleEnterpriseUpdateTLSEncryptedVerifyCertificate) SourceOracleEnterpriseUpdateEncryption {
	typ := SourceOracleEnterpriseUpdateEncryptionTypeSourceOracleEnterpriseUpdateTLSEncryptedVerifyCertificate

	return SourceOracleEnterpriseUpdateEncryption{
		SourceOracleEnterpriseUpdateTLSEncryptedVerifyCertificate: &sourceOracleEnterpriseUpdateTLSEncryptedVerifyCertificate,
		Type: typ,
	}
}

func (u *SourceOracleEnterpriseUpdateEncryption) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var sourceOracleEnterpriseUpdateUnencrypted SourceOracleEnterpriseUpdateUnencrypted = SourceOracleEnterpriseUpdateUnencrypted{}
	if err := utils.UnmarshalJSON(data, &sourceOracleEnterpriseUpdateUnencrypted, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceOracleEnterpriseUpdateEncryptionTypeSourceOracleEnterpriseUpdateUnencrypted,
			Value: &sourceOracleEnterpriseUpdateUnencrypted,
		})
	}

	var sourceOracleEnterpriseUpdateNativeNetworkEncryptionNNE SourceOracleEnterpriseUpdateNativeNetworkEncryptionNNE = SourceOracleEnterpriseUpdateNativeNetworkEncryptionNNE{}
	if err := utils.UnmarshalJSON(data, &sourceOracleEnterpriseUpdateNativeNetworkEncryptionNNE, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceOracleEnterpriseUpdateEncryptionTypeSourceOracleEnterpriseUpdateNativeNetworkEncryptionNNE,
			Value: &sourceOracleEnterpriseUpdateNativeNetworkEncryptionNNE,
		})
	}

	var sourceOracleEnterpriseUpdateTLSEncryptedVerifyCertificate SourceOracleEnterpriseUpdateTLSEncryptedVerifyCertificate = SourceOracleEnterpriseUpdateTLSEncryptedVerifyCertificate{}
	if err := utils.UnmarshalJSON(data, &sourceOracleEnterpriseUpdateTLSEncryptedVerifyCertificate, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceOracleEnterpriseUpdateEncryptionTypeSourceOracleEnterpriseUpdateTLSEncryptedVerifyCertificate,
			Value: &sourceOracleEnterpriseUpdateTLSEncryptedVerifyCertificate,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceOracleEnterpriseUpdateEncryption", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceOracleEnterpriseUpdateEncryption", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceOracleEnterpriseUpdateEncryptionType)
	switch best.Type {
	case SourceOracleEnterpriseUpdateEncryptionTypeSourceOracleEnterpriseUpdateUnencrypted:
		u.SourceOracleEnterpriseUpdateUnencrypted = best.Value.(*SourceOracleEnterpriseUpdateUnencrypted)
		return nil
	case SourceOracleEnterpriseUpdateEncryptionTypeSourceOracleEnterpriseUpdateNativeNetworkEncryptionNNE:
		u.SourceOracleEnterpriseUpdateNativeNetworkEncryptionNNE = best.Value.(*SourceOracleEnterpriseUpdateNativeNetworkEncryptionNNE)
		return nil
	case SourceOracleEnterpriseUpdateEncryptionTypeSourceOracleEnterpriseUpdateTLSEncryptedVerifyCertificate:
		u.SourceOracleEnterpriseUpdateTLSEncryptedVerifyCertificate = best.Value.(*SourceOracleEnterpriseUpdateTLSEncryptedVerifyCertificate)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceOracleEnterpriseUpdateEncryption", string(data))
}

func (u SourceOracleEnterpriseUpdateEncryption) MarshalJSON() ([]byte, error) {
	if u.SourceOracleEnterpriseUpdateUnencrypted != nil {
		return utils.MarshalJSON(u.SourceOracleEnterpriseUpdateUnencrypted, "", true)
	}

	if u.SourceOracleEnterpriseUpdateNativeNetworkEncryptionNNE != nil {
		return utils.MarshalJSON(u.SourceOracleEnterpriseUpdateNativeNetworkEncryptionNNE, "", true)
	}

	if u.SourceOracleEnterpriseUpdateTLSEncryptedVerifyCertificate != nil {
		return utils.MarshalJSON(u.SourceOracleEnterpriseUpdateTLSEncryptedVerifyCertificate, "", true)
	}

	return nil, errors.New("could not marshal union type SourceOracleEnterpriseUpdateEncryption: all fields are null")
}

// SourceOracleEnterpriseUpdateTableFilter - Inclusion filter configuration for table selection per schema.
type SourceOracleEnterpriseUpdateTableFilter struct {
	// The name of the schema to apply this filter to. Should match a schema defined in "Schemas" field above.
	SchemaName *string `json:"schema_name,omitempty"`
	// List of table name patterns to include from this schema. Should be a SQL LIKE pattern.
	TableNamePatterns    []string `json:"table_name_patterns,omitempty"`
	AdditionalProperties any      `additionalProperties:"true" json:"-"`
}

func (s SourceOracleEnterpriseUpdateTableFilter) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceOracleEnterpriseUpdateTableFilter) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceOracleEnterpriseUpdateTableFilter) GetSchemaName() *string {
	if s == nil {
		return nil
	}
	return s.SchemaName
}

func (s *SourceOracleEnterpriseUpdateTableFilter) GetTableNamePatterns() []string {
	if s == nil {
		return nil
	}
	return s.TableNamePatterns
}

func (s *SourceOracleEnterpriseUpdateTableFilter) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceOracleEnterpriseUpdateSchemasTunnelMethodTunnelMethod string

const (
	SourceOracleEnterpriseUpdateSchemasTunnelMethodTunnelMethodSSHPasswordAuth SourceOracleEnterpriseUpdateSchemasTunnelMethodTunnelMethod = "SSH_PASSWORD_AUTH"
)

func (e SourceOracleEnterpriseUpdateSchemasTunnelMethodTunnelMethod) ToPointer() *SourceOracleEnterpriseUpdateSchemasTunnelMethodTunnelMethod {
	return &e
}
func (e *SourceOracleEnterpriseUpdateSchemasTunnelMethodTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_PASSWORD_AUTH":
		*e = SourceOracleEnterpriseUpdateSchemasTunnelMethodTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceOracleEnterpriseUpdateSchemasTunnelMethodTunnelMethod: %v", v)
	}
}

// SourceOracleEnterpriseUpdatePasswordAuthentication - Connect through a jump server tunnel host using username and password authentication
type SourceOracleEnterpriseUpdatePasswordAuthentication struct {
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost   *string                                                      `json:"tunnel_host,omitempty"`
	TunnelMethod *SourceOracleEnterpriseUpdateSchemasTunnelMethodTunnelMethod `default:"SSH_PASSWORD_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser *string `json:"tunnel_user,omitempty"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword   *string `json:"tunnel_user_password,omitempty"`
	AdditionalProperties any     `additionalProperties:"true" json:"-"`
}

func (s SourceOracleEnterpriseUpdatePasswordAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceOracleEnterpriseUpdatePasswordAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceOracleEnterpriseUpdatePasswordAuthentication) GetTunnelHost() *string {
	if s == nil {
		return nil
	}
	return s.TunnelHost
}

func (s *SourceOracleEnterpriseUpdatePasswordAuthentication) GetTunnelMethod() *SourceOracleEnterpriseUpdateSchemasTunnelMethodTunnelMethod {
	if s == nil {
		return nil
	}
	return s.TunnelMethod
}

func (s *SourceOracleEnterpriseUpdatePasswordAuthentication) GetTunnelPort() *int64 {
	if s == nil {
		return nil
	}
	return s.TunnelPort
}

func (s *SourceOracleEnterpriseUpdatePasswordAuthentication) GetTunnelUser() *string {
	if s == nil {
		return nil
	}
	return s.TunnelUser
}

func (s *SourceOracleEnterpriseUpdatePasswordAuthentication) GetTunnelUserPassword() *string {
	if s == nil {
		return nil
	}
	return s.TunnelUserPassword
}

func (s *SourceOracleEnterpriseUpdatePasswordAuthentication) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceOracleEnterpriseUpdateSchemasTunnelMethod string

const (
	SourceOracleEnterpriseUpdateSchemasTunnelMethodSSHKeyAuth SourceOracleEnterpriseUpdateSchemasTunnelMethod = "SSH_KEY_AUTH"
)

func (e SourceOracleEnterpriseUpdateSchemasTunnelMethod) ToPointer() *SourceOracleEnterpriseUpdateSchemasTunnelMethod {
	return &e
}
func (e *SourceOracleEnterpriseUpdateSchemasTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_KEY_AUTH":
		*e = SourceOracleEnterpriseUpdateSchemasTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceOracleEnterpriseUpdateSchemasTunnelMethod: %v", v)
	}
}

// SourceOracleEnterpriseUpdateSSHKeyAuthentication - Connect through a jump server tunnel host using username and ssh key
type SourceOracleEnterpriseUpdateSSHKeyAuthentication struct {
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey *string `json:"ssh_key,omitempty"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost   *string                                          `json:"tunnel_host,omitempty"`
	TunnelMethod *SourceOracleEnterpriseUpdateSchemasTunnelMethod `default:"SSH_KEY_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser           *string `json:"tunnel_user,omitempty"`
	AdditionalProperties any     `additionalProperties:"true" json:"-"`
}

func (s SourceOracleEnterpriseUpdateSSHKeyAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceOracleEnterpriseUpdateSSHKeyAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceOracleEnterpriseUpdateSSHKeyAuthentication) GetSSHKey() *string {
	if s == nil {
		return nil
	}
	return s.SSHKey
}

func (s *SourceOracleEnterpriseUpdateSSHKeyAuthentication) GetTunnelHost() *string {
	if s == nil {
		return nil
	}
	return s.TunnelHost
}

func (s *SourceOracleEnterpriseUpdateSSHKeyAuthentication) GetTunnelMethod() *SourceOracleEnterpriseUpdateSchemasTunnelMethod {
	if s == nil {
		return nil
	}
	return s.TunnelMethod
}

func (s *SourceOracleEnterpriseUpdateSSHKeyAuthentication) GetTunnelPort() *int64 {
	if s == nil {
		return nil
	}
	return s.TunnelPort
}

func (s *SourceOracleEnterpriseUpdateSSHKeyAuthentication) GetTunnelUser() *string {
	if s == nil {
		return nil
	}
	return s.TunnelUser
}

func (s *SourceOracleEnterpriseUpdateSSHKeyAuthentication) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceOracleEnterpriseUpdateTunnelMethod string

const (
	SourceOracleEnterpriseUpdateTunnelMethodNoTunnel SourceOracleEnterpriseUpdateTunnelMethod = "NO_TUNNEL"
)

func (e SourceOracleEnterpriseUpdateTunnelMethod) ToPointer() *SourceOracleEnterpriseUpdateTunnelMethod {
	return &e
}
func (e *SourceOracleEnterpriseUpdateTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NO_TUNNEL":
		*e = SourceOracleEnterpriseUpdateTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceOracleEnterpriseUpdateTunnelMethod: %v", v)
	}
}

// SourceOracleEnterpriseUpdateNoTunnel - No ssh tunnel needed to connect to database
type SourceOracleEnterpriseUpdateNoTunnel struct {
	TunnelMethod         *SourceOracleEnterpriseUpdateTunnelMethod `default:"NO_TUNNEL" json:"tunnel_method"`
	AdditionalProperties any                                       `additionalProperties:"true" json:"-"`
}

func (s SourceOracleEnterpriseUpdateNoTunnel) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceOracleEnterpriseUpdateNoTunnel) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceOracleEnterpriseUpdateNoTunnel) GetTunnelMethod() *SourceOracleEnterpriseUpdateTunnelMethod {
	if s == nil {
		return nil
	}
	return s.TunnelMethod
}

func (s *SourceOracleEnterpriseUpdateNoTunnel) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceOracleEnterpriseUpdateSSHTunnelMethodType string

const (
	SourceOracleEnterpriseUpdateSSHTunnelMethodTypeSourceOracleEnterpriseUpdateNoTunnel               SourceOracleEnterpriseUpdateSSHTunnelMethodType = "source-oracle-enterprise-update_No Tunnel"
	SourceOracleEnterpriseUpdateSSHTunnelMethodTypeSourceOracleEnterpriseUpdateSSHKeyAuthentication   SourceOracleEnterpriseUpdateSSHTunnelMethodType = "source-oracle-enterprise-update_SSH Key Authentication"
	SourceOracleEnterpriseUpdateSSHTunnelMethodTypeSourceOracleEnterpriseUpdatePasswordAuthentication SourceOracleEnterpriseUpdateSSHTunnelMethodType = "source-oracle-enterprise-update_Password Authentication"
)

// SourceOracleEnterpriseUpdateSSHTunnelMethod - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceOracleEnterpriseUpdateSSHTunnelMethod struct {
	SourceOracleEnterpriseUpdateNoTunnel               *SourceOracleEnterpriseUpdateNoTunnel               `queryParam:"inline" union:"member"`
	SourceOracleEnterpriseUpdateSSHKeyAuthentication   *SourceOracleEnterpriseUpdateSSHKeyAuthentication   `queryParam:"inline" union:"member"`
	SourceOracleEnterpriseUpdatePasswordAuthentication *SourceOracleEnterpriseUpdatePasswordAuthentication `queryParam:"inline" union:"member"`

	Type SourceOracleEnterpriseUpdateSSHTunnelMethodType
}

func CreateSourceOracleEnterpriseUpdateSSHTunnelMethodSourceOracleEnterpriseUpdateNoTunnel(sourceOracleEnterpriseUpdateNoTunnel SourceOracleEnterpriseUpdateNoTunnel) SourceOracleEnterpriseUpdateSSHTunnelMethod {
	typ := SourceOracleEnterpriseUpdateSSHTunnelMethodTypeSourceOracleEnterpriseUpdateNoTunnel

	return SourceOracleEnterpriseUpdateSSHTunnelMethod{
		SourceOracleEnterpriseUpdateNoTunnel: &sourceOracleEnterpriseUpdateNoTunnel,
		Type:                                 typ,
	}
}

func CreateSourceOracleEnterpriseUpdateSSHTunnelMethodSourceOracleEnterpriseUpdateSSHKeyAuthentication(sourceOracleEnterpriseUpdateSSHKeyAuthentication SourceOracleEnterpriseUpdateSSHKeyAuthentication) SourceOracleEnterpriseUpdateSSHTunnelMethod {
	typ := SourceOracleEnterpriseUpdateSSHTunnelMethodTypeSourceOracleEnterpriseUpdateSSHKeyAuthentication

	return SourceOracleEnterpriseUpdateSSHTunnelMethod{
		SourceOracleEnterpriseUpdateSSHKeyAuthentication: &sourceOracleEnterpriseUpdateSSHKeyAuthentication,
		Type: typ,
	}
}

func CreateSourceOracleEnterpriseUpdateSSHTunnelMethodSourceOracleEnterpriseUpdatePasswordAuthentication(sourceOracleEnterpriseUpdatePasswordAuthentication SourceOracleEnterpriseUpdatePasswordAuthentication) SourceOracleEnterpriseUpdateSSHTunnelMethod {
	typ := SourceOracleEnterpriseUpdateSSHTunnelMethodTypeSourceOracleEnterpriseUpdatePasswordAuthentication

	return SourceOracleEnterpriseUpdateSSHTunnelMethod{
		SourceOracleEnterpriseUpdatePasswordAuthentication: &sourceOracleEnterpriseUpdatePasswordAuthentication,
		Type: typ,
	}
}

func (u *SourceOracleEnterpriseUpdateSSHTunnelMethod) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var sourceOracleEnterpriseUpdateNoTunnel SourceOracleEnterpriseUpdateNoTunnel = SourceOracleEnterpriseUpdateNoTunnel{}
	if err := utils.UnmarshalJSON(data, &sourceOracleEnterpriseUpdateNoTunnel, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceOracleEnterpriseUpdateSSHTunnelMethodTypeSourceOracleEnterpriseUpdateNoTunnel,
			Value: &sourceOracleEnterpriseUpdateNoTunnel,
		})
	}

	var sourceOracleEnterpriseUpdateSSHKeyAuthentication SourceOracleEnterpriseUpdateSSHKeyAuthentication = SourceOracleEnterpriseUpdateSSHKeyAuthentication{}
	if err := utils.UnmarshalJSON(data, &sourceOracleEnterpriseUpdateSSHKeyAuthentication, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceOracleEnterpriseUpdateSSHTunnelMethodTypeSourceOracleEnterpriseUpdateSSHKeyAuthentication,
			Value: &sourceOracleEnterpriseUpdateSSHKeyAuthentication,
		})
	}

	var sourceOracleEnterpriseUpdatePasswordAuthentication SourceOracleEnterpriseUpdatePasswordAuthentication = SourceOracleEnterpriseUpdatePasswordAuthentication{}
	if err := utils.UnmarshalJSON(data, &sourceOracleEnterpriseUpdatePasswordAuthentication, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceOracleEnterpriseUpdateSSHTunnelMethodTypeSourceOracleEnterpriseUpdatePasswordAuthentication,
			Value: &sourceOracleEnterpriseUpdatePasswordAuthentication,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceOracleEnterpriseUpdateSSHTunnelMethod", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceOracleEnterpriseUpdateSSHTunnelMethod", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceOracleEnterpriseUpdateSSHTunnelMethodType)
	switch best.Type {
	case SourceOracleEnterpriseUpdateSSHTunnelMethodTypeSourceOracleEnterpriseUpdateNoTunnel:
		u.SourceOracleEnterpriseUpdateNoTunnel = best.Value.(*SourceOracleEnterpriseUpdateNoTunnel)
		return nil
	case SourceOracleEnterpriseUpdateSSHTunnelMethodTypeSourceOracleEnterpriseUpdateSSHKeyAuthentication:
		u.SourceOracleEnterpriseUpdateSSHKeyAuthentication = best.Value.(*SourceOracleEnterpriseUpdateSSHKeyAuthentication)
		return nil
	case SourceOracleEnterpriseUpdateSSHTunnelMethodTypeSourceOracleEnterpriseUpdatePasswordAuthentication:
		u.SourceOracleEnterpriseUpdatePasswordAuthentication = best.Value.(*SourceOracleEnterpriseUpdatePasswordAuthentication)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceOracleEnterpriseUpdateSSHTunnelMethod", string(data))
}

func (u SourceOracleEnterpriseUpdateSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.SourceOracleEnterpriseUpdateNoTunnel != nil {
		return utils.MarshalJSON(u.SourceOracleEnterpriseUpdateNoTunnel, "", true)
	}

	if u.SourceOracleEnterpriseUpdateSSHKeyAuthentication != nil {
		return utils.MarshalJSON(u.SourceOracleEnterpriseUpdateSSHKeyAuthentication, "", true)
	}

	if u.SourceOracleEnterpriseUpdatePasswordAuthentication != nil {
		return utils.MarshalJSON(u.SourceOracleEnterpriseUpdatePasswordAuthentication, "", true)
	}

	return nil, errors.New("could not marshal union type SourceOracleEnterpriseUpdateSSHTunnelMethod: all fields are null")
}

type SourceOracleEnterpriseUpdateSourceType string

const (
	SourceOracleEnterpriseUpdateSourceTypeOracleEnterprise SourceOracleEnterpriseUpdateSourceType = "oracle-enterprise"
)

func (e SourceOracleEnterpriseUpdateSourceType) ToPointer() *SourceOracleEnterpriseUpdateSourceType {
	return &e
}
func (e *SourceOracleEnterpriseUpdateSourceType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "oracle-enterprise":
		*e = SourceOracleEnterpriseUpdateSourceType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceOracleEnterpriseUpdateSourceType: %v", v)
	}
}

type SourceOracleEnterpriseUpdate struct {
	// When this feature is enabled, during schema discovery the connector will query each table or view individually to check access privileges and inaccessible tables, views, or columns therein will be removed. In large schemas, this might cause schema discovery to take too long, in which case it might be advisable to disable this feature.
	CheckPrivileges *bool `default:"true" json:"check_privileges"`
	// How often (in seconds) a stream should checkpoint, when possible.
	CheckpointTargetIntervalSeconds *int64 `default:"300" json:"checkpoint_target_interval_seconds"`
	// Maximum number of concurrent queries to the database.
	Concurrency *int64 `default:"1" json:"concurrency"`
	// The scheme by which to establish a database connection.
	ConnectionData *SourceOracleEnterpriseUpdateConnectBy `json:"connection_data,omitempty"`
	// Configures how data is extracted from the database.
	Cursor *SourceOracleEnterpriseUpdateUpdateMethod `json:"cursor,omitempty"`
	// The encryption method with is used when communicating with the database.
	Encryption *SourceOracleEnterpriseUpdateEncryption `json:"encryption,omitempty"`
	// Hostname of the database.
	Host *string `json:"host,omitempty"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// The password associated with the username.
	Password *string `json:"password,omitempty"`
	// Port of the database.
	// Oracle Corporations recommends the following port numbers:
	// 1521 - Default listening port for client connections to the listener.
	// 2484 - Recommended and officially registered listening port for client connections to the listener using TCP/IP with SSL.
	Port *int64 `default:"1521" json:"port"`
	// The list of schemas to sync from. Defaults to user. Case sensitive.
	Schemas []string `json:"schemas,omitempty"`
	// Inclusion filters for table selection per schema. If no filters are specified for a schema, all tables in that schema will be synced.
	TableFilters []SourceOracleEnterpriseUpdateTableFilter `json:"table_filters,omitempty"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod *SourceOracleEnterpriseUpdateSSHTunnelMethod `json:"tunnel_method,omitempty"`
	// The username which is used to access the database.
	Username             *string                                 `json:"username,omitempty"`
	sourceType           *SourceOracleEnterpriseUpdateSourceType `const:"oracle-enterprise" json:"sourceType"`
	AdditionalProperties any                                     `additionalProperties:"true" json:"-"`
}

func (s SourceOracleEnterpriseUpdate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceOracleEnterpriseUpdate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceOracleEnterpriseUpdate) GetCheckPrivileges() *bool {
	if s == nil {
		return nil
	}
	return s.CheckPrivileges
}

func (s *SourceOracleEnterpriseUpdate) GetCheckpointTargetIntervalSeconds() *int64 {
	if s == nil {
		return nil
	}
	return s.CheckpointTargetIntervalSeconds
}

func (s *SourceOracleEnterpriseUpdate) GetConcurrency() *int64 {
	if s == nil {
		return nil
	}
	return s.Concurrency
}

func (s *SourceOracleEnterpriseUpdate) GetConnectionData() *SourceOracleEnterpriseUpdateConnectBy {
	if s == nil {
		return nil
	}
	return s.ConnectionData
}

func (s *SourceOracleEnterpriseUpdate) GetCursor() *SourceOracleEnterpriseUpdateUpdateMethod {
	if s == nil {
		return nil
	}
	return s.Cursor
}

func (s *SourceOracleEnterpriseUpdate) GetEncryption() *SourceOracleEnterpriseUpdateEncryption {
	if s == nil {
		return nil
	}
	return s.Encryption
}

func (s *SourceOracleEnterpriseUpdate) GetHost() *string {
	if s == nil {
		return nil
	}
	return s.Host
}

func (s *SourceOracleEnterpriseUpdate) GetJdbcURLParams() *string {
	if s == nil {
		return nil
	}
	return s.JdbcURLParams
}

func (s *SourceOracleEnterpriseUpdate) GetPassword() *string {
	if s == nil {
		return nil
	}
	return s.Password
}

func (s *SourceOracleEnterpriseUpdate) GetPort() *int64 {
	if s == nil {
		return nil
	}
	return s.Port
}

func (s *SourceOracleEnterpriseUpdate) GetSchemas() []string {
	if s == nil {
		return nil
	}
	return s.Schemas
}

func (s *SourceOracleEnterpriseUpdate) GetTableFilters() []SourceOracleEnterpriseUpdateTableFilter {
	if s == nil {
		return nil
	}
	return s.TableFilters
}

func (s *SourceOracleEnterpriseUpdate) GetTunnelMethod() *SourceOracleEnterpriseUpdateSSHTunnelMethod {
	if s == nil {
		return nil
	}
	return s.TunnelMethod
}

func (s *SourceOracleEnterpriseUpdate) GetUsername() *string {
	if s == nil {
		return nil
	}
	return s.Username
}

func (s *SourceOracleEnterpriseUpdate) GetSourceType() *SourceOracleEnterpriseUpdateSourceType {
	return SourceOracleEnterpriseUpdateSourceTypeOracleEnterprise.ToPointer()
}

func (s *SourceOracleEnterpriseUpdate) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}
