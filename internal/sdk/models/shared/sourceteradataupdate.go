// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/types"
)

// SourceTeradataUpdateReplicationMethod - Replication method to use for extracting data from the database. STANDARD replication requires no setup on the DB side but will not be able to represent deletions incrementally. CDC uses the Binlog to detect inserts, updates, and deletes. This needs to be configured on the source database itself.
type SourceTeradataUpdateReplicationMethod string

const (
	SourceTeradataUpdateReplicationMethodStandard SourceTeradataUpdateReplicationMethod = "STANDARD"
	SourceTeradataUpdateReplicationMethodCdc      SourceTeradataUpdateReplicationMethod = "CDC"
)

func (e SourceTeradataUpdateReplicationMethod) ToPointer() *SourceTeradataUpdateReplicationMethod {
	return &e
}
func (e *SourceTeradataUpdateReplicationMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "STANDARD":
		fallthrough
	case "CDC":
		*e = SourceTeradataUpdateReplicationMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceTeradataUpdateReplicationMethod: %v", v)
	}
}

// SourceTeradataUpdateVerifyFull - Verify-full SSL mode.
type SourceTeradataUpdateVerifyFull struct {
	mode *string `const:"verify-full" json:"mode,omitempty"`
	// Specifies the file name of a PEM file that contains Certificate Authority (CA) certificates for use with SSLMODE=verify-full.
	//  See more information - <a href="https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/jdbcug_chapter_2.html#URL_SSLCA"> in the docs</a>.
	SslCaCertificate     *string `json:"ssl_ca_certificate,omitempty"`
	AdditionalProperties any     `additionalProperties:"true" json:"-"`
}

func (s SourceTeradataUpdateVerifyFull) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceTeradataUpdateVerifyFull) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceTeradataUpdateVerifyFull) GetMode() *string {
	return types.Pointer("verify-full")
}

func (s *SourceTeradataUpdateVerifyFull) GetSslCaCertificate() *string {
	if s == nil {
		return nil
	}
	return s.SslCaCertificate
}

func (s *SourceTeradataUpdateVerifyFull) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

// SourceTeradataUpdateVerifyCa - Verify-ca SSL mode.
type SourceTeradataUpdateVerifyCa struct {
	mode *string `const:"verify-ca" json:"mode,omitempty"`
	// Specifies the file name of a PEM file that contains Certificate Authority (CA) certificates for use with SSLMODE=verify-ca.
	//  See more information - <a href="https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/jdbcug_chapter_2.html#URL_SSLCA"> in the docs</a>.
	SslCaCertificate     *string `json:"ssl_ca_certificate,omitempty"`
	AdditionalProperties any     `additionalProperties:"true" json:"-"`
}

func (s SourceTeradataUpdateVerifyCa) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceTeradataUpdateVerifyCa) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceTeradataUpdateVerifyCa) GetMode() *string {
	return types.Pointer("verify-ca")
}

func (s *SourceTeradataUpdateVerifyCa) GetSslCaCertificate() *string {
	if s == nil {
		return nil
	}
	return s.SslCaCertificate
}

func (s *SourceTeradataUpdateVerifyCa) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

// SourceTeradataUpdateRequire - Require SSL mode.
type SourceTeradataUpdateRequire struct {
	mode                 *string `const:"require" json:"mode,omitempty"`
	AdditionalProperties any     `additionalProperties:"true" json:"-"`
}

func (s SourceTeradataUpdateRequire) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceTeradataUpdateRequire) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceTeradataUpdateRequire) GetMode() *string {
	return types.Pointer("require")
}

func (s *SourceTeradataUpdateRequire) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

// SourceTeradataUpdatePrefer - Prefer SSL mode.
type SourceTeradataUpdatePrefer struct {
	mode                 *string `const:"prefer" json:"mode,omitempty"`
	AdditionalProperties any     `additionalProperties:"true" json:"-"`
}

func (s SourceTeradataUpdatePrefer) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceTeradataUpdatePrefer) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceTeradataUpdatePrefer) GetMode() *string {
	return types.Pointer("prefer")
}

func (s *SourceTeradataUpdatePrefer) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

// SourceTeradataUpdateAllow - Allow SSL mode.
type SourceTeradataUpdateAllow struct {
	mode                 *string `const:"allow" json:"mode,omitempty"`
	AdditionalProperties any     `additionalProperties:"true" json:"-"`
}

func (s SourceTeradataUpdateAllow) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceTeradataUpdateAllow) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceTeradataUpdateAllow) GetMode() *string {
	return types.Pointer("allow")
}

func (s *SourceTeradataUpdateAllow) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

// SourceTeradataUpdateDisable - Disable SSL.
type SourceTeradataUpdateDisable struct {
	mode                 *string `const:"disable" json:"mode,omitempty"`
	AdditionalProperties any     `additionalProperties:"true" json:"-"`
}

func (s SourceTeradataUpdateDisable) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceTeradataUpdateDisable) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceTeradataUpdateDisable) GetMode() *string {
	return types.Pointer("disable")
}

func (s *SourceTeradataUpdateDisable) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceTeradataUpdateSSLModesType string

const (
	SourceTeradataUpdateSSLModesTypeSourceTeradataUpdateDisable    SourceTeradataUpdateSSLModesType = "source-teradata-update_disable"
	SourceTeradataUpdateSSLModesTypeSourceTeradataUpdateAllow      SourceTeradataUpdateSSLModesType = "source-teradata-update_allow"
	SourceTeradataUpdateSSLModesTypeSourceTeradataUpdatePrefer     SourceTeradataUpdateSSLModesType = "source-teradata-update_prefer"
	SourceTeradataUpdateSSLModesTypeSourceTeradataUpdateRequire    SourceTeradataUpdateSSLModesType = "source-teradata-update_require"
	SourceTeradataUpdateSSLModesTypeSourceTeradataUpdateVerifyCa   SourceTeradataUpdateSSLModesType = "source-teradata-update_verify-ca"
	SourceTeradataUpdateSSLModesTypeSourceTeradataUpdateVerifyFull SourceTeradataUpdateSSLModesType = "source-teradata-update_verify-full"
)

// SourceTeradataUpdateSSLModes - SSL connection modes.
//
//	<b>disable</b> - Chose this mode to disable encryption of communication between Airbyte and destination database
//	<b>allow</b> - Chose this mode to enable encryption only when required by the destination database
//	<b>prefer</b> - Chose this mode to allow unencrypted connection only if the destination database does not support encryption
//	<b>require</b> - Chose this mode to always require encryption. If the destination database server does not support encryption, connection will fail
//	 <b>verify-ca</b> - Chose this mode to always require encryption and to verify that the destination database server has a valid SSL certificate
//	 <b>verify-full</b> - This is the most secure mode. Chose this mode to always require encryption and to verify the identity of the destination database server
//	See more information - <a href="https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/jdbcug_chapter_2.html#URL_SSLMODE"> in the docs</a>.
type SourceTeradataUpdateSSLModes struct {
	SourceTeradataUpdateDisable    *SourceTeradataUpdateDisable    `queryParam:"inline" union:"member"`
	SourceTeradataUpdateAllow      *SourceTeradataUpdateAllow      `queryParam:"inline" union:"member"`
	SourceTeradataUpdatePrefer     *SourceTeradataUpdatePrefer     `queryParam:"inline" union:"member"`
	SourceTeradataUpdateRequire    *SourceTeradataUpdateRequire    `queryParam:"inline" union:"member"`
	SourceTeradataUpdateVerifyCa   *SourceTeradataUpdateVerifyCa   `queryParam:"inline" union:"member"`
	SourceTeradataUpdateVerifyFull *SourceTeradataUpdateVerifyFull `queryParam:"inline" union:"member"`

	Type SourceTeradataUpdateSSLModesType
}

func CreateSourceTeradataUpdateSSLModesSourceTeradataUpdateDisable(sourceTeradataUpdateDisable SourceTeradataUpdateDisable) SourceTeradataUpdateSSLModes {
	typ := SourceTeradataUpdateSSLModesTypeSourceTeradataUpdateDisable

	return SourceTeradataUpdateSSLModes{
		SourceTeradataUpdateDisable: &sourceTeradataUpdateDisable,
		Type:                        typ,
	}
}

func CreateSourceTeradataUpdateSSLModesSourceTeradataUpdateAllow(sourceTeradataUpdateAllow SourceTeradataUpdateAllow) SourceTeradataUpdateSSLModes {
	typ := SourceTeradataUpdateSSLModesTypeSourceTeradataUpdateAllow

	return SourceTeradataUpdateSSLModes{
		SourceTeradataUpdateAllow: &sourceTeradataUpdateAllow,
		Type:                      typ,
	}
}

func CreateSourceTeradataUpdateSSLModesSourceTeradataUpdatePrefer(sourceTeradataUpdatePrefer SourceTeradataUpdatePrefer) SourceTeradataUpdateSSLModes {
	typ := SourceTeradataUpdateSSLModesTypeSourceTeradataUpdatePrefer

	return SourceTeradataUpdateSSLModes{
		SourceTeradataUpdatePrefer: &sourceTeradataUpdatePrefer,
		Type:                       typ,
	}
}

func CreateSourceTeradataUpdateSSLModesSourceTeradataUpdateRequire(sourceTeradataUpdateRequire SourceTeradataUpdateRequire) SourceTeradataUpdateSSLModes {
	typ := SourceTeradataUpdateSSLModesTypeSourceTeradataUpdateRequire

	return SourceTeradataUpdateSSLModes{
		SourceTeradataUpdateRequire: &sourceTeradataUpdateRequire,
		Type:                        typ,
	}
}

func CreateSourceTeradataUpdateSSLModesSourceTeradataUpdateVerifyCa(sourceTeradataUpdateVerifyCa SourceTeradataUpdateVerifyCa) SourceTeradataUpdateSSLModes {
	typ := SourceTeradataUpdateSSLModesTypeSourceTeradataUpdateVerifyCa

	return SourceTeradataUpdateSSLModes{
		SourceTeradataUpdateVerifyCa: &sourceTeradataUpdateVerifyCa,
		Type:                         typ,
	}
}

func CreateSourceTeradataUpdateSSLModesSourceTeradataUpdateVerifyFull(sourceTeradataUpdateVerifyFull SourceTeradataUpdateVerifyFull) SourceTeradataUpdateSSLModes {
	typ := SourceTeradataUpdateSSLModesTypeSourceTeradataUpdateVerifyFull

	return SourceTeradataUpdateSSLModes{
		SourceTeradataUpdateVerifyFull: &sourceTeradataUpdateVerifyFull,
		Type:                           typ,
	}
}

func (u *SourceTeradataUpdateSSLModes) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var sourceTeradataUpdateDisable SourceTeradataUpdateDisable = SourceTeradataUpdateDisable{}
	if err := utils.UnmarshalJSON(data, &sourceTeradataUpdateDisable, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceTeradataUpdateSSLModesTypeSourceTeradataUpdateDisable,
			Value: &sourceTeradataUpdateDisable,
		})
	}

	var sourceTeradataUpdateAllow SourceTeradataUpdateAllow = SourceTeradataUpdateAllow{}
	if err := utils.UnmarshalJSON(data, &sourceTeradataUpdateAllow, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceTeradataUpdateSSLModesTypeSourceTeradataUpdateAllow,
			Value: &sourceTeradataUpdateAllow,
		})
	}

	var sourceTeradataUpdatePrefer SourceTeradataUpdatePrefer = SourceTeradataUpdatePrefer{}
	if err := utils.UnmarshalJSON(data, &sourceTeradataUpdatePrefer, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceTeradataUpdateSSLModesTypeSourceTeradataUpdatePrefer,
			Value: &sourceTeradataUpdatePrefer,
		})
	}

	var sourceTeradataUpdateRequire SourceTeradataUpdateRequire = SourceTeradataUpdateRequire{}
	if err := utils.UnmarshalJSON(data, &sourceTeradataUpdateRequire, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceTeradataUpdateSSLModesTypeSourceTeradataUpdateRequire,
			Value: &sourceTeradataUpdateRequire,
		})
	}

	var sourceTeradataUpdateVerifyCa SourceTeradataUpdateVerifyCa = SourceTeradataUpdateVerifyCa{}
	if err := utils.UnmarshalJSON(data, &sourceTeradataUpdateVerifyCa, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceTeradataUpdateSSLModesTypeSourceTeradataUpdateVerifyCa,
			Value: &sourceTeradataUpdateVerifyCa,
		})
	}

	var sourceTeradataUpdateVerifyFull SourceTeradataUpdateVerifyFull = SourceTeradataUpdateVerifyFull{}
	if err := utils.UnmarshalJSON(data, &sourceTeradataUpdateVerifyFull, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceTeradataUpdateSSLModesTypeSourceTeradataUpdateVerifyFull,
			Value: &sourceTeradataUpdateVerifyFull,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceTeradataUpdateSSLModes", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceTeradataUpdateSSLModes", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceTeradataUpdateSSLModesType)
	switch best.Type {
	case SourceTeradataUpdateSSLModesTypeSourceTeradataUpdateDisable:
		u.SourceTeradataUpdateDisable = best.Value.(*SourceTeradataUpdateDisable)
		return nil
	case SourceTeradataUpdateSSLModesTypeSourceTeradataUpdateAllow:
		u.SourceTeradataUpdateAllow = best.Value.(*SourceTeradataUpdateAllow)
		return nil
	case SourceTeradataUpdateSSLModesTypeSourceTeradataUpdatePrefer:
		u.SourceTeradataUpdatePrefer = best.Value.(*SourceTeradataUpdatePrefer)
		return nil
	case SourceTeradataUpdateSSLModesTypeSourceTeradataUpdateRequire:
		u.SourceTeradataUpdateRequire = best.Value.(*SourceTeradataUpdateRequire)
		return nil
	case SourceTeradataUpdateSSLModesTypeSourceTeradataUpdateVerifyCa:
		u.SourceTeradataUpdateVerifyCa = best.Value.(*SourceTeradataUpdateVerifyCa)
		return nil
	case SourceTeradataUpdateSSLModesTypeSourceTeradataUpdateVerifyFull:
		u.SourceTeradataUpdateVerifyFull = best.Value.(*SourceTeradataUpdateVerifyFull)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceTeradataUpdateSSLModes", string(data))
}

func (u SourceTeradataUpdateSSLModes) MarshalJSON() ([]byte, error) {
	if u.SourceTeradataUpdateDisable != nil {
		return utils.MarshalJSON(u.SourceTeradataUpdateDisable, "", true)
	}

	if u.SourceTeradataUpdateAllow != nil {
		return utils.MarshalJSON(u.SourceTeradataUpdateAllow, "", true)
	}

	if u.SourceTeradataUpdatePrefer != nil {
		return utils.MarshalJSON(u.SourceTeradataUpdatePrefer, "", true)
	}

	if u.SourceTeradataUpdateRequire != nil {
		return utils.MarshalJSON(u.SourceTeradataUpdateRequire, "", true)
	}

	if u.SourceTeradataUpdateVerifyCa != nil {
		return utils.MarshalJSON(u.SourceTeradataUpdateVerifyCa, "", true)
	}

	if u.SourceTeradataUpdateVerifyFull != nil {
		return utils.MarshalJSON(u.SourceTeradataUpdateVerifyFull, "", true)
	}

	return nil, errors.New("could not marshal union type SourceTeradataUpdateSSLModes: all fields are null")
}

type SourceTeradataUpdateSourceType string

const (
	SourceTeradataUpdateSourceTypeTeradata SourceTeradataUpdateSourceType = "teradata"
)

func (e SourceTeradataUpdateSourceType) ToPointer() *SourceTeradataUpdateSourceType {
	return &e
}
func (e *SourceTeradataUpdateSourceType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "teradata":
		*e = SourceTeradataUpdateSourceType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceTeradataUpdateSourceType: %v", v)
	}
}

type SourceTeradataUpdate struct {
	// Name of the database.
	Database *string `json:"database,omitempty"`
	// Hostname of the database.
	Host *string `json:"host,omitempty"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3)
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// Password associated with the username.
	Password *string `json:"password,omitempty"`
	// Port of the database.
	Port *int64 `default:"1025" json:"port"`
	// Replication method to use for extracting data from the database. STANDARD replication requires no setup on the DB side but will not be able to represent deletions incrementally. CDC uses the Binlog to detect inserts, updates, and deletes. This needs to be configured on the source database itself.
	ReplicationMethod *SourceTeradataUpdateReplicationMethod `default:"STANDARD" json:"replication_method"`
	// Encrypt data using SSL. When activating SSL, please select one of the connection modes.
	Ssl *bool `default:"false" json:"ssl"`
	// SSL connection modes.
	//  <b>disable</b> - Chose this mode to disable encryption of communication between Airbyte and destination database
	//  <b>allow</b> - Chose this mode to enable encryption only when required by the destination database
	//  <b>prefer</b> - Chose this mode to allow unencrypted connection only if the destination database does not support encryption
	//  <b>require</b> - Chose this mode to always require encryption. If the destination database server does not support encryption, connection will fail
	//   <b>verify-ca</b> - Chose this mode to always require encryption and to verify that the destination database server has a valid SSL certificate
	//   <b>verify-full</b> - This is the most secure mode. Chose this mode to always require encryption and to verify the identity of the destination database server
	//  See more information - <a href="https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/jdbcug_chapter_2.html#URL_SSLMODE"> in the docs</a>.
	SslMode *SourceTeradataUpdateSSLModes `json:"ssl_mode,omitempty"`
	// Username to use to access the database.
	Username   *string                         `json:"username,omitempty"`
	sourceType *SourceTeradataUpdateSourceType `const:"teradata" json:"sourceType"`
}

func (s SourceTeradataUpdate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceTeradataUpdate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceTeradataUpdate) GetDatabase() *string {
	if s == nil {
		return nil
	}
	return s.Database
}

func (s *SourceTeradataUpdate) GetHost() *string {
	if s == nil {
		return nil
	}
	return s.Host
}

func (s *SourceTeradataUpdate) GetJdbcURLParams() *string {
	if s == nil {
		return nil
	}
	return s.JdbcURLParams
}

func (s *SourceTeradataUpdate) GetPassword() *string {
	if s == nil {
		return nil
	}
	return s.Password
}

func (s *SourceTeradataUpdate) GetPort() *int64 {
	if s == nil {
		return nil
	}
	return s.Port
}

func (s *SourceTeradataUpdate) GetReplicationMethod() *SourceTeradataUpdateReplicationMethod {
	if s == nil {
		return nil
	}
	return s.ReplicationMethod
}

func (s *SourceTeradataUpdate) GetSsl() *bool {
	if s == nil {
		return nil
	}
	return s.Ssl
}

func (s *SourceTeradataUpdate) GetSslMode() *SourceTeradataUpdateSSLModes {
	if s == nil {
		return nil
	}
	return s.SslMode
}

func (s *SourceTeradataUpdate) GetUsername() *string {
	if s == nil {
		return nil
	}
	return s.Username
}

func (s *SourceTeradataUpdate) GetSourceType() *SourceTeradataUpdateSourceType {
	return SourceTeradataUpdateSourceTypeTeradata.ToPointer()
}
