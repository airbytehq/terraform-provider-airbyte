// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

type Type string

const (
	TypeOAuth Type = "OAuth"
)

func (e Type) ToPointer() *Type {
	return &e
}
func (e *Type) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "OAuth":
		*e = Type(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Type: %v", v)
	}
}

type DestinationHubspotOAuth struct {
	// The Client ID of your HubSpot developer application. See the <a href=\"https://legacydocs.hubspot.com/docs/methods/oauth2/oauth2-quickstart\">Hubspot docs</a> if you need help finding this ID.
	ClientID string `json:"client_id"`
	// The client secret for your HubSpot developer application. See the <a href=\"https://legacydocs.hubspot.com/docs/methods/oauth2/oauth2-quickstart\">Hubspot docs</a> if you need help finding this secret.
	ClientSecret string `json:"client_secret"`
	// Refresh token to renew an expired access token. See the <a href=\"https://legacydocs.hubspot.com/docs/methods/oauth2/oauth2-quickstart\">Hubspot docs</a> if you need help finding this token.
	RefreshToken         string `json:"refresh_token"`
	Type                 *Type  `default:"OAuth" json:"type"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (d DestinationHubspotOAuth) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationHubspotOAuth) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationHubspotOAuth) GetClientID() string {
	if d == nil {
		return ""
	}
	return d.ClientID
}

func (d *DestinationHubspotOAuth) GetClientSecret() string {
	if d == nil {
		return ""
	}
	return d.ClientSecret
}

func (d *DestinationHubspotOAuth) GetRefreshToken() string {
	if d == nil {
		return ""
	}
	return d.RefreshToken
}

func (d *DestinationHubspotOAuth) GetType() *Type {
	if d == nil {
		return nil
	}
	return d.Type
}

func (d *DestinationHubspotOAuth) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationHubspotCredentialsType string

const (
	DestinationHubspotCredentialsTypeDestinationHubspotOAuth DestinationHubspotCredentialsType = "destination-hubspot_OAuth"
)

// DestinationHubspotCredentials - Choose how to authenticate to HubSpot.
type DestinationHubspotCredentials struct {
	DestinationHubspotOAuth *DestinationHubspotOAuth `queryParam:"inline" union:"member"`

	Type DestinationHubspotCredentialsType
}

func CreateDestinationHubspotCredentialsDestinationHubspotOAuth(destinationHubspotOAuth DestinationHubspotOAuth) DestinationHubspotCredentials {
	typ := DestinationHubspotCredentialsTypeDestinationHubspotOAuth

	return DestinationHubspotCredentials{
		DestinationHubspotOAuth: &destinationHubspotOAuth,
		Type:                    typ,
	}
}

func (u *DestinationHubspotCredentials) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var destinationHubspotOAuth DestinationHubspotOAuth = DestinationHubspotOAuth{}
	if err := utils.UnmarshalJSON(data, &destinationHubspotOAuth, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationHubspotCredentialsTypeDestinationHubspotOAuth,
			Value: &destinationHubspotOAuth,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationHubspotCredentials", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationHubspotCredentials", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(DestinationHubspotCredentialsType)
	switch best.Type {
	case DestinationHubspotCredentialsTypeDestinationHubspotOAuth:
		u.DestinationHubspotOAuth = best.Value.(*DestinationHubspotOAuth)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationHubspotCredentials", string(data))
}

func (u DestinationHubspotCredentials) MarshalJSON() ([]byte, error) {
	if u.DestinationHubspotOAuth != nil {
		return utils.MarshalJSON(u.DestinationHubspotOAuth, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationHubspotCredentials: all fields are null")
}

type DestinationHubspotSchemasCompressionType string

const (
	DestinationHubspotSchemasCompressionTypeGzip DestinationHubspotSchemasCompressionType = "GZIP"
)

func (e DestinationHubspotSchemasCompressionType) ToPointer() *DestinationHubspotSchemasCompressionType {
	return &e
}
func (e *DestinationHubspotSchemasCompressionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "GZIP":
		*e = DestinationHubspotSchemasCompressionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationHubspotSchemasCompressionType: %v", v)
	}
}

type DestinationHubspotGZIP struct {
	CompressionType      *DestinationHubspotSchemasCompressionType `default:"GZIP" json:"compression_type"`
	AdditionalProperties any                                       `additionalProperties:"true" json:"-"`
}

func (d DestinationHubspotGZIP) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationHubspotGZIP) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationHubspotGZIP) GetCompressionType() *DestinationHubspotSchemasCompressionType {
	if d == nil {
		return nil
	}
	return d.CompressionType
}

func (d *DestinationHubspotGZIP) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationHubspotCompressionType string

const (
	DestinationHubspotCompressionTypeNoCompression DestinationHubspotCompressionType = "No Compression"
)

func (e DestinationHubspotCompressionType) ToPointer() *DestinationHubspotCompressionType {
	return &e
}
func (e *DestinationHubspotCompressionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "No Compression":
		*e = DestinationHubspotCompressionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationHubspotCompressionType: %v", v)
	}
}

type DestinationHubspotNoCompression struct {
	CompressionType      *DestinationHubspotCompressionType `default:"No Compression" json:"compression_type"`
	AdditionalProperties any                                `additionalProperties:"true" json:"-"`
}

func (d DestinationHubspotNoCompression) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationHubspotNoCompression) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationHubspotNoCompression) GetCompressionType() *DestinationHubspotCompressionType {
	if d == nil {
		return nil
	}
	return d.CompressionType
}

func (d *DestinationHubspotNoCompression) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationHubspotCompressionUnionType string

const (
	DestinationHubspotCompressionUnionTypeDestinationHubspotNoCompression DestinationHubspotCompressionUnionType = "destination-hubspot_No Compression"
	DestinationHubspotCompressionUnionTypeDestinationHubspotGZIP          DestinationHubspotCompressionUnionType = "destination-hubspot_GZIP"
)

// DestinationHubspotCompression - Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").
type DestinationHubspotCompression struct {
	DestinationHubspotNoCompression *DestinationHubspotNoCompression `queryParam:"inline" union:"member"`
	DestinationHubspotGZIP          *DestinationHubspotGZIP          `queryParam:"inline" union:"member"`

	Type DestinationHubspotCompressionUnionType
}

func CreateDestinationHubspotCompressionDestinationHubspotNoCompression(destinationHubspotNoCompression DestinationHubspotNoCompression) DestinationHubspotCompression {
	typ := DestinationHubspotCompressionUnionTypeDestinationHubspotNoCompression

	return DestinationHubspotCompression{
		DestinationHubspotNoCompression: &destinationHubspotNoCompression,
		Type:                            typ,
	}
}

func CreateDestinationHubspotCompressionDestinationHubspotGZIP(destinationHubspotGZIP DestinationHubspotGZIP) DestinationHubspotCompression {
	typ := DestinationHubspotCompressionUnionTypeDestinationHubspotGZIP

	return DestinationHubspotCompression{
		DestinationHubspotGZIP: &destinationHubspotGZIP,
		Type:                   typ,
	}
}

func (u *DestinationHubspotCompression) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var destinationHubspotNoCompression DestinationHubspotNoCompression = DestinationHubspotNoCompression{}
	if err := utils.UnmarshalJSON(data, &destinationHubspotNoCompression, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationHubspotCompressionUnionTypeDestinationHubspotNoCompression,
			Value: &destinationHubspotNoCompression,
		})
	}

	var destinationHubspotGZIP DestinationHubspotGZIP = DestinationHubspotGZIP{}
	if err := utils.UnmarshalJSON(data, &destinationHubspotGZIP, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationHubspotCompressionUnionTypeDestinationHubspotGZIP,
			Value: &destinationHubspotGZIP,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationHubspotCompression", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationHubspotCompression", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(DestinationHubspotCompressionUnionType)
	switch best.Type {
	case DestinationHubspotCompressionUnionTypeDestinationHubspotNoCompression:
		u.DestinationHubspotNoCompression = best.Value.(*DestinationHubspotNoCompression)
		return nil
	case DestinationHubspotCompressionUnionTypeDestinationHubspotGZIP:
		u.DestinationHubspotGZIP = best.Value.(*DestinationHubspotGZIP)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationHubspotCompression", string(data))
}

func (u DestinationHubspotCompression) MarshalJSON() ([]byte, error) {
	if u.DestinationHubspotNoCompression != nil {
		return utils.MarshalJSON(u.DestinationHubspotNoCompression, "", true)
	}

	if u.DestinationHubspotGZIP != nil {
		return utils.MarshalJSON(u.DestinationHubspotGZIP, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationHubspotCompression: all fields are null")
}

type DestinationHubspotSchemasFlattening string

const (
	DestinationHubspotSchemasFlatteningNoFlattening        DestinationHubspotSchemasFlattening = "No flattening"
	DestinationHubspotSchemasFlatteningRootLevelFlattening DestinationHubspotSchemasFlattening = "Root level flattening"
)

func (e DestinationHubspotSchemasFlattening) ToPointer() *DestinationHubspotSchemasFlattening {
	return &e
}
func (e *DestinationHubspotSchemasFlattening) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "No flattening":
		fallthrough
	case "Root level flattening":
		*e = DestinationHubspotSchemasFlattening(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationHubspotSchemasFlattening: %v", v)
	}
}

type DestinationHubspotSchemasFormatType string

const (
	DestinationHubspotSchemasFormatTypeJsonl DestinationHubspotSchemasFormatType = "JSONL"
)

func (e DestinationHubspotSchemasFormatType) ToPointer() *DestinationHubspotSchemasFormatType {
	return &e
}
func (e *DestinationHubspotSchemasFormatType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "JSONL":
		*e = DestinationHubspotSchemasFormatType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationHubspotSchemasFormatType: %v", v)
	}
}

type DestinationHubspotJSONLinesNewlineDelimitedJSON struct {
	Flattening           *DestinationHubspotSchemasFlattening `default:"No flattening" json:"flattening"`
	FormatType           *DestinationHubspotSchemasFormatType `default:"JSONL" json:"format_type"`
	AdditionalProperties any                                  `additionalProperties:"true" json:"-"`
}

func (d DestinationHubspotJSONLinesNewlineDelimitedJSON) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationHubspotJSONLinesNewlineDelimitedJSON) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationHubspotJSONLinesNewlineDelimitedJSON) GetFlattening() *DestinationHubspotSchemasFlattening {
	if d == nil {
		return nil
	}
	return d.Flattening
}

func (d *DestinationHubspotJSONLinesNewlineDelimitedJSON) GetFormatType() *DestinationHubspotSchemasFormatType {
	if d == nil {
		return nil
	}
	return d.FormatType
}

func (d *DestinationHubspotJSONLinesNewlineDelimitedJSON) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationHubspotFlattening string

const (
	DestinationHubspotFlatteningNoFlattening        DestinationHubspotFlattening = "No flattening"
	DestinationHubspotFlatteningRootLevelFlattening DestinationHubspotFlattening = "Root level flattening"
)

func (e DestinationHubspotFlattening) ToPointer() *DestinationHubspotFlattening {
	return &e
}
func (e *DestinationHubspotFlattening) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "No flattening":
		fallthrough
	case "Root level flattening":
		*e = DestinationHubspotFlattening(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationHubspotFlattening: %v", v)
	}
}

type DestinationHubspotFormatType string

const (
	DestinationHubspotFormatTypeCsv DestinationHubspotFormatType = "CSV"
)

func (e DestinationHubspotFormatType) ToPointer() *DestinationHubspotFormatType {
	return &e
}
func (e *DestinationHubspotFormatType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CSV":
		*e = DestinationHubspotFormatType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationHubspotFormatType: %v", v)
	}
}

type DestinationHubspotCSVCommaSeparatedValues struct {
	Flattening           *DestinationHubspotFlattening `default:"No flattening" json:"flattening"`
	FormatType           *DestinationHubspotFormatType `default:"CSV" json:"format_type"`
	AdditionalProperties any                           `additionalProperties:"true" json:"-"`
}

func (d DestinationHubspotCSVCommaSeparatedValues) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationHubspotCSVCommaSeparatedValues) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationHubspotCSVCommaSeparatedValues) GetFlattening() *DestinationHubspotFlattening {
	if d == nil {
		return nil
	}
	return d.Flattening
}

func (d *DestinationHubspotCSVCommaSeparatedValues) GetFormatType() *DestinationHubspotFormatType {
	if d == nil {
		return nil
	}
	return d.FormatType
}

func (d *DestinationHubspotCSVCommaSeparatedValues) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationHubspotOutputFormatType string

const (
	DestinationHubspotOutputFormatTypeDestinationHubspotCSVCommaSeparatedValues       DestinationHubspotOutputFormatType = "destination-hubspot_CSV: Comma-Separated Values"
	DestinationHubspotOutputFormatTypeDestinationHubspotJSONLinesNewlineDelimitedJSON DestinationHubspotOutputFormatType = "destination-hubspot_JSON Lines: Newline-delimited JSON"
)

// DestinationHubspotOutputFormat - Format of the data output.
type DestinationHubspotOutputFormat struct {
	DestinationHubspotCSVCommaSeparatedValues       *DestinationHubspotCSVCommaSeparatedValues       `queryParam:"inline" union:"member"`
	DestinationHubspotJSONLinesNewlineDelimitedJSON *DestinationHubspotJSONLinesNewlineDelimitedJSON `queryParam:"inline" union:"member"`

	Type DestinationHubspotOutputFormatType
}

func CreateDestinationHubspotOutputFormatDestinationHubspotCSVCommaSeparatedValues(destinationHubspotCSVCommaSeparatedValues DestinationHubspotCSVCommaSeparatedValues) DestinationHubspotOutputFormat {
	typ := DestinationHubspotOutputFormatTypeDestinationHubspotCSVCommaSeparatedValues

	return DestinationHubspotOutputFormat{
		DestinationHubspotCSVCommaSeparatedValues: &destinationHubspotCSVCommaSeparatedValues,
		Type: typ,
	}
}

func CreateDestinationHubspotOutputFormatDestinationHubspotJSONLinesNewlineDelimitedJSON(destinationHubspotJSONLinesNewlineDelimitedJSON DestinationHubspotJSONLinesNewlineDelimitedJSON) DestinationHubspotOutputFormat {
	typ := DestinationHubspotOutputFormatTypeDestinationHubspotJSONLinesNewlineDelimitedJSON

	return DestinationHubspotOutputFormat{
		DestinationHubspotJSONLinesNewlineDelimitedJSON: &destinationHubspotJSONLinesNewlineDelimitedJSON,
		Type: typ,
	}
}

func (u *DestinationHubspotOutputFormat) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var destinationHubspotCSVCommaSeparatedValues DestinationHubspotCSVCommaSeparatedValues = DestinationHubspotCSVCommaSeparatedValues{}
	if err := utils.UnmarshalJSON(data, &destinationHubspotCSVCommaSeparatedValues, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationHubspotOutputFormatTypeDestinationHubspotCSVCommaSeparatedValues,
			Value: &destinationHubspotCSVCommaSeparatedValues,
		})
	}

	var destinationHubspotJSONLinesNewlineDelimitedJSON DestinationHubspotJSONLinesNewlineDelimitedJSON = DestinationHubspotJSONLinesNewlineDelimitedJSON{}
	if err := utils.UnmarshalJSON(data, &destinationHubspotJSONLinesNewlineDelimitedJSON, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationHubspotOutputFormatTypeDestinationHubspotJSONLinesNewlineDelimitedJSON,
			Value: &destinationHubspotJSONLinesNewlineDelimitedJSON,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationHubspotOutputFormat", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationHubspotOutputFormat", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(DestinationHubspotOutputFormatType)
	switch best.Type {
	case DestinationHubspotOutputFormatTypeDestinationHubspotCSVCommaSeparatedValues:
		u.DestinationHubspotCSVCommaSeparatedValues = best.Value.(*DestinationHubspotCSVCommaSeparatedValues)
		return nil
	case DestinationHubspotOutputFormatTypeDestinationHubspotJSONLinesNewlineDelimitedJSON:
		u.DestinationHubspotJSONLinesNewlineDelimitedJSON = best.Value.(*DestinationHubspotJSONLinesNewlineDelimitedJSON)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationHubspotOutputFormat", string(data))
}

func (u DestinationHubspotOutputFormat) MarshalJSON() ([]byte, error) {
	if u.DestinationHubspotCSVCommaSeparatedValues != nil {
		return utils.MarshalJSON(u.DestinationHubspotCSVCommaSeparatedValues, "", true)
	}

	if u.DestinationHubspotJSONLinesNewlineDelimitedJSON != nil {
		return utils.MarshalJSON(u.DestinationHubspotJSONLinesNewlineDelimitedJSON, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationHubspotOutputFormat: all fields are null")
}

// DestinationHubspotS3BucketRegion - The region of the S3 bucket. See <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-available-regions">here</a> for all region codes.
type DestinationHubspotS3BucketRegion string

const (
	DestinationHubspotS3BucketRegionUnknown      DestinationHubspotS3BucketRegion = ""
	DestinationHubspotS3BucketRegionAfSouth1     DestinationHubspotS3BucketRegion = "af-south-1"
	DestinationHubspotS3BucketRegionApEast1      DestinationHubspotS3BucketRegion = "ap-east-1"
	DestinationHubspotS3BucketRegionApNortheast1 DestinationHubspotS3BucketRegion = "ap-northeast-1"
	DestinationHubspotS3BucketRegionApNortheast2 DestinationHubspotS3BucketRegion = "ap-northeast-2"
	DestinationHubspotS3BucketRegionApNortheast3 DestinationHubspotS3BucketRegion = "ap-northeast-3"
	DestinationHubspotS3BucketRegionApSouth1     DestinationHubspotS3BucketRegion = "ap-south-1"
	DestinationHubspotS3BucketRegionApSouth2     DestinationHubspotS3BucketRegion = "ap-south-2"
	DestinationHubspotS3BucketRegionApSoutheast1 DestinationHubspotS3BucketRegion = "ap-southeast-1"
	DestinationHubspotS3BucketRegionApSoutheast2 DestinationHubspotS3BucketRegion = "ap-southeast-2"
	DestinationHubspotS3BucketRegionApSoutheast3 DestinationHubspotS3BucketRegion = "ap-southeast-3"
	DestinationHubspotS3BucketRegionApSoutheast4 DestinationHubspotS3BucketRegion = "ap-southeast-4"
	DestinationHubspotS3BucketRegionCaCentral1   DestinationHubspotS3BucketRegion = "ca-central-1"
	DestinationHubspotS3BucketRegionCaWest1      DestinationHubspotS3BucketRegion = "ca-west-1"
	DestinationHubspotS3BucketRegionCnNorth1     DestinationHubspotS3BucketRegion = "cn-north-1"
	DestinationHubspotS3BucketRegionCnNorthwest1 DestinationHubspotS3BucketRegion = "cn-northwest-1"
	DestinationHubspotS3BucketRegionEuCentral1   DestinationHubspotS3BucketRegion = "eu-central-1"
	DestinationHubspotS3BucketRegionEuCentral2   DestinationHubspotS3BucketRegion = "eu-central-2"
	DestinationHubspotS3BucketRegionEuNorth1     DestinationHubspotS3BucketRegion = "eu-north-1"
	DestinationHubspotS3BucketRegionEuSouth1     DestinationHubspotS3BucketRegion = "eu-south-1"
	DestinationHubspotS3BucketRegionEuSouth2     DestinationHubspotS3BucketRegion = "eu-south-2"
	DestinationHubspotS3BucketRegionEuWest1      DestinationHubspotS3BucketRegion = "eu-west-1"
	DestinationHubspotS3BucketRegionEuWest2      DestinationHubspotS3BucketRegion = "eu-west-2"
	DestinationHubspotS3BucketRegionEuWest3      DestinationHubspotS3BucketRegion = "eu-west-3"
	DestinationHubspotS3BucketRegionIlCentral1   DestinationHubspotS3BucketRegion = "il-central-1"
	DestinationHubspotS3BucketRegionMeCentral1   DestinationHubspotS3BucketRegion = "me-central-1"
	DestinationHubspotS3BucketRegionMeSouth1     DestinationHubspotS3BucketRegion = "me-south-1"
	DestinationHubspotS3BucketRegionSaEast1      DestinationHubspotS3BucketRegion = "sa-east-1"
	DestinationHubspotS3BucketRegionUsEast1      DestinationHubspotS3BucketRegion = "us-east-1"
	DestinationHubspotS3BucketRegionUsEast2      DestinationHubspotS3BucketRegion = "us-east-2"
	DestinationHubspotS3BucketRegionUsGovEast1   DestinationHubspotS3BucketRegion = "us-gov-east-1"
	DestinationHubspotS3BucketRegionUsGovWest1   DestinationHubspotS3BucketRegion = "us-gov-west-1"
	DestinationHubspotS3BucketRegionUsWest1      DestinationHubspotS3BucketRegion = "us-west-1"
	DestinationHubspotS3BucketRegionUsWest2      DestinationHubspotS3BucketRegion = "us-west-2"
)

func (e DestinationHubspotS3BucketRegion) ToPointer() *DestinationHubspotS3BucketRegion {
	return &e
}
func (e *DestinationHubspotS3BucketRegion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "":
		fallthrough
	case "af-south-1":
		fallthrough
	case "ap-east-1":
		fallthrough
	case "ap-northeast-1":
		fallthrough
	case "ap-northeast-2":
		fallthrough
	case "ap-northeast-3":
		fallthrough
	case "ap-south-1":
		fallthrough
	case "ap-south-2":
		fallthrough
	case "ap-southeast-1":
		fallthrough
	case "ap-southeast-2":
		fallthrough
	case "ap-southeast-3":
		fallthrough
	case "ap-southeast-4":
		fallthrough
	case "ca-central-1":
		fallthrough
	case "ca-west-1":
		fallthrough
	case "cn-north-1":
		fallthrough
	case "cn-northwest-1":
		fallthrough
	case "eu-central-1":
		fallthrough
	case "eu-central-2":
		fallthrough
	case "eu-north-1":
		fallthrough
	case "eu-south-1":
		fallthrough
	case "eu-south-2":
		fallthrough
	case "eu-west-1":
		fallthrough
	case "eu-west-2":
		fallthrough
	case "eu-west-3":
		fallthrough
	case "il-central-1":
		fallthrough
	case "me-central-1":
		fallthrough
	case "me-south-1":
		fallthrough
	case "sa-east-1":
		fallthrough
	case "us-east-1":
		fallthrough
	case "us-east-2":
		fallthrough
	case "us-gov-east-1":
		fallthrough
	case "us-gov-west-1":
		fallthrough
	case "us-west-1":
		fallthrough
	case "us-west-2":
		*e = DestinationHubspotS3BucketRegion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationHubspotS3BucketRegion: %v", v)
	}
}

type DestinationHubspotSchemasStorageType string

const (
	DestinationHubspotSchemasStorageTypeS3 DestinationHubspotSchemasStorageType = "S3"
)

func (e DestinationHubspotSchemasStorageType) ToPointer() *DestinationHubspotSchemasStorageType {
	return &e
}
func (e *DestinationHubspotSchemasStorageType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "S3":
		*e = DestinationHubspotSchemasStorageType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationHubspotSchemasStorageType: %v", v)
	}
}

type DestinationHubspotS3 struct {
	// The access key ID to access the S3 bucket. Airbyte requires Read and Write permissions to the given bucket. Read more <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">here</a>.
	AccessKeyID *string `json:"access_key_id,omitempty"`
	// All files in the bucket will be prefixed by this.
	BucketPath string `json:"bucket_path"`
	// Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").
	Compression    *DestinationHubspotCompression `json:"compression,omitempty"`
	FileNameFormat *string                        `default:"{date}_{timestamp}_{part_number}{format_extension}" json:"file_name_format"`
	// Format of the data output.
	Format     DestinationHubspotOutputFormat `json:"format"`
	PathFormat *string                        `default:"{sync_id}/{namespace}/{stream_name}/" json:"path_format"`
	// The ARN of the AWS role to assume. Only usable in Airbyte Cloud.
	RoleArn *string `json:"role_arn,omitempty"`
	// The name of the S3 bucket. Read more <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/create-bucket-overview.html">here</a>.
	S3BucketName string `json:"s3_bucket_name"`
	// The region of the S3 bucket. See <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-available-regions">here</a> for all region codes.
	S3BucketRegion *DestinationHubspotS3BucketRegion `default:"" json:"s3_bucket_region"`
	// Your S3 endpoint url. Read more <a href="https://docs.aws.amazon.com/general/latest/gr/s3.html#:~:text=Service%20endpoints-,Amazon%20S3%20endpoints,-When%20you%20use">here</a>
	S3Endpoint *string `json:"s3_endpoint,omitempty"`
	// The corresponding secret to the access key ID. Read more <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">here</a>
	SecretAccessKey      *string                               `json:"secret_access_key,omitempty"`
	StorageType          *DestinationHubspotSchemasStorageType `default:"S3" json:"storage_type"`
	AdditionalProperties any                                   `additionalProperties:"true" json:"-"`
}

func (d DestinationHubspotS3) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationHubspotS3) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationHubspotS3) GetAccessKeyID() *string {
	if d == nil {
		return nil
	}
	return d.AccessKeyID
}

func (d *DestinationHubspotS3) GetBucketPath() string {
	if d == nil {
		return ""
	}
	return d.BucketPath
}

func (d *DestinationHubspotS3) GetCompression() *DestinationHubspotCompression {
	if d == nil {
		return nil
	}
	return d.Compression
}

func (d *DestinationHubspotS3) GetFileNameFormat() *string {
	if d == nil {
		return nil
	}
	return d.FileNameFormat
}

func (d *DestinationHubspotS3) GetFormat() DestinationHubspotOutputFormat {
	if d == nil {
		return DestinationHubspotOutputFormat{}
	}
	return d.Format
}

func (d *DestinationHubspotS3) GetPathFormat() *string {
	if d == nil {
		return nil
	}
	return d.PathFormat
}

func (d *DestinationHubspotS3) GetRoleArn() *string {
	if d == nil {
		return nil
	}
	return d.RoleArn
}

func (d *DestinationHubspotS3) GetS3BucketName() string {
	if d == nil {
		return ""
	}
	return d.S3BucketName
}

func (d *DestinationHubspotS3) GetS3BucketRegion() *DestinationHubspotS3BucketRegion {
	if d == nil {
		return nil
	}
	return d.S3BucketRegion
}

func (d *DestinationHubspotS3) GetS3Endpoint() *string {
	if d == nil {
		return nil
	}
	return d.S3Endpoint
}

func (d *DestinationHubspotS3) GetSecretAccessKey() *string {
	if d == nil {
		return nil
	}
	return d.SecretAccessKey
}

func (d *DestinationHubspotS3) GetStorageType() *DestinationHubspotSchemasStorageType {
	if d == nil {
		return nil
	}
	return d.StorageType
}

func (d *DestinationHubspotS3) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationHubspotStorageType string

const (
	DestinationHubspotStorageTypeNone DestinationHubspotStorageType = "None"
)

func (e DestinationHubspotStorageType) ToPointer() *DestinationHubspotStorageType {
	return &e
}
func (e *DestinationHubspotStorageType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "None":
		*e = DestinationHubspotStorageType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationHubspotStorageType: %v", v)
	}
}

type DestinationHubspotNone struct {
	StorageType          *DestinationHubspotStorageType `default:"None" json:"storage_type"`
	AdditionalProperties any                            `additionalProperties:"true" json:"-"`
}

func (d DestinationHubspotNone) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationHubspotNone) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationHubspotNone) GetStorageType() *DestinationHubspotStorageType {
	if d == nil {
		return nil
	}
	return d.StorageType
}

func (d *DestinationHubspotNone) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type ObjectStorageConfigurationType string

const (
	ObjectStorageConfigurationTypeDestinationHubspotNone ObjectStorageConfigurationType = "destination-hubspot_None"
	ObjectStorageConfigurationTypeDestinationHubspotS3   ObjectStorageConfigurationType = "destination-hubspot_S3"
)

type ObjectStorageConfiguration struct {
	DestinationHubspotNone *DestinationHubspotNone `queryParam:"inline" union:"member"`
	DestinationHubspotS3   *DestinationHubspotS3   `queryParam:"inline" union:"member"`

	Type ObjectStorageConfigurationType
}

func CreateObjectStorageConfigurationDestinationHubspotNone(destinationHubspotNone DestinationHubspotNone) ObjectStorageConfiguration {
	typ := ObjectStorageConfigurationTypeDestinationHubspotNone

	return ObjectStorageConfiguration{
		DestinationHubspotNone: &destinationHubspotNone,
		Type:                   typ,
	}
}

func CreateObjectStorageConfigurationDestinationHubspotS3(destinationHubspotS3 DestinationHubspotS3) ObjectStorageConfiguration {
	typ := ObjectStorageConfigurationTypeDestinationHubspotS3

	return ObjectStorageConfiguration{
		DestinationHubspotS3: &destinationHubspotS3,
		Type:                 typ,
	}
}

func (u *ObjectStorageConfiguration) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var destinationHubspotNone DestinationHubspotNone = DestinationHubspotNone{}
	if err := utils.UnmarshalJSON(data, &destinationHubspotNone, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ObjectStorageConfigurationTypeDestinationHubspotNone,
			Value: &destinationHubspotNone,
		})
	}

	var destinationHubspotS3 DestinationHubspotS3 = DestinationHubspotS3{}
	if err := utils.UnmarshalJSON(data, &destinationHubspotS3, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ObjectStorageConfigurationTypeDestinationHubspotS3,
			Value: &destinationHubspotS3,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for ObjectStorageConfiguration", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for ObjectStorageConfiguration", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(ObjectStorageConfigurationType)
	switch best.Type {
	case ObjectStorageConfigurationTypeDestinationHubspotNone:
		u.DestinationHubspotNone = best.Value.(*DestinationHubspotNone)
		return nil
	case ObjectStorageConfigurationTypeDestinationHubspotS3:
		u.DestinationHubspotS3 = best.Value.(*DestinationHubspotS3)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ObjectStorageConfiguration", string(data))
}

func (u ObjectStorageConfiguration) MarshalJSON() ([]byte, error) {
	if u.DestinationHubspotNone != nil {
		return utils.MarshalJSON(u.DestinationHubspotNone, "", true)
	}

	if u.DestinationHubspotS3 != nil {
		return utils.MarshalJSON(u.DestinationHubspotS3, "", true)
	}

	return nil, errors.New("could not marshal union type ObjectStorageConfiguration: all fields are null")
}

type DestinationHubspotDestinationType string

const (
	DestinationHubspotDestinationTypeHubspot DestinationHubspotDestinationType = "hubspot"
)

func (e DestinationHubspotDestinationType) ToPointer() *DestinationHubspotDestinationType {
	return &e
}
func (e *DestinationHubspotDestinationType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "hubspot":
		*e = DestinationHubspotDestinationType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationHubspotDestinationType: %v", v)
	}
}

type DestinationHubspot struct {
	// Choose how to authenticate to HubSpot.
	Credentials          DestinationHubspotCredentials      `json:"credentials"`
	ObjectStorageConfig  *ObjectStorageConfiguration        `json:"object_storage_config,omitempty"`
	destinationType      *DestinationHubspotDestinationType `const:"hubspot" json:"destinationType"`
	AdditionalProperties any                                `additionalProperties:"true" json:"-"`
}

func (d DestinationHubspot) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationHubspot) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationHubspot) GetCredentials() DestinationHubspotCredentials {
	if d == nil {
		return DestinationHubspotCredentials{}
	}
	return d.Credentials
}

func (d *DestinationHubspot) GetObjectStorageConfig() *ObjectStorageConfiguration {
	if d == nil {
		return nil
	}
	return d.ObjectStorageConfig
}

func (d *DestinationHubspot) GetDestinationType() *DestinationHubspotDestinationType {
	return DestinationHubspotDestinationTypeHubspot.ToPointer()
}

func (d *DestinationHubspot) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}
