// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

// LoginPassword - Login/Password.
type LoginPassword struct {
	authorization string `const:"login/password" json:"authorization"`
	// Password associated with the username.
	Password string `json:"password"`
	// Username to use to access the database.
	Username string `json:"username"`
}

func (l LoginPassword) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *LoginPassword) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (l *LoginPassword) GetAuthorization() string {
	return "login/password"
}

func (l *LoginPassword) GetPassword() string {
	if l == nil {
		return ""
	}
	return l.Password
}

func (l *LoginPassword) GetUsername() string {
	if l == nil {
		return ""
	}
	return l.Username
}

// DestinationMongodbNone - None.
type DestinationMongodbNone struct {
	authorization string `const:"none" json:"authorization"`
}

func (d DestinationMongodbNone) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationMongodbNone) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationMongodbNone) GetAuthorization() string {
	return "none"
}

type AuthorizationTypeType string

const (
	AuthorizationTypeTypeDestinationMongodbNone AuthorizationTypeType = "destination-mongodb_None"
	AuthorizationTypeTypeLoginPassword          AuthorizationTypeType = "Login/Password"
)

// AuthorizationType - Authorization type.
type AuthorizationType struct {
	DestinationMongodbNone *DestinationMongodbNone `queryParam:"inline" union:"member"`
	LoginPassword          *LoginPassword          `queryParam:"inline" union:"member"`

	Type AuthorizationTypeType
}

func CreateAuthorizationTypeDestinationMongodbNone(destinationMongodbNone DestinationMongodbNone) AuthorizationType {
	typ := AuthorizationTypeTypeDestinationMongodbNone

	return AuthorizationType{
		DestinationMongodbNone: &destinationMongodbNone,
		Type:                   typ,
	}
}

func CreateAuthorizationTypeLoginPassword(loginPassword LoginPassword) AuthorizationType {
	typ := AuthorizationTypeTypeLoginPassword

	return AuthorizationType{
		LoginPassword: &loginPassword,
		Type:          typ,
	}
}

func (u *AuthorizationType) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var destinationMongodbNone DestinationMongodbNone = DestinationMongodbNone{}
	if err := utils.UnmarshalJSON(data, &destinationMongodbNone, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  AuthorizationTypeTypeDestinationMongodbNone,
			Value: &destinationMongodbNone,
		})
	}

	var loginPassword LoginPassword = LoginPassword{}
	if err := utils.UnmarshalJSON(data, &loginPassword, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  AuthorizationTypeTypeLoginPassword,
			Value: &loginPassword,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for AuthorizationType", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for AuthorizationType", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(AuthorizationTypeType)
	switch best.Type {
	case AuthorizationTypeTypeDestinationMongodbNone:
		u.DestinationMongodbNone = best.Value.(*DestinationMongodbNone)
		return nil
	case AuthorizationTypeTypeLoginPassword:
		u.LoginPassword = best.Value.(*LoginPassword)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for AuthorizationType", string(data))
}

func (u AuthorizationType) MarshalJSON() ([]byte, error) {
	if u.DestinationMongodbNone != nil {
		return utils.MarshalJSON(u.DestinationMongodbNone, "", true)
	}

	if u.LoginPassword != nil {
		return utils.MarshalJSON(u.LoginPassword, "", true)
	}

	return nil, errors.New("could not marshal union type AuthorizationType: all fields are null")
}

type DestinationMongodbSchemasInstance string

const (
	DestinationMongodbSchemasInstanceAtlas DestinationMongodbSchemasInstance = "atlas"
)

func (e DestinationMongodbSchemasInstance) ToPointer() *DestinationMongodbSchemasInstance {
	return &e
}
func (e *DestinationMongodbSchemasInstance) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "atlas":
		*e = DestinationMongodbSchemasInstance(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationMongodbSchemasInstance: %v", v)
	}
}

type MongoDBAtlas struct {
	// URL of a cluster to connect to.
	ClusterURL string                             `json:"cluster_url"`
	Instance   *DestinationMongodbSchemasInstance `default:"atlas" json:"instance"`
}

func (m MongoDBAtlas) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(m, "", false)
}

func (m *MongoDBAtlas) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &m, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (m *MongoDBAtlas) GetClusterURL() string {
	if m == nil {
		return ""
	}
	return m.ClusterURL
}

func (m *MongoDBAtlas) GetInstance() *DestinationMongodbSchemasInstance {
	if m == nil {
		return nil
	}
	return m.Instance
}

type DestinationMongodbInstance string

const (
	DestinationMongodbInstanceReplica DestinationMongodbInstance = "replica"
)

func (e DestinationMongodbInstance) ToPointer() *DestinationMongodbInstance {
	return &e
}
func (e *DestinationMongodbInstance) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "replica":
		*e = DestinationMongodbInstance(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationMongodbInstance: %v", v)
	}
}

type ReplicaSet struct {
	Instance *DestinationMongodbInstance `default:"replica" json:"instance"`
	// A replica set name.
	ReplicaSet *string `json:"replica_set,omitempty"`
	// The members of a replica set. Please specify `host`:`port` of each member seperated by comma.
	ServerAddresses string `json:"server_addresses"`
}

func (r ReplicaSet) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(r, "", false)
}

func (r *ReplicaSet) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &r, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (r *ReplicaSet) GetInstance() *DestinationMongodbInstance {
	if r == nil {
		return nil
	}
	return r.Instance
}

func (r *ReplicaSet) GetReplicaSet() *string {
	if r == nil {
		return nil
	}
	return r.ReplicaSet
}

func (r *ReplicaSet) GetServerAddresses() string {
	if r == nil {
		return ""
	}
	return r.ServerAddresses
}

type Instance string

const (
	InstanceStandalone Instance = "standalone"
)

func (e Instance) ToPointer() *Instance {
	return &e
}
func (e *Instance) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "standalone":
		*e = Instance(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Instance: %v", v)
	}
}

type StandaloneMongoDbInstance struct {
	// The Host of a Mongo database to be replicated.
	Host     string    `json:"host"`
	Instance *Instance `default:"standalone" json:"instance"`
	// The Port of a Mongo database to be replicated.
	Port *int64 `default:"27017" json:"port"`
	// Indicates whether TLS encryption protocol will be used to connect to MongoDB. It is recommended to use TLS connection if possible. For more information see <a href="https://docs.airbyte.com/integrations/sources/mongodb-v2">documentation</a>.
	TLS *bool `default:"false" json:"tls"`
}

func (s StandaloneMongoDbInstance) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *StandaloneMongoDbInstance) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *StandaloneMongoDbInstance) GetHost() string {
	if s == nil {
		return ""
	}
	return s.Host
}

func (s *StandaloneMongoDbInstance) GetInstance() *Instance {
	if s == nil {
		return nil
	}
	return s.Instance
}

func (s *StandaloneMongoDbInstance) GetPort() *int64 {
	if s == nil {
		return nil
	}
	return s.Port
}

func (s *StandaloneMongoDbInstance) GetTLS() *bool {
	if s == nil {
		return nil
	}
	return s.TLS
}

type MongoDbInstanceTypeType string

const (
	MongoDbInstanceTypeTypeStandaloneMongoDbInstance MongoDbInstanceTypeType = "Standalone MongoDb Instance"
	MongoDbInstanceTypeTypeReplicaSet                MongoDbInstanceTypeType = "Replica Set"
	MongoDbInstanceTypeTypeMongoDBAtlas              MongoDbInstanceTypeType = "MongoDB Atlas"
)

// MongoDbInstanceType - MongoDb instance to connect to. For MongoDB Atlas and Replica Set TLS connection is used by default.
type MongoDbInstanceType struct {
	StandaloneMongoDbInstance *StandaloneMongoDbInstance `queryParam:"inline" union:"member"`
	ReplicaSet                *ReplicaSet                `queryParam:"inline" union:"member"`
	MongoDBAtlas              *MongoDBAtlas              `queryParam:"inline" union:"member"`

	Type MongoDbInstanceTypeType
}

func CreateMongoDbInstanceTypeStandaloneMongoDbInstance(standaloneMongoDbInstance StandaloneMongoDbInstance) MongoDbInstanceType {
	typ := MongoDbInstanceTypeTypeStandaloneMongoDbInstance

	return MongoDbInstanceType{
		StandaloneMongoDbInstance: &standaloneMongoDbInstance,
		Type:                      typ,
	}
}

func CreateMongoDbInstanceTypeReplicaSet(replicaSet ReplicaSet) MongoDbInstanceType {
	typ := MongoDbInstanceTypeTypeReplicaSet

	return MongoDbInstanceType{
		ReplicaSet: &replicaSet,
		Type:       typ,
	}
}

func CreateMongoDbInstanceTypeMongoDBAtlas(mongoDBAtlas MongoDBAtlas) MongoDbInstanceType {
	typ := MongoDbInstanceTypeTypeMongoDBAtlas

	return MongoDbInstanceType{
		MongoDBAtlas: &mongoDBAtlas,
		Type:         typ,
	}
}

func (u *MongoDbInstanceType) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var standaloneMongoDbInstance StandaloneMongoDbInstance = StandaloneMongoDbInstance{}
	if err := utils.UnmarshalJSON(data, &standaloneMongoDbInstance, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  MongoDbInstanceTypeTypeStandaloneMongoDbInstance,
			Value: &standaloneMongoDbInstance,
		})
	}

	var replicaSet ReplicaSet = ReplicaSet{}
	if err := utils.UnmarshalJSON(data, &replicaSet, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  MongoDbInstanceTypeTypeReplicaSet,
			Value: &replicaSet,
		})
	}

	var mongoDBAtlas MongoDBAtlas = MongoDBAtlas{}
	if err := utils.UnmarshalJSON(data, &mongoDBAtlas, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  MongoDbInstanceTypeTypeMongoDBAtlas,
			Value: &mongoDBAtlas,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for MongoDbInstanceType", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for MongoDbInstanceType", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(MongoDbInstanceTypeType)
	switch best.Type {
	case MongoDbInstanceTypeTypeStandaloneMongoDbInstance:
		u.StandaloneMongoDbInstance = best.Value.(*StandaloneMongoDbInstance)
		return nil
	case MongoDbInstanceTypeTypeReplicaSet:
		u.ReplicaSet = best.Value.(*ReplicaSet)
		return nil
	case MongoDbInstanceTypeTypeMongoDBAtlas:
		u.MongoDBAtlas = best.Value.(*MongoDBAtlas)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for MongoDbInstanceType", string(data))
}

func (u MongoDbInstanceType) MarshalJSON() ([]byte, error) {
	if u.StandaloneMongoDbInstance != nil {
		return utils.MarshalJSON(u.StandaloneMongoDbInstance, "", true)
	}

	if u.ReplicaSet != nil {
		return utils.MarshalJSON(u.ReplicaSet, "", true)
	}

	if u.MongoDBAtlas != nil {
		return utils.MarshalJSON(u.MongoDBAtlas, "", true)
	}

	return nil, errors.New("could not marshal union type MongoDbInstanceType: all fields are null")
}

type DestinationMongodbPasswordAuthentication struct {
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and password authentication
	tunnelMethod string `const:"SSH_PASSWORD_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser string `json:"tunnel_user"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword string `json:"tunnel_user_password"`
}

func (d DestinationMongodbPasswordAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationMongodbPasswordAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationMongodbPasswordAuthentication) GetTunnelHost() string {
	if d == nil {
		return ""
	}
	return d.TunnelHost
}

func (d *DestinationMongodbPasswordAuthentication) GetTunnelMethod() string {
	return "SSH_PASSWORD_AUTH"
}

func (d *DestinationMongodbPasswordAuthentication) GetTunnelPort() *int64 {
	if d == nil {
		return nil
	}
	return d.TunnelPort
}

func (d *DestinationMongodbPasswordAuthentication) GetTunnelUser() string {
	if d == nil {
		return ""
	}
	return d.TunnelUser
}

func (d *DestinationMongodbPasswordAuthentication) GetTunnelUserPassword() string {
	if d == nil {
		return ""
	}
	return d.TunnelUserPassword
}

type DestinationMongodbSSHKeyAuthentication struct {
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey string `json:"ssh_key"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and ssh key
	tunnelMethod string `const:"SSH_KEY_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host.
	TunnelUser string `json:"tunnel_user"`
}

func (d DestinationMongodbSSHKeyAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationMongodbSSHKeyAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationMongodbSSHKeyAuthentication) GetSSHKey() string {
	if d == nil {
		return ""
	}
	return d.SSHKey
}

func (d *DestinationMongodbSSHKeyAuthentication) GetTunnelHost() string {
	if d == nil {
		return ""
	}
	return d.TunnelHost
}

func (d *DestinationMongodbSSHKeyAuthentication) GetTunnelMethod() string {
	return "SSH_KEY_AUTH"
}

func (d *DestinationMongodbSSHKeyAuthentication) GetTunnelPort() *int64 {
	if d == nil {
		return nil
	}
	return d.TunnelPort
}

func (d *DestinationMongodbSSHKeyAuthentication) GetTunnelUser() string {
	if d == nil {
		return ""
	}
	return d.TunnelUser
}

type DestinationMongodbNoTunnel struct {
	// No ssh tunnel needed to connect to database
	tunnelMethod string `const:"NO_TUNNEL" json:"tunnel_method"`
}

func (d DestinationMongodbNoTunnel) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationMongodbNoTunnel) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationMongodbNoTunnel) GetTunnelMethod() string {
	return "NO_TUNNEL"
}

type DestinationMongodbSSHTunnelMethodType string

const (
	DestinationMongodbSSHTunnelMethodTypeDestinationMongodbNoTunnel               DestinationMongodbSSHTunnelMethodType = "destination-mongodb_No Tunnel"
	DestinationMongodbSSHTunnelMethodTypeDestinationMongodbSSHKeyAuthentication   DestinationMongodbSSHTunnelMethodType = "destination-mongodb_SSH Key Authentication"
	DestinationMongodbSSHTunnelMethodTypeDestinationMongodbPasswordAuthentication DestinationMongodbSSHTunnelMethodType = "destination-mongodb_Password Authentication"
)

// DestinationMongodbSSHTunnelMethod - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type DestinationMongodbSSHTunnelMethod struct {
	DestinationMongodbNoTunnel               *DestinationMongodbNoTunnel               `queryParam:"inline" union:"member"`
	DestinationMongodbSSHKeyAuthentication   *DestinationMongodbSSHKeyAuthentication   `queryParam:"inline" union:"member"`
	DestinationMongodbPasswordAuthentication *DestinationMongodbPasswordAuthentication `queryParam:"inline" union:"member"`

	Type DestinationMongodbSSHTunnelMethodType
}

func CreateDestinationMongodbSSHTunnelMethodDestinationMongodbNoTunnel(destinationMongodbNoTunnel DestinationMongodbNoTunnel) DestinationMongodbSSHTunnelMethod {
	typ := DestinationMongodbSSHTunnelMethodTypeDestinationMongodbNoTunnel

	return DestinationMongodbSSHTunnelMethod{
		DestinationMongodbNoTunnel: &destinationMongodbNoTunnel,
		Type:                       typ,
	}
}

func CreateDestinationMongodbSSHTunnelMethodDestinationMongodbSSHKeyAuthentication(destinationMongodbSSHKeyAuthentication DestinationMongodbSSHKeyAuthentication) DestinationMongodbSSHTunnelMethod {
	typ := DestinationMongodbSSHTunnelMethodTypeDestinationMongodbSSHKeyAuthentication

	return DestinationMongodbSSHTunnelMethod{
		DestinationMongodbSSHKeyAuthentication: &destinationMongodbSSHKeyAuthentication,
		Type:                                   typ,
	}
}

func CreateDestinationMongodbSSHTunnelMethodDestinationMongodbPasswordAuthentication(destinationMongodbPasswordAuthentication DestinationMongodbPasswordAuthentication) DestinationMongodbSSHTunnelMethod {
	typ := DestinationMongodbSSHTunnelMethodTypeDestinationMongodbPasswordAuthentication

	return DestinationMongodbSSHTunnelMethod{
		DestinationMongodbPasswordAuthentication: &destinationMongodbPasswordAuthentication,
		Type:                                     typ,
	}
}

func (u *DestinationMongodbSSHTunnelMethod) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var destinationMongodbNoTunnel DestinationMongodbNoTunnel = DestinationMongodbNoTunnel{}
	if err := utils.UnmarshalJSON(data, &destinationMongodbNoTunnel, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationMongodbSSHTunnelMethodTypeDestinationMongodbNoTunnel,
			Value: &destinationMongodbNoTunnel,
		})
	}

	var destinationMongodbSSHKeyAuthentication DestinationMongodbSSHKeyAuthentication = DestinationMongodbSSHKeyAuthentication{}
	if err := utils.UnmarshalJSON(data, &destinationMongodbSSHKeyAuthentication, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationMongodbSSHTunnelMethodTypeDestinationMongodbSSHKeyAuthentication,
			Value: &destinationMongodbSSHKeyAuthentication,
		})
	}

	var destinationMongodbPasswordAuthentication DestinationMongodbPasswordAuthentication = DestinationMongodbPasswordAuthentication{}
	if err := utils.UnmarshalJSON(data, &destinationMongodbPasswordAuthentication, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationMongodbSSHTunnelMethodTypeDestinationMongodbPasswordAuthentication,
			Value: &destinationMongodbPasswordAuthentication,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationMongodbSSHTunnelMethod", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationMongodbSSHTunnelMethod", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(DestinationMongodbSSHTunnelMethodType)
	switch best.Type {
	case DestinationMongodbSSHTunnelMethodTypeDestinationMongodbNoTunnel:
		u.DestinationMongodbNoTunnel = best.Value.(*DestinationMongodbNoTunnel)
		return nil
	case DestinationMongodbSSHTunnelMethodTypeDestinationMongodbSSHKeyAuthentication:
		u.DestinationMongodbSSHKeyAuthentication = best.Value.(*DestinationMongodbSSHKeyAuthentication)
		return nil
	case DestinationMongodbSSHTunnelMethodTypeDestinationMongodbPasswordAuthentication:
		u.DestinationMongodbPasswordAuthentication = best.Value.(*DestinationMongodbPasswordAuthentication)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationMongodbSSHTunnelMethod", string(data))
}

func (u DestinationMongodbSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.DestinationMongodbNoTunnel != nil {
		return utils.MarshalJSON(u.DestinationMongodbNoTunnel, "", true)
	}

	if u.DestinationMongodbSSHKeyAuthentication != nil {
		return utils.MarshalJSON(u.DestinationMongodbSSHKeyAuthentication, "", true)
	}

	if u.DestinationMongodbPasswordAuthentication != nil {
		return utils.MarshalJSON(u.DestinationMongodbPasswordAuthentication, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationMongodbSSHTunnelMethod: all fields are null")
}

type DestinationMongodbDestinationType string

const (
	DestinationMongodbDestinationTypeMongodb DestinationMongodbDestinationType = "mongodb"
)

func (e DestinationMongodbDestinationType) ToPointer() *DestinationMongodbDestinationType {
	return &e
}
func (e *DestinationMongodbDestinationType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "mongodb":
		*e = DestinationMongodbDestinationType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationMongodbDestinationType: %v", v)
	}
}

type DestinationMongodb struct {
	// Authorization type.
	AuthType AuthorizationType `json:"auth_type"`
	// Name of the database.
	Database string `json:"database"`
	// MongoDb instance to connect to. For MongoDB Atlas and Replica Set TLS connection is used by default.
	InstanceType *MongoDbInstanceType `json:"instance_type,omitempty"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod    *DestinationMongodbSSHTunnelMethod `json:"tunnel_method,omitempty"`
	destinationType *DestinationMongodbDestinationType `const:"mongodb" json:"destinationType"`
}

func (d DestinationMongodb) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationMongodb) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationMongodb) GetAuthType() AuthorizationType {
	if d == nil {
		return AuthorizationType{}
	}
	return d.AuthType
}

func (d *DestinationMongodb) GetDatabase() string {
	if d == nil {
		return ""
	}
	return d.Database
}

func (d *DestinationMongodb) GetInstanceType() *MongoDbInstanceType {
	if d == nil {
		return nil
	}
	return d.InstanceType
}

func (d *DestinationMongodb) GetTunnelMethod() *DestinationMongodbSSHTunnelMethod {
	if d == nil {
		return nil
	}
	return d.TunnelMethod
}

func (d *DestinationMongodb) GetDestinationType() *DestinationMongodbDestinationType {
	return DestinationMongodbDestinationTypeMongodb.ToPointer()
}
