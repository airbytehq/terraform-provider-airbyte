// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

type DestinationMongodbSchemasAuthorization string

const (
	DestinationMongodbSchemasAuthorizationLoginPassword DestinationMongodbSchemasAuthorization = "login/password"
)

func (e DestinationMongodbSchemasAuthorization) ToPointer() *DestinationMongodbSchemasAuthorization {
	return &e
}
func (e *DestinationMongodbSchemasAuthorization) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "login/password":
		*e = DestinationMongodbSchemasAuthorization(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationMongodbSchemasAuthorization: %v", v)
	}
}

// DestinationMongodbLoginPassword - Login/Password.
type DestinationMongodbLoginPassword struct {
	authorization DestinationMongodbSchemasAuthorization `const:"login/password" json:"authorization"`
	// Password associated with the username.
	Password string `json:"password"`
	// Username to use to access the database.
	Username string `json:"username"`
}

func (d DestinationMongodbLoginPassword) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationMongodbLoginPassword) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationMongodbLoginPassword) GetAuthorization() DestinationMongodbSchemasAuthorization {
	return DestinationMongodbSchemasAuthorizationLoginPassword
}

func (o *DestinationMongodbLoginPassword) GetPassword() string {
	if o == nil {
		return ""
	}
	return o.Password
}

func (o *DestinationMongodbLoginPassword) GetUsername() string {
	if o == nil {
		return ""
	}
	return o.Username
}

type DestinationMongodbAuthorization string

const (
	DestinationMongodbAuthorizationNone DestinationMongodbAuthorization = "none"
)

func (e DestinationMongodbAuthorization) ToPointer() *DestinationMongodbAuthorization {
	return &e
}
func (e *DestinationMongodbAuthorization) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "none":
		*e = DestinationMongodbAuthorization(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationMongodbAuthorization: %v", v)
	}
}

// DestinationMongodbNone - None.
type DestinationMongodbNone struct {
	authorization DestinationMongodbAuthorization `const:"none" json:"authorization"`
}

func (d DestinationMongodbNone) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationMongodbNone) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationMongodbNone) GetAuthorization() DestinationMongodbAuthorization {
	return DestinationMongodbAuthorizationNone
}

type DestinationMongodbAuthorizationTypeType string

const (
	DestinationMongodbAuthorizationTypeTypeDestinationMongodbNone          DestinationMongodbAuthorizationTypeType = "destination-mongodb_None"
	DestinationMongodbAuthorizationTypeTypeDestinationMongodbLoginPassword DestinationMongodbAuthorizationTypeType = "destination-mongodb_Login/Password"
)

// DestinationMongodbAuthorizationType - Authorization type.
type DestinationMongodbAuthorizationType struct {
	DestinationMongodbNone          *DestinationMongodbNone
	DestinationMongodbLoginPassword *DestinationMongodbLoginPassword

	Type DestinationMongodbAuthorizationTypeType
}

func CreateDestinationMongodbAuthorizationTypeDestinationMongodbNone(destinationMongodbNone DestinationMongodbNone) DestinationMongodbAuthorizationType {
	typ := DestinationMongodbAuthorizationTypeTypeDestinationMongodbNone

	return DestinationMongodbAuthorizationType{
		DestinationMongodbNone: &destinationMongodbNone,
		Type:                   typ,
	}
}

func CreateDestinationMongodbAuthorizationTypeDestinationMongodbLoginPassword(destinationMongodbLoginPassword DestinationMongodbLoginPassword) DestinationMongodbAuthorizationType {
	typ := DestinationMongodbAuthorizationTypeTypeDestinationMongodbLoginPassword

	return DestinationMongodbAuthorizationType{
		DestinationMongodbLoginPassword: &destinationMongodbLoginPassword,
		Type:                            typ,
	}
}

func (u *DestinationMongodbAuthorizationType) UnmarshalJSON(data []byte) error {

	var destinationMongodbNone DestinationMongodbNone = DestinationMongodbNone{}
	if err := utils.UnmarshalJSON(data, &destinationMongodbNone, "", true, true); err == nil {
		u.DestinationMongodbNone = &destinationMongodbNone
		u.Type = DestinationMongodbAuthorizationTypeTypeDestinationMongodbNone
		return nil
	}

	var destinationMongodbLoginPassword DestinationMongodbLoginPassword = DestinationMongodbLoginPassword{}
	if err := utils.UnmarshalJSON(data, &destinationMongodbLoginPassword, "", true, true); err == nil {
		u.DestinationMongodbLoginPassword = &destinationMongodbLoginPassword
		u.Type = DestinationMongodbAuthorizationTypeTypeDestinationMongodbLoginPassword
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationMongodbAuthorizationType", string(data))
}

func (u DestinationMongodbAuthorizationType) MarshalJSON() ([]byte, error) {
	if u.DestinationMongodbNone != nil {
		return utils.MarshalJSON(u.DestinationMongodbNone, "", true)
	}

	if u.DestinationMongodbLoginPassword != nil {
		return utils.MarshalJSON(u.DestinationMongodbLoginPassword, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationMongodbAuthorizationType: all fields are null")
}

type Mongodb string

const (
	MongodbMongodb Mongodb = "mongodb"
)

func (e Mongodb) ToPointer() *Mongodb {
	return &e
}
func (e *Mongodb) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "mongodb":
		*e = Mongodb(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Mongodb: %v", v)
	}
}

type DestinationMongodbSchemasInstanceTypeInstance string

const (
	DestinationMongodbSchemasInstanceTypeInstanceAtlas DestinationMongodbSchemasInstanceTypeInstance = "atlas"
)

func (e DestinationMongodbSchemasInstanceTypeInstance) ToPointer() *DestinationMongodbSchemasInstanceTypeInstance {
	return &e
}
func (e *DestinationMongodbSchemasInstanceTypeInstance) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "atlas":
		*e = DestinationMongodbSchemasInstanceTypeInstance(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationMongodbSchemasInstanceTypeInstance: %v", v)
	}
}

type DestinationMongodbMongoDBAtlas struct {
	// URL of a cluster to connect to.
	ClusterURL string                                         `json:"cluster_url"`
	Instance   *DestinationMongodbSchemasInstanceTypeInstance `default:"atlas" json:"instance"`
}

func (d DestinationMongodbMongoDBAtlas) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationMongodbMongoDBAtlas) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationMongodbMongoDBAtlas) GetClusterURL() string {
	if o == nil {
		return ""
	}
	return o.ClusterURL
}

func (o *DestinationMongodbMongoDBAtlas) GetInstance() *DestinationMongodbSchemasInstanceTypeInstance {
	if o == nil {
		return nil
	}
	return o.Instance
}

type DestinationMongodbSchemasInstance string

const (
	DestinationMongodbSchemasInstanceReplica DestinationMongodbSchemasInstance = "replica"
)

func (e DestinationMongodbSchemasInstance) ToPointer() *DestinationMongodbSchemasInstance {
	return &e
}
func (e *DestinationMongodbSchemasInstance) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "replica":
		*e = DestinationMongodbSchemasInstance(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationMongodbSchemasInstance: %v", v)
	}
}

type DestinationMongodbReplicaSet struct {
	Instance *DestinationMongodbSchemasInstance `default:"replica" json:"instance"`
	// A replica set name.
	ReplicaSet *string `json:"replica_set,omitempty"`
	// The members of a replica set. Please specify `host`:`port` of each member seperated by comma.
	ServerAddresses string `json:"server_addresses"`
}

func (d DestinationMongodbReplicaSet) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationMongodbReplicaSet) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationMongodbReplicaSet) GetInstance() *DestinationMongodbSchemasInstance {
	if o == nil {
		return nil
	}
	return o.Instance
}

func (o *DestinationMongodbReplicaSet) GetReplicaSet() *string {
	if o == nil {
		return nil
	}
	return o.ReplicaSet
}

func (o *DestinationMongodbReplicaSet) GetServerAddresses() string {
	if o == nil {
		return ""
	}
	return o.ServerAddresses
}

type DestinationMongodbInstance string

const (
	DestinationMongodbInstanceStandalone DestinationMongodbInstance = "standalone"
)

func (e DestinationMongodbInstance) ToPointer() *DestinationMongodbInstance {
	return &e
}
func (e *DestinationMongodbInstance) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "standalone":
		*e = DestinationMongodbInstance(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationMongodbInstance: %v", v)
	}
}

type DestinationMongodbStandaloneMongoDbInstance struct {
	// The Host of a Mongo database to be replicated.
	Host     string                      `json:"host"`
	Instance *DestinationMongodbInstance `default:"standalone" json:"instance"`
	// The Port of a Mongo database to be replicated.
	Port *int64 `default:"27017" json:"port"`
}

func (d DestinationMongodbStandaloneMongoDbInstance) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationMongodbStandaloneMongoDbInstance) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationMongodbStandaloneMongoDbInstance) GetHost() string {
	if o == nil {
		return ""
	}
	return o.Host
}

func (o *DestinationMongodbStandaloneMongoDbInstance) GetInstance() *DestinationMongodbInstance {
	if o == nil {
		return nil
	}
	return o.Instance
}

func (o *DestinationMongodbStandaloneMongoDbInstance) GetPort() *int64 {
	if o == nil {
		return nil
	}
	return o.Port
}

type DestinationMongodbMongoDbInstanceTypeType string

const (
	DestinationMongodbMongoDbInstanceTypeTypeDestinationMongodbStandaloneMongoDbInstance DestinationMongodbMongoDbInstanceTypeType = "destination-mongodb_Standalone MongoDb Instance"
	DestinationMongodbMongoDbInstanceTypeTypeDestinationMongodbReplicaSet                DestinationMongodbMongoDbInstanceTypeType = "destination-mongodb_Replica Set"
	DestinationMongodbMongoDbInstanceTypeTypeDestinationMongodbMongoDBAtlas              DestinationMongodbMongoDbInstanceTypeType = "destination-mongodb_MongoDB Atlas"
)

// DestinationMongodbMongoDbInstanceType - MongoDb instance to connect to. For MongoDB Atlas and Replica Set TLS connection is used by default.
type DestinationMongodbMongoDbInstanceType struct {
	DestinationMongodbStandaloneMongoDbInstance *DestinationMongodbStandaloneMongoDbInstance
	DestinationMongodbReplicaSet                *DestinationMongodbReplicaSet
	DestinationMongodbMongoDBAtlas              *DestinationMongodbMongoDBAtlas

	Type DestinationMongodbMongoDbInstanceTypeType
}

func CreateDestinationMongodbMongoDbInstanceTypeDestinationMongodbStandaloneMongoDbInstance(destinationMongodbStandaloneMongoDbInstance DestinationMongodbStandaloneMongoDbInstance) DestinationMongodbMongoDbInstanceType {
	typ := DestinationMongodbMongoDbInstanceTypeTypeDestinationMongodbStandaloneMongoDbInstance

	return DestinationMongodbMongoDbInstanceType{
		DestinationMongodbStandaloneMongoDbInstance: &destinationMongodbStandaloneMongoDbInstance,
		Type: typ,
	}
}

func CreateDestinationMongodbMongoDbInstanceTypeDestinationMongodbReplicaSet(destinationMongodbReplicaSet DestinationMongodbReplicaSet) DestinationMongodbMongoDbInstanceType {
	typ := DestinationMongodbMongoDbInstanceTypeTypeDestinationMongodbReplicaSet

	return DestinationMongodbMongoDbInstanceType{
		DestinationMongodbReplicaSet: &destinationMongodbReplicaSet,
		Type:                         typ,
	}
}

func CreateDestinationMongodbMongoDbInstanceTypeDestinationMongodbMongoDBAtlas(destinationMongodbMongoDBAtlas DestinationMongodbMongoDBAtlas) DestinationMongodbMongoDbInstanceType {
	typ := DestinationMongodbMongoDbInstanceTypeTypeDestinationMongodbMongoDBAtlas

	return DestinationMongodbMongoDbInstanceType{
		DestinationMongodbMongoDBAtlas: &destinationMongodbMongoDBAtlas,
		Type:                           typ,
	}
}

func (u *DestinationMongodbMongoDbInstanceType) UnmarshalJSON(data []byte) error {

	var destinationMongodbMongoDBAtlas DestinationMongodbMongoDBAtlas = DestinationMongodbMongoDBAtlas{}
	if err := utils.UnmarshalJSON(data, &destinationMongodbMongoDBAtlas, "", true, true); err == nil {
		u.DestinationMongodbMongoDBAtlas = &destinationMongodbMongoDBAtlas
		u.Type = DestinationMongodbMongoDbInstanceTypeTypeDestinationMongodbMongoDBAtlas
		return nil
	}

	var destinationMongodbStandaloneMongoDbInstance DestinationMongodbStandaloneMongoDbInstance = DestinationMongodbStandaloneMongoDbInstance{}
	if err := utils.UnmarshalJSON(data, &destinationMongodbStandaloneMongoDbInstance, "", true, true); err == nil {
		u.DestinationMongodbStandaloneMongoDbInstance = &destinationMongodbStandaloneMongoDbInstance
		u.Type = DestinationMongodbMongoDbInstanceTypeTypeDestinationMongodbStandaloneMongoDbInstance
		return nil
	}

	var destinationMongodbReplicaSet DestinationMongodbReplicaSet = DestinationMongodbReplicaSet{}
	if err := utils.UnmarshalJSON(data, &destinationMongodbReplicaSet, "", true, true); err == nil {
		u.DestinationMongodbReplicaSet = &destinationMongodbReplicaSet
		u.Type = DestinationMongodbMongoDbInstanceTypeTypeDestinationMongodbReplicaSet
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationMongodbMongoDbInstanceType", string(data))
}

func (u DestinationMongodbMongoDbInstanceType) MarshalJSON() ([]byte, error) {
	if u.DestinationMongodbStandaloneMongoDbInstance != nil {
		return utils.MarshalJSON(u.DestinationMongodbStandaloneMongoDbInstance, "", true)
	}

	if u.DestinationMongodbReplicaSet != nil {
		return utils.MarshalJSON(u.DestinationMongodbReplicaSet, "", true)
	}

	if u.DestinationMongodbMongoDBAtlas != nil {
		return utils.MarshalJSON(u.DestinationMongodbMongoDBAtlas, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationMongodbMongoDbInstanceType: all fields are null")
}

// DestinationMongodbSchemasTunnelMethodTunnelMethod - Connect through a jump server tunnel host using username and password authentication
type DestinationMongodbSchemasTunnelMethodTunnelMethod string

const (
	DestinationMongodbSchemasTunnelMethodTunnelMethodSSHPasswordAuth DestinationMongodbSchemasTunnelMethodTunnelMethod = "SSH_PASSWORD_AUTH"
)

func (e DestinationMongodbSchemasTunnelMethodTunnelMethod) ToPointer() *DestinationMongodbSchemasTunnelMethodTunnelMethod {
	return &e
}
func (e *DestinationMongodbSchemasTunnelMethodTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_PASSWORD_AUTH":
		*e = DestinationMongodbSchemasTunnelMethodTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationMongodbSchemasTunnelMethodTunnelMethod: %v", v)
	}
}

type DestinationMongodbPasswordAuthentication struct {
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and password authentication
	tunnelMethod DestinationMongodbSchemasTunnelMethodTunnelMethod `const:"SSH_PASSWORD_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser string `json:"tunnel_user"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword string `json:"tunnel_user_password"`
}

func (d DestinationMongodbPasswordAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationMongodbPasswordAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationMongodbPasswordAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *DestinationMongodbPasswordAuthentication) GetTunnelMethod() DestinationMongodbSchemasTunnelMethodTunnelMethod {
	return DestinationMongodbSchemasTunnelMethodTunnelMethodSSHPasswordAuth
}

func (o *DestinationMongodbPasswordAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *DestinationMongodbPasswordAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

func (o *DestinationMongodbPasswordAuthentication) GetTunnelUserPassword() string {
	if o == nil {
		return ""
	}
	return o.TunnelUserPassword
}

// DestinationMongodbSchemasTunnelMethod - Connect through a jump server tunnel host using username and ssh key
type DestinationMongodbSchemasTunnelMethod string

const (
	DestinationMongodbSchemasTunnelMethodSSHKeyAuth DestinationMongodbSchemasTunnelMethod = "SSH_KEY_AUTH"
)

func (e DestinationMongodbSchemasTunnelMethod) ToPointer() *DestinationMongodbSchemasTunnelMethod {
	return &e
}
func (e *DestinationMongodbSchemasTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_KEY_AUTH":
		*e = DestinationMongodbSchemasTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationMongodbSchemasTunnelMethod: %v", v)
	}
}

type DestinationMongodbSSHKeyAuthentication struct {
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey string `json:"ssh_key"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and ssh key
	tunnelMethod DestinationMongodbSchemasTunnelMethod `const:"SSH_KEY_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host.
	TunnelUser string `json:"tunnel_user"`
}

func (d DestinationMongodbSSHKeyAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationMongodbSSHKeyAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationMongodbSSHKeyAuthentication) GetSSHKey() string {
	if o == nil {
		return ""
	}
	return o.SSHKey
}

func (o *DestinationMongodbSSHKeyAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *DestinationMongodbSSHKeyAuthentication) GetTunnelMethod() DestinationMongodbSchemasTunnelMethod {
	return DestinationMongodbSchemasTunnelMethodSSHKeyAuth
}

func (o *DestinationMongodbSSHKeyAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *DestinationMongodbSSHKeyAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

// DestinationMongodbTunnelMethod - No ssh tunnel needed to connect to database
type DestinationMongodbTunnelMethod string

const (
	DestinationMongodbTunnelMethodNoTunnel DestinationMongodbTunnelMethod = "NO_TUNNEL"
)

func (e DestinationMongodbTunnelMethod) ToPointer() *DestinationMongodbTunnelMethod {
	return &e
}
func (e *DestinationMongodbTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NO_TUNNEL":
		*e = DestinationMongodbTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationMongodbTunnelMethod: %v", v)
	}
}

type DestinationMongodbNoTunnel struct {
	// No ssh tunnel needed to connect to database
	tunnelMethod DestinationMongodbTunnelMethod `const:"NO_TUNNEL" json:"tunnel_method"`
}

func (d DestinationMongodbNoTunnel) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationMongodbNoTunnel) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationMongodbNoTunnel) GetTunnelMethod() DestinationMongodbTunnelMethod {
	return DestinationMongodbTunnelMethodNoTunnel
}

type DestinationMongodbSSHTunnelMethodType string

const (
	DestinationMongodbSSHTunnelMethodTypeDestinationMongodbNoTunnel               DestinationMongodbSSHTunnelMethodType = "destination-mongodb_No Tunnel"
	DestinationMongodbSSHTunnelMethodTypeDestinationMongodbSSHKeyAuthentication   DestinationMongodbSSHTunnelMethodType = "destination-mongodb_SSH Key Authentication"
	DestinationMongodbSSHTunnelMethodTypeDestinationMongodbPasswordAuthentication DestinationMongodbSSHTunnelMethodType = "destination-mongodb_Password Authentication"
)

// DestinationMongodbSSHTunnelMethod - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type DestinationMongodbSSHTunnelMethod struct {
	DestinationMongodbNoTunnel               *DestinationMongodbNoTunnel
	DestinationMongodbSSHKeyAuthentication   *DestinationMongodbSSHKeyAuthentication
	DestinationMongodbPasswordAuthentication *DestinationMongodbPasswordAuthentication

	Type DestinationMongodbSSHTunnelMethodType
}

func CreateDestinationMongodbSSHTunnelMethodDestinationMongodbNoTunnel(destinationMongodbNoTunnel DestinationMongodbNoTunnel) DestinationMongodbSSHTunnelMethod {
	typ := DestinationMongodbSSHTunnelMethodTypeDestinationMongodbNoTunnel

	return DestinationMongodbSSHTunnelMethod{
		DestinationMongodbNoTunnel: &destinationMongodbNoTunnel,
		Type:                       typ,
	}
}

func CreateDestinationMongodbSSHTunnelMethodDestinationMongodbSSHKeyAuthentication(destinationMongodbSSHKeyAuthentication DestinationMongodbSSHKeyAuthentication) DestinationMongodbSSHTunnelMethod {
	typ := DestinationMongodbSSHTunnelMethodTypeDestinationMongodbSSHKeyAuthentication

	return DestinationMongodbSSHTunnelMethod{
		DestinationMongodbSSHKeyAuthentication: &destinationMongodbSSHKeyAuthentication,
		Type:                                   typ,
	}
}

func CreateDestinationMongodbSSHTunnelMethodDestinationMongodbPasswordAuthentication(destinationMongodbPasswordAuthentication DestinationMongodbPasswordAuthentication) DestinationMongodbSSHTunnelMethod {
	typ := DestinationMongodbSSHTunnelMethodTypeDestinationMongodbPasswordAuthentication

	return DestinationMongodbSSHTunnelMethod{
		DestinationMongodbPasswordAuthentication: &destinationMongodbPasswordAuthentication,
		Type:                                     typ,
	}
}

func (u *DestinationMongodbSSHTunnelMethod) UnmarshalJSON(data []byte) error {

	var destinationMongodbNoTunnel DestinationMongodbNoTunnel = DestinationMongodbNoTunnel{}
	if err := utils.UnmarshalJSON(data, &destinationMongodbNoTunnel, "", true, true); err == nil {
		u.DestinationMongodbNoTunnel = &destinationMongodbNoTunnel
		u.Type = DestinationMongodbSSHTunnelMethodTypeDestinationMongodbNoTunnel
		return nil
	}

	var destinationMongodbSSHKeyAuthentication DestinationMongodbSSHKeyAuthentication = DestinationMongodbSSHKeyAuthentication{}
	if err := utils.UnmarshalJSON(data, &destinationMongodbSSHKeyAuthentication, "", true, true); err == nil {
		u.DestinationMongodbSSHKeyAuthentication = &destinationMongodbSSHKeyAuthentication
		u.Type = DestinationMongodbSSHTunnelMethodTypeDestinationMongodbSSHKeyAuthentication
		return nil
	}

	var destinationMongodbPasswordAuthentication DestinationMongodbPasswordAuthentication = DestinationMongodbPasswordAuthentication{}
	if err := utils.UnmarshalJSON(data, &destinationMongodbPasswordAuthentication, "", true, true); err == nil {
		u.DestinationMongodbPasswordAuthentication = &destinationMongodbPasswordAuthentication
		u.Type = DestinationMongodbSSHTunnelMethodTypeDestinationMongodbPasswordAuthentication
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationMongodbSSHTunnelMethod", string(data))
}

func (u DestinationMongodbSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.DestinationMongodbNoTunnel != nil {
		return utils.MarshalJSON(u.DestinationMongodbNoTunnel, "", true)
	}

	if u.DestinationMongodbSSHKeyAuthentication != nil {
		return utils.MarshalJSON(u.DestinationMongodbSSHKeyAuthentication, "", true)
	}

	if u.DestinationMongodbPasswordAuthentication != nil {
		return utils.MarshalJSON(u.DestinationMongodbPasswordAuthentication, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationMongodbSSHTunnelMethod: all fields are null")
}

type DestinationMongodb struct {
	// Authorization type.
	AuthType DestinationMongodbAuthorizationType `json:"auth_type"`
	// Name of the database.
	Database        string  `json:"database"`
	destinationType Mongodb `const:"mongodb" json:"destinationType"`
	// MongoDb instance to connect to. For MongoDB Atlas and Replica Set TLS connection is used by default.
	InstanceType *DestinationMongodbMongoDbInstanceType `json:"instance_type,omitempty"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod *DestinationMongodbSSHTunnelMethod `json:"tunnel_method,omitempty"`
}

func (d DestinationMongodb) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationMongodb) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *DestinationMongodb) GetAuthType() DestinationMongodbAuthorizationType {
	if o == nil {
		return DestinationMongodbAuthorizationType{}
	}
	return o.AuthType
}

func (o *DestinationMongodb) GetDatabase() string {
	if o == nil {
		return ""
	}
	return o.Database
}

func (o *DestinationMongodb) GetDestinationType() Mongodb {
	return MongodbMongodb
}

func (o *DestinationMongodb) GetInstanceType() *DestinationMongodbMongoDbInstanceType {
	if o == nil {
		return nil
	}
	return o.InstanceType
}

func (o *DestinationMongodb) GetTunnelMethod() *DestinationMongodbSSHTunnelMethod {
	if o == nil {
		return nil
	}
	return o.TunnelMethod
}
