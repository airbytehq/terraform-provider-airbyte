// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

// DestinationPostgresCDCDeletionMode - Whether to execute CDC deletions as hard deletes (i.e. propagate source deletions to the destination), or soft deletes (i.e. leave a tombstone record in the destination). Defaults to hard deletes.
type DestinationPostgresCDCDeletionMode string

const (
	DestinationPostgresCDCDeletionModeHardDelete DestinationPostgresCDCDeletionMode = "Hard delete"
	DestinationPostgresCDCDeletionModeSoftDelete DestinationPostgresCDCDeletionMode = "Soft delete"
)

func (e DestinationPostgresCDCDeletionMode) ToPointer() *DestinationPostgresCDCDeletionMode {
	return &e
}
func (e *DestinationPostgresCDCDeletionMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Hard delete":
		fallthrough
	case "Soft delete":
		*e = DestinationPostgresCDCDeletionMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationPostgresCDCDeletionMode: %v", v)
	}
}

type DestinationPostgresSchemasSSLModeSSLModes6Mode string

const (
	DestinationPostgresSchemasSSLModeSSLModes6ModeVerifyFull DestinationPostgresSchemasSSLModeSSLModes6Mode = "verify-full"
)

func (e DestinationPostgresSchemasSSLModeSSLModes6Mode) ToPointer() *DestinationPostgresSchemasSSLModeSSLModes6Mode {
	return &e
}
func (e *DestinationPostgresSchemasSSLModeSSLModes6Mode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "verify-full":
		*e = DestinationPostgresSchemasSSLModeSSLModes6Mode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationPostgresSchemasSSLModeSSLModes6Mode: %v", v)
	}
}

// DestinationPostgresVerifyFull - Verify-full SSL mode.
type DestinationPostgresVerifyFull struct {
	// CA certificate
	CaCertificate string `json:"ca_certificate"`
	// Client certificate
	ClientCertificate string `json:"client_certificate"`
	// Client key
	ClientKey string `json:"client_key"`
	// Password for keystorage. This field is optional. If you do not add it - the password will be generated automatically.
	ClientKeyPassword    *string                                         `json:"client_key_password,omitempty"`
	Mode                 *DestinationPostgresSchemasSSLModeSSLModes6Mode `default:"verify-full" json:"mode"`
	AdditionalProperties any                                             `additionalProperties:"true" json:"-"`
}

func (d DestinationPostgresVerifyFull) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationPostgresVerifyFull) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationPostgresVerifyFull) GetCaCertificate() string {
	if d == nil {
		return ""
	}
	return d.CaCertificate
}

func (d *DestinationPostgresVerifyFull) GetClientCertificate() string {
	if d == nil {
		return ""
	}
	return d.ClientCertificate
}

func (d *DestinationPostgresVerifyFull) GetClientKey() string {
	if d == nil {
		return ""
	}
	return d.ClientKey
}

func (d *DestinationPostgresVerifyFull) GetClientKeyPassword() *string {
	if d == nil {
		return nil
	}
	return d.ClientKeyPassword
}

func (d *DestinationPostgresVerifyFull) GetMode() *DestinationPostgresSchemasSSLModeSSLModes6Mode {
	if d == nil {
		return nil
	}
	return d.Mode
}

func (d *DestinationPostgresVerifyFull) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationPostgresSchemasSSLModeSSLModes5Mode string

const (
	DestinationPostgresSchemasSSLModeSSLModes5ModeVerifyCa DestinationPostgresSchemasSSLModeSSLModes5Mode = "verify-ca"
)

func (e DestinationPostgresSchemasSSLModeSSLModes5Mode) ToPointer() *DestinationPostgresSchemasSSLModeSSLModes5Mode {
	return &e
}
func (e *DestinationPostgresSchemasSSLModeSSLModes5Mode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "verify-ca":
		*e = DestinationPostgresSchemasSSLModeSSLModes5Mode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationPostgresSchemasSSLModeSSLModes5Mode: %v", v)
	}
}

// DestinationPostgresVerifyCa - Verify-ca SSL mode.
type DestinationPostgresVerifyCa struct {
	// CA certificate
	CaCertificate string `json:"ca_certificate"`
	// Password for keystorage. This field is optional. If you do not add it - the password will be generated automatically.
	ClientKeyPassword    *string                                         `json:"client_key_password,omitempty"`
	Mode                 *DestinationPostgresSchemasSSLModeSSLModes5Mode `default:"verify-ca" json:"mode"`
	AdditionalProperties any                                             `additionalProperties:"true" json:"-"`
}

func (d DestinationPostgresVerifyCa) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationPostgresVerifyCa) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationPostgresVerifyCa) GetCaCertificate() string {
	if d == nil {
		return ""
	}
	return d.CaCertificate
}

func (d *DestinationPostgresVerifyCa) GetClientKeyPassword() *string {
	if d == nil {
		return nil
	}
	return d.ClientKeyPassword
}

func (d *DestinationPostgresVerifyCa) GetMode() *DestinationPostgresSchemasSSLModeSSLModes5Mode {
	if d == nil {
		return nil
	}
	return d.Mode
}

func (d *DestinationPostgresVerifyCa) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationPostgresSchemasSSLModeSSLModesMode string

const (
	DestinationPostgresSchemasSSLModeSSLModesModeRequire DestinationPostgresSchemasSSLModeSSLModesMode = "require"
)

func (e DestinationPostgresSchemasSSLModeSSLModesMode) ToPointer() *DestinationPostgresSchemasSSLModeSSLModesMode {
	return &e
}
func (e *DestinationPostgresSchemasSSLModeSSLModesMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "require":
		*e = DestinationPostgresSchemasSSLModeSSLModesMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationPostgresSchemasSSLModeSSLModesMode: %v", v)
	}
}

// DestinationPostgresRequire - Require SSL mode.
type DestinationPostgresRequire struct {
	Mode                 *DestinationPostgresSchemasSSLModeSSLModesMode `default:"require" json:"mode"`
	AdditionalProperties any                                            `additionalProperties:"true" json:"-"`
}

func (d DestinationPostgresRequire) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationPostgresRequire) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationPostgresRequire) GetMode() *DestinationPostgresSchemasSSLModeSSLModesMode {
	if d == nil {
		return nil
	}
	return d.Mode
}

func (d *DestinationPostgresRequire) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationPostgresSchemasSslModeMode string

const (
	DestinationPostgresSchemasSslModeModePrefer DestinationPostgresSchemasSslModeMode = "prefer"
)

func (e DestinationPostgresSchemasSslModeMode) ToPointer() *DestinationPostgresSchemasSslModeMode {
	return &e
}
func (e *DestinationPostgresSchemasSslModeMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "prefer":
		*e = DestinationPostgresSchemasSslModeMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationPostgresSchemasSslModeMode: %v", v)
	}
}

// DestinationPostgresPrefer - Prefer SSL mode.
type DestinationPostgresPrefer struct {
	Mode                 *DestinationPostgresSchemasSslModeMode `default:"prefer" json:"mode"`
	AdditionalProperties any                                    `additionalProperties:"true" json:"-"`
}

func (d DestinationPostgresPrefer) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationPostgresPrefer) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationPostgresPrefer) GetMode() *DestinationPostgresSchemasSslModeMode {
	if d == nil {
		return nil
	}
	return d.Mode
}

func (d *DestinationPostgresPrefer) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationPostgresSchemasMode string

const (
	DestinationPostgresSchemasModeAllow DestinationPostgresSchemasMode = "allow"
)

func (e DestinationPostgresSchemasMode) ToPointer() *DestinationPostgresSchemasMode {
	return &e
}
func (e *DestinationPostgresSchemasMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "allow":
		*e = DestinationPostgresSchemasMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationPostgresSchemasMode: %v", v)
	}
}

// DestinationPostgresAllow - Allow SSL mode.
type DestinationPostgresAllow struct {
	Mode                 *DestinationPostgresSchemasMode `default:"allow" json:"mode"`
	AdditionalProperties any                             `additionalProperties:"true" json:"-"`
}

func (d DestinationPostgresAllow) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationPostgresAllow) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationPostgresAllow) GetMode() *DestinationPostgresSchemasMode {
	if d == nil {
		return nil
	}
	return d.Mode
}

func (d *DestinationPostgresAllow) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationPostgresMode string

const (
	DestinationPostgresModeDisable DestinationPostgresMode = "disable"
)

func (e DestinationPostgresMode) ToPointer() *DestinationPostgresMode {
	return &e
}
func (e *DestinationPostgresMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "disable":
		*e = DestinationPostgresMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationPostgresMode: %v", v)
	}
}

// DestinationPostgresDisable - Disable SSL.
type DestinationPostgresDisable struct {
	Mode                 *DestinationPostgresMode `default:"disable" json:"mode"`
	AdditionalProperties any                      `additionalProperties:"true" json:"-"`
}

func (d DestinationPostgresDisable) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationPostgresDisable) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationPostgresDisable) GetMode() *DestinationPostgresMode {
	if d == nil {
		return nil
	}
	return d.Mode
}

func (d *DestinationPostgresDisable) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationPostgresSSLModesType string

const (
	DestinationPostgresSSLModesTypeDestinationPostgresDisable    DestinationPostgresSSLModesType = "destination-postgres_disable"
	DestinationPostgresSSLModesTypeDestinationPostgresAllow      DestinationPostgresSSLModesType = "destination-postgres_allow"
	DestinationPostgresSSLModesTypeDestinationPostgresPrefer     DestinationPostgresSSLModesType = "destination-postgres_prefer"
	DestinationPostgresSSLModesTypeDestinationPostgresRequire    DestinationPostgresSSLModesType = "destination-postgres_require"
	DestinationPostgresSSLModesTypeDestinationPostgresVerifyCa   DestinationPostgresSSLModesType = "destination-postgres_verify-ca"
	DestinationPostgresSSLModesTypeDestinationPostgresVerifyFull DestinationPostgresSSLModesType = "destination-postgres_verify-full"
)

// DestinationPostgresSSLModes - SSL connection modes.
//
//	 <b>disable</b> - Disables encryption of communication between Airbyte and destination database.
//	 <b>allow</b> - Enables encryption only when required by the destination database.
//	 <b>prefer</b> - Allows unencrypted connections only if the destination database does not support encryption.
//	 <b>require</b> - Always require encryption. If the destination database server does not support encryption, connection will fail.
//	 <b>verify-ca</b> - Always require encryption and verifies that the destination database server has a valid SSL certificate.
//	 <b>verify-full</b> - This is the most secure mode. Always require encryption and verifies the identity of the destination database server.
//	See more information - <a href="https://jdbc.postgresql.org/documentation/head/ssl-client.html"> in the docs</a>.
type DestinationPostgresSSLModes struct {
	DestinationPostgresDisable    *DestinationPostgresDisable    `queryParam:"inline" union:"member"`
	DestinationPostgresAllow      *DestinationPostgresAllow      `queryParam:"inline" union:"member"`
	DestinationPostgresPrefer     *DestinationPostgresPrefer     `queryParam:"inline" union:"member"`
	DestinationPostgresRequire    *DestinationPostgresRequire    `queryParam:"inline" union:"member"`
	DestinationPostgresVerifyCa   *DestinationPostgresVerifyCa   `queryParam:"inline" union:"member"`
	DestinationPostgresVerifyFull *DestinationPostgresVerifyFull `queryParam:"inline" union:"member"`

	Type DestinationPostgresSSLModesType
}

func CreateDestinationPostgresSSLModesDestinationPostgresDisable(destinationPostgresDisable DestinationPostgresDisable) DestinationPostgresSSLModes {
	typ := DestinationPostgresSSLModesTypeDestinationPostgresDisable

	return DestinationPostgresSSLModes{
		DestinationPostgresDisable: &destinationPostgresDisable,
		Type:                       typ,
	}
}

func CreateDestinationPostgresSSLModesDestinationPostgresAllow(destinationPostgresAllow DestinationPostgresAllow) DestinationPostgresSSLModes {
	typ := DestinationPostgresSSLModesTypeDestinationPostgresAllow

	return DestinationPostgresSSLModes{
		DestinationPostgresAllow: &destinationPostgresAllow,
		Type:                     typ,
	}
}

func CreateDestinationPostgresSSLModesDestinationPostgresPrefer(destinationPostgresPrefer DestinationPostgresPrefer) DestinationPostgresSSLModes {
	typ := DestinationPostgresSSLModesTypeDestinationPostgresPrefer

	return DestinationPostgresSSLModes{
		DestinationPostgresPrefer: &destinationPostgresPrefer,
		Type:                      typ,
	}
}

func CreateDestinationPostgresSSLModesDestinationPostgresRequire(destinationPostgresRequire DestinationPostgresRequire) DestinationPostgresSSLModes {
	typ := DestinationPostgresSSLModesTypeDestinationPostgresRequire

	return DestinationPostgresSSLModes{
		DestinationPostgresRequire: &destinationPostgresRequire,
		Type:                       typ,
	}
}

func CreateDestinationPostgresSSLModesDestinationPostgresVerifyCa(destinationPostgresVerifyCa DestinationPostgresVerifyCa) DestinationPostgresSSLModes {
	typ := DestinationPostgresSSLModesTypeDestinationPostgresVerifyCa

	return DestinationPostgresSSLModes{
		DestinationPostgresVerifyCa: &destinationPostgresVerifyCa,
		Type:                        typ,
	}
}

func CreateDestinationPostgresSSLModesDestinationPostgresVerifyFull(destinationPostgresVerifyFull DestinationPostgresVerifyFull) DestinationPostgresSSLModes {
	typ := DestinationPostgresSSLModesTypeDestinationPostgresVerifyFull

	return DestinationPostgresSSLModes{
		DestinationPostgresVerifyFull: &destinationPostgresVerifyFull,
		Type:                          typ,
	}
}

func (u *DestinationPostgresSSLModes) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var destinationPostgresDisable DestinationPostgresDisable = DestinationPostgresDisable{}
	if err := utils.UnmarshalJSON(data, &destinationPostgresDisable, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationPostgresSSLModesTypeDestinationPostgresDisable,
			Value: &destinationPostgresDisable,
		})
	}

	var destinationPostgresAllow DestinationPostgresAllow = DestinationPostgresAllow{}
	if err := utils.UnmarshalJSON(data, &destinationPostgresAllow, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationPostgresSSLModesTypeDestinationPostgresAllow,
			Value: &destinationPostgresAllow,
		})
	}

	var destinationPostgresPrefer DestinationPostgresPrefer = DestinationPostgresPrefer{}
	if err := utils.UnmarshalJSON(data, &destinationPostgresPrefer, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationPostgresSSLModesTypeDestinationPostgresPrefer,
			Value: &destinationPostgresPrefer,
		})
	}

	var destinationPostgresRequire DestinationPostgresRequire = DestinationPostgresRequire{}
	if err := utils.UnmarshalJSON(data, &destinationPostgresRequire, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationPostgresSSLModesTypeDestinationPostgresRequire,
			Value: &destinationPostgresRequire,
		})
	}

	var destinationPostgresVerifyCa DestinationPostgresVerifyCa = DestinationPostgresVerifyCa{}
	if err := utils.UnmarshalJSON(data, &destinationPostgresVerifyCa, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationPostgresSSLModesTypeDestinationPostgresVerifyCa,
			Value: &destinationPostgresVerifyCa,
		})
	}

	var destinationPostgresVerifyFull DestinationPostgresVerifyFull = DestinationPostgresVerifyFull{}
	if err := utils.UnmarshalJSON(data, &destinationPostgresVerifyFull, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationPostgresSSLModesTypeDestinationPostgresVerifyFull,
			Value: &destinationPostgresVerifyFull,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationPostgresSSLModes", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationPostgresSSLModes", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(DestinationPostgresSSLModesType)
	switch best.Type {
	case DestinationPostgresSSLModesTypeDestinationPostgresDisable:
		u.DestinationPostgresDisable = best.Value.(*DestinationPostgresDisable)
		return nil
	case DestinationPostgresSSLModesTypeDestinationPostgresAllow:
		u.DestinationPostgresAllow = best.Value.(*DestinationPostgresAllow)
		return nil
	case DestinationPostgresSSLModesTypeDestinationPostgresPrefer:
		u.DestinationPostgresPrefer = best.Value.(*DestinationPostgresPrefer)
		return nil
	case DestinationPostgresSSLModesTypeDestinationPostgresRequire:
		u.DestinationPostgresRequire = best.Value.(*DestinationPostgresRequire)
		return nil
	case DestinationPostgresSSLModesTypeDestinationPostgresVerifyCa:
		u.DestinationPostgresVerifyCa = best.Value.(*DestinationPostgresVerifyCa)
		return nil
	case DestinationPostgresSSLModesTypeDestinationPostgresVerifyFull:
		u.DestinationPostgresVerifyFull = best.Value.(*DestinationPostgresVerifyFull)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationPostgresSSLModes", string(data))
}

func (u DestinationPostgresSSLModes) MarshalJSON() ([]byte, error) {
	if u.DestinationPostgresDisable != nil {
		return utils.MarshalJSON(u.DestinationPostgresDisable, "", true)
	}

	if u.DestinationPostgresAllow != nil {
		return utils.MarshalJSON(u.DestinationPostgresAllow, "", true)
	}

	if u.DestinationPostgresPrefer != nil {
		return utils.MarshalJSON(u.DestinationPostgresPrefer, "", true)
	}

	if u.DestinationPostgresRequire != nil {
		return utils.MarshalJSON(u.DestinationPostgresRequire, "", true)
	}

	if u.DestinationPostgresVerifyCa != nil {
		return utils.MarshalJSON(u.DestinationPostgresVerifyCa, "", true)
	}

	if u.DestinationPostgresVerifyFull != nil {
		return utils.MarshalJSON(u.DestinationPostgresVerifyFull, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationPostgresSSLModes: all fields are null")
}

type DestinationPostgresSchemasTunnelMethodTunnelMethod string

const (
	DestinationPostgresSchemasTunnelMethodTunnelMethodSSHPasswordAuth DestinationPostgresSchemasTunnelMethodTunnelMethod = "SSH_PASSWORD_AUTH"
)

func (e DestinationPostgresSchemasTunnelMethodTunnelMethod) ToPointer() *DestinationPostgresSchemasTunnelMethodTunnelMethod {
	return &e
}
func (e *DestinationPostgresSchemasTunnelMethodTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_PASSWORD_AUTH":
		*e = DestinationPostgresSchemasTunnelMethodTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationPostgresSchemasTunnelMethodTunnelMethod: %v", v)
	}
}

// DestinationPostgresPasswordAuthentication - Connect through a jump server tunnel host using username and password authentication
type DestinationPostgresPasswordAuthentication struct {
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost   string                                              `json:"tunnel_host"`
	TunnelMethod *DestinationPostgresSchemasTunnelMethodTunnelMethod `default:"SSH_PASSWORD_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser string `json:"tunnel_user"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword   string `json:"tunnel_user_password"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (d DestinationPostgresPasswordAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationPostgresPasswordAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationPostgresPasswordAuthentication) GetTunnelHost() string {
	if d == nil {
		return ""
	}
	return d.TunnelHost
}

func (d *DestinationPostgresPasswordAuthentication) GetTunnelMethod() *DestinationPostgresSchemasTunnelMethodTunnelMethod {
	if d == nil {
		return nil
	}
	return d.TunnelMethod
}

func (d *DestinationPostgresPasswordAuthentication) GetTunnelPort() *int64 {
	if d == nil {
		return nil
	}
	return d.TunnelPort
}

func (d *DestinationPostgresPasswordAuthentication) GetTunnelUser() string {
	if d == nil {
		return ""
	}
	return d.TunnelUser
}

func (d *DestinationPostgresPasswordAuthentication) GetTunnelUserPassword() string {
	if d == nil {
		return ""
	}
	return d.TunnelUserPassword
}

func (d *DestinationPostgresPasswordAuthentication) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationPostgresSchemasTunnelMethod string

const (
	DestinationPostgresSchemasTunnelMethodSSHKeyAuth DestinationPostgresSchemasTunnelMethod = "SSH_KEY_AUTH"
)

func (e DestinationPostgresSchemasTunnelMethod) ToPointer() *DestinationPostgresSchemasTunnelMethod {
	return &e
}
func (e *DestinationPostgresSchemasTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_KEY_AUTH":
		*e = DestinationPostgresSchemasTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationPostgresSchemasTunnelMethod: %v", v)
	}
}

// DestinationPostgresSSHKeyAuthentication - Connect through a jump server tunnel host using username and ssh key
type DestinationPostgresSSHKeyAuthentication struct {
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey string `json:"ssh_key"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost   string                                  `json:"tunnel_host"`
	TunnelMethod *DestinationPostgresSchemasTunnelMethod `default:"SSH_KEY_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser           string `json:"tunnel_user"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (d DestinationPostgresSSHKeyAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationPostgresSSHKeyAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationPostgresSSHKeyAuthentication) GetSSHKey() string {
	if d == nil {
		return ""
	}
	return d.SSHKey
}

func (d *DestinationPostgresSSHKeyAuthentication) GetTunnelHost() string {
	if d == nil {
		return ""
	}
	return d.TunnelHost
}

func (d *DestinationPostgresSSHKeyAuthentication) GetTunnelMethod() *DestinationPostgresSchemasTunnelMethod {
	if d == nil {
		return nil
	}
	return d.TunnelMethod
}

func (d *DestinationPostgresSSHKeyAuthentication) GetTunnelPort() *int64 {
	if d == nil {
		return nil
	}
	return d.TunnelPort
}

func (d *DestinationPostgresSSHKeyAuthentication) GetTunnelUser() string {
	if d == nil {
		return ""
	}
	return d.TunnelUser
}

func (d *DestinationPostgresSSHKeyAuthentication) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationPostgresTunnelMethod string

const (
	DestinationPostgresTunnelMethodNoTunnel DestinationPostgresTunnelMethod = "NO_TUNNEL"
)

func (e DestinationPostgresTunnelMethod) ToPointer() *DestinationPostgresTunnelMethod {
	return &e
}
func (e *DestinationPostgresTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NO_TUNNEL":
		*e = DestinationPostgresTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationPostgresTunnelMethod: %v", v)
	}
}

// DestinationPostgresNoTunnel - No ssh tunnel needed to connect to database
type DestinationPostgresNoTunnel struct {
	TunnelMethod         *DestinationPostgresTunnelMethod `default:"NO_TUNNEL" json:"tunnel_method"`
	AdditionalProperties any                              `additionalProperties:"true" json:"-"`
}

func (d DestinationPostgresNoTunnel) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationPostgresNoTunnel) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationPostgresNoTunnel) GetTunnelMethod() *DestinationPostgresTunnelMethod {
	if d == nil {
		return nil
	}
	return d.TunnelMethod
}

func (d *DestinationPostgresNoTunnel) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationPostgresSSHTunnelMethodType string

const (
	DestinationPostgresSSHTunnelMethodTypeDestinationPostgresNoTunnel               DestinationPostgresSSHTunnelMethodType = "destination-postgres_No Tunnel"
	DestinationPostgresSSHTunnelMethodTypeDestinationPostgresSSHKeyAuthentication   DestinationPostgresSSHTunnelMethodType = "destination-postgres_SSH Key Authentication"
	DestinationPostgresSSHTunnelMethodTypeDestinationPostgresPasswordAuthentication DestinationPostgresSSHTunnelMethodType = "destination-postgres_Password Authentication"
)

// DestinationPostgresSSHTunnelMethod - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type DestinationPostgresSSHTunnelMethod struct {
	DestinationPostgresNoTunnel               *DestinationPostgresNoTunnel               `queryParam:"inline" union:"member"`
	DestinationPostgresSSHKeyAuthentication   *DestinationPostgresSSHKeyAuthentication   `queryParam:"inline" union:"member"`
	DestinationPostgresPasswordAuthentication *DestinationPostgresPasswordAuthentication `queryParam:"inline" union:"member"`

	Type DestinationPostgresSSHTunnelMethodType
}

func CreateDestinationPostgresSSHTunnelMethodDestinationPostgresNoTunnel(destinationPostgresNoTunnel DestinationPostgresNoTunnel) DestinationPostgresSSHTunnelMethod {
	typ := DestinationPostgresSSHTunnelMethodTypeDestinationPostgresNoTunnel

	return DestinationPostgresSSHTunnelMethod{
		DestinationPostgresNoTunnel: &destinationPostgresNoTunnel,
		Type:                        typ,
	}
}

func CreateDestinationPostgresSSHTunnelMethodDestinationPostgresSSHKeyAuthentication(destinationPostgresSSHKeyAuthentication DestinationPostgresSSHKeyAuthentication) DestinationPostgresSSHTunnelMethod {
	typ := DestinationPostgresSSHTunnelMethodTypeDestinationPostgresSSHKeyAuthentication

	return DestinationPostgresSSHTunnelMethod{
		DestinationPostgresSSHKeyAuthentication: &destinationPostgresSSHKeyAuthentication,
		Type:                                    typ,
	}
}

func CreateDestinationPostgresSSHTunnelMethodDestinationPostgresPasswordAuthentication(destinationPostgresPasswordAuthentication DestinationPostgresPasswordAuthentication) DestinationPostgresSSHTunnelMethod {
	typ := DestinationPostgresSSHTunnelMethodTypeDestinationPostgresPasswordAuthentication

	return DestinationPostgresSSHTunnelMethod{
		DestinationPostgresPasswordAuthentication: &destinationPostgresPasswordAuthentication,
		Type: typ,
	}
}

func (u *DestinationPostgresSSHTunnelMethod) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var destinationPostgresNoTunnel DestinationPostgresNoTunnel = DestinationPostgresNoTunnel{}
	if err := utils.UnmarshalJSON(data, &destinationPostgresNoTunnel, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationPostgresSSHTunnelMethodTypeDestinationPostgresNoTunnel,
			Value: &destinationPostgresNoTunnel,
		})
	}

	var destinationPostgresSSHKeyAuthentication DestinationPostgresSSHKeyAuthentication = DestinationPostgresSSHKeyAuthentication{}
	if err := utils.UnmarshalJSON(data, &destinationPostgresSSHKeyAuthentication, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationPostgresSSHTunnelMethodTypeDestinationPostgresSSHKeyAuthentication,
			Value: &destinationPostgresSSHKeyAuthentication,
		})
	}

	var destinationPostgresPasswordAuthentication DestinationPostgresPasswordAuthentication = DestinationPostgresPasswordAuthentication{}
	if err := utils.UnmarshalJSON(data, &destinationPostgresPasswordAuthentication, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationPostgresSSHTunnelMethodTypeDestinationPostgresPasswordAuthentication,
			Value: &destinationPostgresPasswordAuthentication,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationPostgresSSHTunnelMethod", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationPostgresSSHTunnelMethod", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(DestinationPostgresSSHTunnelMethodType)
	switch best.Type {
	case DestinationPostgresSSHTunnelMethodTypeDestinationPostgresNoTunnel:
		u.DestinationPostgresNoTunnel = best.Value.(*DestinationPostgresNoTunnel)
		return nil
	case DestinationPostgresSSHTunnelMethodTypeDestinationPostgresSSHKeyAuthentication:
		u.DestinationPostgresSSHKeyAuthentication = best.Value.(*DestinationPostgresSSHKeyAuthentication)
		return nil
	case DestinationPostgresSSHTunnelMethodTypeDestinationPostgresPasswordAuthentication:
		u.DestinationPostgresPasswordAuthentication = best.Value.(*DestinationPostgresPasswordAuthentication)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationPostgresSSHTunnelMethod", string(data))
}

func (u DestinationPostgresSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.DestinationPostgresNoTunnel != nil {
		return utils.MarshalJSON(u.DestinationPostgresNoTunnel, "", true)
	}

	if u.DestinationPostgresSSHKeyAuthentication != nil {
		return utils.MarshalJSON(u.DestinationPostgresSSHKeyAuthentication, "", true)
	}

	if u.DestinationPostgresPasswordAuthentication != nil {
		return utils.MarshalJSON(u.DestinationPostgresPasswordAuthentication, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationPostgresSSHTunnelMethod: all fields are null")
}

type DestinationPostgresDestinationType string

const (
	DestinationPostgresDestinationTypePostgres DestinationPostgresDestinationType = "postgres"
)

func (e DestinationPostgresDestinationType) ToPointer() *DestinationPostgresDestinationType {
	return &e
}
func (e *DestinationPostgresDestinationType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "postgres":
		*e = DestinationPostgresDestinationType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationPostgresDestinationType: %v", v)
	}
}

type DestinationPostgres struct {
	// Whether to execute CDC deletions as hard deletes (i.e. propagate source deletions to the destination), or soft deletes (i.e. leave a tombstone record in the destination). Defaults to hard deletes.
	CdcDeletionMode *DestinationPostgresCDCDeletionMode `default:"Hard delete" json:"cdc_deletion_mode"`
	// Name of the database.
	Database string `json:"database"`
	// Disable Writing Final Tables. WARNING! The data format in _airbyte_data is likely stable but there are no guarantees that other metadata columns will remain the same in future versions
	DisableTypeDedupe *bool `json:"disable_type_dedupe,omitempty"`
	// Drop tables with CASCADE. WARNING! This will delete all data in all dependent objects (views, etc.). Use with caution. This option is intended for usecases which can easily rebuild the dependent objects.
	DropCascade *bool `json:"drop_cascade,omitempty"`
	// Hostname of the database.
	Host string `json:"host"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// Password associated with the username.
	Password *string `json:"password,omitempty"`
	// Port of the database.
	Port int64 `json:"port"`
	// Airbyte will use this schema for various internal tables. In legacy raw tables mode, the raw tables will be stored in this schema. Defaults to "airbyte_internal".
	RawDataSchema *string `json:"raw_data_schema,omitempty"`
	// The default schema tables are written. If not specified otherwise, the "public" schema will be used.
	Schema *string `default:"public" json:"schema"`
	// Encrypt data using SSL. When activating SSL, please select one of the connection modes.
	Ssl *bool `default:"true" json:"ssl"`
	// SSL connection modes.
	//   <b>disable</b> - Disables encryption of communication between Airbyte and destination database.
	//   <b>allow</b> - Enables encryption only when required by the destination database.
	//   <b>prefer</b> - Allows unencrypted connections only if the destination database does not support encryption.
	//   <b>require</b> - Always require encryption. If the destination database server does not support encryption, connection will fail.
	//   <b>verify-ca</b> - Always require encryption and verifies that the destination database server has a valid SSL certificate.
	//   <b>verify-full</b> - This is the most secure mode. Always require encryption and verifies the identity of the destination database server.
	//  See more information - <a href="https://jdbc.postgresql.org/documentation/head/ssl-client.html"> in the docs</a>.
	SslMode *DestinationPostgresSSLModes `json:"ssl_mode,omitempty"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod *DestinationPostgresSSHTunnelMethod `json:"tunnel_method,omitempty"`
	// Create numeric columns as unconstrained DECIMAL instead of NUMBER(38, 9). This will allow increased precision in numeric values. (this is disabled by default for backwards compatibility, but is recommended to enable)
	UnconstrainedNumber *bool `json:"unconstrained_number,omitempty"`
	// Username to access the database.
	Username             string                              `json:"username"`
	destinationType      *DestinationPostgresDestinationType `const:"postgres" json:"destinationType"`
	AdditionalProperties any                                 `additionalProperties:"true" json:"-"`
}

func (d DestinationPostgres) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationPostgres) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationPostgres) GetCdcDeletionMode() *DestinationPostgresCDCDeletionMode {
	if d == nil {
		return nil
	}
	return d.CdcDeletionMode
}

func (d *DestinationPostgres) GetDatabase() string {
	if d == nil {
		return ""
	}
	return d.Database
}

func (d *DestinationPostgres) GetDisableTypeDedupe() *bool {
	if d == nil {
		return nil
	}
	return d.DisableTypeDedupe
}

func (d *DestinationPostgres) GetDropCascade() *bool {
	if d == nil {
		return nil
	}
	return d.DropCascade
}

func (d *DestinationPostgres) GetHost() string {
	if d == nil {
		return ""
	}
	return d.Host
}

func (d *DestinationPostgres) GetJdbcURLParams() *string {
	if d == nil {
		return nil
	}
	return d.JdbcURLParams
}

func (d *DestinationPostgres) GetPassword() *string {
	if d == nil {
		return nil
	}
	return d.Password
}

func (d *DestinationPostgres) GetPort() int64 {
	if d == nil {
		return 0
	}
	return d.Port
}

func (d *DestinationPostgres) GetRawDataSchema() *string {
	if d == nil {
		return nil
	}
	return d.RawDataSchema
}

func (d *DestinationPostgres) GetSchema() *string {
	if d == nil {
		return nil
	}
	return d.Schema
}

func (d *DestinationPostgres) GetSsl() *bool {
	if d == nil {
		return nil
	}
	return d.Ssl
}

func (d *DestinationPostgres) GetSslMode() *DestinationPostgresSSLModes {
	if d == nil {
		return nil
	}
	return d.SslMode
}

func (d *DestinationPostgres) GetTunnelMethod() *DestinationPostgresSSHTunnelMethod {
	if d == nil {
		return nil
	}
	return d.TunnelMethod
}

func (d *DestinationPostgres) GetUnconstrainedNumber() *bool {
	if d == nil {
		return nil
	}
	return d.UnconstrainedNumber
}

func (d *DestinationPostgres) GetUsername() string {
	if d == nil {
		return ""
	}
	return d.Username
}

func (d *DestinationPostgres) GetDestinationType() *DestinationPostgresDestinationType {
	return DestinationPostgresDestinationTypePostgres.ToPointer()
}

func (d *DestinationPostgres) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}
