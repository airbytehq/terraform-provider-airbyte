// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/types"
	"time"
)

type SourceXeroUpdateBearerAccessToken struct {
	// The access token used to call the Xero API.
	AccessToken *string `json:"access_token,omitempty"`
	authType    *string `const:"oauth2_access_token" json:"auth_type,omitempty"`
}

func (s SourceXeroUpdateBearerAccessToken) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceXeroUpdateBearerAccessToken) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceXeroUpdateBearerAccessToken) GetAccessToken() *string {
	if s == nil {
		return nil
	}
	return s.AccessToken
}

func (s *SourceXeroUpdateBearerAccessToken) GetAuthType() *string {
	return types.Pointer("oauth2_access_token")
}

type SourceXeroUpdateOAuthCustomConnection struct {
	authType *string `const:"oauth2_confidential_application" json:"auth_type,omitempty"`
	// Your Xero application's Client ID.
	ClientID *string `json:"client_id,omitempty"`
	// Your Xero application's Client Secret.
	ClientSecret *string `json:"client_secret,omitempty"`
}

func (s SourceXeroUpdateOAuthCustomConnection) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceXeroUpdateOAuthCustomConnection) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceXeroUpdateOAuthCustomConnection) GetAuthType() *string {
	return types.Pointer("oauth2_confidential_application")
}

func (s *SourceXeroUpdateOAuthCustomConnection) GetClientID() *string {
	if s == nil {
		return nil
	}
	return s.ClientID
}

func (s *SourceXeroUpdateOAuthCustomConnection) GetClientSecret() *string {
	if s == nil {
		return nil
	}
	return s.ClientSecret
}

type SourceXeroUpdateAuthenticationMethodType string

const (
	SourceXeroUpdateAuthenticationMethodTypeSourceXeroUpdateOAuthCustomConnection SourceXeroUpdateAuthenticationMethodType = "source-xero-update_OAuth Custom Connection"
	SourceXeroUpdateAuthenticationMethodTypeSourceXeroUpdateBearerAccessToken     SourceXeroUpdateAuthenticationMethodType = "source-xero-update_Bearer Access Token"
)

type SourceXeroUpdateAuthenticationMethod struct {
	SourceXeroUpdateOAuthCustomConnection *SourceXeroUpdateOAuthCustomConnection `queryParam:"inline" union:"member"`
	SourceXeroUpdateBearerAccessToken     *SourceXeroUpdateBearerAccessToken     `queryParam:"inline" union:"member"`

	Type SourceXeroUpdateAuthenticationMethodType
}

func CreateSourceXeroUpdateAuthenticationMethodSourceXeroUpdateOAuthCustomConnection(sourceXeroUpdateOAuthCustomConnection SourceXeroUpdateOAuthCustomConnection) SourceXeroUpdateAuthenticationMethod {
	typ := SourceXeroUpdateAuthenticationMethodTypeSourceXeroUpdateOAuthCustomConnection

	return SourceXeroUpdateAuthenticationMethod{
		SourceXeroUpdateOAuthCustomConnection: &sourceXeroUpdateOAuthCustomConnection,
		Type:                                  typ,
	}
}

func CreateSourceXeroUpdateAuthenticationMethodSourceXeroUpdateBearerAccessToken(sourceXeroUpdateBearerAccessToken SourceXeroUpdateBearerAccessToken) SourceXeroUpdateAuthenticationMethod {
	typ := SourceXeroUpdateAuthenticationMethodTypeSourceXeroUpdateBearerAccessToken

	return SourceXeroUpdateAuthenticationMethod{
		SourceXeroUpdateBearerAccessToken: &sourceXeroUpdateBearerAccessToken,
		Type:                              typ,
	}
}

func (u *SourceXeroUpdateAuthenticationMethod) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var sourceXeroUpdateOAuthCustomConnection SourceXeroUpdateOAuthCustomConnection = SourceXeroUpdateOAuthCustomConnection{}
	if err := utils.UnmarshalJSON(data, &sourceXeroUpdateOAuthCustomConnection, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceXeroUpdateAuthenticationMethodTypeSourceXeroUpdateOAuthCustomConnection,
			Value: &sourceXeroUpdateOAuthCustomConnection,
		})
	}

	var sourceXeroUpdateBearerAccessToken SourceXeroUpdateBearerAccessToken = SourceXeroUpdateBearerAccessToken{}
	if err := utils.UnmarshalJSON(data, &sourceXeroUpdateBearerAccessToken, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceXeroUpdateAuthenticationMethodTypeSourceXeroUpdateBearerAccessToken,
			Value: &sourceXeroUpdateBearerAccessToken,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceXeroUpdateAuthenticationMethod", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceXeroUpdateAuthenticationMethod", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceXeroUpdateAuthenticationMethodType)
	switch best.Type {
	case SourceXeroUpdateAuthenticationMethodTypeSourceXeroUpdateOAuthCustomConnection:
		u.SourceXeroUpdateOAuthCustomConnection = best.Value.(*SourceXeroUpdateOAuthCustomConnection)
		return nil
	case SourceXeroUpdateAuthenticationMethodTypeSourceXeroUpdateBearerAccessToken:
		u.SourceXeroUpdateBearerAccessToken = best.Value.(*SourceXeroUpdateBearerAccessToken)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceXeroUpdateAuthenticationMethod", string(data))
}

func (u SourceXeroUpdateAuthenticationMethod) MarshalJSON() ([]byte, error) {
	if u.SourceXeroUpdateOAuthCustomConnection != nil {
		return utils.MarshalJSON(u.SourceXeroUpdateOAuthCustomConnection, "", true)
	}

	if u.SourceXeroUpdateBearerAccessToken != nil {
		return utils.MarshalJSON(u.SourceXeroUpdateBearerAccessToken, "", true)
	}

	return nil, errors.New("could not marshal union type SourceXeroUpdateAuthenticationMethod: all fields are null")
}

type SourceXeroUpdateSourceType string

const (
	SourceXeroUpdateSourceTypeXero SourceXeroUpdateSourceType = "xero"
)

func (e SourceXeroUpdateSourceType) ToPointer() *SourceXeroUpdateSourceType {
	return &e
}
func (e *SourceXeroUpdateSourceType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "xero":
		*e = SourceXeroUpdateSourceType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceXeroUpdateSourceType: %v", v)
	}
}

type SourceXeroUpdate struct {
	Credentials *SourceXeroUpdateAuthenticationMethod `json:"credentials,omitempty"`
	// UTC date and time in the format YYYY-MM-DDTHH:mm:ssZ. Any data with created_at before this date will not be synced.
	StartDate *time.Time `json:"start_date,omitempty"`
	// Enter your Xero organization's Tenant ID
	TenantID             *string                     `json:"tenant_id,omitempty"`
	sourceType           *SourceXeroUpdateSourceType `const:"xero" json:"sourceType"`
	AdditionalProperties any                         `additionalProperties:"true" json:"-"`
}

func (s SourceXeroUpdate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceXeroUpdate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceXeroUpdate) GetCredentials() *SourceXeroUpdateAuthenticationMethod {
	if s == nil {
		return nil
	}
	return s.Credentials
}

func (s *SourceXeroUpdate) GetStartDate() *time.Time {
	if s == nil {
		return nil
	}
	return s.StartDate
}

func (s *SourceXeroUpdate) GetTenantID() *string {
	if s == nil {
		return nil
	}
	return s.TenantID
}

func (s *SourceXeroUpdate) GetSourceType() *SourceXeroUpdateSourceType {
	return SourceXeroUpdateSourceTypeXero.ToPointer()
}

func (s *SourceXeroUpdate) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}
