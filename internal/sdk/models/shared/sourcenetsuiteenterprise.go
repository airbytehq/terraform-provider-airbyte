// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

type SourceNetsuiteEnterpriseSchemasAuthenticationMethod string

const (
	SourceNetsuiteEnterpriseSchemasAuthenticationMethodTokenBasedAuthentication SourceNetsuiteEnterpriseSchemasAuthenticationMethod = "token_based_authentication"
)

func (e SourceNetsuiteEnterpriseSchemasAuthenticationMethod) ToPointer() *SourceNetsuiteEnterpriseSchemasAuthenticationMethod {
	return &e
}
func (e *SourceNetsuiteEnterpriseSchemasAuthenticationMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "token_based_authentication":
		*e = SourceNetsuiteEnterpriseSchemasAuthenticationMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceNetsuiteEnterpriseSchemasAuthenticationMethod: %v", v)
	}
}

// TokenBasedAuthentication - Authenticate using a token-based authentication method. This requires a consumer key and secret, as well as a token ID and secret.
type TokenBasedAuthentication struct {
	AuthenticationMethod *SourceNetsuiteEnterpriseSchemasAuthenticationMethod `default:"token_based_authentication" json:"authentication_method"`
	// The consumer key used for token-based authentication. This is generated in NetSuite when creating an integration record.
	ClientID string `json:"client_id"`
	// The consumer secret used for token-based authentication. This is generated in NetSuite when creating an integration record.
	ClientSecret string `json:"client_secret"`
	// The token ID used for token-based authentication. This is generated in NetSuite when creating a token-based role.
	TokenID string `json:"token_id"`
	// The token secret used for token-based authentication. This is generated in NetSuite when creating a token-based role.Ensure to keep this value secure.
	TokenSecret          string `json:"token_secret"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (t TokenBasedAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(t, "", false)
}

func (t *TokenBasedAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &t, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *TokenBasedAuthentication) GetAuthenticationMethod() *SourceNetsuiteEnterpriseSchemasAuthenticationMethod {
	if o == nil {
		return nil
	}
	return o.AuthenticationMethod
}

func (o *TokenBasedAuthentication) GetClientID() string {
	if o == nil {
		return ""
	}
	return o.ClientID
}

func (o *TokenBasedAuthentication) GetClientSecret() string {
	if o == nil {
		return ""
	}
	return o.ClientSecret
}

func (o *TokenBasedAuthentication) GetTokenID() string {
	if o == nil {
		return ""
	}
	return o.TokenID
}

func (o *TokenBasedAuthentication) GetTokenSecret() string {
	if o == nil {
		return ""
	}
	return o.TokenSecret
}

func (o *TokenBasedAuthentication) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

type SourceNetsuiteEnterpriseSchemasAuthenticationMethodAuthenticationMethod string

const (
	SourceNetsuiteEnterpriseSchemasAuthenticationMethodAuthenticationMethodPasswordAuthentication SourceNetsuiteEnterpriseSchemasAuthenticationMethodAuthenticationMethod = "password_authentication"
)

func (e SourceNetsuiteEnterpriseSchemasAuthenticationMethodAuthenticationMethod) ToPointer() *SourceNetsuiteEnterpriseSchemasAuthenticationMethodAuthenticationMethod {
	return &e
}
func (e *SourceNetsuiteEnterpriseSchemasAuthenticationMethodAuthenticationMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "password_authentication":
		*e = SourceNetsuiteEnterpriseSchemasAuthenticationMethodAuthenticationMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceNetsuiteEnterpriseSchemasAuthenticationMethodAuthenticationMethod: %v", v)
	}
}

// SourceNetsuiteEnterprisePasswordAuthentication - Authenticate using a password.
type SourceNetsuiteEnterprisePasswordAuthentication struct {
	AuthenticationMethod *SourceNetsuiteEnterpriseSchemasAuthenticationMethodAuthenticationMethod `default:"password_authentication" json:"authentication_method"`
	// The password associated with the username.
	Password             string `json:"password"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (s SourceNetsuiteEnterprisePasswordAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceNetsuiteEnterprisePasswordAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceNetsuiteEnterprisePasswordAuthentication) GetAuthenticationMethod() *SourceNetsuiteEnterpriseSchemasAuthenticationMethodAuthenticationMethod {
	if o == nil {
		return nil
	}
	return o.AuthenticationMethod
}

func (o *SourceNetsuiteEnterprisePasswordAuthentication) GetPassword() string {
	if o == nil {
		return ""
	}
	return o.Password
}

func (o *SourceNetsuiteEnterprisePasswordAuthentication) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

type SourceNetsuiteEnterpriseAuthenticationMethodType string

const (
	SourceNetsuiteEnterpriseAuthenticationMethodTypeSourceNetsuiteEnterprisePasswordAuthentication SourceNetsuiteEnterpriseAuthenticationMethodType = "source-netsuite-enterprise_Password Authentication"
	SourceNetsuiteEnterpriseAuthenticationMethodTypeTokenBasedAuthentication                       SourceNetsuiteEnterpriseAuthenticationMethodType = "Token Based Authentication"
)

// SourceNetsuiteEnterpriseAuthenticationMethod - Configure how to authenticate to Netsuite. Options include username/password or token-based authentication.
type SourceNetsuiteEnterpriseAuthenticationMethod struct {
	SourceNetsuiteEnterprisePasswordAuthentication *SourceNetsuiteEnterprisePasswordAuthentication `queryParam:"inline"`
	TokenBasedAuthentication                       *TokenBasedAuthentication                       `queryParam:"inline"`

	Type SourceNetsuiteEnterpriseAuthenticationMethodType
}

func CreateSourceNetsuiteEnterpriseAuthenticationMethodSourceNetsuiteEnterprisePasswordAuthentication(sourceNetsuiteEnterprisePasswordAuthentication SourceNetsuiteEnterprisePasswordAuthentication) SourceNetsuiteEnterpriseAuthenticationMethod {
	typ := SourceNetsuiteEnterpriseAuthenticationMethodTypeSourceNetsuiteEnterprisePasswordAuthentication

	return SourceNetsuiteEnterpriseAuthenticationMethod{
		SourceNetsuiteEnterprisePasswordAuthentication: &sourceNetsuiteEnterprisePasswordAuthentication,
		Type: typ,
	}
}

func CreateSourceNetsuiteEnterpriseAuthenticationMethodTokenBasedAuthentication(tokenBasedAuthentication TokenBasedAuthentication) SourceNetsuiteEnterpriseAuthenticationMethod {
	typ := SourceNetsuiteEnterpriseAuthenticationMethodTypeTokenBasedAuthentication

	return SourceNetsuiteEnterpriseAuthenticationMethod{
		TokenBasedAuthentication: &tokenBasedAuthentication,
		Type:                     typ,
	}
}

func (u *SourceNetsuiteEnterpriseAuthenticationMethod) UnmarshalJSON(data []byte) error {

	var sourceNetsuiteEnterprisePasswordAuthentication SourceNetsuiteEnterprisePasswordAuthentication = SourceNetsuiteEnterprisePasswordAuthentication{}
	if err := utils.UnmarshalJSON(data, &sourceNetsuiteEnterprisePasswordAuthentication, "", true, true); err == nil {
		u.SourceNetsuiteEnterprisePasswordAuthentication = &sourceNetsuiteEnterprisePasswordAuthentication
		u.Type = SourceNetsuiteEnterpriseAuthenticationMethodTypeSourceNetsuiteEnterprisePasswordAuthentication
		return nil
	}

	var tokenBasedAuthentication TokenBasedAuthentication = TokenBasedAuthentication{}
	if err := utils.UnmarshalJSON(data, &tokenBasedAuthentication, "", true, true); err == nil {
		u.TokenBasedAuthentication = &tokenBasedAuthentication
		u.Type = SourceNetsuiteEnterpriseAuthenticationMethodTypeTokenBasedAuthentication
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceNetsuiteEnterpriseAuthenticationMethod", string(data))
}

func (u SourceNetsuiteEnterpriseAuthenticationMethod) MarshalJSON() ([]byte, error) {
	if u.SourceNetsuiteEnterprisePasswordAuthentication != nil {
		return utils.MarshalJSON(u.SourceNetsuiteEnterprisePasswordAuthentication, "", true)
	}

	if u.TokenBasedAuthentication != nil {
		return utils.MarshalJSON(u.TokenBasedAuthentication, "", true)
	}

	return nil, errors.New("could not marshal union type SourceNetsuiteEnterpriseAuthenticationMethod: all fields are null")
}

type SourceNetsuiteEnterpriseSchemasTunnelMethodTunnelMethod string

const (
	SourceNetsuiteEnterpriseSchemasTunnelMethodTunnelMethodSSHPasswordAuth SourceNetsuiteEnterpriseSchemasTunnelMethodTunnelMethod = "SSH_PASSWORD_AUTH"
)

func (e SourceNetsuiteEnterpriseSchemasTunnelMethodTunnelMethod) ToPointer() *SourceNetsuiteEnterpriseSchemasTunnelMethodTunnelMethod {
	return &e
}
func (e *SourceNetsuiteEnterpriseSchemasTunnelMethodTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_PASSWORD_AUTH":
		*e = SourceNetsuiteEnterpriseSchemasTunnelMethodTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceNetsuiteEnterpriseSchemasTunnelMethodTunnelMethod: %v", v)
	}
}

// SourceNetsuiteEnterpriseSchemasPasswordAuthentication - Connect through a jump server tunnel host using username and password authentication
type SourceNetsuiteEnterpriseSchemasPasswordAuthentication struct {
	TunnelMethod *SourceNetsuiteEnterpriseSchemasTunnelMethodTunnelMethod `default:"SSH_PASSWORD_AUTH" json:"tunnel_method"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser string `json:"tunnel_user"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword   string `json:"tunnel_user_password"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (s SourceNetsuiteEnterpriseSchemasPasswordAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceNetsuiteEnterpriseSchemasPasswordAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceNetsuiteEnterpriseSchemasPasswordAuthentication) GetTunnelMethod() *SourceNetsuiteEnterpriseSchemasTunnelMethodTunnelMethod {
	if o == nil {
		return nil
	}
	return o.TunnelMethod
}

func (o *SourceNetsuiteEnterpriseSchemasPasswordAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *SourceNetsuiteEnterpriseSchemasPasswordAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *SourceNetsuiteEnterpriseSchemasPasswordAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

func (o *SourceNetsuiteEnterpriseSchemasPasswordAuthentication) GetTunnelUserPassword() string {
	if o == nil {
		return ""
	}
	return o.TunnelUserPassword
}

func (o *SourceNetsuiteEnterpriseSchemasPasswordAuthentication) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

type SourceNetsuiteEnterpriseSchemasTunnelMethod string

const (
	SourceNetsuiteEnterpriseSchemasTunnelMethodSSHKeyAuth SourceNetsuiteEnterpriseSchemasTunnelMethod = "SSH_KEY_AUTH"
)

func (e SourceNetsuiteEnterpriseSchemasTunnelMethod) ToPointer() *SourceNetsuiteEnterpriseSchemasTunnelMethod {
	return &e
}
func (e *SourceNetsuiteEnterpriseSchemasTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_KEY_AUTH":
		*e = SourceNetsuiteEnterpriseSchemasTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceNetsuiteEnterpriseSchemasTunnelMethod: %v", v)
	}
}

// SourceNetsuiteEnterpriseSSHKeyAuthentication - Connect through a jump server tunnel host using username and ssh key
type SourceNetsuiteEnterpriseSSHKeyAuthentication struct {
	TunnelMethod *SourceNetsuiteEnterpriseSchemasTunnelMethod `default:"SSH_KEY_AUTH" json:"tunnel_method"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser string `json:"tunnel_user"`
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey               string `json:"ssh_key"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (s SourceNetsuiteEnterpriseSSHKeyAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceNetsuiteEnterpriseSSHKeyAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceNetsuiteEnterpriseSSHKeyAuthentication) GetTunnelMethod() *SourceNetsuiteEnterpriseSchemasTunnelMethod {
	if o == nil {
		return nil
	}
	return o.TunnelMethod
}

func (o *SourceNetsuiteEnterpriseSSHKeyAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *SourceNetsuiteEnterpriseSSHKeyAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *SourceNetsuiteEnterpriseSSHKeyAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

func (o *SourceNetsuiteEnterpriseSSHKeyAuthentication) GetSSHKey() string {
	if o == nil {
		return ""
	}
	return o.SSHKey
}

func (o *SourceNetsuiteEnterpriseSSHKeyAuthentication) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

type SourceNetsuiteEnterpriseTunnelMethod string

const (
	SourceNetsuiteEnterpriseTunnelMethodNoTunnel SourceNetsuiteEnterpriseTunnelMethod = "NO_TUNNEL"
)

func (e SourceNetsuiteEnterpriseTunnelMethod) ToPointer() *SourceNetsuiteEnterpriseTunnelMethod {
	return &e
}
func (e *SourceNetsuiteEnterpriseTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NO_TUNNEL":
		*e = SourceNetsuiteEnterpriseTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceNetsuiteEnterpriseTunnelMethod: %v", v)
	}
}

// SourceNetsuiteEnterpriseNoTunnel - No ssh tunnel needed to connect to database
type SourceNetsuiteEnterpriseNoTunnel struct {
	TunnelMethod         *SourceNetsuiteEnterpriseTunnelMethod `default:"NO_TUNNEL" json:"tunnel_method"`
	AdditionalProperties any                                   `additionalProperties:"true" json:"-"`
}

func (s SourceNetsuiteEnterpriseNoTunnel) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceNetsuiteEnterpriseNoTunnel) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceNetsuiteEnterpriseNoTunnel) GetTunnelMethod() *SourceNetsuiteEnterpriseTunnelMethod {
	if o == nil {
		return nil
	}
	return o.TunnelMethod
}

func (o *SourceNetsuiteEnterpriseNoTunnel) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

type SourceNetsuiteEnterpriseSSHTunnelMethodType string

const (
	SourceNetsuiteEnterpriseSSHTunnelMethodTypeSourceNetsuiteEnterpriseNoTunnel                      SourceNetsuiteEnterpriseSSHTunnelMethodType = "source-netsuite-enterprise_No Tunnel"
	SourceNetsuiteEnterpriseSSHTunnelMethodTypeSourceNetsuiteEnterpriseSSHKeyAuthentication          SourceNetsuiteEnterpriseSSHTunnelMethodType = "source-netsuite-enterprise_SSH Key Authentication"
	SourceNetsuiteEnterpriseSSHTunnelMethodTypeSourceNetsuiteEnterpriseSchemasPasswordAuthentication SourceNetsuiteEnterpriseSSHTunnelMethodType = "source-netsuite-enterprise_Schemas_Password Authentication"
)

// SourceNetsuiteEnterpriseSSHTunnelMethod - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceNetsuiteEnterpriseSSHTunnelMethod struct {
	SourceNetsuiteEnterpriseNoTunnel                      *SourceNetsuiteEnterpriseNoTunnel                      `queryParam:"inline"`
	SourceNetsuiteEnterpriseSSHKeyAuthentication          *SourceNetsuiteEnterpriseSSHKeyAuthentication          `queryParam:"inline"`
	SourceNetsuiteEnterpriseSchemasPasswordAuthentication *SourceNetsuiteEnterpriseSchemasPasswordAuthentication `queryParam:"inline"`

	Type SourceNetsuiteEnterpriseSSHTunnelMethodType
}

func CreateSourceNetsuiteEnterpriseSSHTunnelMethodSourceNetsuiteEnterpriseNoTunnel(sourceNetsuiteEnterpriseNoTunnel SourceNetsuiteEnterpriseNoTunnel) SourceNetsuiteEnterpriseSSHTunnelMethod {
	typ := SourceNetsuiteEnterpriseSSHTunnelMethodTypeSourceNetsuiteEnterpriseNoTunnel

	return SourceNetsuiteEnterpriseSSHTunnelMethod{
		SourceNetsuiteEnterpriseNoTunnel: &sourceNetsuiteEnterpriseNoTunnel,
		Type:                             typ,
	}
}

func CreateSourceNetsuiteEnterpriseSSHTunnelMethodSourceNetsuiteEnterpriseSSHKeyAuthentication(sourceNetsuiteEnterpriseSSHKeyAuthentication SourceNetsuiteEnterpriseSSHKeyAuthentication) SourceNetsuiteEnterpriseSSHTunnelMethod {
	typ := SourceNetsuiteEnterpriseSSHTunnelMethodTypeSourceNetsuiteEnterpriseSSHKeyAuthentication

	return SourceNetsuiteEnterpriseSSHTunnelMethod{
		SourceNetsuiteEnterpriseSSHKeyAuthentication: &sourceNetsuiteEnterpriseSSHKeyAuthentication,
		Type: typ,
	}
}

func CreateSourceNetsuiteEnterpriseSSHTunnelMethodSourceNetsuiteEnterpriseSchemasPasswordAuthentication(sourceNetsuiteEnterpriseSchemasPasswordAuthentication SourceNetsuiteEnterpriseSchemasPasswordAuthentication) SourceNetsuiteEnterpriseSSHTunnelMethod {
	typ := SourceNetsuiteEnterpriseSSHTunnelMethodTypeSourceNetsuiteEnterpriseSchemasPasswordAuthentication

	return SourceNetsuiteEnterpriseSSHTunnelMethod{
		SourceNetsuiteEnterpriseSchemasPasswordAuthentication: &sourceNetsuiteEnterpriseSchemasPasswordAuthentication,
		Type: typ,
	}
}

func (u *SourceNetsuiteEnterpriseSSHTunnelMethod) UnmarshalJSON(data []byte) error {

	var sourceNetsuiteEnterpriseNoTunnel SourceNetsuiteEnterpriseNoTunnel = SourceNetsuiteEnterpriseNoTunnel{}
	if err := utils.UnmarshalJSON(data, &sourceNetsuiteEnterpriseNoTunnel, "", true, true); err == nil {
		u.SourceNetsuiteEnterpriseNoTunnel = &sourceNetsuiteEnterpriseNoTunnel
		u.Type = SourceNetsuiteEnterpriseSSHTunnelMethodTypeSourceNetsuiteEnterpriseNoTunnel
		return nil
	}

	var sourceNetsuiteEnterpriseSSHKeyAuthentication SourceNetsuiteEnterpriseSSHKeyAuthentication = SourceNetsuiteEnterpriseSSHKeyAuthentication{}
	if err := utils.UnmarshalJSON(data, &sourceNetsuiteEnterpriseSSHKeyAuthentication, "", true, true); err == nil {
		u.SourceNetsuiteEnterpriseSSHKeyAuthentication = &sourceNetsuiteEnterpriseSSHKeyAuthentication
		u.Type = SourceNetsuiteEnterpriseSSHTunnelMethodTypeSourceNetsuiteEnterpriseSSHKeyAuthentication
		return nil
	}

	var sourceNetsuiteEnterpriseSchemasPasswordAuthentication SourceNetsuiteEnterpriseSchemasPasswordAuthentication = SourceNetsuiteEnterpriseSchemasPasswordAuthentication{}
	if err := utils.UnmarshalJSON(data, &sourceNetsuiteEnterpriseSchemasPasswordAuthentication, "", true, true); err == nil {
		u.SourceNetsuiteEnterpriseSchemasPasswordAuthentication = &sourceNetsuiteEnterpriseSchemasPasswordAuthentication
		u.Type = SourceNetsuiteEnterpriseSSHTunnelMethodTypeSourceNetsuiteEnterpriseSchemasPasswordAuthentication
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceNetsuiteEnterpriseSSHTunnelMethod", string(data))
}

func (u SourceNetsuiteEnterpriseSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.SourceNetsuiteEnterpriseNoTunnel != nil {
		return utils.MarshalJSON(u.SourceNetsuiteEnterpriseNoTunnel, "", true)
	}

	if u.SourceNetsuiteEnterpriseSSHKeyAuthentication != nil {
		return utils.MarshalJSON(u.SourceNetsuiteEnterpriseSSHKeyAuthentication, "", true)
	}

	if u.SourceNetsuiteEnterpriseSchemasPasswordAuthentication != nil {
		return utils.MarshalJSON(u.SourceNetsuiteEnterpriseSchemasPasswordAuthentication, "", true)
	}

	return nil, errors.New("could not marshal union type SourceNetsuiteEnterpriseSSHTunnelMethod: all fields are null")
}

type CursorMethod string

const (
	CursorMethodUserDefined CursorMethod = "user_defined"
)

func (e CursorMethod) ToPointer() *CursorMethod {
	return &e
}
func (e *CursorMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "user_defined":
		*e = CursorMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CursorMethod: %v", v)
	}
}

// SourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor - Incrementally detects new inserts and updates using the <a href="https://docs.airbyte.com/understanding-airbyte/connections/incremental-append/#user-defined-cursor">cursor column</a> chosen when configuring a connection (e.g. created_at, updated_at).
type SourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor struct {
	CursorMethod         *CursorMethod `default:"user_defined" json:"cursor_method"`
	AdditionalProperties any           `additionalProperties:"true" json:"-"`
}

func (s SourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor) GetCursorMethod() *CursorMethod {
	if o == nil {
		return nil
	}
	return o.CursorMethod
}

func (o *SourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

type SourceNetsuiteEnterpriseUpdateMethodType string

const (
	SourceNetsuiteEnterpriseUpdateMethodTypeSourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor SourceNetsuiteEnterpriseUpdateMethodType = "source-netsuite-enterprise_Scan Changes with User Defined Cursor"
)

// SourceNetsuiteEnterpriseUpdateMethod - Configures how data is extracted from the database.
type SourceNetsuiteEnterpriseUpdateMethod struct {
	SourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor *SourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor `queryParam:"inline"`

	Type SourceNetsuiteEnterpriseUpdateMethodType
}

func CreateSourceNetsuiteEnterpriseUpdateMethodSourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor(sourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor SourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor) SourceNetsuiteEnterpriseUpdateMethod {
	typ := SourceNetsuiteEnterpriseUpdateMethodTypeSourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor

	return SourceNetsuiteEnterpriseUpdateMethod{
		SourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor: &sourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor,
		Type: typ,
	}
}

func (u *SourceNetsuiteEnterpriseUpdateMethod) UnmarshalJSON(data []byte) error {

	var sourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor SourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor = SourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor{}
	if err := utils.UnmarshalJSON(data, &sourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor, "", true, true); err == nil {
		u.SourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor = &sourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor
		u.Type = SourceNetsuiteEnterpriseUpdateMethodTypeSourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceNetsuiteEnterpriseUpdateMethod", string(data))
}

func (u SourceNetsuiteEnterpriseUpdateMethod) MarshalJSON() ([]byte, error) {
	if u.SourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor != nil {
		return utils.MarshalJSON(u.SourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor, "", true)
	}

	return nil, errors.New("could not marshal union type SourceNetsuiteEnterpriseUpdateMethod: all fields are null")
}

type NetsuiteEnterprise string

const (
	NetsuiteEnterpriseNetsuiteEnterprise NetsuiteEnterprise = "netsuite-enterprise"
)

func (e NetsuiteEnterprise) ToPointer() *NetsuiteEnterprise {
	return &e
}
func (e *NetsuiteEnterprise) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "netsuite-enterprise":
		*e = NetsuiteEnterprise(v)
		return nil
	default:
		return fmt.Errorf("invalid value for NetsuiteEnterprise: %v", v)
	}
}

type SourceNetsuiteEnterprise struct {
	// Hostname of the database.
	Host string `json:"host"`
	// Port of the database.
	Port *int64 `default:"1708" json:"port"`
	// The username which is used to access the database.
	Username string `json:"username"`
	// Configure how to authenticate to Netsuite. Options include username/password or token-based authentication.
	AuthenticationMethod SourceNetsuiteEnterpriseAuthenticationMethod `json:"authentication_method"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod SourceNetsuiteEnterpriseSSHTunnelMethod `json:"tunnel_method"`
	// Configures how data is extracted from the database.
	Cursor SourceNetsuiteEnterpriseUpdateMethod `json:"cursor"`
	// The username which is used to access the database.
	AccountID string `json:"account_id"`
	// The username which is used to access the database.
	RoleID string `json:"role_id"`
	// How often (in seconds) a stream should checkpoint, when possible.
	CheckpointTargetIntervalSeconds *int64 `default:"300" json:"checkpoint_target_interval_seconds"`
	// Maximum number of concurrent queries to the database.
	Concurrency *int64 `default:"1" json:"concurrency"`
	// When this feature is enabled, during schema discovery the connector will query each table or view individually to check access privileges and inaccessible tables, views, or columns therein will be removed. In large schemas, this might cause schema discovery to take too long, in which case it might be advisable to disable this feature.
	CheckPrivileges *bool              `default:"true" json:"check_privileges"`
	sourceType      NetsuiteEnterprise `const:"netsuite-enterprise" json:"sourceType"`
}

func (s SourceNetsuiteEnterprise) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceNetsuiteEnterprise) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *SourceNetsuiteEnterprise) GetHost() string {
	if o == nil {
		return ""
	}
	return o.Host
}

func (o *SourceNetsuiteEnterprise) GetPort() *int64 {
	if o == nil {
		return nil
	}
	return o.Port
}

func (o *SourceNetsuiteEnterprise) GetUsername() string {
	if o == nil {
		return ""
	}
	return o.Username
}

func (o *SourceNetsuiteEnterprise) GetAuthenticationMethod() SourceNetsuiteEnterpriseAuthenticationMethod {
	if o == nil {
		return SourceNetsuiteEnterpriseAuthenticationMethod{}
	}
	return o.AuthenticationMethod
}

func (o *SourceNetsuiteEnterprise) GetJdbcURLParams() *string {
	if o == nil {
		return nil
	}
	return o.JdbcURLParams
}

func (o *SourceNetsuiteEnterprise) GetTunnelMethod() SourceNetsuiteEnterpriseSSHTunnelMethod {
	if o == nil {
		return SourceNetsuiteEnterpriseSSHTunnelMethod{}
	}
	return o.TunnelMethod
}

func (o *SourceNetsuiteEnterprise) GetCursor() SourceNetsuiteEnterpriseUpdateMethod {
	if o == nil {
		return SourceNetsuiteEnterpriseUpdateMethod{}
	}
	return o.Cursor
}

func (o *SourceNetsuiteEnterprise) GetAccountID() string {
	if o == nil {
		return ""
	}
	return o.AccountID
}

func (o *SourceNetsuiteEnterprise) GetRoleID() string {
	if o == nil {
		return ""
	}
	return o.RoleID
}

func (o *SourceNetsuiteEnterprise) GetCheckpointTargetIntervalSeconds() *int64 {
	if o == nil {
		return nil
	}
	return o.CheckpointTargetIntervalSeconds
}

func (o *SourceNetsuiteEnterprise) GetConcurrency() *int64 {
	if o == nil {
		return nil
	}
	return o.Concurrency
}

func (o *SourceNetsuiteEnterprise) GetCheckPrivileges() *bool {
	if o == nil {
		return nil
	}
	return o.CheckPrivileges
}

func (o *SourceNetsuiteEnterprise) GetSourceType() NetsuiteEnterprise {
	return NetsuiteEnterpriseNetsuiteEnterprise
}
