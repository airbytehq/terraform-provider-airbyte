// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

type SourceNetsuiteEnterpriseSchemasAuthenticationMethodAuthenticationMethod string

const (
	SourceNetsuiteEnterpriseSchemasAuthenticationMethodAuthenticationMethodOauth2Authentication SourceNetsuiteEnterpriseSchemasAuthenticationMethodAuthenticationMethod = "oauth2_authentication"
)

func (e SourceNetsuiteEnterpriseSchemasAuthenticationMethodAuthenticationMethod) ToPointer() *SourceNetsuiteEnterpriseSchemasAuthenticationMethodAuthenticationMethod {
	return &e
}
func (e *SourceNetsuiteEnterpriseSchemasAuthenticationMethodAuthenticationMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "oauth2_authentication":
		*e = SourceNetsuiteEnterpriseSchemasAuthenticationMethodAuthenticationMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceNetsuiteEnterpriseSchemasAuthenticationMethodAuthenticationMethod: %v", v)
	}
}

// OAuth2Authentication - Authenticate using OAuth2. This requires a consumer key, the private part of the certificate with which netsuite OAuth2 Client Credentials was setup and the certificate ID for the OAuth2 setup entry.
type OAuth2Authentication struct {
	AuthenticationMethod *SourceNetsuiteEnterpriseSchemasAuthenticationMethodAuthenticationMethod `default:"oauth2_authentication" json:"authentication_method"`
	// The consumer key used for OAuth2 authentication. This is generated in NetSuite when creating an integration record.
	ClientID string `json:"client_id"`
	// The certificate ID for the OAuth 2.0 Client Credentials Setup entry.
	KeyID string `json:"key_id"`
	// The private portion of the certificate with which OAuth2 was setup. ( created with openssl req -new -x509 -newkey rsa:4096 -keyout private.pem -sigopt rsa_padding_mode:pss -sha256 -sigopt rsa_pss_saltlen:64 -out public.pem -nodes -days 365 )
	Oauth2PrivateKey     string `json:"oauth2_private_key"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (o OAuth2Authentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(o, "", false)
}

func (o *OAuth2Authentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &o, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *OAuth2Authentication) GetAuthenticationMethod() *SourceNetsuiteEnterpriseSchemasAuthenticationMethodAuthenticationMethod {
	if o == nil {
		return nil
	}
	return o.AuthenticationMethod
}

func (o *OAuth2Authentication) GetClientID() string {
	if o == nil {
		return ""
	}
	return o.ClientID
}

func (o *OAuth2Authentication) GetKeyID() string {
	if o == nil {
		return ""
	}
	return o.KeyID
}

func (o *OAuth2Authentication) GetOauth2PrivateKey() string {
	if o == nil {
		return ""
	}
	return o.Oauth2PrivateKey
}

func (o *OAuth2Authentication) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

type SourceNetsuiteEnterpriseSchemasAuthenticationMethod string

const (
	SourceNetsuiteEnterpriseSchemasAuthenticationMethodTokenBasedAuthentication SourceNetsuiteEnterpriseSchemasAuthenticationMethod = "token_based_authentication"
)

func (e SourceNetsuiteEnterpriseSchemasAuthenticationMethod) ToPointer() *SourceNetsuiteEnterpriseSchemasAuthenticationMethod {
	return &e
}
func (e *SourceNetsuiteEnterpriseSchemasAuthenticationMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "token_based_authentication":
		*e = SourceNetsuiteEnterpriseSchemasAuthenticationMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceNetsuiteEnterpriseSchemasAuthenticationMethod: %v", v)
	}
}

// TokenBasedAuthentication - Authenticate using a token-based authentication method. This requires a consumer key and secret, as well as a token ID and secret.
type TokenBasedAuthentication struct {
	AuthenticationMethod *SourceNetsuiteEnterpriseSchemasAuthenticationMethod `default:"token_based_authentication" json:"authentication_method"`
	// The consumer key used for token-based authentication. This is generated in NetSuite when creating an integration record.
	ClientID string `json:"client_id"`
	// The consumer secret used for token-based authentication. This is generated in NetSuite when creating an integration record.
	ClientSecret string `json:"client_secret"`
	// The token ID used for token-based authentication. This is generated in NetSuite when creating a token-based role.
	TokenID string `json:"token_id"`
	// The token secret used for token-based authentication. This is generated in NetSuite when creating a token-based role.Ensure to keep this value secure.
	TokenSecret          string `json:"token_secret"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (t TokenBasedAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(t, "", false)
}

func (t *TokenBasedAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &t, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (t *TokenBasedAuthentication) GetAuthenticationMethod() *SourceNetsuiteEnterpriseSchemasAuthenticationMethod {
	if t == nil {
		return nil
	}
	return t.AuthenticationMethod
}

func (t *TokenBasedAuthentication) GetClientID() string {
	if t == nil {
		return ""
	}
	return t.ClientID
}

func (t *TokenBasedAuthentication) GetClientSecret() string {
	if t == nil {
		return ""
	}
	return t.ClientSecret
}

func (t *TokenBasedAuthentication) GetTokenID() string {
	if t == nil {
		return ""
	}
	return t.TokenID
}

func (t *TokenBasedAuthentication) GetTokenSecret() string {
	if t == nil {
		return ""
	}
	return t.TokenSecret
}

func (t *TokenBasedAuthentication) GetAdditionalProperties() any {
	if t == nil {
		return nil
	}
	return t.AdditionalProperties
}

type SourceNetsuiteEnterpriseSchemasAuthenticationMethodAuthenticationMethodAuthenticationMethod string

const (
	SourceNetsuiteEnterpriseSchemasAuthenticationMethodAuthenticationMethodAuthenticationMethodPasswordAuthentication SourceNetsuiteEnterpriseSchemasAuthenticationMethodAuthenticationMethodAuthenticationMethod = "password_authentication"
)

func (e SourceNetsuiteEnterpriseSchemasAuthenticationMethodAuthenticationMethodAuthenticationMethod) ToPointer() *SourceNetsuiteEnterpriseSchemasAuthenticationMethodAuthenticationMethodAuthenticationMethod {
	return &e
}
func (e *SourceNetsuiteEnterpriseSchemasAuthenticationMethodAuthenticationMethodAuthenticationMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "password_authentication":
		*e = SourceNetsuiteEnterpriseSchemasAuthenticationMethodAuthenticationMethodAuthenticationMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceNetsuiteEnterpriseSchemasAuthenticationMethodAuthenticationMethodAuthenticationMethod: %v", v)
	}
}

// SourceNetsuiteEnterprisePasswordAuthentication - Authenticate using a password.
type SourceNetsuiteEnterprisePasswordAuthentication struct {
	AuthenticationMethod *SourceNetsuiteEnterpriseSchemasAuthenticationMethodAuthenticationMethodAuthenticationMethod `default:"password_authentication" json:"authentication_method"`
	// The password associated with the username.
	Password             string `json:"password"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (s SourceNetsuiteEnterprisePasswordAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceNetsuiteEnterprisePasswordAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceNetsuiteEnterprisePasswordAuthentication) GetAuthenticationMethod() *SourceNetsuiteEnterpriseSchemasAuthenticationMethodAuthenticationMethodAuthenticationMethod {
	if s == nil {
		return nil
	}
	return s.AuthenticationMethod
}

func (s *SourceNetsuiteEnterprisePasswordAuthentication) GetPassword() string {
	if s == nil {
		return ""
	}
	return s.Password
}

func (s *SourceNetsuiteEnterprisePasswordAuthentication) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceNetsuiteEnterpriseAuthenticationMethodType string

const (
	SourceNetsuiteEnterpriseAuthenticationMethodTypeSourceNetsuiteEnterprisePasswordAuthentication SourceNetsuiteEnterpriseAuthenticationMethodType = "source-netsuite-enterprise_Password Authentication"
	SourceNetsuiteEnterpriseAuthenticationMethodTypeTokenBasedAuthentication                       SourceNetsuiteEnterpriseAuthenticationMethodType = "Token Based Authentication"
	SourceNetsuiteEnterpriseAuthenticationMethodTypeOAuth2Authentication                           SourceNetsuiteEnterpriseAuthenticationMethodType = "OAuth2 Authentication"
)

// SourceNetsuiteEnterpriseAuthenticationMethod - Configure how to authenticate to Netsuite. Options include username/password or token-based authentication.
type SourceNetsuiteEnterpriseAuthenticationMethod struct {
	SourceNetsuiteEnterprisePasswordAuthentication *SourceNetsuiteEnterprisePasswordAuthentication `queryParam:"inline" union:"member"`
	TokenBasedAuthentication                       *TokenBasedAuthentication                       `queryParam:"inline" union:"member"`
	OAuth2Authentication                           *OAuth2Authentication                           `queryParam:"inline" union:"member"`

	Type SourceNetsuiteEnterpriseAuthenticationMethodType
}

func CreateSourceNetsuiteEnterpriseAuthenticationMethodSourceNetsuiteEnterprisePasswordAuthentication(sourceNetsuiteEnterprisePasswordAuthentication SourceNetsuiteEnterprisePasswordAuthentication) SourceNetsuiteEnterpriseAuthenticationMethod {
	typ := SourceNetsuiteEnterpriseAuthenticationMethodTypeSourceNetsuiteEnterprisePasswordAuthentication

	return SourceNetsuiteEnterpriseAuthenticationMethod{
		SourceNetsuiteEnterprisePasswordAuthentication: &sourceNetsuiteEnterprisePasswordAuthentication,
		Type: typ,
	}
}

func CreateSourceNetsuiteEnterpriseAuthenticationMethodTokenBasedAuthentication(tokenBasedAuthentication TokenBasedAuthentication) SourceNetsuiteEnterpriseAuthenticationMethod {
	typ := SourceNetsuiteEnterpriseAuthenticationMethodTypeTokenBasedAuthentication

	return SourceNetsuiteEnterpriseAuthenticationMethod{
		TokenBasedAuthentication: &tokenBasedAuthentication,
		Type:                     typ,
	}
}

func CreateSourceNetsuiteEnterpriseAuthenticationMethodOAuth2Authentication(oAuth2Authentication OAuth2Authentication) SourceNetsuiteEnterpriseAuthenticationMethod {
	typ := SourceNetsuiteEnterpriseAuthenticationMethodTypeOAuth2Authentication

	return SourceNetsuiteEnterpriseAuthenticationMethod{
		OAuth2Authentication: &oAuth2Authentication,
		Type:                 typ,
	}
}

func (u *SourceNetsuiteEnterpriseAuthenticationMethod) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var sourceNetsuiteEnterprisePasswordAuthentication SourceNetsuiteEnterprisePasswordAuthentication = SourceNetsuiteEnterprisePasswordAuthentication{}
	if err := utils.UnmarshalJSON(data, &sourceNetsuiteEnterprisePasswordAuthentication, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceNetsuiteEnterpriseAuthenticationMethodTypeSourceNetsuiteEnterprisePasswordAuthentication,
			Value: &sourceNetsuiteEnterprisePasswordAuthentication,
		})
	}

	var tokenBasedAuthentication TokenBasedAuthentication = TokenBasedAuthentication{}
	if err := utils.UnmarshalJSON(data, &tokenBasedAuthentication, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceNetsuiteEnterpriseAuthenticationMethodTypeTokenBasedAuthentication,
			Value: &tokenBasedAuthentication,
		})
	}

	var oAuth2Authentication OAuth2Authentication = OAuth2Authentication{}
	if err := utils.UnmarshalJSON(data, &oAuth2Authentication, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceNetsuiteEnterpriseAuthenticationMethodTypeOAuth2Authentication,
			Value: &oAuth2Authentication,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceNetsuiteEnterpriseAuthenticationMethod", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceNetsuiteEnterpriseAuthenticationMethod", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceNetsuiteEnterpriseAuthenticationMethodType)
	switch best.Type {
	case SourceNetsuiteEnterpriseAuthenticationMethodTypeSourceNetsuiteEnterprisePasswordAuthentication:
		u.SourceNetsuiteEnterprisePasswordAuthentication = best.Value.(*SourceNetsuiteEnterprisePasswordAuthentication)
		return nil
	case SourceNetsuiteEnterpriseAuthenticationMethodTypeTokenBasedAuthentication:
		u.TokenBasedAuthentication = best.Value.(*TokenBasedAuthentication)
		return nil
	case SourceNetsuiteEnterpriseAuthenticationMethodTypeOAuth2Authentication:
		u.OAuth2Authentication = best.Value.(*OAuth2Authentication)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceNetsuiteEnterpriseAuthenticationMethod", string(data))
}

func (u SourceNetsuiteEnterpriseAuthenticationMethod) MarshalJSON() ([]byte, error) {
	if u.SourceNetsuiteEnterprisePasswordAuthentication != nil {
		return utils.MarshalJSON(u.SourceNetsuiteEnterprisePasswordAuthentication, "", true)
	}

	if u.TokenBasedAuthentication != nil {
		return utils.MarshalJSON(u.TokenBasedAuthentication, "", true)
	}

	if u.OAuth2Authentication != nil {
		return utils.MarshalJSON(u.OAuth2Authentication, "", true)
	}

	return nil, errors.New("could not marshal union type SourceNetsuiteEnterpriseAuthenticationMethod: all fields are null")
}

type SourceNetsuiteEnterpriseCursorMethod string

const (
	SourceNetsuiteEnterpriseCursorMethodUserDefined SourceNetsuiteEnterpriseCursorMethod = "user_defined"
)

func (e SourceNetsuiteEnterpriseCursorMethod) ToPointer() *SourceNetsuiteEnterpriseCursorMethod {
	return &e
}
func (e *SourceNetsuiteEnterpriseCursorMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "user_defined":
		*e = SourceNetsuiteEnterpriseCursorMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceNetsuiteEnterpriseCursorMethod: %v", v)
	}
}

// SourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor - Incrementally detects new inserts and updates using the <a href="https://docs.airbyte.com/understanding-airbyte/connections/incremental-append/#user-defined-cursor">cursor column</a> chosen when configuring a connection (e.g. created_at, updated_at).
type SourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor struct {
	CursorMethod         *SourceNetsuiteEnterpriseCursorMethod `default:"user_defined" json:"cursor_method"`
	AdditionalProperties any                                   `additionalProperties:"true" json:"-"`
}

func (s SourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor) GetCursorMethod() *SourceNetsuiteEnterpriseCursorMethod {
	if s == nil {
		return nil
	}
	return s.CursorMethod
}

func (s *SourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceNetsuiteEnterpriseUpdateMethodType string

const (
	SourceNetsuiteEnterpriseUpdateMethodTypeSourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor SourceNetsuiteEnterpriseUpdateMethodType = "source-netsuite-enterprise_Scan Changes with User Defined Cursor"
)

// SourceNetsuiteEnterpriseUpdateMethod - Configures how data is extracted from the database.
type SourceNetsuiteEnterpriseUpdateMethod struct {
	SourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor *SourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor `queryParam:"inline" union:"member"`

	Type SourceNetsuiteEnterpriseUpdateMethodType
}

func CreateSourceNetsuiteEnterpriseUpdateMethodSourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor(sourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor SourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor) SourceNetsuiteEnterpriseUpdateMethod {
	typ := SourceNetsuiteEnterpriseUpdateMethodTypeSourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor

	return SourceNetsuiteEnterpriseUpdateMethod{
		SourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor: &sourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor,
		Type: typ,
	}
}

func (u *SourceNetsuiteEnterpriseUpdateMethod) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var sourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor SourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor = SourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor{}
	if err := utils.UnmarshalJSON(data, &sourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceNetsuiteEnterpriseUpdateMethodTypeSourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor,
			Value: &sourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceNetsuiteEnterpriseUpdateMethod", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceNetsuiteEnterpriseUpdateMethod", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceNetsuiteEnterpriseUpdateMethodType)
	switch best.Type {
	case SourceNetsuiteEnterpriseUpdateMethodTypeSourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor:
		u.SourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor = best.Value.(*SourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceNetsuiteEnterpriseUpdateMethod", string(data))
}

func (u SourceNetsuiteEnterpriseUpdateMethod) MarshalJSON() ([]byte, error) {
	if u.SourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor != nil {
		return utils.MarshalJSON(u.SourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor, "", true)
	}

	return nil, errors.New("could not marshal union type SourceNetsuiteEnterpriseUpdateMethod: all fields are null")
}

type SourceNetsuiteEnterpriseSchemasTunnelMethodTunnelMethod string

const (
	SourceNetsuiteEnterpriseSchemasTunnelMethodTunnelMethodSSHPasswordAuth SourceNetsuiteEnterpriseSchemasTunnelMethodTunnelMethod = "SSH_PASSWORD_AUTH"
)

func (e SourceNetsuiteEnterpriseSchemasTunnelMethodTunnelMethod) ToPointer() *SourceNetsuiteEnterpriseSchemasTunnelMethodTunnelMethod {
	return &e
}
func (e *SourceNetsuiteEnterpriseSchemasTunnelMethodTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_PASSWORD_AUTH":
		*e = SourceNetsuiteEnterpriseSchemasTunnelMethodTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceNetsuiteEnterpriseSchemasTunnelMethodTunnelMethod: %v", v)
	}
}

// SourceNetsuiteEnterpriseSchemasPasswordAuthentication - Connect through a jump server tunnel host using username and password authentication
type SourceNetsuiteEnterpriseSchemasPasswordAuthentication struct {
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost   string                                                   `json:"tunnel_host"`
	TunnelMethod *SourceNetsuiteEnterpriseSchemasTunnelMethodTunnelMethod `default:"SSH_PASSWORD_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser string `json:"tunnel_user"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword   string `json:"tunnel_user_password"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (s SourceNetsuiteEnterpriseSchemasPasswordAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceNetsuiteEnterpriseSchemasPasswordAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceNetsuiteEnterpriseSchemasPasswordAuthentication) GetTunnelHost() string {
	if s == nil {
		return ""
	}
	return s.TunnelHost
}

func (s *SourceNetsuiteEnterpriseSchemasPasswordAuthentication) GetTunnelMethod() *SourceNetsuiteEnterpriseSchemasTunnelMethodTunnelMethod {
	if s == nil {
		return nil
	}
	return s.TunnelMethod
}

func (s *SourceNetsuiteEnterpriseSchemasPasswordAuthentication) GetTunnelPort() *int64 {
	if s == nil {
		return nil
	}
	return s.TunnelPort
}

func (s *SourceNetsuiteEnterpriseSchemasPasswordAuthentication) GetTunnelUser() string {
	if s == nil {
		return ""
	}
	return s.TunnelUser
}

func (s *SourceNetsuiteEnterpriseSchemasPasswordAuthentication) GetTunnelUserPassword() string {
	if s == nil {
		return ""
	}
	return s.TunnelUserPassword
}

func (s *SourceNetsuiteEnterpriseSchemasPasswordAuthentication) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceNetsuiteEnterpriseSchemasTunnelMethod string

const (
	SourceNetsuiteEnterpriseSchemasTunnelMethodSSHKeyAuth SourceNetsuiteEnterpriseSchemasTunnelMethod = "SSH_KEY_AUTH"
)

func (e SourceNetsuiteEnterpriseSchemasTunnelMethod) ToPointer() *SourceNetsuiteEnterpriseSchemasTunnelMethod {
	return &e
}
func (e *SourceNetsuiteEnterpriseSchemasTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_KEY_AUTH":
		*e = SourceNetsuiteEnterpriseSchemasTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceNetsuiteEnterpriseSchemasTunnelMethod: %v", v)
	}
}

// SourceNetsuiteEnterpriseSSHKeyAuthentication - Connect through a jump server tunnel host using username and ssh key
type SourceNetsuiteEnterpriseSSHKeyAuthentication struct {
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey string `json:"ssh_key"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost   string                                       `json:"tunnel_host"`
	TunnelMethod *SourceNetsuiteEnterpriseSchemasTunnelMethod `default:"SSH_KEY_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser           string `json:"tunnel_user"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (s SourceNetsuiteEnterpriseSSHKeyAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceNetsuiteEnterpriseSSHKeyAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceNetsuiteEnterpriseSSHKeyAuthentication) GetSSHKey() string {
	if s == nil {
		return ""
	}
	return s.SSHKey
}

func (s *SourceNetsuiteEnterpriseSSHKeyAuthentication) GetTunnelHost() string {
	if s == nil {
		return ""
	}
	return s.TunnelHost
}

func (s *SourceNetsuiteEnterpriseSSHKeyAuthentication) GetTunnelMethod() *SourceNetsuiteEnterpriseSchemasTunnelMethod {
	if s == nil {
		return nil
	}
	return s.TunnelMethod
}

func (s *SourceNetsuiteEnterpriseSSHKeyAuthentication) GetTunnelPort() *int64 {
	if s == nil {
		return nil
	}
	return s.TunnelPort
}

func (s *SourceNetsuiteEnterpriseSSHKeyAuthentication) GetTunnelUser() string {
	if s == nil {
		return ""
	}
	return s.TunnelUser
}

func (s *SourceNetsuiteEnterpriseSSHKeyAuthentication) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceNetsuiteEnterpriseTunnelMethod string

const (
	SourceNetsuiteEnterpriseTunnelMethodNoTunnel SourceNetsuiteEnterpriseTunnelMethod = "NO_TUNNEL"
)

func (e SourceNetsuiteEnterpriseTunnelMethod) ToPointer() *SourceNetsuiteEnterpriseTunnelMethod {
	return &e
}
func (e *SourceNetsuiteEnterpriseTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NO_TUNNEL":
		*e = SourceNetsuiteEnterpriseTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceNetsuiteEnterpriseTunnelMethod: %v", v)
	}
}

// SourceNetsuiteEnterpriseNoTunnel - No ssh tunnel needed to connect to database
type SourceNetsuiteEnterpriseNoTunnel struct {
	TunnelMethod         *SourceNetsuiteEnterpriseTunnelMethod `default:"NO_TUNNEL" json:"tunnel_method"`
	AdditionalProperties any                                   `additionalProperties:"true" json:"-"`
}

func (s SourceNetsuiteEnterpriseNoTunnel) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceNetsuiteEnterpriseNoTunnel) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceNetsuiteEnterpriseNoTunnel) GetTunnelMethod() *SourceNetsuiteEnterpriseTunnelMethod {
	if s == nil {
		return nil
	}
	return s.TunnelMethod
}

func (s *SourceNetsuiteEnterpriseNoTunnel) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceNetsuiteEnterpriseSSHTunnelMethodType string

const (
	SourceNetsuiteEnterpriseSSHTunnelMethodTypeSourceNetsuiteEnterpriseNoTunnel                      SourceNetsuiteEnterpriseSSHTunnelMethodType = "source-netsuite-enterprise_No Tunnel"
	SourceNetsuiteEnterpriseSSHTunnelMethodTypeSourceNetsuiteEnterpriseSSHKeyAuthentication          SourceNetsuiteEnterpriseSSHTunnelMethodType = "source-netsuite-enterprise_SSH Key Authentication"
	SourceNetsuiteEnterpriseSSHTunnelMethodTypeSourceNetsuiteEnterpriseSchemasPasswordAuthentication SourceNetsuiteEnterpriseSSHTunnelMethodType = "source-netsuite-enterprise_Schemas_Password Authentication"
)

// SourceNetsuiteEnterpriseSSHTunnelMethod - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceNetsuiteEnterpriseSSHTunnelMethod struct {
	SourceNetsuiteEnterpriseNoTunnel                      *SourceNetsuiteEnterpriseNoTunnel                      `queryParam:"inline" union:"member"`
	SourceNetsuiteEnterpriseSSHKeyAuthentication          *SourceNetsuiteEnterpriseSSHKeyAuthentication          `queryParam:"inline" union:"member"`
	SourceNetsuiteEnterpriseSchemasPasswordAuthentication *SourceNetsuiteEnterpriseSchemasPasswordAuthentication `queryParam:"inline" union:"member"`

	Type SourceNetsuiteEnterpriseSSHTunnelMethodType
}

func CreateSourceNetsuiteEnterpriseSSHTunnelMethodSourceNetsuiteEnterpriseNoTunnel(sourceNetsuiteEnterpriseNoTunnel SourceNetsuiteEnterpriseNoTunnel) SourceNetsuiteEnterpriseSSHTunnelMethod {
	typ := SourceNetsuiteEnterpriseSSHTunnelMethodTypeSourceNetsuiteEnterpriseNoTunnel

	return SourceNetsuiteEnterpriseSSHTunnelMethod{
		SourceNetsuiteEnterpriseNoTunnel: &sourceNetsuiteEnterpriseNoTunnel,
		Type:                             typ,
	}
}

func CreateSourceNetsuiteEnterpriseSSHTunnelMethodSourceNetsuiteEnterpriseSSHKeyAuthentication(sourceNetsuiteEnterpriseSSHKeyAuthentication SourceNetsuiteEnterpriseSSHKeyAuthentication) SourceNetsuiteEnterpriseSSHTunnelMethod {
	typ := SourceNetsuiteEnterpriseSSHTunnelMethodTypeSourceNetsuiteEnterpriseSSHKeyAuthentication

	return SourceNetsuiteEnterpriseSSHTunnelMethod{
		SourceNetsuiteEnterpriseSSHKeyAuthentication: &sourceNetsuiteEnterpriseSSHKeyAuthentication,
		Type: typ,
	}
}

func CreateSourceNetsuiteEnterpriseSSHTunnelMethodSourceNetsuiteEnterpriseSchemasPasswordAuthentication(sourceNetsuiteEnterpriseSchemasPasswordAuthentication SourceNetsuiteEnterpriseSchemasPasswordAuthentication) SourceNetsuiteEnterpriseSSHTunnelMethod {
	typ := SourceNetsuiteEnterpriseSSHTunnelMethodTypeSourceNetsuiteEnterpriseSchemasPasswordAuthentication

	return SourceNetsuiteEnterpriseSSHTunnelMethod{
		SourceNetsuiteEnterpriseSchemasPasswordAuthentication: &sourceNetsuiteEnterpriseSchemasPasswordAuthentication,
		Type: typ,
	}
}

func (u *SourceNetsuiteEnterpriseSSHTunnelMethod) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var sourceNetsuiteEnterpriseNoTunnel SourceNetsuiteEnterpriseNoTunnel = SourceNetsuiteEnterpriseNoTunnel{}
	if err := utils.UnmarshalJSON(data, &sourceNetsuiteEnterpriseNoTunnel, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceNetsuiteEnterpriseSSHTunnelMethodTypeSourceNetsuiteEnterpriseNoTunnel,
			Value: &sourceNetsuiteEnterpriseNoTunnel,
		})
	}

	var sourceNetsuiteEnterpriseSSHKeyAuthentication SourceNetsuiteEnterpriseSSHKeyAuthentication = SourceNetsuiteEnterpriseSSHKeyAuthentication{}
	if err := utils.UnmarshalJSON(data, &sourceNetsuiteEnterpriseSSHKeyAuthentication, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceNetsuiteEnterpriseSSHTunnelMethodTypeSourceNetsuiteEnterpriseSSHKeyAuthentication,
			Value: &sourceNetsuiteEnterpriseSSHKeyAuthentication,
		})
	}

	var sourceNetsuiteEnterpriseSchemasPasswordAuthentication SourceNetsuiteEnterpriseSchemasPasswordAuthentication = SourceNetsuiteEnterpriseSchemasPasswordAuthentication{}
	if err := utils.UnmarshalJSON(data, &sourceNetsuiteEnterpriseSchemasPasswordAuthentication, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceNetsuiteEnterpriseSSHTunnelMethodTypeSourceNetsuiteEnterpriseSchemasPasswordAuthentication,
			Value: &sourceNetsuiteEnterpriseSchemasPasswordAuthentication,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceNetsuiteEnterpriseSSHTunnelMethod", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceNetsuiteEnterpriseSSHTunnelMethod", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceNetsuiteEnterpriseSSHTunnelMethodType)
	switch best.Type {
	case SourceNetsuiteEnterpriseSSHTunnelMethodTypeSourceNetsuiteEnterpriseNoTunnel:
		u.SourceNetsuiteEnterpriseNoTunnel = best.Value.(*SourceNetsuiteEnterpriseNoTunnel)
		return nil
	case SourceNetsuiteEnterpriseSSHTunnelMethodTypeSourceNetsuiteEnterpriseSSHKeyAuthentication:
		u.SourceNetsuiteEnterpriseSSHKeyAuthentication = best.Value.(*SourceNetsuiteEnterpriseSSHKeyAuthentication)
		return nil
	case SourceNetsuiteEnterpriseSSHTunnelMethodTypeSourceNetsuiteEnterpriseSchemasPasswordAuthentication:
		u.SourceNetsuiteEnterpriseSchemasPasswordAuthentication = best.Value.(*SourceNetsuiteEnterpriseSchemasPasswordAuthentication)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceNetsuiteEnterpriseSSHTunnelMethod", string(data))
}

func (u SourceNetsuiteEnterpriseSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.SourceNetsuiteEnterpriseNoTunnel != nil {
		return utils.MarshalJSON(u.SourceNetsuiteEnterpriseNoTunnel, "", true)
	}

	if u.SourceNetsuiteEnterpriseSSHKeyAuthentication != nil {
		return utils.MarshalJSON(u.SourceNetsuiteEnterpriseSSHKeyAuthentication, "", true)
	}

	if u.SourceNetsuiteEnterpriseSchemasPasswordAuthentication != nil {
		return utils.MarshalJSON(u.SourceNetsuiteEnterpriseSchemasPasswordAuthentication, "", true)
	}

	return nil, errors.New("could not marshal union type SourceNetsuiteEnterpriseSSHTunnelMethod: all fields are null")
}

type SourceNetsuiteEnterpriseSourceType string

const (
	SourceNetsuiteEnterpriseSourceTypeNetsuiteEnterprise SourceNetsuiteEnterpriseSourceType = "netsuite-enterprise"
)

func (e SourceNetsuiteEnterpriseSourceType) ToPointer() *SourceNetsuiteEnterpriseSourceType {
	return &e
}
func (e *SourceNetsuiteEnterpriseSourceType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "netsuite-enterprise":
		*e = SourceNetsuiteEnterpriseSourceType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceNetsuiteEnterpriseSourceType: %v", v)
	}
}

type SourceNetsuiteEnterprise struct {
	// The username which is used to access the database.
	AccountID string `json:"account_id"`
	// Configure how to authenticate to Netsuite. Options include username/password or token-based authentication.
	AuthenticationMethod SourceNetsuiteEnterpriseAuthenticationMethod `json:"authentication_method"`
	// When this feature is enabled, during schema discovery the connector will query each table or view individually to check access privileges and inaccessible tables, views, or columns therein will be removed. In large schemas, this might cause schema discovery to take too long, in which case it might be advisable to disable this feature.
	CheckPrivileges *bool `default:"true" json:"check_privileges"`
	// How often (in seconds) a stream should checkpoint, when possible.
	CheckpointTargetIntervalSeconds *int64 `default:"300" json:"checkpoint_target_interval_seconds"`
	// Maximum number of concurrent queries to the database.
	Concurrency *int64 `default:"1" json:"concurrency"`
	// Configures how data is extracted from the database.
	Cursor SourceNetsuiteEnterpriseUpdateMethod `json:"cursor"`
	// Hostname of the database.
	Host string `json:"host"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// Port of the database.
	Port *int64 `default:"1708" json:"port"`
	// The username which is used to access the database.
	RoleID string `json:"role_id"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod SourceNetsuiteEnterpriseSSHTunnelMethod `json:"tunnel_method"`
	// The username which is used to access the database.
	Username             string                              `json:"username"`
	sourceType           *SourceNetsuiteEnterpriseSourceType `const:"netsuite-enterprise" json:"sourceType"`
	AdditionalProperties any                                 `additionalProperties:"true" json:"-"`
}

func (s SourceNetsuiteEnterprise) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceNetsuiteEnterprise) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceNetsuiteEnterprise) GetAccountID() string {
	if s == nil {
		return ""
	}
	return s.AccountID
}

func (s *SourceNetsuiteEnterprise) GetAuthenticationMethod() SourceNetsuiteEnterpriseAuthenticationMethod {
	if s == nil {
		return SourceNetsuiteEnterpriseAuthenticationMethod{}
	}
	return s.AuthenticationMethod
}

func (s *SourceNetsuiteEnterprise) GetCheckPrivileges() *bool {
	if s == nil {
		return nil
	}
	return s.CheckPrivileges
}

func (s *SourceNetsuiteEnterprise) GetCheckpointTargetIntervalSeconds() *int64 {
	if s == nil {
		return nil
	}
	return s.CheckpointTargetIntervalSeconds
}

func (s *SourceNetsuiteEnterprise) GetConcurrency() *int64 {
	if s == nil {
		return nil
	}
	return s.Concurrency
}

func (s *SourceNetsuiteEnterprise) GetCursor() SourceNetsuiteEnterpriseUpdateMethod {
	if s == nil {
		return SourceNetsuiteEnterpriseUpdateMethod{}
	}
	return s.Cursor
}

func (s *SourceNetsuiteEnterprise) GetHost() string {
	if s == nil {
		return ""
	}
	return s.Host
}

func (s *SourceNetsuiteEnterprise) GetJdbcURLParams() *string {
	if s == nil {
		return nil
	}
	return s.JdbcURLParams
}

func (s *SourceNetsuiteEnterprise) GetPort() *int64 {
	if s == nil {
		return nil
	}
	return s.Port
}

func (s *SourceNetsuiteEnterprise) GetRoleID() string {
	if s == nil {
		return ""
	}
	return s.RoleID
}

func (s *SourceNetsuiteEnterprise) GetTunnelMethod() SourceNetsuiteEnterpriseSSHTunnelMethod {
	if s == nil {
		return SourceNetsuiteEnterpriseSSHTunnelMethod{}
	}
	return s.TunnelMethod
}

func (s *SourceNetsuiteEnterprise) GetUsername() string {
	if s == nil {
		return ""
	}
	return s.Username
}

func (s *SourceNetsuiteEnterprise) GetSourceType() *SourceNetsuiteEnterpriseSourceType {
	return SourceNetsuiteEnterpriseSourceTypeNetsuiteEnterprise.ToPointer()
}

func (s *SourceNetsuiteEnterprise) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}
