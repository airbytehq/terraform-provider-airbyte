// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

type SourceNetsuiteEnterpriseSchemasTunnelMethodTunnelMethod string

const (
	SourceNetsuiteEnterpriseSchemasTunnelMethodTunnelMethodSSHPasswordAuth SourceNetsuiteEnterpriseSchemasTunnelMethodTunnelMethod = "SSH_PASSWORD_AUTH"
)

func (e SourceNetsuiteEnterpriseSchemasTunnelMethodTunnelMethod) ToPointer() *SourceNetsuiteEnterpriseSchemasTunnelMethodTunnelMethod {
	return &e
}
func (e *SourceNetsuiteEnterpriseSchemasTunnelMethodTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_PASSWORD_AUTH":
		*e = SourceNetsuiteEnterpriseSchemasTunnelMethodTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceNetsuiteEnterpriseSchemasTunnelMethodTunnelMethod: %v", v)
	}
}

// SourceNetsuiteEnterprisePasswordAuthentication - Connect through a jump server tunnel host using username and password authentication
type SourceNetsuiteEnterprisePasswordAuthentication struct {
	TunnelMethod *SourceNetsuiteEnterpriseSchemasTunnelMethodTunnelMethod `default:"SSH_PASSWORD_AUTH" json:"tunnel_method"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser string `json:"tunnel_user"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword   string `json:"tunnel_user_password"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (s SourceNetsuiteEnterprisePasswordAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceNetsuiteEnterprisePasswordAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceNetsuiteEnterprisePasswordAuthentication) GetTunnelMethod() *SourceNetsuiteEnterpriseSchemasTunnelMethodTunnelMethod {
	if o == nil {
		return nil
	}
	return o.TunnelMethod
}

func (o *SourceNetsuiteEnterprisePasswordAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *SourceNetsuiteEnterprisePasswordAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *SourceNetsuiteEnterprisePasswordAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

func (o *SourceNetsuiteEnterprisePasswordAuthentication) GetTunnelUserPassword() string {
	if o == nil {
		return ""
	}
	return o.TunnelUserPassword
}

func (o *SourceNetsuiteEnterprisePasswordAuthentication) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

type SourceNetsuiteEnterpriseSchemasTunnelMethod string

const (
	SourceNetsuiteEnterpriseSchemasTunnelMethodSSHKeyAuth SourceNetsuiteEnterpriseSchemasTunnelMethod = "SSH_KEY_AUTH"
)

func (e SourceNetsuiteEnterpriseSchemasTunnelMethod) ToPointer() *SourceNetsuiteEnterpriseSchemasTunnelMethod {
	return &e
}
func (e *SourceNetsuiteEnterpriseSchemasTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_KEY_AUTH":
		*e = SourceNetsuiteEnterpriseSchemasTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceNetsuiteEnterpriseSchemasTunnelMethod: %v", v)
	}
}

// SourceNetsuiteEnterpriseSSHKeyAuthentication - Connect through a jump server tunnel host using username and ssh key
type SourceNetsuiteEnterpriseSSHKeyAuthentication struct {
	TunnelMethod *SourceNetsuiteEnterpriseSchemasTunnelMethod `default:"SSH_KEY_AUTH" json:"tunnel_method"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser string `json:"tunnel_user"`
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey               string `json:"ssh_key"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (s SourceNetsuiteEnterpriseSSHKeyAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceNetsuiteEnterpriseSSHKeyAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceNetsuiteEnterpriseSSHKeyAuthentication) GetTunnelMethod() *SourceNetsuiteEnterpriseSchemasTunnelMethod {
	if o == nil {
		return nil
	}
	return o.TunnelMethod
}

func (o *SourceNetsuiteEnterpriseSSHKeyAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *SourceNetsuiteEnterpriseSSHKeyAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *SourceNetsuiteEnterpriseSSHKeyAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

func (o *SourceNetsuiteEnterpriseSSHKeyAuthentication) GetSSHKey() string {
	if o == nil {
		return ""
	}
	return o.SSHKey
}

func (o *SourceNetsuiteEnterpriseSSHKeyAuthentication) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

type SourceNetsuiteEnterpriseTunnelMethod string

const (
	SourceNetsuiteEnterpriseTunnelMethodNoTunnel SourceNetsuiteEnterpriseTunnelMethod = "NO_TUNNEL"
)

func (e SourceNetsuiteEnterpriseTunnelMethod) ToPointer() *SourceNetsuiteEnterpriseTunnelMethod {
	return &e
}
func (e *SourceNetsuiteEnterpriseTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NO_TUNNEL":
		*e = SourceNetsuiteEnterpriseTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceNetsuiteEnterpriseTunnelMethod: %v", v)
	}
}

// SourceNetsuiteEnterpriseNoTunnel - No ssh tunnel needed to connect to database
type SourceNetsuiteEnterpriseNoTunnel struct {
	TunnelMethod         *SourceNetsuiteEnterpriseTunnelMethod `default:"NO_TUNNEL" json:"tunnel_method"`
	AdditionalProperties any                                   `additionalProperties:"true" json:"-"`
}

func (s SourceNetsuiteEnterpriseNoTunnel) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceNetsuiteEnterpriseNoTunnel) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceNetsuiteEnterpriseNoTunnel) GetTunnelMethod() *SourceNetsuiteEnterpriseTunnelMethod {
	if o == nil {
		return nil
	}
	return o.TunnelMethod
}

func (o *SourceNetsuiteEnterpriseNoTunnel) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

type SourceNetsuiteEnterpriseSSHTunnelMethodType string

const (
	SourceNetsuiteEnterpriseSSHTunnelMethodTypeSourceNetsuiteEnterpriseNoTunnel               SourceNetsuiteEnterpriseSSHTunnelMethodType = "source-netsuite-enterprise_No Tunnel"
	SourceNetsuiteEnterpriseSSHTunnelMethodTypeSourceNetsuiteEnterpriseSSHKeyAuthentication   SourceNetsuiteEnterpriseSSHTunnelMethodType = "source-netsuite-enterprise_SSH Key Authentication"
	SourceNetsuiteEnterpriseSSHTunnelMethodTypeSourceNetsuiteEnterprisePasswordAuthentication SourceNetsuiteEnterpriseSSHTunnelMethodType = "source-netsuite-enterprise_Password Authentication"
)

// SourceNetsuiteEnterpriseSSHTunnelMethod - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceNetsuiteEnterpriseSSHTunnelMethod struct {
	SourceNetsuiteEnterpriseNoTunnel               *SourceNetsuiteEnterpriseNoTunnel               `queryParam:"inline"`
	SourceNetsuiteEnterpriseSSHKeyAuthentication   *SourceNetsuiteEnterpriseSSHKeyAuthentication   `queryParam:"inline"`
	SourceNetsuiteEnterprisePasswordAuthentication *SourceNetsuiteEnterprisePasswordAuthentication `queryParam:"inline"`

	Type SourceNetsuiteEnterpriseSSHTunnelMethodType
}

func CreateSourceNetsuiteEnterpriseSSHTunnelMethodSourceNetsuiteEnterpriseNoTunnel(sourceNetsuiteEnterpriseNoTunnel SourceNetsuiteEnterpriseNoTunnel) SourceNetsuiteEnterpriseSSHTunnelMethod {
	typ := SourceNetsuiteEnterpriseSSHTunnelMethodTypeSourceNetsuiteEnterpriseNoTunnel

	return SourceNetsuiteEnterpriseSSHTunnelMethod{
		SourceNetsuiteEnterpriseNoTunnel: &sourceNetsuiteEnterpriseNoTunnel,
		Type:                             typ,
	}
}

func CreateSourceNetsuiteEnterpriseSSHTunnelMethodSourceNetsuiteEnterpriseSSHKeyAuthentication(sourceNetsuiteEnterpriseSSHKeyAuthentication SourceNetsuiteEnterpriseSSHKeyAuthentication) SourceNetsuiteEnterpriseSSHTunnelMethod {
	typ := SourceNetsuiteEnterpriseSSHTunnelMethodTypeSourceNetsuiteEnterpriseSSHKeyAuthentication

	return SourceNetsuiteEnterpriseSSHTunnelMethod{
		SourceNetsuiteEnterpriseSSHKeyAuthentication: &sourceNetsuiteEnterpriseSSHKeyAuthentication,
		Type: typ,
	}
}

func CreateSourceNetsuiteEnterpriseSSHTunnelMethodSourceNetsuiteEnterprisePasswordAuthentication(sourceNetsuiteEnterprisePasswordAuthentication SourceNetsuiteEnterprisePasswordAuthentication) SourceNetsuiteEnterpriseSSHTunnelMethod {
	typ := SourceNetsuiteEnterpriseSSHTunnelMethodTypeSourceNetsuiteEnterprisePasswordAuthentication

	return SourceNetsuiteEnterpriseSSHTunnelMethod{
		SourceNetsuiteEnterprisePasswordAuthentication: &sourceNetsuiteEnterprisePasswordAuthentication,
		Type: typ,
	}
}

func (u *SourceNetsuiteEnterpriseSSHTunnelMethod) UnmarshalJSON(data []byte) error {

	var sourceNetsuiteEnterpriseNoTunnel SourceNetsuiteEnterpriseNoTunnel = SourceNetsuiteEnterpriseNoTunnel{}
	if err := utils.UnmarshalJSON(data, &sourceNetsuiteEnterpriseNoTunnel, "", true, true); err == nil {
		u.SourceNetsuiteEnterpriseNoTunnel = &sourceNetsuiteEnterpriseNoTunnel
		u.Type = SourceNetsuiteEnterpriseSSHTunnelMethodTypeSourceNetsuiteEnterpriseNoTunnel
		return nil
	}

	var sourceNetsuiteEnterpriseSSHKeyAuthentication SourceNetsuiteEnterpriseSSHKeyAuthentication = SourceNetsuiteEnterpriseSSHKeyAuthentication{}
	if err := utils.UnmarshalJSON(data, &sourceNetsuiteEnterpriseSSHKeyAuthentication, "", true, true); err == nil {
		u.SourceNetsuiteEnterpriseSSHKeyAuthentication = &sourceNetsuiteEnterpriseSSHKeyAuthentication
		u.Type = SourceNetsuiteEnterpriseSSHTunnelMethodTypeSourceNetsuiteEnterpriseSSHKeyAuthentication
		return nil
	}

	var sourceNetsuiteEnterprisePasswordAuthentication SourceNetsuiteEnterprisePasswordAuthentication = SourceNetsuiteEnterprisePasswordAuthentication{}
	if err := utils.UnmarshalJSON(data, &sourceNetsuiteEnterprisePasswordAuthentication, "", true, true); err == nil {
		u.SourceNetsuiteEnterprisePasswordAuthentication = &sourceNetsuiteEnterprisePasswordAuthentication
		u.Type = SourceNetsuiteEnterpriseSSHTunnelMethodTypeSourceNetsuiteEnterprisePasswordAuthentication
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceNetsuiteEnterpriseSSHTunnelMethod", string(data))
}

func (u SourceNetsuiteEnterpriseSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.SourceNetsuiteEnterpriseNoTunnel != nil {
		return utils.MarshalJSON(u.SourceNetsuiteEnterpriseNoTunnel, "", true)
	}

	if u.SourceNetsuiteEnterpriseSSHKeyAuthentication != nil {
		return utils.MarshalJSON(u.SourceNetsuiteEnterpriseSSHKeyAuthentication, "", true)
	}

	if u.SourceNetsuiteEnterprisePasswordAuthentication != nil {
		return utils.MarshalJSON(u.SourceNetsuiteEnterprisePasswordAuthentication, "", true)
	}

	return nil, errors.New("could not marshal union type SourceNetsuiteEnterpriseSSHTunnelMethod: all fields are null")
}

type CursorMethod string

const (
	CursorMethodUserDefined CursorMethod = "user_defined"
)

func (e CursorMethod) ToPointer() *CursorMethod {
	return &e
}
func (e *CursorMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "user_defined":
		*e = CursorMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CursorMethod: %v", v)
	}
}

// SourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor - Incrementally detects new inserts and updates using the <a href="https://docs.airbyte.com/understanding-airbyte/connections/incremental-append/#user-defined-cursor">cursor column</a> chosen when configuring a connection (e.g. created_at, updated_at).
type SourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor struct {
	CursorMethod         *CursorMethod `default:"user_defined" json:"cursor_method"`
	AdditionalProperties any           `additionalProperties:"true" json:"-"`
}

func (s SourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor) GetCursorMethod() *CursorMethod {
	if o == nil {
		return nil
	}
	return o.CursorMethod
}

func (o *SourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

type SourceNetsuiteEnterpriseUpdateMethodType string

const (
	SourceNetsuiteEnterpriseUpdateMethodTypeSourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor SourceNetsuiteEnterpriseUpdateMethodType = "source-netsuite-enterprise_Scan Changes with User Defined Cursor"
)

// SourceNetsuiteEnterpriseUpdateMethod - Configures how data is extracted from the database.
type SourceNetsuiteEnterpriseUpdateMethod struct {
	SourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor *SourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor `queryParam:"inline"`

	Type SourceNetsuiteEnterpriseUpdateMethodType
}

func CreateSourceNetsuiteEnterpriseUpdateMethodSourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor(sourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor SourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor) SourceNetsuiteEnterpriseUpdateMethod {
	typ := SourceNetsuiteEnterpriseUpdateMethodTypeSourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor

	return SourceNetsuiteEnterpriseUpdateMethod{
		SourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor: &sourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor,
		Type: typ,
	}
}

func (u *SourceNetsuiteEnterpriseUpdateMethod) UnmarshalJSON(data []byte) error {

	var sourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor SourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor = SourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor{}
	if err := utils.UnmarshalJSON(data, &sourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor, "", true, true); err == nil {
		u.SourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor = &sourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor
		u.Type = SourceNetsuiteEnterpriseUpdateMethodTypeSourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceNetsuiteEnterpriseUpdateMethod", string(data))
}

func (u SourceNetsuiteEnterpriseUpdateMethod) MarshalJSON() ([]byte, error) {
	if u.SourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor != nil {
		return utils.MarshalJSON(u.SourceNetsuiteEnterpriseScanChangesWithUserDefinedCursor, "", true)
	}

	return nil, errors.New("could not marshal union type SourceNetsuiteEnterpriseUpdateMethod: all fields are null")
}

type NetsuiteEnterprise string

const (
	NetsuiteEnterpriseNetsuiteEnterprise NetsuiteEnterprise = "netsuite-enterprise"
)

func (e NetsuiteEnterprise) ToPointer() *NetsuiteEnterprise {
	return &e
}
func (e *NetsuiteEnterprise) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "netsuite-enterprise":
		*e = NetsuiteEnterprise(v)
		return nil
	default:
		return fmt.Errorf("invalid value for NetsuiteEnterprise: %v", v)
	}
}

type SourceNetsuiteEnterprise struct {
	// Hostname of the database.
	Host string `json:"host"`
	// Port of the database.
	Port *int64 `default:"1708" json:"port"`
	// The username which is used to access the database.
	Username string `json:"username"`
	// The password associated with the username.
	Password *string `json:"password,omitempty"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod SourceNetsuiteEnterpriseSSHTunnelMethod `json:"tunnel_method"`
	// Configures how data is extracted from the database.
	Cursor SourceNetsuiteEnterpriseUpdateMethod `json:"cursor"`
	// The username which is used to access the database.
	AccountID string `json:"account_id"`
	// The username which is used to access the database.
	RoleID string `json:"role_id"`
	// How often (in seconds) a stream should checkpoint, when possible.
	CheckpointTargetIntervalSeconds *int64 `default:"300" json:"checkpoint_target_interval_seconds"`
	// Maximum number of concurrent queries to the database.
	Concurrency *int64 `default:"1" json:"concurrency"`
	// When this feature is enabled, during schema discovery the connector will query each table or view individually to check access privileges and inaccessible tables, views, or columns therein will be removed. In large schemas, this might cause schema discovery to take too long, in which case it might be advisable to disable this feature.
	CheckPrivileges *bool              `default:"true" json:"check_privileges"`
	sourceType      NetsuiteEnterprise `const:"netsuite-enterprise" json:"sourceType"`
}

func (s SourceNetsuiteEnterprise) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceNetsuiteEnterprise) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *SourceNetsuiteEnterprise) GetHost() string {
	if o == nil {
		return ""
	}
	return o.Host
}

func (o *SourceNetsuiteEnterprise) GetPort() *int64 {
	if o == nil {
		return nil
	}
	return o.Port
}

func (o *SourceNetsuiteEnterprise) GetUsername() string {
	if o == nil {
		return ""
	}
	return o.Username
}

func (o *SourceNetsuiteEnterprise) GetPassword() *string {
	if o == nil {
		return nil
	}
	return o.Password
}

func (o *SourceNetsuiteEnterprise) GetJdbcURLParams() *string {
	if o == nil {
		return nil
	}
	return o.JdbcURLParams
}

func (o *SourceNetsuiteEnterprise) GetTunnelMethod() SourceNetsuiteEnterpriseSSHTunnelMethod {
	if o == nil {
		return SourceNetsuiteEnterpriseSSHTunnelMethod{}
	}
	return o.TunnelMethod
}

func (o *SourceNetsuiteEnterprise) GetCursor() SourceNetsuiteEnterpriseUpdateMethod {
	if o == nil {
		return SourceNetsuiteEnterpriseUpdateMethod{}
	}
	return o.Cursor
}

func (o *SourceNetsuiteEnterprise) GetAccountID() string {
	if o == nil {
		return ""
	}
	return o.AccountID
}

func (o *SourceNetsuiteEnterprise) GetRoleID() string {
	if o == nil {
		return ""
	}
	return o.RoleID
}

func (o *SourceNetsuiteEnterprise) GetCheckpointTargetIntervalSeconds() *int64 {
	if o == nil {
		return nil
	}
	return o.CheckpointTargetIntervalSeconds
}

func (o *SourceNetsuiteEnterprise) GetConcurrency() *int64 {
	if o == nil {
		return nil
	}
	return o.Concurrency
}

func (o *SourceNetsuiteEnterprise) GetCheckPrivileges() *bool {
	if o == nil {
		return nil
	}
	return o.CheckPrivileges
}

func (o *SourceNetsuiteEnterprise) GetSourceType() NetsuiteEnterprise {
	return NetsuiteEnterpriseNetsuiteEnterprise
}
