// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

type SourceDb2EnterpriseUpdateSchemasCursorMethod string

const (
	SourceDb2EnterpriseUpdateSchemasCursorMethodCdc SourceDb2EnterpriseUpdateSchemasCursorMethod = "cdc"
)

func (e SourceDb2EnterpriseUpdateSchemasCursorMethod) ToPointer() *SourceDb2EnterpriseUpdateSchemasCursorMethod {
	return &e
}
func (e *SourceDb2EnterpriseUpdateSchemasCursorMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "cdc":
		*e = SourceDb2EnterpriseUpdateSchemasCursorMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceDb2EnterpriseUpdateSchemasCursorMethod: %v", v)
	}
}

// SourceDb2EnterpriseUpdateReadChangesUsingChangeDataCaptureCDC - <i>Recommended</i> - Incrementally reads new inserts, updates, and deletes using change data capture feature. This must be enabled on your database.
type SourceDb2EnterpriseUpdateReadChangesUsingChangeDataCaptureCDC struct {
	CursorMethod *SourceDb2EnterpriseUpdateSchemasCursorMethod `default:"cdc" json:"cursor_method"`
	// The amount of time an initial load is allowed to continue for before catching up on CDC events.
	InitialLoadTimeoutHours *int64 `default:"8" json:"initial_load_timeout_hours"`
	AdditionalProperties    any    `additionalProperties:"true" json:"-"`
}

func (s SourceDb2EnterpriseUpdateReadChangesUsingChangeDataCaptureCDC) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceDb2EnterpriseUpdateReadChangesUsingChangeDataCaptureCDC) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceDb2EnterpriseUpdateReadChangesUsingChangeDataCaptureCDC) GetCursorMethod() *SourceDb2EnterpriseUpdateSchemasCursorMethod {
	if s == nil {
		return nil
	}
	return s.CursorMethod
}

func (s *SourceDb2EnterpriseUpdateReadChangesUsingChangeDataCaptureCDC) GetInitialLoadTimeoutHours() *int64 {
	if s == nil {
		return nil
	}
	return s.InitialLoadTimeoutHours
}

func (s *SourceDb2EnterpriseUpdateReadChangesUsingChangeDataCaptureCDC) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceDb2EnterpriseUpdateCursorMethod string

const (
	SourceDb2EnterpriseUpdateCursorMethodUserDefined SourceDb2EnterpriseUpdateCursorMethod = "user_defined"
)

func (e SourceDb2EnterpriseUpdateCursorMethod) ToPointer() *SourceDb2EnterpriseUpdateCursorMethod {
	return &e
}
func (e *SourceDb2EnterpriseUpdateCursorMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "user_defined":
		*e = SourceDb2EnterpriseUpdateCursorMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceDb2EnterpriseUpdateCursorMethod: %v", v)
	}
}

// SourceDb2EnterpriseUpdateScanChangesWithUserDefinedCursor - Incrementally detects new inserts and updates using the <a href="https://docs.airbyte.com/understanding-airbyte/connections/incremental-append/#user-defined-cursor">cursor column</a> chosen when configuring a connection (e.g. created_at, updated_at).
type SourceDb2EnterpriseUpdateScanChangesWithUserDefinedCursor struct {
	CursorMethod         *SourceDb2EnterpriseUpdateCursorMethod `default:"user_defined" json:"cursor_method"`
	AdditionalProperties any                                    `additionalProperties:"true" json:"-"`
}

func (s SourceDb2EnterpriseUpdateScanChangesWithUserDefinedCursor) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceDb2EnterpriseUpdateScanChangesWithUserDefinedCursor) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceDb2EnterpriseUpdateScanChangesWithUserDefinedCursor) GetCursorMethod() *SourceDb2EnterpriseUpdateCursorMethod {
	if s == nil {
		return nil
	}
	return s.CursorMethod
}

func (s *SourceDb2EnterpriseUpdateScanChangesWithUserDefinedCursor) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceDb2EnterpriseUpdateUpdateMethodType string

const (
	SourceDb2EnterpriseUpdateUpdateMethodTypeSourceDb2EnterpriseUpdateScanChangesWithUserDefinedCursor     SourceDb2EnterpriseUpdateUpdateMethodType = "source-db2-enterprise-update_Scan Changes with User Defined Cursor"
	SourceDb2EnterpriseUpdateUpdateMethodTypeSourceDb2EnterpriseUpdateReadChangesUsingChangeDataCaptureCDC SourceDb2EnterpriseUpdateUpdateMethodType = "source-db2-enterprise-update_Read Changes using Change Data Capture (CDC)"
)

// SourceDb2EnterpriseUpdateUpdateMethod - Configures how data is extracted from the database.
type SourceDb2EnterpriseUpdateUpdateMethod struct {
	SourceDb2EnterpriseUpdateScanChangesWithUserDefinedCursor     *SourceDb2EnterpriseUpdateScanChangesWithUserDefinedCursor     `queryParam:"inline" union:"member"`
	SourceDb2EnterpriseUpdateReadChangesUsingChangeDataCaptureCDC *SourceDb2EnterpriseUpdateReadChangesUsingChangeDataCaptureCDC `queryParam:"inline" union:"member"`

	Type SourceDb2EnterpriseUpdateUpdateMethodType
}

func CreateSourceDb2EnterpriseUpdateUpdateMethodSourceDb2EnterpriseUpdateScanChangesWithUserDefinedCursor(sourceDb2EnterpriseUpdateScanChangesWithUserDefinedCursor SourceDb2EnterpriseUpdateScanChangesWithUserDefinedCursor) SourceDb2EnterpriseUpdateUpdateMethod {
	typ := SourceDb2EnterpriseUpdateUpdateMethodTypeSourceDb2EnterpriseUpdateScanChangesWithUserDefinedCursor

	return SourceDb2EnterpriseUpdateUpdateMethod{
		SourceDb2EnterpriseUpdateScanChangesWithUserDefinedCursor: &sourceDb2EnterpriseUpdateScanChangesWithUserDefinedCursor,
		Type: typ,
	}
}

func CreateSourceDb2EnterpriseUpdateUpdateMethodSourceDb2EnterpriseUpdateReadChangesUsingChangeDataCaptureCDC(sourceDb2EnterpriseUpdateReadChangesUsingChangeDataCaptureCDC SourceDb2EnterpriseUpdateReadChangesUsingChangeDataCaptureCDC) SourceDb2EnterpriseUpdateUpdateMethod {
	typ := SourceDb2EnterpriseUpdateUpdateMethodTypeSourceDb2EnterpriseUpdateReadChangesUsingChangeDataCaptureCDC

	return SourceDb2EnterpriseUpdateUpdateMethod{
		SourceDb2EnterpriseUpdateReadChangesUsingChangeDataCaptureCDC: &sourceDb2EnterpriseUpdateReadChangesUsingChangeDataCaptureCDC,
		Type: typ,
	}
}

func (u *SourceDb2EnterpriseUpdateUpdateMethod) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var sourceDb2EnterpriseUpdateScanChangesWithUserDefinedCursor SourceDb2EnterpriseUpdateScanChangesWithUserDefinedCursor = SourceDb2EnterpriseUpdateScanChangesWithUserDefinedCursor{}
	if err := utils.UnmarshalJSON(data, &sourceDb2EnterpriseUpdateScanChangesWithUserDefinedCursor, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceDb2EnterpriseUpdateUpdateMethodTypeSourceDb2EnterpriseUpdateScanChangesWithUserDefinedCursor,
			Value: &sourceDb2EnterpriseUpdateScanChangesWithUserDefinedCursor,
		})
	}

	var sourceDb2EnterpriseUpdateReadChangesUsingChangeDataCaptureCDC SourceDb2EnterpriseUpdateReadChangesUsingChangeDataCaptureCDC = SourceDb2EnterpriseUpdateReadChangesUsingChangeDataCaptureCDC{}
	if err := utils.UnmarshalJSON(data, &sourceDb2EnterpriseUpdateReadChangesUsingChangeDataCaptureCDC, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceDb2EnterpriseUpdateUpdateMethodTypeSourceDb2EnterpriseUpdateReadChangesUsingChangeDataCaptureCDC,
			Value: &sourceDb2EnterpriseUpdateReadChangesUsingChangeDataCaptureCDC,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceDb2EnterpriseUpdateUpdateMethod", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceDb2EnterpriseUpdateUpdateMethod", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceDb2EnterpriseUpdateUpdateMethodType)
	switch best.Type {
	case SourceDb2EnterpriseUpdateUpdateMethodTypeSourceDb2EnterpriseUpdateScanChangesWithUserDefinedCursor:
		u.SourceDb2EnterpriseUpdateScanChangesWithUserDefinedCursor = best.Value.(*SourceDb2EnterpriseUpdateScanChangesWithUserDefinedCursor)
		return nil
	case SourceDb2EnterpriseUpdateUpdateMethodTypeSourceDb2EnterpriseUpdateReadChangesUsingChangeDataCaptureCDC:
		u.SourceDb2EnterpriseUpdateReadChangesUsingChangeDataCaptureCDC = best.Value.(*SourceDb2EnterpriseUpdateReadChangesUsingChangeDataCaptureCDC)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceDb2EnterpriseUpdateUpdateMethod", string(data))
}

func (u SourceDb2EnterpriseUpdateUpdateMethod) MarshalJSON() ([]byte, error) {
	if u.SourceDb2EnterpriseUpdateScanChangesWithUserDefinedCursor != nil {
		return utils.MarshalJSON(u.SourceDb2EnterpriseUpdateScanChangesWithUserDefinedCursor, "", true)
	}

	if u.SourceDb2EnterpriseUpdateReadChangesUsingChangeDataCaptureCDC != nil {
		return utils.MarshalJSON(u.SourceDb2EnterpriseUpdateReadChangesUsingChangeDataCaptureCDC, "", true)
	}

	return nil, errors.New("could not marshal union type SourceDb2EnterpriseUpdateUpdateMethod: all fields are null")
}

type SourceDb2EnterpriseUpdateSchemasEncryptionMethod string

const (
	SourceDb2EnterpriseUpdateSchemasEncryptionMethodEncryptedVerifyCertificate SourceDb2EnterpriseUpdateSchemasEncryptionMethod = "encrypted_verify_certificate"
)

func (e SourceDb2EnterpriseUpdateSchemasEncryptionMethod) ToPointer() *SourceDb2EnterpriseUpdateSchemasEncryptionMethod {
	return &e
}
func (e *SourceDb2EnterpriseUpdateSchemasEncryptionMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "encrypted_verify_certificate":
		*e = SourceDb2EnterpriseUpdateSchemasEncryptionMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceDb2EnterpriseUpdateSchemasEncryptionMethod: %v", v)
	}
}

// SourceDb2EnterpriseUpdateTLSEncryptedVerifyCertificate - Verify and use the certificate provided by the server.
type SourceDb2EnterpriseUpdateTLSEncryptedVerifyCertificate struct {
	EncryptionMethod *SourceDb2EnterpriseUpdateSchemasEncryptionMethod `default:"encrypted_verify_certificate" json:"encryption_method"`
	// Privacy Enhanced Mail (PEM) files are concatenated certificate containers frequently used in certificate installations.
	SslCertificate       *string `json:"ssl_certificate,omitempty"`
	AdditionalProperties any     `additionalProperties:"true" json:"-"`
}

func (s SourceDb2EnterpriseUpdateTLSEncryptedVerifyCertificate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceDb2EnterpriseUpdateTLSEncryptedVerifyCertificate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceDb2EnterpriseUpdateTLSEncryptedVerifyCertificate) GetEncryptionMethod() *SourceDb2EnterpriseUpdateSchemasEncryptionMethod {
	if s == nil {
		return nil
	}
	return s.EncryptionMethod
}

func (s *SourceDb2EnterpriseUpdateTLSEncryptedVerifyCertificate) GetSslCertificate() *string {
	if s == nil {
		return nil
	}
	return s.SslCertificate
}

func (s *SourceDb2EnterpriseUpdateTLSEncryptedVerifyCertificate) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceDb2EnterpriseUpdateEncryptionMethod string

const (
	SourceDb2EnterpriseUpdateEncryptionMethodUnencrypted SourceDb2EnterpriseUpdateEncryptionMethod = "unencrypted"
)

func (e SourceDb2EnterpriseUpdateEncryptionMethod) ToPointer() *SourceDb2EnterpriseUpdateEncryptionMethod {
	return &e
}
func (e *SourceDb2EnterpriseUpdateEncryptionMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "unencrypted":
		*e = SourceDb2EnterpriseUpdateEncryptionMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceDb2EnterpriseUpdateEncryptionMethod: %v", v)
	}
}

// SourceDb2EnterpriseUpdateUnencrypted - Data transfer will not be encrypted.
type SourceDb2EnterpriseUpdateUnencrypted struct {
	EncryptionMethod     *SourceDb2EnterpriseUpdateEncryptionMethod `default:"unencrypted" json:"encryption_method"`
	AdditionalProperties any                                        `additionalProperties:"true" json:"-"`
}

func (s SourceDb2EnterpriseUpdateUnencrypted) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceDb2EnterpriseUpdateUnencrypted) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceDb2EnterpriseUpdateUnencrypted) GetEncryptionMethod() *SourceDb2EnterpriseUpdateEncryptionMethod {
	if s == nil {
		return nil
	}
	return s.EncryptionMethod
}

func (s *SourceDb2EnterpriseUpdateUnencrypted) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceDb2EnterpriseUpdateEncryptionType string

const (
	SourceDb2EnterpriseUpdateEncryptionTypeSourceDb2EnterpriseUpdateUnencrypted                   SourceDb2EnterpriseUpdateEncryptionType = "source-db2-enterprise-update_Unencrypted"
	SourceDb2EnterpriseUpdateEncryptionTypeSourceDb2EnterpriseUpdateTLSEncryptedVerifyCertificate SourceDb2EnterpriseUpdateEncryptionType = "source-db2-enterprise-update_TLS Encrypted (verify certificate)"
)

// SourceDb2EnterpriseUpdateEncryption - The encryption method with is used when communicating with the database.
type SourceDb2EnterpriseUpdateEncryption struct {
	SourceDb2EnterpriseUpdateUnencrypted                   *SourceDb2EnterpriseUpdateUnencrypted                   `queryParam:"inline" union:"member"`
	SourceDb2EnterpriseUpdateTLSEncryptedVerifyCertificate *SourceDb2EnterpriseUpdateTLSEncryptedVerifyCertificate `queryParam:"inline" union:"member"`

	Type SourceDb2EnterpriseUpdateEncryptionType
}

func CreateSourceDb2EnterpriseUpdateEncryptionSourceDb2EnterpriseUpdateUnencrypted(sourceDb2EnterpriseUpdateUnencrypted SourceDb2EnterpriseUpdateUnencrypted) SourceDb2EnterpriseUpdateEncryption {
	typ := SourceDb2EnterpriseUpdateEncryptionTypeSourceDb2EnterpriseUpdateUnencrypted

	return SourceDb2EnterpriseUpdateEncryption{
		SourceDb2EnterpriseUpdateUnencrypted: &sourceDb2EnterpriseUpdateUnencrypted,
		Type:                                 typ,
	}
}

func CreateSourceDb2EnterpriseUpdateEncryptionSourceDb2EnterpriseUpdateTLSEncryptedVerifyCertificate(sourceDb2EnterpriseUpdateTLSEncryptedVerifyCertificate SourceDb2EnterpriseUpdateTLSEncryptedVerifyCertificate) SourceDb2EnterpriseUpdateEncryption {
	typ := SourceDb2EnterpriseUpdateEncryptionTypeSourceDb2EnterpriseUpdateTLSEncryptedVerifyCertificate

	return SourceDb2EnterpriseUpdateEncryption{
		SourceDb2EnterpriseUpdateTLSEncryptedVerifyCertificate: &sourceDb2EnterpriseUpdateTLSEncryptedVerifyCertificate,
		Type: typ,
	}
}

func (u *SourceDb2EnterpriseUpdateEncryption) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var sourceDb2EnterpriseUpdateUnencrypted SourceDb2EnterpriseUpdateUnencrypted = SourceDb2EnterpriseUpdateUnencrypted{}
	if err := utils.UnmarshalJSON(data, &sourceDb2EnterpriseUpdateUnencrypted, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceDb2EnterpriseUpdateEncryptionTypeSourceDb2EnterpriseUpdateUnencrypted,
			Value: &sourceDb2EnterpriseUpdateUnencrypted,
		})
	}

	var sourceDb2EnterpriseUpdateTLSEncryptedVerifyCertificate SourceDb2EnterpriseUpdateTLSEncryptedVerifyCertificate = SourceDb2EnterpriseUpdateTLSEncryptedVerifyCertificate{}
	if err := utils.UnmarshalJSON(data, &sourceDb2EnterpriseUpdateTLSEncryptedVerifyCertificate, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceDb2EnterpriseUpdateEncryptionTypeSourceDb2EnterpriseUpdateTLSEncryptedVerifyCertificate,
			Value: &sourceDb2EnterpriseUpdateTLSEncryptedVerifyCertificate,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceDb2EnterpriseUpdateEncryption", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceDb2EnterpriseUpdateEncryption", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceDb2EnterpriseUpdateEncryptionType)
	switch best.Type {
	case SourceDb2EnterpriseUpdateEncryptionTypeSourceDb2EnterpriseUpdateUnencrypted:
		u.SourceDb2EnterpriseUpdateUnencrypted = best.Value.(*SourceDb2EnterpriseUpdateUnencrypted)
		return nil
	case SourceDb2EnterpriseUpdateEncryptionTypeSourceDb2EnterpriseUpdateTLSEncryptedVerifyCertificate:
		u.SourceDb2EnterpriseUpdateTLSEncryptedVerifyCertificate = best.Value.(*SourceDb2EnterpriseUpdateTLSEncryptedVerifyCertificate)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceDb2EnterpriseUpdateEncryption", string(data))
}

func (u SourceDb2EnterpriseUpdateEncryption) MarshalJSON() ([]byte, error) {
	if u.SourceDb2EnterpriseUpdateUnencrypted != nil {
		return utils.MarshalJSON(u.SourceDb2EnterpriseUpdateUnencrypted, "", true)
	}

	if u.SourceDb2EnterpriseUpdateTLSEncryptedVerifyCertificate != nil {
		return utils.MarshalJSON(u.SourceDb2EnterpriseUpdateTLSEncryptedVerifyCertificate, "", true)
	}

	return nil, errors.New("could not marshal union type SourceDb2EnterpriseUpdateEncryption: all fields are null")
}

type SourceDb2EnterpriseUpdateSchemasTunnelMethodTunnelMethod string

const (
	SourceDb2EnterpriseUpdateSchemasTunnelMethodTunnelMethodSSHPasswordAuth SourceDb2EnterpriseUpdateSchemasTunnelMethodTunnelMethod = "SSH_PASSWORD_AUTH"
)

func (e SourceDb2EnterpriseUpdateSchemasTunnelMethodTunnelMethod) ToPointer() *SourceDb2EnterpriseUpdateSchemasTunnelMethodTunnelMethod {
	return &e
}
func (e *SourceDb2EnterpriseUpdateSchemasTunnelMethodTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_PASSWORD_AUTH":
		*e = SourceDb2EnterpriseUpdateSchemasTunnelMethodTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceDb2EnterpriseUpdateSchemasTunnelMethodTunnelMethod: %v", v)
	}
}

// SourceDb2EnterpriseUpdatePasswordAuthentication - Connect through a jump server tunnel host using username and password authentication
type SourceDb2EnterpriseUpdatePasswordAuthentication struct {
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost   *string                                                   `json:"tunnel_host,omitempty"`
	TunnelMethod *SourceDb2EnterpriseUpdateSchemasTunnelMethodTunnelMethod `default:"SSH_PASSWORD_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser *string `json:"tunnel_user,omitempty"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword   *string `json:"tunnel_user_password,omitempty"`
	AdditionalProperties any     `additionalProperties:"true" json:"-"`
}

func (s SourceDb2EnterpriseUpdatePasswordAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceDb2EnterpriseUpdatePasswordAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceDb2EnterpriseUpdatePasswordAuthentication) GetTunnelHost() *string {
	if s == nil {
		return nil
	}
	return s.TunnelHost
}

func (s *SourceDb2EnterpriseUpdatePasswordAuthentication) GetTunnelMethod() *SourceDb2EnterpriseUpdateSchemasTunnelMethodTunnelMethod {
	if s == nil {
		return nil
	}
	return s.TunnelMethod
}

func (s *SourceDb2EnterpriseUpdatePasswordAuthentication) GetTunnelPort() *int64 {
	if s == nil {
		return nil
	}
	return s.TunnelPort
}

func (s *SourceDb2EnterpriseUpdatePasswordAuthentication) GetTunnelUser() *string {
	if s == nil {
		return nil
	}
	return s.TunnelUser
}

func (s *SourceDb2EnterpriseUpdatePasswordAuthentication) GetTunnelUserPassword() *string {
	if s == nil {
		return nil
	}
	return s.TunnelUserPassword
}

func (s *SourceDb2EnterpriseUpdatePasswordAuthentication) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceDb2EnterpriseUpdateSchemasTunnelMethod string

const (
	SourceDb2EnterpriseUpdateSchemasTunnelMethodSSHKeyAuth SourceDb2EnterpriseUpdateSchemasTunnelMethod = "SSH_KEY_AUTH"
)

func (e SourceDb2EnterpriseUpdateSchemasTunnelMethod) ToPointer() *SourceDb2EnterpriseUpdateSchemasTunnelMethod {
	return &e
}
func (e *SourceDb2EnterpriseUpdateSchemasTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_KEY_AUTH":
		*e = SourceDb2EnterpriseUpdateSchemasTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceDb2EnterpriseUpdateSchemasTunnelMethod: %v", v)
	}
}

// SourceDb2EnterpriseUpdateSSHKeyAuthentication - Connect through a jump server tunnel host using username and ssh key
type SourceDb2EnterpriseUpdateSSHKeyAuthentication struct {
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey *string `json:"ssh_key,omitempty"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost   *string                                       `json:"tunnel_host,omitempty"`
	TunnelMethod *SourceDb2EnterpriseUpdateSchemasTunnelMethod `default:"SSH_KEY_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser           *string `json:"tunnel_user,omitempty"`
	AdditionalProperties any     `additionalProperties:"true" json:"-"`
}

func (s SourceDb2EnterpriseUpdateSSHKeyAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceDb2EnterpriseUpdateSSHKeyAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceDb2EnterpriseUpdateSSHKeyAuthentication) GetSSHKey() *string {
	if s == nil {
		return nil
	}
	return s.SSHKey
}

func (s *SourceDb2EnterpriseUpdateSSHKeyAuthentication) GetTunnelHost() *string {
	if s == nil {
		return nil
	}
	return s.TunnelHost
}

func (s *SourceDb2EnterpriseUpdateSSHKeyAuthentication) GetTunnelMethod() *SourceDb2EnterpriseUpdateSchemasTunnelMethod {
	if s == nil {
		return nil
	}
	return s.TunnelMethod
}

func (s *SourceDb2EnterpriseUpdateSSHKeyAuthentication) GetTunnelPort() *int64 {
	if s == nil {
		return nil
	}
	return s.TunnelPort
}

func (s *SourceDb2EnterpriseUpdateSSHKeyAuthentication) GetTunnelUser() *string {
	if s == nil {
		return nil
	}
	return s.TunnelUser
}

func (s *SourceDb2EnterpriseUpdateSSHKeyAuthentication) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceDb2EnterpriseUpdateTunnelMethod string

const (
	SourceDb2EnterpriseUpdateTunnelMethodNoTunnel SourceDb2EnterpriseUpdateTunnelMethod = "NO_TUNNEL"
)

func (e SourceDb2EnterpriseUpdateTunnelMethod) ToPointer() *SourceDb2EnterpriseUpdateTunnelMethod {
	return &e
}
func (e *SourceDb2EnterpriseUpdateTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NO_TUNNEL":
		*e = SourceDb2EnterpriseUpdateTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceDb2EnterpriseUpdateTunnelMethod: %v", v)
	}
}

// SourceDb2EnterpriseUpdateNoTunnel - No ssh tunnel needed to connect to database
type SourceDb2EnterpriseUpdateNoTunnel struct {
	TunnelMethod         *SourceDb2EnterpriseUpdateTunnelMethod `default:"NO_TUNNEL" json:"tunnel_method"`
	AdditionalProperties any                                    `additionalProperties:"true" json:"-"`
}

func (s SourceDb2EnterpriseUpdateNoTunnel) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceDb2EnterpriseUpdateNoTunnel) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceDb2EnterpriseUpdateNoTunnel) GetTunnelMethod() *SourceDb2EnterpriseUpdateTunnelMethod {
	if s == nil {
		return nil
	}
	return s.TunnelMethod
}

func (s *SourceDb2EnterpriseUpdateNoTunnel) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceDb2EnterpriseUpdateSSHTunnelMethodType string

const (
	SourceDb2EnterpriseUpdateSSHTunnelMethodTypeSourceDb2EnterpriseUpdateNoTunnel               SourceDb2EnterpriseUpdateSSHTunnelMethodType = "source-db2-enterprise-update_No Tunnel"
	SourceDb2EnterpriseUpdateSSHTunnelMethodTypeSourceDb2EnterpriseUpdateSSHKeyAuthentication   SourceDb2EnterpriseUpdateSSHTunnelMethodType = "source-db2-enterprise-update_SSH Key Authentication"
	SourceDb2EnterpriseUpdateSSHTunnelMethodTypeSourceDb2EnterpriseUpdatePasswordAuthentication SourceDb2EnterpriseUpdateSSHTunnelMethodType = "source-db2-enterprise-update_Password Authentication"
)

// SourceDb2EnterpriseUpdateSSHTunnelMethod - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceDb2EnterpriseUpdateSSHTunnelMethod struct {
	SourceDb2EnterpriseUpdateNoTunnel               *SourceDb2EnterpriseUpdateNoTunnel               `queryParam:"inline" union:"member"`
	SourceDb2EnterpriseUpdateSSHKeyAuthentication   *SourceDb2EnterpriseUpdateSSHKeyAuthentication   `queryParam:"inline" union:"member"`
	SourceDb2EnterpriseUpdatePasswordAuthentication *SourceDb2EnterpriseUpdatePasswordAuthentication `queryParam:"inline" union:"member"`

	Type SourceDb2EnterpriseUpdateSSHTunnelMethodType
}

func CreateSourceDb2EnterpriseUpdateSSHTunnelMethodSourceDb2EnterpriseUpdateNoTunnel(sourceDb2EnterpriseUpdateNoTunnel SourceDb2EnterpriseUpdateNoTunnel) SourceDb2EnterpriseUpdateSSHTunnelMethod {
	typ := SourceDb2EnterpriseUpdateSSHTunnelMethodTypeSourceDb2EnterpriseUpdateNoTunnel

	return SourceDb2EnterpriseUpdateSSHTunnelMethod{
		SourceDb2EnterpriseUpdateNoTunnel: &sourceDb2EnterpriseUpdateNoTunnel,
		Type:                              typ,
	}
}

func CreateSourceDb2EnterpriseUpdateSSHTunnelMethodSourceDb2EnterpriseUpdateSSHKeyAuthentication(sourceDb2EnterpriseUpdateSSHKeyAuthentication SourceDb2EnterpriseUpdateSSHKeyAuthentication) SourceDb2EnterpriseUpdateSSHTunnelMethod {
	typ := SourceDb2EnterpriseUpdateSSHTunnelMethodTypeSourceDb2EnterpriseUpdateSSHKeyAuthentication

	return SourceDb2EnterpriseUpdateSSHTunnelMethod{
		SourceDb2EnterpriseUpdateSSHKeyAuthentication: &sourceDb2EnterpriseUpdateSSHKeyAuthentication,
		Type: typ,
	}
}

func CreateSourceDb2EnterpriseUpdateSSHTunnelMethodSourceDb2EnterpriseUpdatePasswordAuthentication(sourceDb2EnterpriseUpdatePasswordAuthentication SourceDb2EnterpriseUpdatePasswordAuthentication) SourceDb2EnterpriseUpdateSSHTunnelMethod {
	typ := SourceDb2EnterpriseUpdateSSHTunnelMethodTypeSourceDb2EnterpriseUpdatePasswordAuthentication

	return SourceDb2EnterpriseUpdateSSHTunnelMethod{
		SourceDb2EnterpriseUpdatePasswordAuthentication: &sourceDb2EnterpriseUpdatePasswordAuthentication,
		Type: typ,
	}
}

func (u *SourceDb2EnterpriseUpdateSSHTunnelMethod) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var sourceDb2EnterpriseUpdateNoTunnel SourceDb2EnterpriseUpdateNoTunnel = SourceDb2EnterpriseUpdateNoTunnel{}
	if err := utils.UnmarshalJSON(data, &sourceDb2EnterpriseUpdateNoTunnel, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceDb2EnterpriseUpdateSSHTunnelMethodTypeSourceDb2EnterpriseUpdateNoTunnel,
			Value: &sourceDb2EnterpriseUpdateNoTunnel,
		})
	}

	var sourceDb2EnterpriseUpdateSSHKeyAuthentication SourceDb2EnterpriseUpdateSSHKeyAuthentication = SourceDb2EnterpriseUpdateSSHKeyAuthentication{}
	if err := utils.UnmarshalJSON(data, &sourceDb2EnterpriseUpdateSSHKeyAuthentication, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceDb2EnterpriseUpdateSSHTunnelMethodTypeSourceDb2EnterpriseUpdateSSHKeyAuthentication,
			Value: &sourceDb2EnterpriseUpdateSSHKeyAuthentication,
		})
	}

	var sourceDb2EnterpriseUpdatePasswordAuthentication SourceDb2EnterpriseUpdatePasswordAuthentication = SourceDb2EnterpriseUpdatePasswordAuthentication{}
	if err := utils.UnmarshalJSON(data, &sourceDb2EnterpriseUpdatePasswordAuthentication, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceDb2EnterpriseUpdateSSHTunnelMethodTypeSourceDb2EnterpriseUpdatePasswordAuthentication,
			Value: &sourceDb2EnterpriseUpdatePasswordAuthentication,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceDb2EnterpriseUpdateSSHTunnelMethod", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceDb2EnterpriseUpdateSSHTunnelMethod", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceDb2EnterpriseUpdateSSHTunnelMethodType)
	switch best.Type {
	case SourceDb2EnterpriseUpdateSSHTunnelMethodTypeSourceDb2EnterpriseUpdateNoTunnel:
		u.SourceDb2EnterpriseUpdateNoTunnel = best.Value.(*SourceDb2EnterpriseUpdateNoTunnel)
		return nil
	case SourceDb2EnterpriseUpdateSSHTunnelMethodTypeSourceDb2EnterpriseUpdateSSHKeyAuthentication:
		u.SourceDb2EnterpriseUpdateSSHKeyAuthentication = best.Value.(*SourceDb2EnterpriseUpdateSSHKeyAuthentication)
		return nil
	case SourceDb2EnterpriseUpdateSSHTunnelMethodTypeSourceDb2EnterpriseUpdatePasswordAuthentication:
		u.SourceDb2EnterpriseUpdatePasswordAuthentication = best.Value.(*SourceDb2EnterpriseUpdatePasswordAuthentication)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceDb2EnterpriseUpdateSSHTunnelMethod", string(data))
}

func (u SourceDb2EnterpriseUpdateSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.SourceDb2EnterpriseUpdateNoTunnel != nil {
		return utils.MarshalJSON(u.SourceDb2EnterpriseUpdateNoTunnel, "", true)
	}

	if u.SourceDb2EnterpriseUpdateSSHKeyAuthentication != nil {
		return utils.MarshalJSON(u.SourceDb2EnterpriseUpdateSSHKeyAuthentication, "", true)
	}

	if u.SourceDb2EnterpriseUpdatePasswordAuthentication != nil {
		return utils.MarshalJSON(u.SourceDb2EnterpriseUpdatePasswordAuthentication, "", true)
	}

	return nil, errors.New("could not marshal union type SourceDb2EnterpriseUpdateSSHTunnelMethod: all fields are null")
}

type SourceDb2EnterpriseUpdateSourceType string

const (
	SourceDb2EnterpriseUpdateSourceTypeDb2Enterprise SourceDb2EnterpriseUpdateSourceType = "db2-enterprise"
)

func (e SourceDb2EnterpriseUpdateSourceType) ToPointer() *SourceDb2EnterpriseUpdateSourceType {
	return &e
}
func (e *SourceDb2EnterpriseUpdateSourceType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "db2-enterprise":
		*e = SourceDb2EnterpriseUpdateSourceType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceDb2EnterpriseUpdateSourceType: %v", v)
	}
}

type SourceDb2EnterpriseUpdate struct {
	// When this feature is enabled, during schema discovery the connector will query each table or view individually to check access privileges and inaccessible tables, views, or columns therein will be removed. In large schemas, this might cause schema discovery to take too long, in which case it might be advisable to disable this feature.
	CheckPrivileges *bool `default:"true" json:"check_privileges"`
	// How often (in seconds) a stream should checkpoint, when possible.
	CheckpointTargetIntervalSeconds *int64 `default:"300" json:"checkpoint_target_interval_seconds"`
	// Maximum number of concurrent queries to the database.
	Concurrency *int64 `default:"1" json:"concurrency"`
	// Configures how data is extracted from the database.
	Cursor *SourceDb2EnterpriseUpdateUpdateMethod `json:"cursor,omitempty"`
	// The database name.
	Database *string `json:"database,omitempty"`
	// The encryption method with is used when communicating with the database.
	Encryption *SourceDb2EnterpriseUpdateEncryption `json:"encryption,omitempty"`
	// Hostname of the database.
	Host *string `json:"host,omitempty"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// The password associated with the username.
	Password *string `json:"password,omitempty"`
	// Port of the database.
	Port *int64 `default:"50000" json:"port"`
	// The list of schemas to sync from.
	Schemas []string `json:"schemas,omitempty"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod *SourceDb2EnterpriseUpdateSSHTunnelMethod `json:"tunnel_method,omitempty"`
	// The username which is used to access the database.
	Username             *string                              `json:"username,omitempty"`
	sourceType           *SourceDb2EnterpriseUpdateSourceType `const:"db2-enterprise" json:"sourceType"`
	AdditionalProperties any                                  `additionalProperties:"true" json:"-"`
}

func (s SourceDb2EnterpriseUpdate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceDb2EnterpriseUpdate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceDb2EnterpriseUpdate) GetCheckPrivileges() *bool {
	if s == nil {
		return nil
	}
	return s.CheckPrivileges
}

func (s *SourceDb2EnterpriseUpdate) GetCheckpointTargetIntervalSeconds() *int64 {
	if s == nil {
		return nil
	}
	return s.CheckpointTargetIntervalSeconds
}

func (s *SourceDb2EnterpriseUpdate) GetConcurrency() *int64 {
	if s == nil {
		return nil
	}
	return s.Concurrency
}

func (s *SourceDb2EnterpriseUpdate) GetCursor() *SourceDb2EnterpriseUpdateUpdateMethod {
	if s == nil {
		return nil
	}
	return s.Cursor
}

func (s *SourceDb2EnterpriseUpdate) GetDatabase() *string {
	if s == nil {
		return nil
	}
	return s.Database
}

func (s *SourceDb2EnterpriseUpdate) GetEncryption() *SourceDb2EnterpriseUpdateEncryption {
	if s == nil {
		return nil
	}
	return s.Encryption
}

func (s *SourceDb2EnterpriseUpdate) GetHost() *string {
	if s == nil {
		return nil
	}
	return s.Host
}

func (s *SourceDb2EnterpriseUpdate) GetJdbcURLParams() *string {
	if s == nil {
		return nil
	}
	return s.JdbcURLParams
}

func (s *SourceDb2EnterpriseUpdate) GetPassword() *string {
	if s == nil {
		return nil
	}
	return s.Password
}

func (s *SourceDb2EnterpriseUpdate) GetPort() *int64 {
	if s == nil {
		return nil
	}
	return s.Port
}

func (s *SourceDb2EnterpriseUpdate) GetSchemas() []string {
	if s == nil {
		return nil
	}
	return s.Schemas
}

func (s *SourceDb2EnterpriseUpdate) GetTunnelMethod() *SourceDb2EnterpriseUpdateSSHTunnelMethod {
	if s == nil {
		return nil
	}
	return s.TunnelMethod
}

func (s *SourceDb2EnterpriseUpdate) GetUsername() *string {
	if s == nil {
		return nil
	}
	return s.Username
}

func (s *SourceDb2EnterpriseUpdate) GetSourceType() *SourceDb2EnterpriseUpdateSourceType {
	return SourceDb2EnterpriseUpdateSourceTypeDb2Enterprise.ToPointer()
}

func (s *SourceDb2EnterpriseUpdate) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}
