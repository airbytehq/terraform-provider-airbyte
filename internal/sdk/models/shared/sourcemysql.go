// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

// SourceMysqlInvalidCDCPositionBehaviorAdvanced - Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value in the mined logs. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss.
type SourceMysqlInvalidCDCPositionBehaviorAdvanced string

const (
	SourceMysqlInvalidCDCPositionBehaviorAdvancedFailSync   SourceMysqlInvalidCDCPositionBehaviorAdvanced = "Fail sync"
	SourceMysqlInvalidCDCPositionBehaviorAdvancedReSyncData SourceMysqlInvalidCDCPositionBehaviorAdvanced = "Re-sync data"
)

func (e SourceMysqlInvalidCDCPositionBehaviorAdvanced) ToPointer() *SourceMysqlInvalidCDCPositionBehaviorAdvanced {
	return &e
}
func (e *SourceMysqlInvalidCDCPositionBehaviorAdvanced) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Fail sync":
		fallthrough
	case "Re-sync data":
		*e = SourceMysqlInvalidCDCPositionBehaviorAdvanced(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlInvalidCDCPositionBehaviorAdvanced: %v", v)
	}
}

type SourceMysqlSchemasMethod string

const (
	SourceMysqlSchemasMethodCdc SourceMysqlSchemasMethod = "CDC"
)

func (e SourceMysqlSchemasMethod) ToPointer() *SourceMysqlSchemasMethod {
	return &e
}
func (e *SourceMysqlSchemasMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CDC":
		*e = SourceMysqlSchemasMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlSchemasMethod: %v", v)
	}
}

// SourceMysqlReadChangesUsingChangeDataCaptureCDC - <i>Recommended</i> - Incrementally reads new inserts, updates, and deletes using MySQL's <a href="https://docs.airbyte.com/integrations/sources/mssql/#change-data-capture-cdc"> change data capture feature</a>. This must be enabled on your database.
type SourceMysqlReadChangesUsingChangeDataCaptureCDC struct {
	// The amount of time an initial load is allowed to continue for before catching up on CDC logs.
	InitialLoadTimeoutHours *int64 `default:"8" json:"initial_load_timeout_hours"`
	// Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value in the mined logs. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss.
	InvalidCdcCursorPositionBehavior *SourceMysqlInvalidCDCPositionBehaviorAdvanced `default:"Fail sync" json:"invalid_cdc_cursor_position_behavior"`
	Method                           *SourceMysqlSchemasMethod                      `default:"CDC" json:"method"`
	// Enter the configured MySQL server timezone. This should only be done if the configured timezone in your MySQL instance does not conform to IANNA standard.
	ServerTimezone       *string `json:"server_timezone,omitempty"`
	AdditionalProperties any     `additionalProperties:"true" json:"-"`
}

func (s SourceMysqlReadChangesUsingChangeDataCaptureCDC) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMysqlReadChangesUsingChangeDataCaptureCDC) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceMysqlReadChangesUsingChangeDataCaptureCDC) GetInitialLoadTimeoutHours() *int64 {
	if s == nil {
		return nil
	}
	return s.InitialLoadTimeoutHours
}

func (s *SourceMysqlReadChangesUsingChangeDataCaptureCDC) GetInvalidCdcCursorPositionBehavior() *SourceMysqlInvalidCDCPositionBehaviorAdvanced {
	if s == nil {
		return nil
	}
	return s.InvalidCdcCursorPositionBehavior
}

func (s *SourceMysqlReadChangesUsingChangeDataCaptureCDC) GetMethod() *SourceMysqlSchemasMethod {
	if s == nil {
		return nil
	}
	return s.Method
}

func (s *SourceMysqlReadChangesUsingChangeDataCaptureCDC) GetServerTimezone() *string {
	if s == nil {
		return nil
	}
	return s.ServerTimezone
}

func (s *SourceMysqlReadChangesUsingChangeDataCaptureCDC) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceMysqlMethod string

const (
	SourceMysqlMethodStandard SourceMysqlMethod = "STANDARD"
)

func (e SourceMysqlMethod) ToPointer() *SourceMysqlMethod {
	return &e
}
func (e *SourceMysqlMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "STANDARD":
		*e = SourceMysqlMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlMethod: %v", v)
	}
}

// SourceMysqlScanChangesWithUserDefinedCursor - Incrementally detects new inserts and updates using the <a href="https://docs.airbyte.com/understanding-airbyte/connections/incremental-append/#user-defined-cursor">cursor column</a> chosen when configuring a connection (e.g. created_at, updated_at).
type SourceMysqlScanChangesWithUserDefinedCursor struct {
	Method               *SourceMysqlMethod `default:"STANDARD" json:"method"`
	AdditionalProperties any                `additionalProperties:"true" json:"-"`
}

func (s SourceMysqlScanChangesWithUserDefinedCursor) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMysqlScanChangesWithUserDefinedCursor) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceMysqlScanChangesWithUserDefinedCursor) GetMethod() *SourceMysqlMethod {
	if s == nil {
		return nil
	}
	return s.Method
}

func (s *SourceMysqlScanChangesWithUserDefinedCursor) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceMysqlUpdateMethodType string

const (
	SourceMysqlUpdateMethodTypeSourceMysqlScanChangesWithUserDefinedCursor     SourceMysqlUpdateMethodType = "source-mysql_Scan Changes with User Defined Cursor"
	SourceMysqlUpdateMethodTypeSourceMysqlReadChangesUsingChangeDataCaptureCDC SourceMysqlUpdateMethodType = "source-mysql_Read Changes using Change Data Capture (CDC)"
)

// SourceMysqlUpdateMethod - Configures how data is extracted from the database.
type SourceMysqlUpdateMethod struct {
	SourceMysqlScanChangesWithUserDefinedCursor     *SourceMysqlScanChangesWithUserDefinedCursor     `queryParam:"inline" union:"member"`
	SourceMysqlReadChangesUsingChangeDataCaptureCDC *SourceMysqlReadChangesUsingChangeDataCaptureCDC `queryParam:"inline" union:"member"`

	Type SourceMysqlUpdateMethodType
}

func CreateSourceMysqlUpdateMethodSourceMysqlScanChangesWithUserDefinedCursor(sourceMysqlScanChangesWithUserDefinedCursor SourceMysqlScanChangesWithUserDefinedCursor) SourceMysqlUpdateMethod {
	typ := SourceMysqlUpdateMethodTypeSourceMysqlScanChangesWithUserDefinedCursor

	return SourceMysqlUpdateMethod{
		SourceMysqlScanChangesWithUserDefinedCursor: &sourceMysqlScanChangesWithUserDefinedCursor,
		Type: typ,
	}
}

func CreateSourceMysqlUpdateMethodSourceMysqlReadChangesUsingChangeDataCaptureCDC(sourceMysqlReadChangesUsingChangeDataCaptureCDC SourceMysqlReadChangesUsingChangeDataCaptureCDC) SourceMysqlUpdateMethod {
	typ := SourceMysqlUpdateMethodTypeSourceMysqlReadChangesUsingChangeDataCaptureCDC

	return SourceMysqlUpdateMethod{
		SourceMysqlReadChangesUsingChangeDataCaptureCDC: &sourceMysqlReadChangesUsingChangeDataCaptureCDC,
		Type: typ,
	}
}

func (u *SourceMysqlUpdateMethod) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var sourceMysqlScanChangesWithUserDefinedCursor SourceMysqlScanChangesWithUserDefinedCursor = SourceMysqlScanChangesWithUserDefinedCursor{}
	if err := utils.UnmarshalJSON(data, &sourceMysqlScanChangesWithUserDefinedCursor, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceMysqlUpdateMethodTypeSourceMysqlScanChangesWithUserDefinedCursor,
			Value: &sourceMysqlScanChangesWithUserDefinedCursor,
		})
	}

	var sourceMysqlReadChangesUsingChangeDataCaptureCDC SourceMysqlReadChangesUsingChangeDataCaptureCDC = SourceMysqlReadChangesUsingChangeDataCaptureCDC{}
	if err := utils.UnmarshalJSON(data, &sourceMysqlReadChangesUsingChangeDataCaptureCDC, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceMysqlUpdateMethodTypeSourceMysqlReadChangesUsingChangeDataCaptureCDC,
			Value: &sourceMysqlReadChangesUsingChangeDataCaptureCDC,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMysqlUpdateMethod", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMysqlUpdateMethod", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceMysqlUpdateMethodType)
	switch best.Type {
	case SourceMysqlUpdateMethodTypeSourceMysqlScanChangesWithUserDefinedCursor:
		u.SourceMysqlScanChangesWithUserDefinedCursor = best.Value.(*SourceMysqlScanChangesWithUserDefinedCursor)
		return nil
	case SourceMysqlUpdateMethodTypeSourceMysqlReadChangesUsingChangeDataCaptureCDC:
		u.SourceMysqlReadChangesUsingChangeDataCaptureCDC = best.Value.(*SourceMysqlReadChangesUsingChangeDataCaptureCDC)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMysqlUpdateMethod", string(data))
}

func (u SourceMysqlUpdateMethod) MarshalJSON() ([]byte, error) {
	if u.SourceMysqlScanChangesWithUserDefinedCursor != nil {
		return utils.MarshalJSON(u.SourceMysqlScanChangesWithUserDefinedCursor, "", true)
	}

	if u.SourceMysqlReadChangesUsingChangeDataCaptureCDC != nil {
		return utils.MarshalJSON(u.SourceMysqlReadChangesUsingChangeDataCaptureCDC, "", true)
	}

	return nil, errors.New("could not marshal union type SourceMysqlUpdateMethod: all fields are null")
}

type SourceMysqlSchemasSslModeEncryptionMode string

const (
	SourceMysqlSchemasSslModeEncryptionModeVerifyIdentity SourceMysqlSchemasSslModeEncryptionMode = "verify_identity"
)

func (e SourceMysqlSchemasSslModeEncryptionMode) ToPointer() *SourceMysqlSchemasSslModeEncryptionMode {
	return &e
}
func (e *SourceMysqlSchemasSslModeEncryptionMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "verify_identity":
		*e = SourceMysqlSchemasSslModeEncryptionMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlSchemasSslModeEncryptionMode: %v", v)
	}
}

// VerifyIdentity - To always require encryption and verify that the source has a valid SSL certificate.
type VerifyIdentity struct {
	// CA certificate
	CaCertificate string `json:"ca_certificate"`
	// Client certificate (this is not a required field, but if you want to use it, you will need to add the Client key as well)
	ClientCertificate *string `json:"client_certificate,omitempty"`
	// Client key (this is not a required field, but if you want to use it, you will need to add the Client certificate as well)
	ClientKey *string `json:"client_key,omitempty"`
	// Password for keystorage. This field is optional. If you do not add it - the password will be generated automatically.
	ClientKeyPassword    *string                                  `json:"client_key_password,omitempty"`
	Mode                 *SourceMysqlSchemasSslModeEncryptionMode `default:"verify_identity" json:"mode"`
	AdditionalProperties any                                      `additionalProperties:"true" json:"-"`
}

func (v VerifyIdentity) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(v, "", false)
}

func (v *VerifyIdentity) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &v, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (v *VerifyIdentity) GetCaCertificate() string {
	if v == nil {
		return ""
	}
	return v.CaCertificate
}

func (v *VerifyIdentity) GetClientCertificate() *string {
	if v == nil {
		return nil
	}
	return v.ClientCertificate
}

func (v *VerifyIdentity) GetClientKey() *string {
	if v == nil {
		return nil
	}
	return v.ClientKey
}

func (v *VerifyIdentity) GetClientKeyPassword() *string {
	if v == nil {
		return nil
	}
	return v.ClientKeyPassword
}

func (v *VerifyIdentity) GetMode() *SourceMysqlSchemasSslModeEncryptionMode {
	if v == nil {
		return nil
	}
	return v.Mode
}

func (v *VerifyIdentity) GetAdditionalProperties() any {
	if v == nil {
		return nil
	}
	return v.AdditionalProperties
}

type SourceMysqlSchemasSslModeMode string

const (
	SourceMysqlSchemasSslModeModeVerifyCa SourceMysqlSchemasSslModeMode = "verify_ca"
)

func (e SourceMysqlSchemasSslModeMode) ToPointer() *SourceMysqlSchemasSslModeMode {
	return &e
}
func (e *SourceMysqlSchemasSslModeMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "verify_ca":
		*e = SourceMysqlSchemasSslModeMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlSchemasSslModeMode: %v", v)
	}
}

// VerifyCa - To always require encryption and verify that the source has a valid SSL certificate.
type VerifyCa struct {
	// CA certificate
	CaCertificate string `json:"ca_certificate"`
	// Client certificate (this is not a required field, but if you want to use it, you will need to add the Client key as well)
	ClientCertificate *string `json:"client_certificate,omitempty"`
	// Client key (this is not a required field, but if you want to use it, you will need to add the Client certificate as well)
	ClientKey *string `json:"client_key,omitempty"`
	// Password for keystorage. This field is optional. If you do not add it - the password will be generated automatically.
	ClientKeyPassword    *string                        `json:"client_key_password,omitempty"`
	Mode                 *SourceMysqlSchemasSslModeMode `default:"verify_ca" json:"mode"`
	AdditionalProperties any                            `additionalProperties:"true" json:"-"`
}

func (v VerifyCa) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(v, "", false)
}

func (v *VerifyCa) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &v, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (v *VerifyCa) GetCaCertificate() string {
	if v == nil {
		return ""
	}
	return v.CaCertificate
}

func (v *VerifyCa) GetClientCertificate() *string {
	if v == nil {
		return nil
	}
	return v.ClientCertificate
}

func (v *VerifyCa) GetClientKey() *string {
	if v == nil {
		return nil
	}
	return v.ClientKey
}

func (v *VerifyCa) GetClientKeyPassword() *string {
	if v == nil {
		return nil
	}
	return v.ClientKeyPassword
}

func (v *VerifyCa) GetMode() *SourceMysqlSchemasSslModeMode {
	if v == nil {
		return nil
	}
	return v.Mode
}

func (v *VerifyCa) GetAdditionalProperties() any {
	if v == nil {
		return nil
	}
	return v.AdditionalProperties
}

type SourceMysqlSchemasMode string

const (
	SourceMysqlSchemasModeRequired SourceMysqlSchemasMode = "required"
)

func (e SourceMysqlSchemasMode) ToPointer() *SourceMysqlSchemasMode {
	return &e
}
func (e *SourceMysqlSchemasMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "required":
		*e = SourceMysqlSchemasMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlSchemasMode: %v", v)
	}
}

// Required - To always require encryption. Note: The connection will fail if the source doesn't support encryption.
type Required struct {
	Mode                 *SourceMysqlSchemasMode `default:"required" json:"mode"`
	AdditionalProperties any                     `additionalProperties:"true" json:"-"`
}

func (r Required) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(r, "", false)
}

func (r *Required) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &r, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (r *Required) GetMode() *SourceMysqlSchemasMode {
	if r == nil {
		return nil
	}
	return r.Mode
}

func (r *Required) GetAdditionalProperties() any {
	if r == nil {
		return nil
	}
	return r.AdditionalProperties
}

type SourceMysqlMode string

const (
	SourceMysqlModePreferred SourceMysqlMode = "preferred"
)

func (e SourceMysqlMode) ToPointer() *SourceMysqlMode {
	return &e
}
func (e *SourceMysqlMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "preferred":
		*e = SourceMysqlMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlMode: %v", v)
	}
}

// Preferred - To allow unencrypted communication only when the source doesn't support encryption.
type Preferred struct {
	Mode                 *SourceMysqlMode `default:"preferred" json:"mode"`
	AdditionalProperties any              `additionalProperties:"true" json:"-"`
}

func (p Preferred) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *Preferred) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (p *Preferred) GetMode() *SourceMysqlMode {
	if p == nil {
		return nil
	}
	return p.Mode
}

func (p *Preferred) GetAdditionalProperties() any {
	if p == nil {
		return nil
	}
	return p.AdditionalProperties
}

type SourceMysqlEncryptionType string

const (
	SourceMysqlEncryptionTypePreferred      SourceMysqlEncryptionType = "preferred"
	SourceMysqlEncryptionTypeRequired       SourceMysqlEncryptionType = "required"
	SourceMysqlEncryptionTypeVerifyCa       SourceMysqlEncryptionType = "verify_ca"
	SourceMysqlEncryptionTypeVerifyIdentity SourceMysqlEncryptionType = "verify_identity"
)

// SourceMysqlEncryption - The encryption method which is used when communicating with the database.
type SourceMysqlEncryption struct {
	Preferred      *Preferred      `queryParam:"inline" union:"member"`
	Required       *Required       `queryParam:"inline" union:"member"`
	VerifyCa       *VerifyCa       `queryParam:"inline" union:"member"`
	VerifyIdentity *VerifyIdentity `queryParam:"inline" union:"member"`

	Type SourceMysqlEncryptionType
}

func CreateSourceMysqlEncryptionPreferred(preferred Preferred) SourceMysqlEncryption {
	typ := SourceMysqlEncryptionTypePreferred

	return SourceMysqlEncryption{
		Preferred: &preferred,
		Type:      typ,
	}
}

func CreateSourceMysqlEncryptionRequired(required Required) SourceMysqlEncryption {
	typ := SourceMysqlEncryptionTypeRequired

	return SourceMysqlEncryption{
		Required: &required,
		Type:     typ,
	}
}

func CreateSourceMysqlEncryptionVerifyCa(verifyCa VerifyCa) SourceMysqlEncryption {
	typ := SourceMysqlEncryptionTypeVerifyCa

	return SourceMysqlEncryption{
		VerifyCa: &verifyCa,
		Type:     typ,
	}
}

func CreateSourceMysqlEncryptionVerifyIdentity(verifyIdentity VerifyIdentity) SourceMysqlEncryption {
	typ := SourceMysqlEncryptionTypeVerifyIdentity

	return SourceMysqlEncryption{
		VerifyIdentity: &verifyIdentity,
		Type:           typ,
	}
}

func (u *SourceMysqlEncryption) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var preferred Preferred = Preferred{}
	if err := utils.UnmarshalJSON(data, &preferred, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceMysqlEncryptionTypePreferred,
			Value: &preferred,
		})
	}

	var required Required = Required{}
	if err := utils.UnmarshalJSON(data, &required, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceMysqlEncryptionTypeRequired,
			Value: &required,
		})
	}

	var verifyCa VerifyCa = VerifyCa{}
	if err := utils.UnmarshalJSON(data, &verifyCa, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceMysqlEncryptionTypeVerifyCa,
			Value: &verifyCa,
		})
	}

	var verifyIdentity VerifyIdentity = VerifyIdentity{}
	if err := utils.UnmarshalJSON(data, &verifyIdentity, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceMysqlEncryptionTypeVerifyIdentity,
			Value: &verifyIdentity,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMysqlEncryption", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMysqlEncryption", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceMysqlEncryptionType)
	switch best.Type {
	case SourceMysqlEncryptionTypePreferred:
		u.Preferred = best.Value.(*Preferred)
		return nil
	case SourceMysqlEncryptionTypeRequired:
		u.Required = best.Value.(*Required)
		return nil
	case SourceMysqlEncryptionTypeVerifyCa:
		u.VerifyCa = best.Value.(*VerifyCa)
		return nil
	case SourceMysqlEncryptionTypeVerifyIdentity:
		u.VerifyIdentity = best.Value.(*VerifyIdentity)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMysqlEncryption", string(data))
}

func (u SourceMysqlEncryption) MarshalJSON() ([]byte, error) {
	if u.Preferred != nil {
		return utils.MarshalJSON(u.Preferred, "", true)
	}

	if u.Required != nil {
		return utils.MarshalJSON(u.Required, "", true)
	}

	if u.VerifyCa != nil {
		return utils.MarshalJSON(u.VerifyCa, "", true)
	}

	if u.VerifyIdentity != nil {
		return utils.MarshalJSON(u.VerifyIdentity, "", true)
	}

	return nil, errors.New("could not marshal union type SourceMysqlEncryption: all fields are null")
}

// TableFilter - Inclusion filter configuration for table selection per database.
type TableFilter struct {
	// The name of the database to apply this filter to. Should match the database defined in the "Database" field above.
	DatabaseName string `json:"database_name"`
	// List of table name patterns to include. Should be a SQL LIKE pattern.
	TableNamePatterns    []string `json:"table_name_patterns"`
	AdditionalProperties any      `additionalProperties:"true" json:"-"`
}

func (t TableFilter) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(t, "", false)
}

func (t *TableFilter) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &t, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (t *TableFilter) GetDatabaseName() string {
	if t == nil {
		return ""
	}
	return t.DatabaseName
}

func (t *TableFilter) GetTableNamePatterns() []string {
	if t == nil {
		return []string{}
	}
	return t.TableNamePatterns
}

func (t *TableFilter) GetAdditionalProperties() any {
	if t == nil {
		return nil
	}
	return t.AdditionalProperties
}

type SourceMysqlSchemasTunnelMethodTunnelMethod string

const (
	SourceMysqlSchemasTunnelMethodTunnelMethodSSHPasswordAuth SourceMysqlSchemasTunnelMethodTunnelMethod = "SSH_PASSWORD_AUTH"
)

func (e SourceMysqlSchemasTunnelMethodTunnelMethod) ToPointer() *SourceMysqlSchemasTunnelMethodTunnelMethod {
	return &e
}
func (e *SourceMysqlSchemasTunnelMethodTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_PASSWORD_AUTH":
		*e = SourceMysqlSchemasTunnelMethodTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlSchemasTunnelMethodTunnelMethod: %v", v)
	}
}

// SourceMysqlPasswordAuthentication - Connect through a jump server tunnel host using username and password authentication
type SourceMysqlPasswordAuthentication struct {
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost   string                                      `json:"tunnel_host"`
	TunnelMethod *SourceMysqlSchemasTunnelMethodTunnelMethod `default:"SSH_PASSWORD_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser string `json:"tunnel_user"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword   string `json:"tunnel_user_password"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (s SourceMysqlPasswordAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMysqlPasswordAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceMysqlPasswordAuthentication) GetTunnelHost() string {
	if s == nil {
		return ""
	}
	return s.TunnelHost
}

func (s *SourceMysqlPasswordAuthentication) GetTunnelMethod() *SourceMysqlSchemasTunnelMethodTunnelMethod {
	if s == nil {
		return nil
	}
	return s.TunnelMethod
}

func (s *SourceMysqlPasswordAuthentication) GetTunnelPort() *int64 {
	if s == nil {
		return nil
	}
	return s.TunnelPort
}

func (s *SourceMysqlPasswordAuthentication) GetTunnelUser() string {
	if s == nil {
		return ""
	}
	return s.TunnelUser
}

func (s *SourceMysqlPasswordAuthentication) GetTunnelUserPassword() string {
	if s == nil {
		return ""
	}
	return s.TunnelUserPassword
}

func (s *SourceMysqlPasswordAuthentication) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceMysqlSchemasTunnelMethod string

const (
	SourceMysqlSchemasTunnelMethodSSHKeyAuth SourceMysqlSchemasTunnelMethod = "SSH_KEY_AUTH"
)

func (e SourceMysqlSchemasTunnelMethod) ToPointer() *SourceMysqlSchemasTunnelMethod {
	return &e
}
func (e *SourceMysqlSchemasTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_KEY_AUTH":
		*e = SourceMysqlSchemasTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlSchemasTunnelMethod: %v", v)
	}
}

// SourceMysqlSSHKeyAuthentication - Connect through a jump server tunnel host using username and ssh key
type SourceMysqlSSHKeyAuthentication struct {
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey string `json:"ssh_key"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost   string                          `json:"tunnel_host"`
	TunnelMethod *SourceMysqlSchemasTunnelMethod `default:"SSH_KEY_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser           string `json:"tunnel_user"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (s SourceMysqlSSHKeyAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMysqlSSHKeyAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceMysqlSSHKeyAuthentication) GetSSHKey() string {
	if s == nil {
		return ""
	}
	return s.SSHKey
}

func (s *SourceMysqlSSHKeyAuthentication) GetTunnelHost() string {
	if s == nil {
		return ""
	}
	return s.TunnelHost
}

func (s *SourceMysqlSSHKeyAuthentication) GetTunnelMethod() *SourceMysqlSchemasTunnelMethod {
	if s == nil {
		return nil
	}
	return s.TunnelMethod
}

func (s *SourceMysqlSSHKeyAuthentication) GetTunnelPort() *int64 {
	if s == nil {
		return nil
	}
	return s.TunnelPort
}

func (s *SourceMysqlSSHKeyAuthentication) GetTunnelUser() string {
	if s == nil {
		return ""
	}
	return s.TunnelUser
}

func (s *SourceMysqlSSHKeyAuthentication) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceMysqlTunnelMethod string

const (
	SourceMysqlTunnelMethodNoTunnel SourceMysqlTunnelMethod = "NO_TUNNEL"
)

func (e SourceMysqlTunnelMethod) ToPointer() *SourceMysqlTunnelMethod {
	return &e
}
func (e *SourceMysqlTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NO_TUNNEL":
		*e = SourceMysqlTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlTunnelMethod: %v", v)
	}
}

// SourceMysqlNoTunnel - No ssh tunnel needed to connect to database
type SourceMysqlNoTunnel struct {
	TunnelMethod         *SourceMysqlTunnelMethod `default:"NO_TUNNEL" json:"tunnel_method"`
	AdditionalProperties any                      `additionalProperties:"true" json:"-"`
}

func (s SourceMysqlNoTunnel) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMysqlNoTunnel) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceMysqlNoTunnel) GetTunnelMethod() *SourceMysqlTunnelMethod {
	if s == nil {
		return nil
	}
	return s.TunnelMethod
}

func (s *SourceMysqlNoTunnel) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceMysqlSSHTunnelMethodType string

const (
	SourceMysqlSSHTunnelMethodTypeSourceMysqlNoTunnel               SourceMysqlSSHTunnelMethodType = "source-mysql_No Tunnel"
	SourceMysqlSSHTunnelMethodTypeSourceMysqlSSHKeyAuthentication   SourceMysqlSSHTunnelMethodType = "source-mysql_SSH Key Authentication"
	SourceMysqlSSHTunnelMethodTypeSourceMysqlPasswordAuthentication SourceMysqlSSHTunnelMethodType = "source-mysql_Password Authentication"
)

// SourceMysqlSSHTunnelMethod - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceMysqlSSHTunnelMethod struct {
	SourceMysqlNoTunnel               *SourceMysqlNoTunnel               `queryParam:"inline" union:"member"`
	SourceMysqlSSHKeyAuthentication   *SourceMysqlSSHKeyAuthentication   `queryParam:"inline" union:"member"`
	SourceMysqlPasswordAuthentication *SourceMysqlPasswordAuthentication `queryParam:"inline" union:"member"`

	Type SourceMysqlSSHTunnelMethodType
}

func CreateSourceMysqlSSHTunnelMethodSourceMysqlNoTunnel(sourceMysqlNoTunnel SourceMysqlNoTunnel) SourceMysqlSSHTunnelMethod {
	typ := SourceMysqlSSHTunnelMethodTypeSourceMysqlNoTunnel

	return SourceMysqlSSHTunnelMethod{
		SourceMysqlNoTunnel: &sourceMysqlNoTunnel,
		Type:                typ,
	}
}

func CreateSourceMysqlSSHTunnelMethodSourceMysqlSSHKeyAuthentication(sourceMysqlSSHKeyAuthentication SourceMysqlSSHKeyAuthentication) SourceMysqlSSHTunnelMethod {
	typ := SourceMysqlSSHTunnelMethodTypeSourceMysqlSSHKeyAuthentication

	return SourceMysqlSSHTunnelMethod{
		SourceMysqlSSHKeyAuthentication: &sourceMysqlSSHKeyAuthentication,
		Type:                            typ,
	}
}

func CreateSourceMysqlSSHTunnelMethodSourceMysqlPasswordAuthentication(sourceMysqlPasswordAuthentication SourceMysqlPasswordAuthentication) SourceMysqlSSHTunnelMethod {
	typ := SourceMysqlSSHTunnelMethodTypeSourceMysqlPasswordAuthentication

	return SourceMysqlSSHTunnelMethod{
		SourceMysqlPasswordAuthentication: &sourceMysqlPasswordAuthentication,
		Type:                              typ,
	}
}

func (u *SourceMysqlSSHTunnelMethod) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var sourceMysqlNoTunnel SourceMysqlNoTunnel = SourceMysqlNoTunnel{}
	if err := utils.UnmarshalJSON(data, &sourceMysqlNoTunnel, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceMysqlSSHTunnelMethodTypeSourceMysqlNoTunnel,
			Value: &sourceMysqlNoTunnel,
		})
	}

	var sourceMysqlSSHKeyAuthentication SourceMysqlSSHKeyAuthentication = SourceMysqlSSHKeyAuthentication{}
	if err := utils.UnmarshalJSON(data, &sourceMysqlSSHKeyAuthentication, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceMysqlSSHTunnelMethodTypeSourceMysqlSSHKeyAuthentication,
			Value: &sourceMysqlSSHKeyAuthentication,
		})
	}

	var sourceMysqlPasswordAuthentication SourceMysqlPasswordAuthentication = SourceMysqlPasswordAuthentication{}
	if err := utils.UnmarshalJSON(data, &sourceMysqlPasswordAuthentication, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceMysqlSSHTunnelMethodTypeSourceMysqlPasswordAuthentication,
			Value: &sourceMysqlPasswordAuthentication,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMysqlSSHTunnelMethod", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMysqlSSHTunnelMethod", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceMysqlSSHTunnelMethodType)
	switch best.Type {
	case SourceMysqlSSHTunnelMethodTypeSourceMysqlNoTunnel:
		u.SourceMysqlNoTunnel = best.Value.(*SourceMysqlNoTunnel)
		return nil
	case SourceMysqlSSHTunnelMethodTypeSourceMysqlSSHKeyAuthentication:
		u.SourceMysqlSSHKeyAuthentication = best.Value.(*SourceMysqlSSHKeyAuthentication)
		return nil
	case SourceMysqlSSHTunnelMethodTypeSourceMysqlPasswordAuthentication:
		u.SourceMysqlPasswordAuthentication = best.Value.(*SourceMysqlPasswordAuthentication)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMysqlSSHTunnelMethod", string(data))
}

func (u SourceMysqlSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.SourceMysqlNoTunnel != nil {
		return utils.MarshalJSON(u.SourceMysqlNoTunnel, "", true)
	}

	if u.SourceMysqlSSHKeyAuthentication != nil {
		return utils.MarshalJSON(u.SourceMysqlSSHKeyAuthentication, "", true)
	}

	if u.SourceMysqlPasswordAuthentication != nil {
		return utils.MarshalJSON(u.SourceMysqlPasswordAuthentication, "", true)
	}

	return nil, errors.New("could not marshal union type SourceMysqlSSHTunnelMethod: all fields are null")
}

type SourceMysqlSourceType string

const (
	SourceMysqlSourceTypeMysql SourceMysqlSourceType = "mysql"
)

func (e SourceMysqlSourceType) ToPointer() *SourceMysqlSourceType {
	return &e
}
func (e *SourceMysqlSourceType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "mysql":
		*e = SourceMysqlSourceType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlSourceType: %v", v)
	}
}

type SourceMysql struct {
	// When this feature is enabled, during schema discovery the connector will query each table or view individually to check access privileges and inaccessible tables, views, or columns therein will be removed. In large schemas, this might cause schema discovery to take too long, in which case it might be advisable to disable this feature.
	CheckPrivileges *bool `default:"true" json:"check_privileges"`
	// How often (in seconds) a stream should checkpoint, when possible.
	CheckpointTargetIntervalSeconds *int64 `default:"300" json:"checkpoint_target_interval_seconds"`
	// Maximum number of concurrent queries to the database.
	Concurrency *int64 `default:"1" json:"concurrency"`
	// The database name.
	Database string `json:"database"`
	// Hostname of the database.
	Host string `json:"host"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// Maximum number of concurrent queries to the database. Leave empty to let Airbyte optimize performance.
	MaxDbConnections *int64 `json:"max_db_connections,omitempty"`
	// The password associated with the username.
	Password *string `json:"password,omitempty"`
	// Port of the database.
	Port *int64 `default:"3306" json:"port"`
	// Configures how data is extracted from the database.
	ReplicationMethod SourceMysqlUpdateMethod `json:"replication_method"`
	// The encryption method which is used when communicating with the database.
	SslMode *SourceMysqlEncryption `json:"ssl_mode,omitempty"`
	// Optional filters to include only specific tables from the specified database.
	TableFilters []TableFilter `json:"table_filters,omitempty"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod *SourceMysqlSSHTunnelMethod `json:"tunnel_method,omitempty"`
	// The username which is used to access the database.
	Username             string                 `json:"username"`
	sourceType           *SourceMysqlSourceType `const:"mysql" json:"sourceType"`
	AdditionalProperties any                    `additionalProperties:"true" json:"-"`
}

func (s SourceMysql) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMysql) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceMysql) GetCheckPrivileges() *bool {
	if s == nil {
		return nil
	}
	return s.CheckPrivileges
}

func (s *SourceMysql) GetCheckpointTargetIntervalSeconds() *int64 {
	if s == nil {
		return nil
	}
	return s.CheckpointTargetIntervalSeconds
}

func (s *SourceMysql) GetConcurrency() *int64 {
	if s == nil {
		return nil
	}
	return s.Concurrency
}

func (s *SourceMysql) GetDatabase() string {
	if s == nil {
		return ""
	}
	return s.Database
}

func (s *SourceMysql) GetHost() string {
	if s == nil {
		return ""
	}
	return s.Host
}

func (s *SourceMysql) GetJdbcURLParams() *string {
	if s == nil {
		return nil
	}
	return s.JdbcURLParams
}

func (s *SourceMysql) GetMaxDbConnections() *int64 {
	if s == nil {
		return nil
	}
	return s.MaxDbConnections
}

func (s *SourceMysql) GetPassword() *string {
	if s == nil {
		return nil
	}
	return s.Password
}

func (s *SourceMysql) GetPort() *int64 {
	if s == nil {
		return nil
	}
	return s.Port
}

func (s *SourceMysql) GetReplicationMethod() SourceMysqlUpdateMethod {
	if s == nil {
		return SourceMysqlUpdateMethod{}
	}
	return s.ReplicationMethod
}

func (s *SourceMysql) GetSslMode() *SourceMysqlEncryption {
	if s == nil {
		return nil
	}
	return s.SslMode
}

func (s *SourceMysql) GetTableFilters() []TableFilter {
	if s == nil {
		return nil
	}
	return s.TableFilters
}

func (s *SourceMysql) GetTunnelMethod() *SourceMysqlSSHTunnelMethod {
	if s == nil {
		return nil
	}
	return s.TunnelMethod
}

func (s *SourceMysql) GetUsername() string {
	if s == nil {
		return ""
	}
	return s.Username
}

func (s *SourceMysql) GetSourceType() *SourceMysqlSourceType {
	return SourceMysqlSourceTypeMysql.ToPointer()
}

func (s *SourceMysql) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}
