// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

// SourceMysqlInvalidCDCPositionBehaviorAdvanced - Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value in the mined logs. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss.
type SourceMysqlInvalidCDCPositionBehaviorAdvanced string

const (
	SourceMysqlInvalidCDCPositionBehaviorAdvancedFailSync   SourceMysqlInvalidCDCPositionBehaviorAdvanced = "Fail sync"
	SourceMysqlInvalidCDCPositionBehaviorAdvancedReSyncData SourceMysqlInvalidCDCPositionBehaviorAdvanced = "Re-sync data"
)

func (e SourceMysqlInvalidCDCPositionBehaviorAdvanced) ToPointer() *SourceMysqlInvalidCDCPositionBehaviorAdvanced {
	return &e
}
func (e *SourceMysqlInvalidCDCPositionBehaviorAdvanced) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Fail sync":
		fallthrough
	case "Re-sync data":
		*e = SourceMysqlInvalidCDCPositionBehaviorAdvanced(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlInvalidCDCPositionBehaviorAdvanced: %v", v)
	}
}

type SourceMysqlSchemasMethod string

const (
	SourceMysqlSchemasMethodCdc SourceMysqlSchemasMethod = "CDC"
)

func (e SourceMysqlSchemasMethod) ToPointer() *SourceMysqlSchemasMethod {
	return &e
}
func (e *SourceMysqlSchemasMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CDC":
		*e = SourceMysqlSchemasMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlSchemasMethod: %v", v)
	}
}

// SourceMysqlReadChangesUsingChangeDataCaptureCDC - <i>Recommended</i> - Incrementally reads new inserts, updates, and deletes using MySQL's <a href="https://docs.airbyte.com/integrations/sources/mssql/#change-data-capture-cdc"> change data capture feature</a>. This must be enabled on your database.
type SourceMysqlReadChangesUsingChangeDataCaptureCDC struct {
	// The amount of time an initial load is allowed to continue for before catching up on CDC logs.
	InitialLoadTimeoutHours *int64 `default:"8" json:"initial_load_timeout_hours"`
	// Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value in the mined logs. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss.
	InvalidCdcCursorPositionBehavior *SourceMysqlInvalidCDCPositionBehaviorAdvanced `default:"Fail sync" json:"invalid_cdc_cursor_position_behavior"`
	Method                           *SourceMysqlSchemasMethod                      `default:"CDC" json:"method"`
	// Enter the configured MySQL server timezone. This should only be done if the configured timezone in your MySQL instance does not conform to IANNA standard.
	ServerTimezone       *string `json:"server_timezone,omitempty"`
	AdditionalProperties any     `additionalProperties:"true" json:"-"`
}

func (s SourceMysqlReadChangesUsingChangeDataCaptureCDC) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMysqlReadChangesUsingChangeDataCaptureCDC) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceMysqlReadChangesUsingChangeDataCaptureCDC) GetInitialLoadTimeoutHours() *int64 {
	if o == nil {
		return nil
	}
	return o.InitialLoadTimeoutHours
}

func (o *SourceMysqlReadChangesUsingChangeDataCaptureCDC) GetInvalidCdcCursorPositionBehavior() *SourceMysqlInvalidCDCPositionBehaviorAdvanced {
	if o == nil {
		return nil
	}
	return o.InvalidCdcCursorPositionBehavior
}

func (o *SourceMysqlReadChangesUsingChangeDataCaptureCDC) GetMethod() *SourceMysqlSchemasMethod {
	if o == nil {
		return nil
	}
	return o.Method
}

func (o *SourceMysqlReadChangesUsingChangeDataCaptureCDC) GetServerTimezone() *string {
	if o == nil {
		return nil
	}
	return o.ServerTimezone
}

func (o *SourceMysqlReadChangesUsingChangeDataCaptureCDC) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

type SourceMysqlMethod string

const (
	SourceMysqlMethodStandard SourceMysqlMethod = "STANDARD"
)

func (e SourceMysqlMethod) ToPointer() *SourceMysqlMethod {
	return &e
}
func (e *SourceMysqlMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "STANDARD":
		*e = SourceMysqlMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlMethod: %v", v)
	}
}

// SourceMysqlScanChangesWithUserDefinedCursor - Incrementally detects new inserts and updates using the <a href="https://docs.airbyte.com/understanding-airbyte/connections/incremental-append/#user-defined-cursor">cursor column</a> chosen when configuring a connection (e.g. created_at, updated_at).
type SourceMysqlScanChangesWithUserDefinedCursor struct {
	Method               *SourceMysqlMethod `default:"STANDARD" json:"method"`
	AdditionalProperties any                `additionalProperties:"true" json:"-"`
}

func (s SourceMysqlScanChangesWithUserDefinedCursor) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMysqlScanChangesWithUserDefinedCursor) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceMysqlScanChangesWithUserDefinedCursor) GetMethod() *SourceMysqlMethod {
	if o == nil {
		return nil
	}
	return o.Method
}

func (o *SourceMysqlScanChangesWithUserDefinedCursor) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

type SourceMysqlUpdateMethodType string

const (
	SourceMysqlUpdateMethodTypeSourceMysqlScanChangesWithUserDefinedCursor     SourceMysqlUpdateMethodType = "source-mysql_Scan Changes with User Defined Cursor"
	SourceMysqlUpdateMethodTypeSourceMysqlReadChangesUsingChangeDataCaptureCDC SourceMysqlUpdateMethodType = "source-mysql_Read Changes using Change Data Capture (CDC)"
)

// SourceMysqlUpdateMethod - Configures how data is extracted from the database.
type SourceMysqlUpdateMethod struct {
	SourceMysqlScanChangesWithUserDefinedCursor     *SourceMysqlScanChangesWithUserDefinedCursor     `queryParam:"inline"`
	SourceMysqlReadChangesUsingChangeDataCaptureCDC *SourceMysqlReadChangesUsingChangeDataCaptureCDC `queryParam:"inline"`

	Type SourceMysqlUpdateMethodType
}

func CreateSourceMysqlUpdateMethodSourceMysqlScanChangesWithUserDefinedCursor(sourceMysqlScanChangesWithUserDefinedCursor SourceMysqlScanChangesWithUserDefinedCursor) SourceMysqlUpdateMethod {
	typ := SourceMysqlUpdateMethodTypeSourceMysqlScanChangesWithUserDefinedCursor

	return SourceMysqlUpdateMethod{
		SourceMysqlScanChangesWithUserDefinedCursor: &sourceMysqlScanChangesWithUserDefinedCursor,
		Type: typ,
	}
}

func CreateSourceMysqlUpdateMethodSourceMysqlReadChangesUsingChangeDataCaptureCDC(sourceMysqlReadChangesUsingChangeDataCaptureCDC SourceMysqlReadChangesUsingChangeDataCaptureCDC) SourceMysqlUpdateMethod {
	typ := SourceMysqlUpdateMethodTypeSourceMysqlReadChangesUsingChangeDataCaptureCDC

	return SourceMysqlUpdateMethod{
		SourceMysqlReadChangesUsingChangeDataCaptureCDC: &sourceMysqlReadChangesUsingChangeDataCaptureCDC,
		Type: typ,
	}
}

func (u *SourceMysqlUpdateMethod) UnmarshalJSON(data []byte) error {

	var sourceMysqlScanChangesWithUserDefinedCursor SourceMysqlScanChangesWithUserDefinedCursor = SourceMysqlScanChangesWithUserDefinedCursor{}
	if err := utils.UnmarshalJSON(data, &sourceMysqlScanChangesWithUserDefinedCursor, "", true, true); err == nil {
		u.SourceMysqlScanChangesWithUserDefinedCursor = &sourceMysqlScanChangesWithUserDefinedCursor
		u.Type = SourceMysqlUpdateMethodTypeSourceMysqlScanChangesWithUserDefinedCursor
		return nil
	}

	var sourceMysqlReadChangesUsingChangeDataCaptureCDC SourceMysqlReadChangesUsingChangeDataCaptureCDC = SourceMysqlReadChangesUsingChangeDataCaptureCDC{}
	if err := utils.UnmarshalJSON(data, &sourceMysqlReadChangesUsingChangeDataCaptureCDC, "", true, true); err == nil {
		u.SourceMysqlReadChangesUsingChangeDataCaptureCDC = &sourceMysqlReadChangesUsingChangeDataCaptureCDC
		u.Type = SourceMysqlUpdateMethodTypeSourceMysqlReadChangesUsingChangeDataCaptureCDC
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMysqlUpdateMethod", string(data))
}

func (u SourceMysqlUpdateMethod) MarshalJSON() ([]byte, error) {
	if u.SourceMysqlScanChangesWithUserDefinedCursor != nil {
		return utils.MarshalJSON(u.SourceMysqlScanChangesWithUserDefinedCursor, "", true)
	}

	if u.SourceMysqlReadChangesUsingChangeDataCaptureCDC != nil {
		return utils.MarshalJSON(u.SourceMysqlReadChangesUsingChangeDataCaptureCDC, "", true)
	}

	return nil, errors.New("could not marshal union type SourceMysqlUpdateMethod: all fields are null")
}

type SourceMysqlSchemasSslModeEncryptionMode string

const (
	SourceMysqlSchemasSslModeEncryptionModeVerifyIdentity SourceMysqlSchemasSslModeEncryptionMode = "verify_identity"
)

func (e SourceMysqlSchemasSslModeEncryptionMode) ToPointer() *SourceMysqlSchemasSslModeEncryptionMode {
	return &e
}
func (e *SourceMysqlSchemasSslModeEncryptionMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "verify_identity":
		*e = SourceMysqlSchemasSslModeEncryptionMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlSchemasSslModeEncryptionMode: %v", v)
	}
}

// VerifyIdentity - To always require encryption and verify that the source has a valid SSL certificate.
type VerifyIdentity struct {
	// CA certificate
	CaCertificate string `json:"ca_certificate"`
	// Client certificate (this is not a required field, but if you want to use it, you will need to add the Client key as well)
	ClientCertificate *string `json:"client_certificate,omitempty"`
	// Client key (this is not a required field, but if you want to use it, you will need to add the Client certificate as well)
	ClientKey *string `json:"client_key,omitempty"`
	// Password for keystorage. This field is optional. If you do not add it - the password will be generated automatically.
	ClientKeyPassword    *string                                  `json:"client_key_password,omitempty"`
	Mode                 *SourceMysqlSchemasSslModeEncryptionMode `default:"verify_identity" json:"mode"`
	AdditionalProperties any                                      `additionalProperties:"true" json:"-"`
}

func (v VerifyIdentity) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(v, "", false)
}

func (v *VerifyIdentity) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &v, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *VerifyIdentity) GetCaCertificate() string {
	if o == nil {
		return ""
	}
	return o.CaCertificate
}

func (o *VerifyIdentity) GetClientCertificate() *string {
	if o == nil {
		return nil
	}
	return o.ClientCertificate
}

func (o *VerifyIdentity) GetClientKey() *string {
	if o == nil {
		return nil
	}
	return o.ClientKey
}

func (o *VerifyIdentity) GetClientKeyPassword() *string {
	if o == nil {
		return nil
	}
	return o.ClientKeyPassword
}

func (o *VerifyIdentity) GetMode() *SourceMysqlSchemasSslModeEncryptionMode {
	if o == nil {
		return nil
	}
	return o.Mode
}

func (o *VerifyIdentity) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

type SourceMysqlSchemasSslModeMode string

const (
	SourceMysqlSchemasSslModeModeVerifyCa SourceMysqlSchemasSslModeMode = "verify_ca"
)

func (e SourceMysqlSchemasSslModeMode) ToPointer() *SourceMysqlSchemasSslModeMode {
	return &e
}
func (e *SourceMysqlSchemasSslModeMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "verify_ca":
		*e = SourceMysqlSchemasSslModeMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlSchemasSslModeMode: %v", v)
	}
}

// VerifyCa - To always require encryption and verify that the source has a valid SSL certificate.
type VerifyCa struct {
	// CA certificate
	CaCertificate string `json:"ca_certificate"`
	// Client certificate (this is not a required field, but if you want to use it, you will need to add the Client key as well)
	ClientCertificate *string `json:"client_certificate,omitempty"`
	// Client key (this is not a required field, but if you want to use it, you will need to add the Client certificate as well)
	ClientKey *string `json:"client_key,omitempty"`
	// Password for keystorage. This field is optional. If you do not add it - the password will be generated automatically.
	ClientKeyPassword    *string                        `json:"client_key_password,omitempty"`
	Mode                 *SourceMysqlSchemasSslModeMode `default:"verify_ca" json:"mode"`
	AdditionalProperties any                            `additionalProperties:"true" json:"-"`
}

func (v VerifyCa) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(v, "", false)
}

func (v *VerifyCa) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &v, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *VerifyCa) GetCaCertificate() string {
	if o == nil {
		return ""
	}
	return o.CaCertificate
}

func (o *VerifyCa) GetClientCertificate() *string {
	if o == nil {
		return nil
	}
	return o.ClientCertificate
}

func (o *VerifyCa) GetClientKey() *string {
	if o == nil {
		return nil
	}
	return o.ClientKey
}

func (o *VerifyCa) GetClientKeyPassword() *string {
	if o == nil {
		return nil
	}
	return o.ClientKeyPassword
}

func (o *VerifyCa) GetMode() *SourceMysqlSchemasSslModeMode {
	if o == nil {
		return nil
	}
	return o.Mode
}

func (o *VerifyCa) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

type SourceMysqlSchemasMode string

const (
	SourceMysqlSchemasModeRequired SourceMysqlSchemasMode = "required"
)

func (e SourceMysqlSchemasMode) ToPointer() *SourceMysqlSchemasMode {
	return &e
}
func (e *SourceMysqlSchemasMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "required":
		*e = SourceMysqlSchemasMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlSchemasMode: %v", v)
	}
}

// Required - To always require encryption. Note: The connection will fail if the source doesn't support encryption.
type Required struct {
	Mode                 *SourceMysqlSchemasMode `default:"required" json:"mode"`
	AdditionalProperties any                     `additionalProperties:"true" json:"-"`
}

func (r Required) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(r, "", false)
}

func (r *Required) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &r, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *Required) GetMode() *SourceMysqlSchemasMode {
	if o == nil {
		return nil
	}
	return o.Mode
}

func (o *Required) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

type SourceMysqlMode string

const (
	SourceMysqlModePreferred SourceMysqlMode = "preferred"
)

func (e SourceMysqlMode) ToPointer() *SourceMysqlMode {
	return &e
}
func (e *SourceMysqlMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "preferred":
		*e = SourceMysqlMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlMode: %v", v)
	}
}

// Preferred - To allow unencrypted communication only when the source doesn't support encryption.
type Preferred struct {
	Mode                 *SourceMysqlMode `default:"preferred" json:"mode"`
	AdditionalProperties any              `additionalProperties:"true" json:"-"`
}

func (p Preferred) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *Preferred) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *Preferred) GetMode() *SourceMysqlMode {
	if o == nil {
		return nil
	}
	return o.Mode
}

func (o *Preferred) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

type SourceMysqlEncryptionType string

const (
	SourceMysqlEncryptionTypePreferred      SourceMysqlEncryptionType = "preferred"
	SourceMysqlEncryptionTypeRequired       SourceMysqlEncryptionType = "required"
	SourceMysqlEncryptionTypeVerifyCa       SourceMysqlEncryptionType = "verify_ca"
	SourceMysqlEncryptionTypeVerifyIdentity SourceMysqlEncryptionType = "verify_identity"
)

// SourceMysqlEncryption - The encryption method which is used when communicating with the database.
type SourceMysqlEncryption struct {
	Preferred      *Preferred      `queryParam:"inline"`
	Required       *Required       `queryParam:"inline"`
	VerifyCa       *VerifyCa       `queryParam:"inline"`
	VerifyIdentity *VerifyIdentity `queryParam:"inline"`

	Type SourceMysqlEncryptionType
}

func CreateSourceMysqlEncryptionPreferred(preferred Preferred) SourceMysqlEncryption {
	typ := SourceMysqlEncryptionTypePreferred

	return SourceMysqlEncryption{
		Preferred: &preferred,
		Type:      typ,
	}
}

func CreateSourceMysqlEncryptionRequired(required Required) SourceMysqlEncryption {
	typ := SourceMysqlEncryptionTypeRequired

	return SourceMysqlEncryption{
		Required: &required,
		Type:     typ,
	}
}

func CreateSourceMysqlEncryptionVerifyCa(verifyCa VerifyCa) SourceMysqlEncryption {
	typ := SourceMysqlEncryptionTypeVerifyCa

	return SourceMysqlEncryption{
		VerifyCa: &verifyCa,
		Type:     typ,
	}
}

func CreateSourceMysqlEncryptionVerifyIdentity(verifyIdentity VerifyIdentity) SourceMysqlEncryption {
	typ := SourceMysqlEncryptionTypeVerifyIdentity

	return SourceMysqlEncryption{
		VerifyIdentity: &verifyIdentity,
		Type:           typ,
	}
}

func (u *SourceMysqlEncryption) UnmarshalJSON(data []byte) error {

	var preferred Preferred = Preferred{}
	if err := utils.UnmarshalJSON(data, &preferred, "", true, true); err == nil {
		u.Preferred = &preferred
		u.Type = SourceMysqlEncryptionTypePreferred
		return nil
	}

	var required Required = Required{}
	if err := utils.UnmarshalJSON(data, &required, "", true, true); err == nil {
		u.Required = &required
		u.Type = SourceMysqlEncryptionTypeRequired
		return nil
	}

	var verifyCa VerifyCa = VerifyCa{}
	if err := utils.UnmarshalJSON(data, &verifyCa, "", true, true); err == nil {
		u.VerifyCa = &verifyCa
		u.Type = SourceMysqlEncryptionTypeVerifyCa
		return nil
	}

	var verifyIdentity VerifyIdentity = VerifyIdentity{}
	if err := utils.UnmarshalJSON(data, &verifyIdentity, "", true, true); err == nil {
		u.VerifyIdentity = &verifyIdentity
		u.Type = SourceMysqlEncryptionTypeVerifyIdentity
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMysqlEncryption", string(data))
}

func (u SourceMysqlEncryption) MarshalJSON() ([]byte, error) {
	if u.Preferred != nil {
		return utils.MarshalJSON(u.Preferred, "", true)
	}

	if u.Required != nil {
		return utils.MarshalJSON(u.Required, "", true)
	}

	if u.VerifyCa != nil {
		return utils.MarshalJSON(u.VerifyCa, "", true)
	}

	if u.VerifyIdentity != nil {
		return utils.MarshalJSON(u.VerifyIdentity, "", true)
	}

	return nil, errors.New("could not marshal union type SourceMysqlEncryption: all fields are null")
}

type SourceMysqlSchemasTunnelMethodTunnelMethod string

const (
	SourceMysqlSchemasTunnelMethodTunnelMethodSSHPasswordAuth SourceMysqlSchemasTunnelMethodTunnelMethod = "SSH_PASSWORD_AUTH"
)

func (e SourceMysqlSchemasTunnelMethodTunnelMethod) ToPointer() *SourceMysqlSchemasTunnelMethodTunnelMethod {
	return &e
}
func (e *SourceMysqlSchemasTunnelMethodTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_PASSWORD_AUTH":
		*e = SourceMysqlSchemasTunnelMethodTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlSchemasTunnelMethodTunnelMethod: %v", v)
	}
}

// SourceMysqlPasswordAuthentication - Connect through a jump server tunnel host using username and password authentication
type SourceMysqlPasswordAuthentication struct {
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost   string                                      `json:"tunnel_host"`
	TunnelMethod *SourceMysqlSchemasTunnelMethodTunnelMethod `default:"SSH_PASSWORD_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser string `json:"tunnel_user"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword   string `json:"tunnel_user_password"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (s SourceMysqlPasswordAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMysqlPasswordAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceMysqlPasswordAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *SourceMysqlPasswordAuthentication) GetTunnelMethod() *SourceMysqlSchemasTunnelMethodTunnelMethod {
	if o == nil {
		return nil
	}
	return o.TunnelMethod
}

func (o *SourceMysqlPasswordAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *SourceMysqlPasswordAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

func (o *SourceMysqlPasswordAuthentication) GetTunnelUserPassword() string {
	if o == nil {
		return ""
	}
	return o.TunnelUserPassword
}

func (o *SourceMysqlPasswordAuthentication) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

type SourceMysqlSchemasTunnelMethod string

const (
	SourceMysqlSchemasTunnelMethodSSHKeyAuth SourceMysqlSchemasTunnelMethod = "SSH_KEY_AUTH"
)

func (e SourceMysqlSchemasTunnelMethod) ToPointer() *SourceMysqlSchemasTunnelMethod {
	return &e
}
func (e *SourceMysqlSchemasTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_KEY_AUTH":
		*e = SourceMysqlSchemasTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlSchemasTunnelMethod: %v", v)
	}
}

// SourceMysqlSSHKeyAuthentication - Connect through a jump server tunnel host using username and ssh key
type SourceMysqlSSHKeyAuthentication struct {
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey string `json:"ssh_key"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost   string                          `json:"tunnel_host"`
	TunnelMethod *SourceMysqlSchemasTunnelMethod `default:"SSH_KEY_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser           string `json:"tunnel_user"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (s SourceMysqlSSHKeyAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMysqlSSHKeyAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceMysqlSSHKeyAuthentication) GetSSHKey() string {
	if o == nil {
		return ""
	}
	return o.SSHKey
}

func (o *SourceMysqlSSHKeyAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *SourceMysqlSSHKeyAuthentication) GetTunnelMethod() *SourceMysqlSchemasTunnelMethod {
	if o == nil {
		return nil
	}
	return o.TunnelMethod
}

func (o *SourceMysqlSSHKeyAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *SourceMysqlSSHKeyAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

func (o *SourceMysqlSSHKeyAuthentication) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

type SourceMysqlTunnelMethod string

const (
	SourceMysqlTunnelMethodNoTunnel SourceMysqlTunnelMethod = "NO_TUNNEL"
)

func (e SourceMysqlTunnelMethod) ToPointer() *SourceMysqlTunnelMethod {
	return &e
}
func (e *SourceMysqlTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NO_TUNNEL":
		*e = SourceMysqlTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlTunnelMethod: %v", v)
	}
}

// SourceMysqlNoTunnel - No ssh tunnel needed to connect to database
type SourceMysqlNoTunnel struct {
	TunnelMethod         *SourceMysqlTunnelMethod `default:"NO_TUNNEL" json:"tunnel_method"`
	AdditionalProperties any                      `additionalProperties:"true" json:"-"`
}

func (s SourceMysqlNoTunnel) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMysqlNoTunnel) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceMysqlNoTunnel) GetTunnelMethod() *SourceMysqlTunnelMethod {
	if o == nil {
		return nil
	}
	return o.TunnelMethod
}

func (o *SourceMysqlNoTunnel) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

type SourceMysqlSSHTunnelMethodType string

const (
	SourceMysqlSSHTunnelMethodTypeSourceMysqlNoTunnel               SourceMysqlSSHTunnelMethodType = "source-mysql_No Tunnel"
	SourceMysqlSSHTunnelMethodTypeSourceMysqlSSHKeyAuthentication   SourceMysqlSSHTunnelMethodType = "source-mysql_SSH Key Authentication"
	SourceMysqlSSHTunnelMethodTypeSourceMysqlPasswordAuthentication SourceMysqlSSHTunnelMethodType = "source-mysql_Password Authentication"
)

// SourceMysqlSSHTunnelMethod - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceMysqlSSHTunnelMethod struct {
	SourceMysqlNoTunnel               *SourceMysqlNoTunnel               `queryParam:"inline"`
	SourceMysqlSSHKeyAuthentication   *SourceMysqlSSHKeyAuthentication   `queryParam:"inline"`
	SourceMysqlPasswordAuthentication *SourceMysqlPasswordAuthentication `queryParam:"inline"`

	Type SourceMysqlSSHTunnelMethodType
}

func CreateSourceMysqlSSHTunnelMethodSourceMysqlNoTunnel(sourceMysqlNoTunnel SourceMysqlNoTunnel) SourceMysqlSSHTunnelMethod {
	typ := SourceMysqlSSHTunnelMethodTypeSourceMysqlNoTunnel

	return SourceMysqlSSHTunnelMethod{
		SourceMysqlNoTunnel: &sourceMysqlNoTunnel,
		Type:                typ,
	}
}

func CreateSourceMysqlSSHTunnelMethodSourceMysqlSSHKeyAuthentication(sourceMysqlSSHKeyAuthentication SourceMysqlSSHKeyAuthentication) SourceMysqlSSHTunnelMethod {
	typ := SourceMysqlSSHTunnelMethodTypeSourceMysqlSSHKeyAuthentication

	return SourceMysqlSSHTunnelMethod{
		SourceMysqlSSHKeyAuthentication: &sourceMysqlSSHKeyAuthentication,
		Type:                            typ,
	}
}

func CreateSourceMysqlSSHTunnelMethodSourceMysqlPasswordAuthentication(sourceMysqlPasswordAuthentication SourceMysqlPasswordAuthentication) SourceMysqlSSHTunnelMethod {
	typ := SourceMysqlSSHTunnelMethodTypeSourceMysqlPasswordAuthentication

	return SourceMysqlSSHTunnelMethod{
		SourceMysqlPasswordAuthentication: &sourceMysqlPasswordAuthentication,
		Type:                              typ,
	}
}

func (u *SourceMysqlSSHTunnelMethod) UnmarshalJSON(data []byte) error {

	var sourceMysqlNoTunnel SourceMysqlNoTunnel = SourceMysqlNoTunnel{}
	if err := utils.UnmarshalJSON(data, &sourceMysqlNoTunnel, "", true, true); err == nil {
		u.SourceMysqlNoTunnel = &sourceMysqlNoTunnel
		u.Type = SourceMysqlSSHTunnelMethodTypeSourceMysqlNoTunnel
		return nil
	}

	var sourceMysqlSSHKeyAuthentication SourceMysqlSSHKeyAuthentication = SourceMysqlSSHKeyAuthentication{}
	if err := utils.UnmarshalJSON(data, &sourceMysqlSSHKeyAuthentication, "", true, true); err == nil {
		u.SourceMysqlSSHKeyAuthentication = &sourceMysqlSSHKeyAuthentication
		u.Type = SourceMysqlSSHTunnelMethodTypeSourceMysqlSSHKeyAuthentication
		return nil
	}

	var sourceMysqlPasswordAuthentication SourceMysqlPasswordAuthentication = SourceMysqlPasswordAuthentication{}
	if err := utils.UnmarshalJSON(data, &sourceMysqlPasswordAuthentication, "", true, true); err == nil {
		u.SourceMysqlPasswordAuthentication = &sourceMysqlPasswordAuthentication
		u.Type = SourceMysqlSSHTunnelMethodTypeSourceMysqlPasswordAuthentication
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMysqlSSHTunnelMethod", string(data))
}

func (u SourceMysqlSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.SourceMysqlNoTunnel != nil {
		return utils.MarshalJSON(u.SourceMysqlNoTunnel, "", true)
	}

	if u.SourceMysqlSSHKeyAuthentication != nil {
		return utils.MarshalJSON(u.SourceMysqlSSHKeyAuthentication, "", true)
	}

	if u.SourceMysqlPasswordAuthentication != nil {
		return utils.MarshalJSON(u.SourceMysqlPasswordAuthentication, "", true)
	}

	return nil, errors.New("could not marshal union type SourceMysqlSSHTunnelMethod: all fields are null")
}

type Mysql string

const (
	MysqlMysql Mysql = "mysql"
)

func (e Mysql) ToPointer() *Mysql {
	return &e
}
func (e *Mysql) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "mysql":
		*e = Mysql(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Mysql: %v", v)
	}
}

type SourceMysql struct {
	// When this feature is enabled, during schema discovery the connector will query each table or view individually to check access privileges and inaccessible tables, views, or columns therein will be removed. In large schemas, this might cause schema discovery to take too long, in which case it might be advisable to disable this feature.
	CheckPrivileges *bool `default:"true" json:"check_privileges"`
	// How often (in seconds) a stream should checkpoint, when possible.
	CheckpointTargetIntervalSeconds *int64 `default:"300" json:"checkpoint_target_interval_seconds"`
	// Maximum number of concurrent queries to the database.
	Concurrency *int64 `default:"1" json:"concurrency"`
	// The database name.
	Database string `json:"database"`
	// Hostname of the database.
	Host string `json:"host"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// The password associated with the username.
	Password *string `json:"password,omitempty"`
	// Port of the database.
	Port *int64 `default:"3306" json:"port"`
	// Configures how data is extracted from the database.
	ReplicationMethod SourceMysqlUpdateMethod `json:"replication_method"`
	// The encryption method which is used when communicating with the database.
	SslMode *SourceMysqlEncryption `json:"ssl_mode,omitempty"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod *SourceMysqlSSHTunnelMethod `json:"tunnel_method,omitempty"`
	// The username which is used to access the database.
	Username   string `json:"username"`
	sourceType Mysql  `const:"mysql" json:"sourceType"`
}

func (s SourceMysql) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMysql) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *SourceMysql) GetCheckPrivileges() *bool {
	if o == nil {
		return nil
	}
	return o.CheckPrivileges
}

func (o *SourceMysql) GetCheckpointTargetIntervalSeconds() *int64 {
	if o == nil {
		return nil
	}
	return o.CheckpointTargetIntervalSeconds
}

func (o *SourceMysql) GetConcurrency() *int64 {
	if o == nil {
		return nil
	}
	return o.Concurrency
}

func (o *SourceMysql) GetDatabase() string {
	if o == nil {
		return ""
	}
	return o.Database
}

func (o *SourceMysql) GetHost() string {
	if o == nil {
		return ""
	}
	return o.Host
}

func (o *SourceMysql) GetJdbcURLParams() *string {
	if o == nil {
		return nil
	}
	return o.JdbcURLParams
}

func (o *SourceMysql) GetPassword() *string {
	if o == nil {
		return nil
	}
	return o.Password
}

func (o *SourceMysql) GetPort() *int64 {
	if o == nil {
		return nil
	}
	return o.Port
}

func (o *SourceMysql) GetReplicationMethod() SourceMysqlUpdateMethod {
	if o == nil {
		return SourceMysqlUpdateMethod{}
	}
	return o.ReplicationMethod
}

func (o *SourceMysql) GetSslMode() *SourceMysqlEncryption {
	if o == nil {
		return nil
	}
	return o.SslMode
}

func (o *SourceMysql) GetTunnelMethod() *SourceMysqlSSHTunnelMethod {
	if o == nil {
		return nil
	}
	return o.TunnelMethod
}

func (o *SourceMysql) GetUsername() string {
	if o == nil {
		return ""
	}
	return o.Username
}

func (o *SourceMysql) GetSourceType() Mysql {
	return MysqlMysql
}
