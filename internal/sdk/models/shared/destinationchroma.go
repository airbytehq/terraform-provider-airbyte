// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

type DestinationChromaSchemasEmbeddingEmbedding7Mode string

const (
	DestinationChromaSchemasEmbeddingEmbedding7ModeNoEmbedding DestinationChromaSchemasEmbeddingEmbedding7Mode = "no_embedding"
)

func (e DestinationChromaSchemasEmbeddingEmbedding7Mode) ToPointer() *DestinationChromaSchemasEmbeddingEmbedding7Mode {
	return &e
}
func (e *DestinationChromaSchemasEmbeddingEmbedding7Mode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "no_embedding":
		*e = DestinationChromaSchemasEmbeddingEmbedding7Mode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationChromaSchemasEmbeddingEmbedding7Mode: %v", v)
	}
}

// ChromaDefaultEmbeddingFunction - Do not calculate embeddings. Chromadb uses the sentence transfomer (https://www.sbert.net/index.html) as a default if an embedding function is not defined. Note that depending on your hardware, calculating embeddings locally can be very slow and is mostly suited for prototypes.
type ChromaDefaultEmbeddingFunction struct {
	mode *DestinationChromaSchemasEmbeddingEmbedding7Mode `const:"no_embedding" json:"mode"`
}

func (c ChromaDefaultEmbeddingFunction) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *ChromaDefaultEmbeddingFunction) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *ChromaDefaultEmbeddingFunction) GetMode() *DestinationChromaSchemasEmbeddingEmbedding7Mode {
	return DestinationChromaSchemasEmbeddingEmbedding7ModeNoEmbedding.ToPointer()
}

type DestinationChromaSchemasEmbeddingEmbedding6Mode string

const (
	DestinationChromaSchemasEmbeddingEmbedding6ModeOpenaiCompatible DestinationChromaSchemasEmbeddingEmbedding6Mode = "openai_compatible"
)

func (e DestinationChromaSchemasEmbeddingEmbedding6Mode) ToPointer() *DestinationChromaSchemasEmbeddingEmbedding6Mode {
	return &e
}
func (e *DestinationChromaSchemasEmbeddingEmbedding6Mode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "openai_compatible":
		*e = DestinationChromaSchemasEmbeddingEmbedding6Mode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationChromaSchemasEmbeddingEmbedding6Mode: %v", v)
	}
}

// DestinationChromaOpenAICompatible - Use a service that's compatible with the OpenAI API to embed text.
type DestinationChromaOpenAICompatible struct {
	APIKey *string `default:"" json:"api_key"`
	// The base URL for your OpenAI-compatible service
	BaseURL string `json:"base_url"`
	// The number of dimensions the embedding model is generating
	Dimensions int64                                            `json:"dimensions"`
	mode       *DestinationChromaSchemasEmbeddingEmbedding6Mode `const:"openai_compatible" json:"mode"`
	// The name of the model to use for embedding
	ModelName *string `default:"text-embedding-ada-002" json:"model_name"`
}

func (d DestinationChromaOpenAICompatible) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationChromaOpenAICompatible) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationChromaOpenAICompatible) GetAPIKey() *string {
	if d == nil {
		return nil
	}
	return d.APIKey
}

func (d *DestinationChromaOpenAICompatible) GetBaseURL() string {
	if d == nil {
		return ""
	}
	return d.BaseURL
}

func (d *DestinationChromaOpenAICompatible) GetDimensions() int64 {
	if d == nil {
		return 0
	}
	return d.Dimensions
}

func (d *DestinationChromaOpenAICompatible) GetMode() *DestinationChromaSchemasEmbeddingEmbedding6Mode {
	return DestinationChromaSchemasEmbeddingEmbedding6ModeOpenaiCompatible.ToPointer()
}

func (d *DestinationChromaOpenAICompatible) GetModelName() *string {
	if d == nil {
		return nil
	}
	return d.ModelName
}

type DestinationChromaSchemasEmbeddingEmbedding5Mode string

const (
	DestinationChromaSchemasEmbeddingEmbedding5ModeFake DestinationChromaSchemasEmbeddingEmbedding5Mode = "fake"
)

func (e DestinationChromaSchemasEmbeddingEmbedding5Mode) ToPointer() *DestinationChromaSchemasEmbeddingEmbedding5Mode {
	return &e
}
func (e *DestinationChromaSchemasEmbeddingEmbedding5Mode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "fake":
		*e = DestinationChromaSchemasEmbeddingEmbedding5Mode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationChromaSchemasEmbeddingEmbedding5Mode: %v", v)
	}
}

// DestinationChromaFake - Use a fake embedding made out of random vectors with 1536 embedding dimensions. This is useful for testing the data pipeline without incurring any costs.
type DestinationChromaFake struct {
	mode *DestinationChromaSchemasEmbeddingEmbedding5Mode `const:"fake" json:"mode"`
}

func (d DestinationChromaFake) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationChromaFake) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationChromaFake) GetMode() *DestinationChromaSchemasEmbeddingEmbedding5Mode {
	return DestinationChromaSchemasEmbeddingEmbedding5ModeFake.ToPointer()
}

type DestinationChromaSchemasEmbeddingEmbeddingMode string

const (
	DestinationChromaSchemasEmbeddingEmbeddingModeFromField DestinationChromaSchemasEmbeddingEmbeddingMode = "from_field"
)

func (e DestinationChromaSchemasEmbeddingEmbeddingMode) ToPointer() *DestinationChromaSchemasEmbeddingEmbeddingMode {
	return &e
}
func (e *DestinationChromaSchemasEmbeddingEmbeddingMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "from_field":
		*e = DestinationChromaSchemasEmbeddingEmbeddingMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationChromaSchemasEmbeddingEmbeddingMode: %v", v)
	}
}

// FromField - Use a field in the record as the embedding. This is useful if you already have an embedding for your data and want to store it in the vector store.
type FromField struct {
	// The number of dimensions the embedding model is generating
	Dimensions int64 `json:"dimensions"`
	// Name of the field in the record that contains the embedding
	FieldName string                                          `json:"field_name"`
	mode      *DestinationChromaSchemasEmbeddingEmbeddingMode `const:"from_field" json:"mode"`
}

func (f FromField) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(f, "", false)
}

func (f *FromField) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &f, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (f *FromField) GetDimensions() int64 {
	if f == nil {
		return 0
	}
	return f.Dimensions
}

func (f *FromField) GetFieldName() string {
	if f == nil {
		return ""
	}
	return f.FieldName
}

func (f *FromField) GetMode() *DestinationChromaSchemasEmbeddingEmbeddingMode {
	return DestinationChromaSchemasEmbeddingEmbeddingModeFromField.ToPointer()
}

type DestinationChromaSchemasEmbeddingMode string

const (
	DestinationChromaSchemasEmbeddingModeCohere DestinationChromaSchemasEmbeddingMode = "cohere"
)

func (e DestinationChromaSchemasEmbeddingMode) ToPointer() *DestinationChromaSchemasEmbeddingMode {
	return &e
}
func (e *DestinationChromaSchemasEmbeddingMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "cohere":
		*e = DestinationChromaSchemasEmbeddingMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationChromaSchemasEmbeddingMode: %v", v)
	}
}

// DestinationChromaCohere - Use the Cohere API to embed text.
type DestinationChromaCohere struct {
	CohereKey string                                 `json:"cohere_key"`
	mode      *DestinationChromaSchemasEmbeddingMode `const:"cohere" json:"mode"`
}

func (d DestinationChromaCohere) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationChromaCohere) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationChromaCohere) GetCohereKey() string {
	if d == nil {
		return ""
	}
	return d.CohereKey
}

func (d *DestinationChromaCohere) GetMode() *DestinationChromaSchemasEmbeddingMode {
	return DestinationChromaSchemasEmbeddingModeCohere.ToPointer()
}

type DestinationChromaSchemasMode string

const (
	DestinationChromaSchemasModeOpenai DestinationChromaSchemasMode = "openai"
)

func (e DestinationChromaSchemasMode) ToPointer() *DestinationChromaSchemasMode {
	return &e
}
func (e *DestinationChromaSchemasMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "openai":
		*e = DestinationChromaSchemasMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationChromaSchemasMode: %v", v)
	}
}

// DestinationChromaOpenAI - Use the OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
type DestinationChromaOpenAI struct {
	mode      *DestinationChromaSchemasMode `const:"openai" json:"mode"`
	OpenaiKey string                        `json:"openai_key"`
}

func (d DestinationChromaOpenAI) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationChromaOpenAI) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationChromaOpenAI) GetMode() *DestinationChromaSchemasMode {
	return DestinationChromaSchemasModeOpenai.ToPointer()
}

func (d *DestinationChromaOpenAI) GetOpenaiKey() string {
	if d == nil {
		return ""
	}
	return d.OpenaiKey
}

type DestinationChromaMode string

const (
	DestinationChromaModeAzureOpenai DestinationChromaMode = "azure_openai"
)

func (e DestinationChromaMode) ToPointer() *DestinationChromaMode {
	return &e
}
func (e *DestinationChromaMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "azure_openai":
		*e = DestinationChromaMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationChromaMode: %v", v)
	}
}

// DestinationChromaAzureOpenAI - Use the Azure-hosted OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
type DestinationChromaAzureOpenAI struct {
	// The base URL for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
	APIBase string `json:"api_base"`
	// The deployment for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
	Deployment string                 `json:"deployment"`
	mode       *DestinationChromaMode `const:"azure_openai" json:"mode"`
	// The API key for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
	OpenaiKey string `json:"openai_key"`
}

func (d DestinationChromaAzureOpenAI) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationChromaAzureOpenAI) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationChromaAzureOpenAI) GetAPIBase() string {
	if d == nil {
		return ""
	}
	return d.APIBase
}

func (d *DestinationChromaAzureOpenAI) GetDeployment() string {
	if d == nil {
		return ""
	}
	return d.Deployment
}

func (d *DestinationChromaAzureOpenAI) GetMode() *DestinationChromaMode {
	return DestinationChromaModeAzureOpenai.ToPointer()
}

func (d *DestinationChromaAzureOpenAI) GetOpenaiKey() string {
	if d == nil {
		return ""
	}
	return d.OpenaiKey
}

type DestinationChromaEmbeddingType string

const (
	DestinationChromaEmbeddingTypeDestinationChromaAzureOpenAI      DestinationChromaEmbeddingType = "destination-chroma_Azure OpenAI"
	DestinationChromaEmbeddingTypeDestinationChromaOpenAI           DestinationChromaEmbeddingType = "destination-chroma_OpenAI"
	DestinationChromaEmbeddingTypeDestinationChromaCohere           DestinationChromaEmbeddingType = "destination-chroma_Cohere"
	DestinationChromaEmbeddingTypeFromField                         DestinationChromaEmbeddingType = "From Field"
	DestinationChromaEmbeddingTypeDestinationChromaFake             DestinationChromaEmbeddingType = "destination-chroma_Fake"
	DestinationChromaEmbeddingTypeDestinationChromaOpenAICompatible DestinationChromaEmbeddingType = "destination-chroma_OpenAI-compatible"
	DestinationChromaEmbeddingTypeChromaDefaultEmbeddingFunction    DestinationChromaEmbeddingType = "Chroma Default Embedding Function"
)

// DestinationChromaEmbedding - Embedding configuration
type DestinationChromaEmbedding struct {
	DestinationChromaAzureOpenAI      *DestinationChromaAzureOpenAI      `queryParam:"inline" union:"member"`
	DestinationChromaOpenAI           *DestinationChromaOpenAI           `queryParam:"inline" union:"member"`
	DestinationChromaCohere           *DestinationChromaCohere           `queryParam:"inline" union:"member"`
	FromField                         *FromField                         `queryParam:"inline" union:"member"`
	DestinationChromaFake             *DestinationChromaFake             `queryParam:"inline" union:"member"`
	DestinationChromaOpenAICompatible *DestinationChromaOpenAICompatible `queryParam:"inline" union:"member"`
	ChromaDefaultEmbeddingFunction    *ChromaDefaultEmbeddingFunction    `queryParam:"inline" union:"member"`

	Type DestinationChromaEmbeddingType
}

func CreateDestinationChromaEmbeddingDestinationChromaAzureOpenAI(destinationChromaAzureOpenAI DestinationChromaAzureOpenAI) DestinationChromaEmbedding {
	typ := DestinationChromaEmbeddingTypeDestinationChromaAzureOpenAI

	return DestinationChromaEmbedding{
		DestinationChromaAzureOpenAI: &destinationChromaAzureOpenAI,
		Type:                         typ,
	}
}

func CreateDestinationChromaEmbeddingDestinationChromaOpenAI(destinationChromaOpenAI DestinationChromaOpenAI) DestinationChromaEmbedding {
	typ := DestinationChromaEmbeddingTypeDestinationChromaOpenAI

	return DestinationChromaEmbedding{
		DestinationChromaOpenAI: &destinationChromaOpenAI,
		Type:                    typ,
	}
}

func CreateDestinationChromaEmbeddingDestinationChromaCohere(destinationChromaCohere DestinationChromaCohere) DestinationChromaEmbedding {
	typ := DestinationChromaEmbeddingTypeDestinationChromaCohere

	return DestinationChromaEmbedding{
		DestinationChromaCohere: &destinationChromaCohere,
		Type:                    typ,
	}
}

func CreateDestinationChromaEmbeddingFromField(fromField FromField) DestinationChromaEmbedding {
	typ := DestinationChromaEmbeddingTypeFromField

	return DestinationChromaEmbedding{
		FromField: &fromField,
		Type:      typ,
	}
}

func CreateDestinationChromaEmbeddingDestinationChromaFake(destinationChromaFake DestinationChromaFake) DestinationChromaEmbedding {
	typ := DestinationChromaEmbeddingTypeDestinationChromaFake

	return DestinationChromaEmbedding{
		DestinationChromaFake: &destinationChromaFake,
		Type:                  typ,
	}
}

func CreateDestinationChromaEmbeddingDestinationChromaOpenAICompatible(destinationChromaOpenAICompatible DestinationChromaOpenAICompatible) DestinationChromaEmbedding {
	typ := DestinationChromaEmbeddingTypeDestinationChromaOpenAICompatible

	return DestinationChromaEmbedding{
		DestinationChromaOpenAICompatible: &destinationChromaOpenAICompatible,
		Type:                              typ,
	}
}

func CreateDestinationChromaEmbeddingChromaDefaultEmbeddingFunction(chromaDefaultEmbeddingFunction ChromaDefaultEmbeddingFunction) DestinationChromaEmbedding {
	typ := DestinationChromaEmbeddingTypeChromaDefaultEmbeddingFunction

	return DestinationChromaEmbedding{
		ChromaDefaultEmbeddingFunction: &chromaDefaultEmbeddingFunction,
		Type:                           typ,
	}
}

func (u *DestinationChromaEmbedding) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var destinationChromaAzureOpenAI DestinationChromaAzureOpenAI = DestinationChromaAzureOpenAI{}
	if err := utils.UnmarshalJSON(data, &destinationChromaAzureOpenAI, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationChromaEmbeddingTypeDestinationChromaAzureOpenAI,
			Value: &destinationChromaAzureOpenAI,
		})
	}

	var destinationChromaOpenAI DestinationChromaOpenAI = DestinationChromaOpenAI{}
	if err := utils.UnmarshalJSON(data, &destinationChromaOpenAI, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationChromaEmbeddingTypeDestinationChromaOpenAI,
			Value: &destinationChromaOpenAI,
		})
	}

	var destinationChromaCohere DestinationChromaCohere = DestinationChromaCohere{}
	if err := utils.UnmarshalJSON(data, &destinationChromaCohere, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationChromaEmbeddingTypeDestinationChromaCohere,
			Value: &destinationChromaCohere,
		})
	}

	var fromField FromField = FromField{}
	if err := utils.UnmarshalJSON(data, &fromField, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationChromaEmbeddingTypeFromField,
			Value: &fromField,
		})
	}

	var destinationChromaFake DestinationChromaFake = DestinationChromaFake{}
	if err := utils.UnmarshalJSON(data, &destinationChromaFake, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationChromaEmbeddingTypeDestinationChromaFake,
			Value: &destinationChromaFake,
		})
	}

	var destinationChromaOpenAICompatible DestinationChromaOpenAICompatible = DestinationChromaOpenAICompatible{}
	if err := utils.UnmarshalJSON(data, &destinationChromaOpenAICompatible, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationChromaEmbeddingTypeDestinationChromaOpenAICompatible,
			Value: &destinationChromaOpenAICompatible,
		})
	}

	var chromaDefaultEmbeddingFunction ChromaDefaultEmbeddingFunction = ChromaDefaultEmbeddingFunction{}
	if err := utils.UnmarshalJSON(data, &chromaDefaultEmbeddingFunction, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationChromaEmbeddingTypeChromaDefaultEmbeddingFunction,
			Value: &chromaDefaultEmbeddingFunction,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationChromaEmbedding", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationChromaEmbedding", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(DestinationChromaEmbeddingType)
	switch best.Type {
	case DestinationChromaEmbeddingTypeDestinationChromaAzureOpenAI:
		u.DestinationChromaAzureOpenAI = best.Value.(*DestinationChromaAzureOpenAI)
		return nil
	case DestinationChromaEmbeddingTypeDestinationChromaOpenAI:
		u.DestinationChromaOpenAI = best.Value.(*DestinationChromaOpenAI)
		return nil
	case DestinationChromaEmbeddingTypeDestinationChromaCohere:
		u.DestinationChromaCohere = best.Value.(*DestinationChromaCohere)
		return nil
	case DestinationChromaEmbeddingTypeFromField:
		u.FromField = best.Value.(*FromField)
		return nil
	case DestinationChromaEmbeddingTypeDestinationChromaFake:
		u.DestinationChromaFake = best.Value.(*DestinationChromaFake)
		return nil
	case DestinationChromaEmbeddingTypeDestinationChromaOpenAICompatible:
		u.DestinationChromaOpenAICompatible = best.Value.(*DestinationChromaOpenAICompatible)
		return nil
	case DestinationChromaEmbeddingTypeChromaDefaultEmbeddingFunction:
		u.ChromaDefaultEmbeddingFunction = best.Value.(*ChromaDefaultEmbeddingFunction)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationChromaEmbedding", string(data))
}

func (u DestinationChromaEmbedding) MarshalJSON() ([]byte, error) {
	if u.DestinationChromaAzureOpenAI != nil {
		return utils.MarshalJSON(u.DestinationChromaAzureOpenAI, "", true)
	}

	if u.DestinationChromaOpenAI != nil {
		return utils.MarshalJSON(u.DestinationChromaOpenAI, "", true)
	}

	if u.DestinationChromaCohere != nil {
		return utils.MarshalJSON(u.DestinationChromaCohere, "", true)
	}

	if u.FromField != nil {
		return utils.MarshalJSON(u.FromField, "", true)
	}

	if u.DestinationChromaFake != nil {
		return utils.MarshalJSON(u.DestinationChromaFake, "", true)
	}

	if u.DestinationChromaOpenAICompatible != nil {
		return utils.MarshalJSON(u.DestinationChromaOpenAICompatible, "", true)
	}

	if u.ChromaDefaultEmbeddingFunction != nil {
		return utils.MarshalJSON(u.ChromaDefaultEmbeddingFunction, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationChromaEmbedding: all fields are null")
}

type DestinationChromaSchemasIndexingAuthMethodMode string

const (
	DestinationChromaSchemasIndexingAuthMethodModeHTTPClient DestinationChromaSchemasIndexingAuthMethodMode = "http_client"
)

func (e DestinationChromaSchemasIndexingAuthMethodMode) ToPointer() *DestinationChromaSchemasIndexingAuthMethodMode {
	return &e
}
func (e *DestinationChromaSchemasIndexingAuthMethodMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "http_client":
		*e = DestinationChromaSchemasIndexingAuthMethodMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationChromaSchemasIndexingAuthMethodMode: %v", v)
	}
}

// ClientServerMode - Authenticate using username and password (suitable for self-managed Chroma clusters)
type ClientServerMode struct {
	// The URL to the chromadb instance
	Host string                                          `json:"host"`
	mode *DestinationChromaSchemasIndexingAuthMethodMode `const:"http_client" json:"mode"`
	// Password used in server/client mode only
	Password *string `default:"" json:"password"`
	// The port to the chromadb instance
	Port int64 `json:"port"`
	// Whether to use SSL to connect to the Chroma server
	Ssl bool `json:"ssl"`
	// Username used in server/client mode only
	Username *string `default:"" json:"username"`
}

func (c ClientServerMode) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *ClientServerMode) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *ClientServerMode) GetHost() string {
	if c == nil {
		return ""
	}
	return c.Host
}

func (c *ClientServerMode) GetMode() *DestinationChromaSchemasIndexingAuthMethodMode {
	return DestinationChromaSchemasIndexingAuthMethodModeHTTPClient.ToPointer()
}

func (c *ClientServerMode) GetPassword() *string {
	if c == nil {
		return nil
	}
	return c.Password
}

func (c *ClientServerMode) GetPort() int64 {
	if c == nil {
		return 0
	}
	return c.Port
}

func (c *ClientServerMode) GetSsl() bool {
	if c == nil {
		return false
	}
	return c.Ssl
}

func (c *ClientServerMode) GetUsername() *string {
	if c == nil {
		return nil
	}
	return c.Username
}

type DestinationChromaSchemasIndexingMode string

const (
	DestinationChromaSchemasIndexingModePersistentClient DestinationChromaSchemasIndexingMode = "persistent_client"
)

func (e DestinationChromaSchemasIndexingMode) ToPointer() *DestinationChromaSchemasIndexingMode {
	return &e
}
func (e *DestinationChromaSchemasIndexingMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "persistent_client":
		*e = DestinationChromaSchemasIndexingMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationChromaSchemasIndexingMode: %v", v)
	}
}

// PersistentClientMode - Configure Chroma to save and load from your local machine
type PersistentClientMode struct {
	mode *DestinationChromaSchemasIndexingMode `const:"persistent_client" json:"mode"`
	// Where Chroma will store its database files on disk, and load them on start.
	Path string `json:"path"`
}

func (p PersistentClientMode) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *PersistentClientMode) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (p *PersistentClientMode) GetMode() *DestinationChromaSchemasIndexingMode {
	return DestinationChromaSchemasIndexingModePersistentClient.ToPointer()
}

func (p *PersistentClientMode) GetPath() string {
	if p == nil {
		return ""
	}
	return p.Path
}

type ConnectionModeType string

const (
	ConnectionModeTypePersistentClientMode ConnectionModeType = "Persistent Client Mode"
	ConnectionModeTypeClientServerMode     ConnectionModeType = "Client/Server Mode"
)

// ConnectionMode - Mode how to connect to Chroma
type ConnectionMode struct {
	PersistentClientMode *PersistentClientMode `queryParam:"inline" union:"member"`
	ClientServerMode     *ClientServerMode     `queryParam:"inline" union:"member"`

	Type ConnectionModeType
}

func CreateConnectionModePersistentClientMode(persistentClientMode PersistentClientMode) ConnectionMode {
	typ := ConnectionModeTypePersistentClientMode

	return ConnectionMode{
		PersistentClientMode: &persistentClientMode,
		Type:                 typ,
	}
}

func CreateConnectionModeClientServerMode(clientServerMode ClientServerMode) ConnectionMode {
	typ := ConnectionModeTypeClientServerMode

	return ConnectionMode{
		ClientServerMode: &clientServerMode,
		Type:             typ,
	}
}

func (u *ConnectionMode) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var persistentClientMode PersistentClientMode = PersistentClientMode{}
	if err := utils.UnmarshalJSON(data, &persistentClientMode, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ConnectionModeTypePersistentClientMode,
			Value: &persistentClientMode,
		})
	}

	var clientServerMode ClientServerMode = ClientServerMode{}
	if err := utils.UnmarshalJSON(data, &clientServerMode, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ConnectionModeTypeClientServerMode,
			Value: &clientServerMode,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for ConnectionMode", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for ConnectionMode", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(ConnectionModeType)
	switch best.Type {
	case ConnectionModeTypePersistentClientMode:
		u.PersistentClientMode = best.Value.(*PersistentClientMode)
		return nil
	case ConnectionModeTypeClientServerMode:
		u.ClientServerMode = best.Value.(*ClientServerMode)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ConnectionMode", string(data))
}

func (u ConnectionMode) MarshalJSON() ([]byte, error) {
	if u.PersistentClientMode != nil {
		return utils.MarshalJSON(u.PersistentClientMode, "", true)
	}

	if u.ClientServerMode != nil {
		return utils.MarshalJSON(u.ClientServerMode, "", true)
	}

	return nil, errors.New("could not marshal union type ConnectionMode: all fields are null")
}

// DestinationChromaIndexing - Indexing configuration
type DestinationChromaIndexing struct {
	// Mode how to connect to Chroma
	AuthMethod ConnectionMode `json:"auth_method"`
	// The collection to load data into
	CollectionName string `json:"collection_name"`
}

func (d *DestinationChromaIndexing) GetAuthMethod() ConnectionMode {
	if d == nil {
		return ConnectionMode{}
	}
	return d.AuthMethod
}

func (d *DestinationChromaIndexing) GetCollectionName() string {
	if d == nil {
		return ""
	}
	return d.CollectionName
}

type DestinationChromaFieldNameMappingConfigModel struct {
	// The field name in the source
	FromField string `json:"from_field"`
	// The field name to use in the destination
	ToField string `json:"to_field"`
}

func (d *DestinationChromaFieldNameMappingConfigModel) GetFromField() string {
	if d == nil {
		return ""
	}
	return d.FromField
}

func (d *DestinationChromaFieldNameMappingConfigModel) GetToField() string {
	if d == nil {
		return ""
	}
	return d.ToField
}

// DestinationChromaLanguage - Split code in suitable places based on the programming language
type DestinationChromaLanguage string

const (
	DestinationChromaLanguageCpp      DestinationChromaLanguage = "cpp"
	DestinationChromaLanguageGo       DestinationChromaLanguage = "go"
	DestinationChromaLanguageJava     DestinationChromaLanguage = "java"
	DestinationChromaLanguageJs       DestinationChromaLanguage = "js"
	DestinationChromaLanguagePhp      DestinationChromaLanguage = "php"
	DestinationChromaLanguageProto    DestinationChromaLanguage = "proto"
	DestinationChromaLanguagePython   DestinationChromaLanguage = "python"
	DestinationChromaLanguageRst      DestinationChromaLanguage = "rst"
	DestinationChromaLanguageRuby     DestinationChromaLanguage = "ruby"
	DestinationChromaLanguageRust     DestinationChromaLanguage = "rust"
	DestinationChromaLanguageScala    DestinationChromaLanguage = "scala"
	DestinationChromaLanguageSwift    DestinationChromaLanguage = "swift"
	DestinationChromaLanguageMarkdown DestinationChromaLanguage = "markdown"
	DestinationChromaLanguageLatex    DestinationChromaLanguage = "latex"
	DestinationChromaLanguageHTML     DestinationChromaLanguage = "html"
	DestinationChromaLanguageSol      DestinationChromaLanguage = "sol"
)

func (e DestinationChromaLanguage) ToPointer() *DestinationChromaLanguage {
	return &e
}
func (e *DestinationChromaLanguage) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "cpp":
		fallthrough
	case "go":
		fallthrough
	case "java":
		fallthrough
	case "js":
		fallthrough
	case "php":
		fallthrough
	case "proto":
		fallthrough
	case "python":
		fallthrough
	case "rst":
		fallthrough
	case "ruby":
		fallthrough
	case "rust":
		fallthrough
	case "scala":
		fallthrough
	case "swift":
		fallthrough
	case "markdown":
		fallthrough
	case "latex":
		fallthrough
	case "html":
		fallthrough
	case "sol":
		*e = DestinationChromaLanguage(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationChromaLanguage: %v", v)
	}
}

type DestinationChromaSchemasProcessingTextSplitterTextSplitterMode string

const (
	DestinationChromaSchemasProcessingTextSplitterTextSplitterModeCode DestinationChromaSchemasProcessingTextSplitterTextSplitterMode = "code"
)

func (e DestinationChromaSchemasProcessingTextSplitterTextSplitterMode) ToPointer() *DestinationChromaSchemasProcessingTextSplitterTextSplitterMode {
	return &e
}
func (e *DestinationChromaSchemasProcessingTextSplitterTextSplitterMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "code":
		*e = DestinationChromaSchemasProcessingTextSplitterTextSplitterMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationChromaSchemasProcessingTextSplitterTextSplitterMode: %v", v)
	}
}

// DestinationChromaByProgrammingLanguage - Split the text by suitable delimiters based on the programming language. This is useful for splitting code into chunks.
type DestinationChromaByProgrammingLanguage struct {
	// Split code in suitable places based on the programming language
	Language DestinationChromaLanguage                                       `json:"language"`
	mode     *DestinationChromaSchemasProcessingTextSplitterTextSplitterMode `const:"code" json:"mode"`
}

func (d DestinationChromaByProgrammingLanguage) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationChromaByProgrammingLanguage) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationChromaByProgrammingLanguage) GetLanguage() DestinationChromaLanguage {
	if d == nil {
		return DestinationChromaLanguage("")
	}
	return d.Language
}

func (d *DestinationChromaByProgrammingLanguage) GetMode() *DestinationChromaSchemasProcessingTextSplitterTextSplitterMode {
	return DestinationChromaSchemasProcessingTextSplitterTextSplitterModeCode.ToPointer()
}

type DestinationChromaSchemasProcessingTextSplitterMode string

const (
	DestinationChromaSchemasProcessingTextSplitterModeMarkdown DestinationChromaSchemasProcessingTextSplitterMode = "markdown"
)

func (e DestinationChromaSchemasProcessingTextSplitterMode) ToPointer() *DestinationChromaSchemasProcessingTextSplitterMode {
	return &e
}
func (e *DestinationChromaSchemasProcessingTextSplitterMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "markdown":
		*e = DestinationChromaSchemasProcessingTextSplitterMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationChromaSchemasProcessingTextSplitterMode: %v", v)
	}
}

// DestinationChromaByMarkdownHeader - Split the text by Markdown headers down to the specified header level. If the chunk size fits multiple sections, they will be combined into a single chunk.
type DestinationChromaByMarkdownHeader struct {
	mode *DestinationChromaSchemasProcessingTextSplitterMode `const:"markdown" json:"mode"`
	// Level of markdown headers to split text fields by. Headings down to the specified level will be used as split points
	SplitLevel *int64 `default:"1" json:"split_level"`
}

func (d DestinationChromaByMarkdownHeader) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationChromaByMarkdownHeader) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationChromaByMarkdownHeader) GetMode() *DestinationChromaSchemasProcessingTextSplitterMode {
	return DestinationChromaSchemasProcessingTextSplitterModeMarkdown.ToPointer()
}

func (d *DestinationChromaByMarkdownHeader) GetSplitLevel() *int64 {
	if d == nil {
		return nil
	}
	return d.SplitLevel
}

type DestinationChromaSchemasProcessingMode string

const (
	DestinationChromaSchemasProcessingModeSeparator DestinationChromaSchemasProcessingMode = "separator"
)

func (e DestinationChromaSchemasProcessingMode) ToPointer() *DestinationChromaSchemasProcessingMode {
	return &e
}
func (e *DestinationChromaSchemasProcessingMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "separator":
		*e = DestinationChromaSchemasProcessingMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationChromaSchemasProcessingMode: %v", v)
	}
}

// DestinationChromaBySeparator - Split the text by the list of separators until the chunk size is reached, using the earlier mentioned separators where possible. This is useful for splitting text fields by paragraphs, sentences, words, etc.
type DestinationChromaBySeparator struct {
	// Whether to keep the separator in the resulting chunks
	KeepSeparator *bool                                   `default:"false" json:"keep_separator"`
	mode          *DestinationChromaSchemasProcessingMode `const:"separator" json:"mode"`
	// List of separator strings to split text fields by. The separator itself needs to be wrapped in double quotes, e.g. to split by the dot character, use ".". To split by a newline, use "\n".
	Separators []string `json:"separators,omitempty"`
}

func (d DestinationChromaBySeparator) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationChromaBySeparator) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationChromaBySeparator) GetKeepSeparator() *bool {
	if d == nil {
		return nil
	}
	return d.KeepSeparator
}

func (d *DestinationChromaBySeparator) GetMode() *DestinationChromaSchemasProcessingMode {
	return DestinationChromaSchemasProcessingModeSeparator.ToPointer()
}

func (d *DestinationChromaBySeparator) GetSeparators() []string {
	if d == nil {
		return nil
	}
	return d.Separators
}

type DestinationChromaTextSplitterType string

const (
	DestinationChromaTextSplitterTypeDestinationChromaBySeparator           DestinationChromaTextSplitterType = "destination-chroma_By Separator"
	DestinationChromaTextSplitterTypeDestinationChromaByMarkdownHeader      DestinationChromaTextSplitterType = "destination-chroma_By Markdown header"
	DestinationChromaTextSplitterTypeDestinationChromaByProgrammingLanguage DestinationChromaTextSplitterType = "destination-chroma_By Programming Language"
)

// DestinationChromaTextSplitter - Split text fields into chunks based on the specified method.
type DestinationChromaTextSplitter struct {
	DestinationChromaBySeparator           *DestinationChromaBySeparator           `queryParam:"inline" union:"member"`
	DestinationChromaByMarkdownHeader      *DestinationChromaByMarkdownHeader      `queryParam:"inline" union:"member"`
	DestinationChromaByProgrammingLanguage *DestinationChromaByProgrammingLanguage `queryParam:"inline" union:"member"`

	Type DestinationChromaTextSplitterType
}

func CreateDestinationChromaTextSplitterDestinationChromaBySeparator(destinationChromaBySeparator DestinationChromaBySeparator) DestinationChromaTextSplitter {
	typ := DestinationChromaTextSplitterTypeDestinationChromaBySeparator

	return DestinationChromaTextSplitter{
		DestinationChromaBySeparator: &destinationChromaBySeparator,
		Type:                         typ,
	}
}

func CreateDestinationChromaTextSplitterDestinationChromaByMarkdownHeader(destinationChromaByMarkdownHeader DestinationChromaByMarkdownHeader) DestinationChromaTextSplitter {
	typ := DestinationChromaTextSplitterTypeDestinationChromaByMarkdownHeader

	return DestinationChromaTextSplitter{
		DestinationChromaByMarkdownHeader: &destinationChromaByMarkdownHeader,
		Type:                              typ,
	}
}

func CreateDestinationChromaTextSplitterDestinationChromaByProgrammingLanguage(destinationChromaByProgrammingLanguage DestinationChromaByProgrammingLanguage) DestinationChromaTextSplitter {
	typ := DestinationChromaTextSplitterTypeDestinationChromaByProgrammingLanguage

	return DestinationChromaTextSplitter{
		DestinationChromaByProgrammingLanguage: &destinationChromaByProgrammingLanguage,
		Type:                                   typ,
	}
}

func (u *DestinationChromaTextSplitter) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var destinationChromaBySeparator DestinationChromaBySeparator = DestinationChromaBySeparator{}
	if err := utils.UnmarshalJSON(data, &destinationChromaBySeparator, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationChromaTextSplitterTypeDestinationChromaBySeparator,
			Value: &destinationChromaBySeparator,
		})
	}

	var destinationChromaByMarkdownHeader DestinationChromaByMarkdownHeader = DestinationChromaByMarkdownHeader{}
	if err := utils.UnmarshalJSON(data, &destinationChromaByMarkdownHeader, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationChromaTextSplitterTypeDestinationChromaByMarkdownHeader,
			Value: &destinationChromaByMarkdownHeader,
		})
	}

	var destinationChromaByProgrammingLanguage DestinationChromaByProgrammingLanguage = DestinationChromaByProgrammingLanguage{}
	if err := utils.UnmarshalJSON(data, &destinationChromaByProgrammingLanguage, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationChromaTextSplitterTypeDestinationChromaByProgrammingLanguage,
			Value: &destinationChromaByProgrammingLanguage,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationChromaTextSplitter", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationChromaTextSplitter", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(DestinationChromaTextSplitterType)
	switch best.Type {
	case DestinationChromaTextSplitterTypeDestinationChromaBySeparator:
		u.DestinationChromaBySeparator = best.Value.(*DestinationChromaBySeparator)
		return nil
	case DestinationChromaTextSplitterTypeDestinationChromaByMarkdownHeader:
		u.DestinationChromaByMarkdownHeader = best.Value.(*DestinationChromaByMarkdownHeader)
		return nil
	case DestinationChromaTextSplitterTypeDestinationChromaByProgrammingLanguage:
		u.DestinationChromaByProgrammingLanguage = best.Value.(*DestinationChromaByProgrammingLanguage)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationChromaTextSplitter", string(data))
}

func (u DestinationChromaTextSplitter) MarshalJSON() ([]byte, error) {
	if u.DestinationChromaBySeparator != nil {
		return utils.MarshalJSON(u.DestinationChromaBySeparator, "", true)
	}

	if u.DestinationChromaByMarkdownHeader != nil {
		return utils.MarshalJSON(u.DestinationChromaByMarkdownHeader, "", true)
	}

	if u.DestinationChromaByProgrammingLanguage != nil {
		return utils.MarshalJSON(u.DestinationChromaByProgrammingLanguage, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationChromaTextSplitter: all fields are null")
}

type DestinationChromaProcessingConfigModel struct {
	// Size of overlap between chunks in tokens to store in vector store to better capture relevant context
	ChunkOverlap *int64 `default:"0" json:"chunk_overlap"`
	// Size of chunks in tokens to store in vector store (make sure it is not too big for the context if your LLM)
	ChunkSize int64 `json:"chunk_size"`
	// List of fields to rename. Not applicable for nested fields, but can be used to rename fields already flattened via dot notation.
	FieldNameMappings []DestinationChromaFieldNameMappingConfigModel `json:"field_name_mappings,omitempty"`
	// List of fields in the record that should be stored as metadata. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered metadata fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array. When specifying nested paths, all matching values are flattened into an array set to a field named by the path.
	MetadataFields []string `json:"metadata_fields,omitempty"`
	// List of fields in the record that should be used to calculate the embedding. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered text fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array.
	TextFields []string `json:"text_fields,omitempty"`
	// Split text fields into chunks based on the specified method.
	TextSplitter *DestinationChromaTextSplitter `json:"text_splitter,omitempty"`
}

func (d DestinationChromaProcessingConfigModel) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationChromaProcessingConfigModel) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationChromaProcessingConfigModel) GetChunkOverlap() *int64 {
	if d == nil {
		return nil
	}
	return d.ChunkOverlap
}

func (d *DestinationChromaProcessingConfigModel) GetChunkSize() int64 {
	if d == nil {
		return 0
	}
	return d.ChunkSize
}

func (d *DestinationChromaProcessingConfigModel) GetFieldNameMappings() []DestinationChromaFieldNameMappingConfigModel {
	if d == nil {
		return nil
	}
	return d.FieldNameMappings
}

func (d *DestinationChromaProcessingConfigModel) GetMetadataFields() []string {
	if d == nil {
		return nil
	}
	return d.MetadataFields
}

func (d *DestinationChromaProcessingConfigModel) GetTextFields() []string {
	if d == nil {
		return nil
	}
	return d.TextFields
}

func (d *DestinationChromaProcessingConfigModel) GetTextSplitter() *DestinationChromaTextSplitter {
	if d == nil {
		return nil
	}
	return d.TextSplitter
}

type DestinationChromaDestinationType string

const (
	DestinationChromaDestinationTypeChroma DestinationChromaDestinationType = "chroma"
)

func (e DestinationChromaDestinationType) ToPointer() *DestinationChromaDestinationType {
	return &e
}
func (e *DestinationChromaDestinationType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "chroma":
		*e = DestinationChromaDestinationType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationChromaDestinationType: %v", v)
	}
}

// DestinationChroma - The configuration model for the Vector DB based destinations. This model is used to generate the UI for the destination configuration, as well as to provide type safety for the configuration passed to the destination. The configuration model is composed of four parts: * Processing configuration * Embedding configuration * Indexing configuration * Advanced configuration Processing, embedding and advanced configuration are provided by this base class, while the indexing configuration is provided by the destination connector in the sub class.
type DestinationChroma struct {
	// Embedding configuration
	Embedding DestinationChromaEmbedding `json:"embedding"`
	// Indexing configuration
	Indexing DestinationChromaIndexing `json:"indexing"`
	// Do not store the text that gets embedded along with the vector and the metadata in the destination. If set to true, only the vector and the metadata will be stored - in this case raw text for LLM use cases needs to be retrieved from another source.
	OmitRawText     *bool                                  `default:"false" json:"omit_raw_text"`
	Processing      DestinationChromaProcessingConfigModel `json:"processing"`
	destinationType *DestinationChromaDestinationType      `const:"chroma" json:"destinationType"`
}

func (d DestinationChroma) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationChroma) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationChroma) GetEmbedding() DestinationChromaEmbedding {
	if d == nil {
		return DestinationChromaEmbedding{}
	}
	return d.Embedding
}

func (d *DestinationChroma) GetIndexing() DestinationChromaIndexing {
	if d == nil {
		return DestinationChromaIndexing{}
	}
	return d.Indexing
}

func (d *DestinationChroma) GetOmitRawText() *bool {
	if d == nil {
		return nil
	}
	return d.OmitRawText
}

func (d *DestinationChroma) GetProcessing() DestinationChromaProcessingConfigModel {
	if d == nil {
		return DestinationChromaProcessingConfigModel{}
	}
	return d.Processing
}

func (d *DestinationChroma) GetDestinationType() *DestinationChromaDestinationType {
	return DestinationChromaDestinationTypeChroma.ToPointer()
}
