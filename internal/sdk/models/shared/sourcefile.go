// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

// FileFormat - The Format of the file which should be replicated (Warning: some formats may be experimental, please refer to the docs).
type FileFormat string

const (
	FileFormatCsv         FileFormat = "csv"
	FileFormatJSON        FileFormat = "json"
	FileFormatJsonl       FileFormat = "jsonl"
	FileFormatExcel       FileFormat = "excel"
	FileFormatExcelBinary FileFormat = "excel_binary"
	FileFormatFwf         FileFormat = "fwf"
	FileFormatFeather     FileFormat = "feather"
	FileFormatParquet     FileFormat = "parquet"
	FileFormatYaml        FileFormat = "yaml"
)

func (e FileFormat) ToPointer() *FileFormat {
	return &e
}
func (e *FileFormat) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "csv":
		fallthrough
	case "json":
		fallthrough
	case "jsonl":
		fallthrough
	case "excel":
		fallthrough
	case "excel_binary":
		fallthrough
	case "fwf":
		fallthrough
	case "feather":
		fallthrough
	case "parquet":
		fallthrough
	case "yaml":
		*e = FileFormat(v)
		return nil
	default:
		return fmt.Errorf("invalid value for FileFormat: %v", v)
	}
}

type SFTPSecureFileTransferProtocol struct {
	Host     string  `json:"host"`
	Password *string `json:"password,omitempty"`
	Port     *string `default:"22" json:"port"`
	storage  string  `const:"SFTP" json:"storage"`
	User     string  `json:"user"`
}

func (s SFTPSecureFileTransferProtocol) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SFTPSecureFileTransferProtocol) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SFTPSecureFileTransferProtocol) GetHost() string {
	if s == nil {
		return ""
	}
	return s.Host
}

func (s *SFTPSecureFileTransferProtocol) GetPassword() *string {
	if s == nil {
		return nil
	}
	return s.Password
}

func (s *SFTPSecureFileTransferProtocol) GetPort() *string {
	if s == nil {
		return nil
	}
	return s.Port
}

func (s *SFTPSecureFileTransferProtocol) GetStorage() string {
	return "SFTP"
}

func (s *SFTPSecureFileTransferProtocol) GetUser() string {
	if s == nil {
		return ""
	}
	return s.User
}

type SCPSecureCopyProtocol struct {
	Host     string  `json:"host"`
	Password *string `json:"password,omitempty"`
	Port     *string `default:"22" json:"port"`
	storage  string  `const:"SCP" json:"storage"`
	User     string  `json:"user"`
}

func (s SCPSecureCopyProtocol) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SCPSecureCopyProtocol) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SCPSecureCopyProtocol) GetHost() string {
	if s == nil {
		return ""
	}
	return s.Host
}

func (s *SCPSecureCopyProtocol) GetPassword() *string {
	if s == nil {
		return nil
	}
	return s.Password
}

func (s *SCPSecureCopyProtocol) GetPort() *string {
	if s == nil {
		return nil
	}
	return s.Port
}

func (s *SCPSecureCopyProtocol) GetStorage() string {
	return "SCP"
}

func (s *SCPSecureCopyProtocol) GetUser() string {
	if s == nil {
		return ""
	}
	return s.User
}

type SSHSecureShell struct {
	Host     string  `json:"host"`
	Password *string `json:"password,omitempty"`
	Port     *string `default:"22" json:"port"`
	storage  string  `const:"SSH" json:"storage"`
	User     string  `json:"user"`
}

func (s SSHSecureShell) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SSHSecureShell) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SSHSecureShell) GetHost() string {
	if s == nil {
		return ""
	}
	return s.Host
}

func (s *SSHSecureShell) GetPassword() *string {
	if s == nil {
		return nil
	}
	return s.Password
}

func (s *SSHSecureShell) GetPort() *string {
	if s == nil {
		return nil
	}
	return s.Port
}

func (s *SSHSecureShell) GetStorage() string {
	return "SSH"
}

func (s *SSHSecureShell) GetUser() string {
	if s == nil {
		return ""
	}
	return s.User
}

type AzBlobAzureBlobStorage struct {
	// To access Azure Blob Storage, this connector would need credentials with the proper permissions. One option is a SAS (Shared Access Signature) token. If accessing publicly available data, this field is not necessary.
	SasToken *string `json:"sas_token,omitempty"`
	// To access Azure Blob Storage, this connector would need credentials with the proper permissions. One option is a storage account shared key (aka account key or access key). If accessing publicly available data, this field is not necessary.
	SharedKey *string `json:"shared_key,omitempty"`
	storage   string  `const:"AzBlob" json:"storage"`
	// The globally unique name of the storage account that the desired blob sits within. See <a href="https://docs.microsoft.com/en-us/azure/storage/common/storage-account-overview" target="_blank">here</a> for more details.
	StorageAccount string `json:"storage_account"`
}

func (a AzBlobAzureBlobStorage) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AzBlobAzureBlobStorage) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (a *AzBlobAzureBlobStorage) GetSasToken() *string {
	if a == nil {
		return nil
	}
	return a.SasToken
}

func (a *AzBlobAzureBlobStorage) GetSharedKey() *string {
	if a == nil {
		return nil
	}
	return a.SharedKey
}

func (a *AzBlobAzureBlobStorage) GetStorage() string {
	return "AzBlob"
}

func (a *AzBlobAzureBlobStorage) GetStorageAccount() string {
	if a == nil {
		return ""
	}
	return a.StorageAccount
}

type SourceFileS3AmazonWebServices struct {
	// In order to access private Buckets stored on AWS S3, this connector would need credentials with the proper permissions. If accessing publicly available data, this field is not necessary.
	AwsAccessKeyID *string `json:"aws_access_key_id,omitempty"`
	// In order to access private Buckets stored on AWS S3, this connector would need credentials with the proper permissions. If accessing publicly available data, this field is not necessary.
	AwsSecretAccessKey *string `json:"aws_secret_access_key,omitempty"`
	storage            string  `const:"S3" json:"storage"`
}

func (s SourceFileS3AmazonWebServices) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceFileS3AmazonWebServices) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceFileS3AmazonWebServices) GetAwsAccessKeyID() *string {
	if s == nil {
		return nil
	}
	return s.AwsAccessKeyID
}

func (s *SourceFileS3AmazonWebServices) GetAwsSecretAccessKey() *string {
	if s == nil {
		return nil
	}
	return s.AwsSecretAccessKey
}

func (s *SourceFileS3AmazonWebServices) GetStorage() string {
	return "S3"
}

type GCSGoogleCloudStorage struct {
	// In order to access private Buckets stored on Google Cloud, this connector would need a service account json credentials with the proper permissions as described <a href="https://cloud.google.com/iam/docs/service-accounts" target="_blank">here</a>. Please generate the credentials.json file and copy/paste its content to this field (expecting JSON formats). If accessing publicly available data, this field is not necessary.
	ServiceAccountJSON *string `json:"service_account_json,omitempty"`
	storage            string  `const:"GCS" json:"storage"`
}

func (g GCSGoogleCloudStorage) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GCSGoogleCloudStorage) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (g *GCSGoogleCloudStorage) GetServiceAccountJSON() *string {
	if g == nil {
		return nil
	}
	return g.ServiceAccountJSON
}

func (g *GCSGoogleCloudStorage) GetStorage() string {
	return "GCS"
}

type HTTPSPublicWeb struct {
	storage string `const:"HTTPS" json:"storage"`
	// Add User-Agent to request
	UserAgent *bool `default:"false" json:"user_agent"`
}

func (h HTTPSPublicWeb) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(h, "", false)
}

func (h *HTTPSPublicWeb) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &h, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (h *HTTPSPublicWeb) GetStorage() string {
	return "HTTPS"
}

func (h *HTTPSPublicWeb) GetUserAgent() *bool {
	if h == nil {
		return nil
	}
	return h.UserAgent
}

type StorageProviderType string

const (
	StorageProviderTypeHTTPSPublicWeb                 StorageProviderType = "HTTPS: Public Web"
	StorageProviderTypeGCSGoogleCloudStorage          StorageProviderType = "GCS: Google Cloud Storage"
	StorageProviderTypeSourceFileS3AmazonWebServices  StorageProviderType = "source-file_S3: Amazon Web Services"
	StorageProviderTypeAzBlobAzureBlobStorage         StorageProviderType = "AzBlob: Azure Blob Storage"
	StorageProviderTypeSSHSecureShell                 StorageProviderType = "SSH: Secure Shell"
	StorageProviderTypeSCPSecureCopyProtocol          StorageProviderType = "SCP: Secure copy protocol"
	StorageProviderTypeSFTPSecureFileTransferProtocol StorageProviderType = "SFTP: Secure File Transfer Protocol"
)

// StorageProvider - The storage Provider or Location of the file(s) which should be replicated.
type StorageProvider struct {
	HTTPSPublicWeb                 *HTTPSPublicWeb                 `queryParam:"inline" union:"member"`
	GCSGoogleCloudStorage          *GCSGoogleCloudStorage          `queryParam:"inline" union:"member"`
	SourceFileS3AmazonWebServices  *SourceFileS3AmazonWebServices  `queryParam:"inline" union:"member"`
	AzBlobAzureBlobStorage         *AzBlobAzureBlobStorage         `queryParam:"inline" union:"member"`
	SSHSecureShell                 *SSHSecureShell                 `queryParam:"inline" union:"member"`
	SCPSecureCopyProtocol          *SCPSecureCopyProtocol          `queryParam:"inline" union:"member"`
	SFTPSecureFileTransferProtocol *SFTPSecureFileTransferProtocol `queryParam:"inline" union:"member"`

	Type StorageProviderType
}

func CreateStorageProviderHTTPSPublicWeb(httpsPublicWeb HTTPSPublicWeb) StorageProvider {
	typ := StorageProviderTypeHTTPSPublicWeb

	return StorageProvider{
		HTTPSPublicWeb: &httpsPublicWeb,
		Type:           typ,
	}
}

func CreateStorageProviderGCSGoogleCloudStorage(gcsGoogleCloudStorage GCSGoogleCloudStorage) StorageProvider {
	typ := StorageProviderTypeGCSGoogleCloudStorage

	return StorageProvider{
		GCSGoogleCloudStorage: &gcsGoogleCloudStorage,
		Type:                  typ,
	}
}

func CreateStorageProviderSourceFileS3AmazonWebServices(sourceFileS3AmazonWebServices SourceFileS3AmazonWebServices) StorageProvider {
	typ := StorageProviderTypeSourceFileS3AmazonWebServices

	return StorageProvider{
		SourceFileS3AmazonWebServices: &sourceFileS3AmazonWebServices,
		Type:                          typ,
	}
}

func CreateStorageProviderAzBlobAzureBlobStorage(azBlobAzureBlobStorage AzBlobAzureBlobStorage) StorageProvider {
	typ := StorageProviderTypeAzBlobAzureBlobStorage

	return StorageProvider{
		AzBlobAzureBlobStorage: &azBlobAzureBlobStorage,
		Type:                   typ,
	}
}

func CreateStorageProviderSSHSecureShell(sshSecureShell SSHSecureShell) StorageProvider {
	typ := StorageProviderTypeSSHSecureShell

	return StorageProvider{
		SSHSecureShell: &sshSecureShell,
		Type:           typ,
	}
}

func CreateStorageProviderSCPSecureCopyProtocol(scpSecureCopyProtocol SCPSecureCopyProtocol) StorageProvider {
	typ := StorageProviderTypeSCPSecureCopyProtocol

	return StorageProvider{
		SCPSecureCopyProtocol: &scpSecureCopyProtocol,
		Type:                  typ,
	}
}

func CreateStorageProviderSFTPSecureFileTransferProtocol(sftpSecureFileTransferProtocol SFTPSecureFileTransferProtocol) StorageProvider {
	typ := StorageProviderTypeSFTPSecureFileTransferProtocol

	return StorageProvider{
		SFTPSecureFileTransferProtocol: &sftpSecureFileTransferProtocol,
		Type:                           typ,
	}
}

func (u *StorageProvider) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var httpsPublicWeb HTTPSPublicWeb = HTTPSPublicWeb{}
	if err := utils.UnmarshalJSON(data, &httpsPublicWeb, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  StorageProviderTypeHTTPSPublicWeb,
			Value: &httpsPublicWeb,
		})
	}

	var gcsGoogleCloudStorage GCSGoogleCloudStorage = GCSGoogleCloudStorage{}
	if err := utils.UnmarshalJSON(data, &gcsGoogleCloudStorage, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  StorageProviderTypeGCSGoogleCloudStorage,
			Value: &gcsGoogleCloudStorage,
		})
	}

	var sourceFileS3AmazonWebServices SourceFileS3AmazonWebServices = SourceFileS3AmazonWebServices{}
	if err := utils.UnmarshalJSON(data, &sourceFileS3AmazonWebServices, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  StorageProviderTypeSourceFileS3AmazonWebServices,
			Value: &sourceFileS3AmazonWebServices,
		})
	}

	var azBlobAzureBlobStorage AzBlobAzureBlobStorage = AzBlobAzureBlobStorage{}
	if err := utils.UnmarshalJSON(data, &azBlobAzureBlobStorage, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  StorageProviderTypeAzBlobAzureBlobStorage,
			Value: &azBlobAzureBlobStorage,
		})
	}

	var sshSecureShell SSHSecureShell = SSHSecureShell{}
	if err := utils.UnmarshalJSON(data, &sshSecureShell, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  StorageProviderTypeSSHSecureShell,
			Value: &sshSecureShell,
		})
	}

	var scpSecureCopyProtocol SCPSecureCopyProtocol = SCPSecureCopyProtocol{}
	if err := utils.UnmarshalJSON(data, &scpSecureCopyProtocol, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  StorageProviderTypeSCPSecureCopyProtocol,
			Value: &scpSecureCopyProtocol,
		})
	}

	var sftpSecureFileTransferProtocol SFTPSecureFileTransferProtocol = SFTPSecureFileTransferProtocol{}
	if err := utils.UnmarshalJSON(data, &sftpSecureFileTransferProtocol, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  StorageProviderTypeSFTPSecureFileTransferProtocol,
			Value: &sftpSecureFileTransferProtocol,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for StorageProvider", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for StorageProvider", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(StorageProviderType)
	switch best.Type {
	case StorageProviderTypeHTTPSPublicWeb:
		u.HTTPSPublicWeb = best.Value.(*HTTPSPublicWeb)
		return nil
	case StorageProviderTypeGCSGoogleCloudStorage:
		u.GCSGoogleCloudStorage = best.Value.(*GCSGoogleCloudStorage)
		return nil
	case StorageProviderTypeSourceFileS3AmazonWebServices:
		u.SourceFileS3AmazonWebServices = best.Value.(*SourceFileS3AmazonWebServices)
		return nil
	case StorageProviderTypeAzBlobAzureBlobStorage:
		u.AzBlobAzureBlobStorage = best.Value.(*AzBlobAzureBlobStorage)
		return nil
	case StorageProviderTypeSSHSecureShell:
		u.SSHSecureShell = best.Value.(*SSHSecureShell)
		return nil
	case StorageProviderTypeSCPSecureCopyProtocol:
		u.SCPSecureCopyProtocol = best.Value.(*SCPSecureCopyProtocol)
		return nil
	case StorageProviderTypeSFTPSecureFileTransferProtocol:
		u.SFTPSecureFileTransferProtocol = best.Value.(*SFTPSecureFileTransferProtocol)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for StorageProvider", string(data))
}

func (u StorageProvider) MarshalJSON() ([]byte, error) {
	if u.HTTPSPublicWeb != nil {
		return utils.MarshalJSON(u.HTTPSPublicWeb, "", true)
	}

	if u.GCSGoogleCloudStorage != nil {
		return utils.MarshalJSON(u.GCSGoogleCloudStorage, "", true)
	}

	if u.SourceFileS3AmazonWebServices != nil {
		return utils.MarshalJSON(u.SourceFileS3AmazonWebServices, "", true)
	}

	if u.AzBlobAzureBlobStorage != nil {
		return utils.MarshalJSON(u.AzBlobAzureBlobStorage, "", true)
	}

	if u.SSHSecureShell != nil {
		return utils.MarshalJSON(u.SSHSecureShell, "", true)
	}

	if u.SCPSecureCopyProtocol != nil {
		return utils.MarshalJSON(u.SCPSecureCopyProtocol, "", true)
	}

	if u.SFTPSecureFileTransferProtocol != nil {
		return utils.MarshalJSON(u.SFTPSecureFileTransferProtocol, "", true)
	}

	return nil, errors.New("could not marshal union type StorageProvider: all fields are null")
}

type SourceFileSourceType string

const (
	SourceFileSourceTypeFile SourceFileSourceType = "file"
)

func (e SourceFileSourceType) ToPointer() *SourceFileSourceType {
	return &e
}
func (e *SourceFileSourceType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "file":
		*e = SourceFileSourceType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceFileSourceType: %v", v)
	}
}

type SourceFile struct {
	// The Name of the final table to replicate this file into (should include letters, numbers dash and underscores only).
	DatasetName string `json:"dataset_name"`
	// The Format of the file which should be replicated (Warning: some formats may be experimental, please refer to the docs).
	Format *FileFormat `default:"csv" json:"format"`
	// The storage Provider or Location of the file(s) which should be replicated.
	Provider StorageProvider `json:"provider"`
	// This should be a string in JSON format. It depends on the chosen file format to provide additional options and tune its behavior.
	ReaderOptions *string `json:"reader_options,omitempty"`
	// The URL path to access the file which should be replicated.
	URL                  string                `json:"url"`
	sourceType           *SourceFileSourceType `const:"file" json:"sourceType"`
	AdditionalProperties any                   `additionalProperties:"true" json:"-"`
}

func (s SourceFile) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceFile) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceFile) GetDatasetName() string {
	if s == nil {
		return ""
	}
	return s.DatasetName
}

func (s *SourceFile) GetFormat() *FileFormat {
	if s == nil {
		return nil
	}
	return s.Format
}

func (s *SourceFile) GetProvider() StorageProvider {
	if s == nil {
		return StorageProvider{}
	}
	return s.Provider
}

func (s *SourceFile) GetReaderOptions() *string {
	if s == nil {
		return nil
	}
	return s.ReaderOptions
}

func (s *SourceFile) GetURL() string {
	if s == nil {
		return ""
	}
	return s.URL
}

func (s *SourceFile) GetSourceType() *SourceFileSourceType {
	return SourceFileSourceTypeFile.ToPointer()
}

func (s *SourceFile) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}
