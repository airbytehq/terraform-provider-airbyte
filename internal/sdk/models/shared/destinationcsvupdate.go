// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/types"
)

type DestinationCsvUpdateSpace struct {
	delimiter *string `const:"\\u0020" json:"delimiter,omitempty"`
}

func (d DestinationCsvUpdateSpace) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationCsvUpdateSpace) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationCsvUpdateSpace) GetDelimiter() *string {
	return types.Pointer("\\u0020")
}

type DestinationCsvUpdateTab struct {
	delimiter *string `const:"\\u0009" json:"delimiter,omitempty"`
}

func (d DestinationCsvUpdateTab) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationCsvUpdateTab) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationCsvUpdateTab) GetDelimiter() *string {
	return types.Pointer("\\u0009")
}

type DestinationCsvUpdatePipe struct {
	delimiter *string `const:"\\u007c" json:"delimiter,omitempty"`
}

func (d DestinationCsvUpdatePipe) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationCsvUpdatePipe) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationCsvUpdatePipe) GetDelimiter() *string {
	return types.Pointer("\\u007c")
}

type DestinationCsvUpdateSemicolon struct {
	delimiter *string `const:"\\u003b" json:"delimiter,omitempty"`
}

func (d DestinationCsvUpdateSemicolon) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationCsvUpdateSemicolon) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationCsvUpdateSemicolon) GetDelimiter() *string {
	return types.Pointer("\\u003b")
}

type DestinationCsvUpdateComma struct {
	delimiter *string `const:"\\u002c" json:"delimiter,omitempty"`
}

func (d DestinationCsvUpdateComma) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationCsvUpdateComma) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationCsvUpdateComma) GetDelimiter() *string {
	return types.Pointer("\\u002c")
}

type DestinationCsvUpdateDelimiterType string

const (
	DestinationCsvUpdateDelimiterTypeDestinationCsvUpdateComma     DestinationCsvUpdateDelimiterType = "destination-csv-update_Comma"
	DestinationCsvUpdateDelimiterTypeDestinationCsvUpdateSemicolon DestinationCsvUpdateDelimiterType = "destination-csv-update_Semicolon"
	DestinationCsvUpdateDelimiterTypeDestinationCsvUpdatePipe      DestinationCsvUpdateDelimiterType = "destination-csv-update_Pipe"
	DestinationCsvUpdateDelimiterTypeDestinationCsvUpdateTab       DestinationCsvUpdateDelimiterType = "destination-csv-update_Tab"
	DestinationCsvUpdateDelimiterTypeDestinationCsvUpdateSpace     DestinationCsvUpdateDelimiterType = "destination-csv-update_Space"
)

// DestinationCsvUpdateDelimiter - The character delimiting individual cells in the CSV data.
type DestinationCsvUpdateDelimiter struct {
	DestinationCsvUpdateComma     *DestinationCsvUpdateComma     `queryParam:"inline" union:"member"`
	DestinationCsvUpdateSemicolon *DestinationCsvUpdateSemicolon `queryParam:"inline" union:"member"`
	DestinationCsvUpdatePipe      *DestinationCsvUpdatePipe      `queryParam:"inline" union:"member"`
	DestinationCsvUpdateTab       *DestinationCsvUpdateTab       `queryParam:"inline" union:"member"`
	DestinationCsvUpdateSpace     *DestinationCsvUpdateSpace     `queryParam:"inline" union:"member"`

	Type DestinationCsvUpdateDelimiterType
}

func CreateDestinationCsvUpdateDelimiterDestinationCsvUpdateComma(destinationCsvUpdateComma DestinationCsvUpdateComma) DestinationCsvUpdateDelimiter {
	typ := DestinationCsvUpdateDelimiterTypeDestinationCsvUpdateComma

	return DestinationCsvUpdateDelimiter{
		DestinationCsvUpdateComma: &destinationCsvUpdateComma,
		Type:                      typ,
	}
}

func CreateDestinationCsvUpdateDelimiterDestinationCsvUpdateSemicolon(destinationCsvUpdateSemicolon DestinationCsvUpdateSemicolon) DestinationCsvUpdateDelimiter {
	typ := DestinationCsvUpdateDelimiterTypeDestinationCsvUpdateSemicolon

	return DestinationCsvUpdateDelimiter{
		DestinationCsvUpdateSemicolon: &destinationCsvUpdateSemicolon,
		Type:                          typ,
	}
}

func CreateDestinationCsvUpdateDelimiterDestinationCsvUpdatePipe(destinationCsvUpdatePipe DestinationCsvUpdatePipe) DestinationCsvUpdateDelimiter {
	typ := DestinationCsvUpdateDelimiterTypeDestinationCsvUpdatePipe

	return DestinationCsvUpdateDelimiter{
		DestinationCsvUpdatePipe: &destinationCsvUpdatePipe,
		Type:                     typ,
	}
}

func CreateDestinationCsvUpdateDelimiterDestinationCsvUpdateTab(destinationCsvUpdateTab DestinationCsvUpdateTab) DestinationCsvUpdateDelimiter {
	typ := DestinationCsvUpdateDelimiterTypeDestinationCsvUpdateTab

	return DestinationCsvUpdateDelimiter{
		DestinationCsvUpdateTab: &destinationCsvUpdateTab,
		Type:                    typ,
	}
}

func CreateDestinationCsvUpdateDelimiterDestinationCsvUpdateSpace(destinationCsvUpdateSpace DestinationCsvUpdateSpace) DestinationCsvUpdateDelimiter {
	typ := DestinationCsvUpdateDelimiterTypeDestinationCsvUpdateSpace

	return DestinationCsvUpdateDelimiter{
		DestinationCsvUpdateSpace: &destinationCsvUpdateSpace,
		Type:                      typ,
	}
}

func (u *DestinationCsvUpdateDelimiter) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var destinationCsvUpdateComma DestinationCsvUpdateComma = DestinationCsvUpdateComma{}
	if err := utils.UnmarshalJSON(data, &destinationCsvUpdateComma, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationCsvUpdateDelimiterTypeDestinationCsvUpdateComma,
			Value: &destinationCsvUpdateComma,
		})
	}

	var destinationCsvUpdateSemicolon DestinationCsvUpdateSemicolon = DestinationCsvUpdateSemicolon{}
	if err := utils.UnmarshalJSON(data, &destinationCsvUpdateSemicolon, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationCsvUpdateDelimiterTypeDestinationCsvUpdateSemicolon,
			Value: &destinationCsvUpdateSemicolon,
		})
	}

	var destinationCsvUpdatePipe DestinationCsvUpdatePipe = DestinationCsvUpdatePipe{}
	if err := utils.UnmarshalJSON(data, &destinationCsvUpdatePipe, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationCsvUpdateDelimiterTypeDestinationCsvUpdatePipe,
			Value: &destinationCsvUpdatePipe,
		})
	}

	var destinationCsvUpdateTab DestinationCsvUpdateTab = DestinationCsvUpdateTab{}
	if err := utils.UnmarshalJSON(data, &destinationCsvUpdateTab, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationCsvUpdateDelimiterTypeDestinationCsvUpdateTab,
			Value: &destinationCsvUpdateTab,
		})
	}

	var destinationCsvUpdateSpace DestinationCsvUpdateSpace = DestinationCsvUpdateSpace{}
	if err := utils.UnmarshalJSON(data, &destinationCsvUpdateSpace, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationCsvUpdateDelimiterTypeDestinationCsvUpdateSpace,
			Value: &destinationCsvUpdateSpace,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationCsvUpdateDelimiter", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationCsvUpdateDelimiter", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(DestinationCsvUpdateDelimiterType)
	switch best.Type {
	case DestinationCsvUpdateDelimiterTypeDestinationCsvUpdateComma:
		u.DestinationCsvUpdateComma = best.Value.(*DestinationCsvUpdateComma)
		return nil
	case DestinationCsvUpdateDelimiterTypeDestinationCsvUpdateSemicolon:
		u.DestinationCsvUpdateSemicolon = best.Value.(*DestinationCsvUpdateSemicolon)
		return nil
	case DestinationCsvUpdateDelimiterTypeDestinationCsvUpdatePipe:
		u.DestinationCsvUpdatePipe = best.Value.(*DestinationCsvUpdatePipe)
		return nil
	case DestinationCsvUpdateDelimiterTypeDestinationCsvUpdateTab:
		u.DestinationCsvUpdateTab = best.Value.(*DestinationCsvUpdateTab)
		return nil
	case DestinationCsvUpdateDelimiterTypeDestinationCsvUpdateSpace:
		u.DestinationCsvUpdateSpace = best.Value.(*DestinationCsvUpdateSpace)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationCsvUpdateDelimiter", string(data))
}

func (u DestinationCsvUpdateDelimiter) MarshalJSON() ([]byte, error) {
	if u.DestinationCsvUpdateComma != nil {
		return utils.MarshalJSON(u.DestinationCsvUpdateComma, "", true)
	}

	if u.DestinationCsvUpdateSemicolon != nil {
		return utils.MarshalJSON(u.DestinationCsvUpdateSemicolon, "", true)
	}

	if u.DestinationCsvUpdatePipe != nil {
		return utils.MarshalJSON(u.DestinationCsvUpdatePipe, "", true)
	}

	if u.DestinationCsvUpdateTab != nil {
		return utils.MarshalJSON(u.DestinationCsvUpdateTab, "", true)
	}

	if u.DestinationCsvUpdateSpace != nil {
		return utils.MarshalJSON(u.DestinationCsvUpdateSpace, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationCsvUpdateDelimiter: all fields are null")
}

type DestinationCsvUpdateDestinationType string

const (
	DestinationCsvUpdateDestinationTypeCsv DestinationCsvUpdateDestinationType = "csv"
)

func (e DestinationCsvUpdateDestinationType) ToPointer() *DestinationCsvUpdateDestinationType {
	return &e
}
func (e *DestinationCsvUpdateDestinationType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "csv":
		*e = DestinationCsvUpdateDestinationType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationCsvUpdateDestinationType: %v", v)
	}
}

type DestinationCsvUpdate struct {
	// The character delimiting individual cells in the CSV data.
	DelimiterType *DestinationCsvUpdateDelimiter `json:"delimiter_type,omitempty"`
	// Path to the directory where csv files will be written. The destination uses the local mount "/local" and any data files will be placed inside that local mount. For more information check out our <a href="https://docs.airbyte.com/integrations/destinations/local-csv">docs</a>
	DestinationPath      *string                              `json:"destination_path,omitempty"`
	destinationType      *DestinationCsvUpdateDestinationType `const:"csv" json:"destinationType"`
	AdditionalProperties any                                  `additionalProperties:"true" json:"-"`
}

func (d DestinationCsvUpdate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationCsvUpdate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationCsvUpdate) GetDelimiterType() *DestinationCsvUpdateDelimiter {
	if d == nil {
		return nil
	}
	return d.DelimiterType
}

func (d *DestinationCsvUpdate) GetDestinationPath() *string {
	if d == nil {
		return nil
	}
	return d.DestinationPath
}

func (d *DestinationCsvUpdate) GetDestinationType() *DestinationCsvUpdateDestinationType {
	return DestinationCsvUpdateDestinationTypeCsv.ToPointer()
}

func (d *DestinationCsvUpdate) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}
