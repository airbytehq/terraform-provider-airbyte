// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

type SourcePostgresSchemasReplicationMethodMethod string

const (
	SourcePostgresSchemasReplicationMethodMethodStandard SourcePostgresSchemasReplicationMethodMethod = "Standard"
)

func (e SourcePostgresSchemasReplicationMethodMethod) ToPointer() *SourcePostgresSchemasReplicationMethodMethod {
	return &e
}
func (e *SourcePostgresSchemasReplicationMethodMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Standard":
		*e = SourcePostgresSchemasReplicationMethodMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresSchemasReplicationMethodMethod: %v", v)
	}
}

// SourcePostgresScanChangesWithUserDefinedCursor - Incrementally detects new inserts and updates using the <a href="https://docs.airbyte.com/understanding-airbyte/connections/incremental-append/#user-defined-cursor">cursor column</a> chosen when configuring a connection (e.g. created_at, updated_at).
type SourcePostgresScanChangesWithUserDefinedCursor struct {
	method SourcePostgresSchemasReplicationMethodMethod `const:"Standard" json:"method"`
}

func (s SourcePostgresScanChangesWithUserDefinedCursor) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresScanChangesWithUserDefinedCursor) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresScanChangesWithUserDefinedCursor) GetMethod() SourcePostgresSchemasReplicationMethodMethod {
	return SourcePostgresSchemasReplicationMethodMethodStandard
}

type SourcePostgresSchemasMethod string

const (
	SourcePostgresSchemasMethodXmin SourcePostgresSchemasMethod = "Xmin"
)

func (e SourcePostgresSchemasMethod) ToPointer() *SourcePostgresSchemasMethod {
	return &e
}
func (e *SourcePostgresSchemasMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Xmin":
		*e = SourcePostgresSchemasMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresSchemasMethod: %v", v)
	}
}

// SourcePostgresDetectChangesWithXminSystemColumn - <i>Recommended</i> - Incrementally reads new inserts and updates via Postgres <a href="https://docs.airbyte.com/integrations/sources/postgres/#xmin">Xmin system column</a>. Suitable for databases that have low transaction pressure.
type SourcePostgresDetectChangesWithXminSystemColumn struct {
	method SourcePostgresSchemasMethod `const:"Xmin" json:"method"`
}

func (s SourcePostgresDetectChangesWithXminSystemColumn) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresDetectChangesWithXminSystemColumn) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresDetectChangesWithXminSystemColumn) GetMethod() SourcePostgresSchemasMethod {
	return SourcePostgresSchemasMethodXmin
}

// SourcePostgresInvalidCDCPositionBehaviorAdvanced - Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value into the WAL. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss.
type SourcePostgresInvalidCDCPositionBehaviorAdvanced string

const (
	SourcePostgresInvalidCDCPositionBehaviorAdvancedFailSync   SourcePostgresInvalidCDCPositionBehaviorAdvanced = "Fail sync"
	SourcePostgresInvalidCDCPositionBehaviorAdvancedReSyncData SourcePostgresInvalidCDCPositionBehaviorAdvanced = "Re-sync data"
)

func (e SourcePostgresInvalidCDCPositionBehaviorAdvanced) ToPointer() *SourcePostgresInvalidCDCPositionBehaviorAdvanced {
	return &e
}
func (e *SourcePostgresInvalidCDCPositionBehaviorAdvanced) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Fail sync":
		fallthrough
	case "Re-sync data":
		*e = SourcePostgresInvalidCDCPositionBehaviorAdvanced(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresInvalidCDCPositionBehaviorAdvanced: %v", v)
	}
}

// SourcePostgresLSNCommitBehaviour - Determines when Airbyte should flush the LSN of processed WAL logs in the source database. `After loading Data in the destination` is default. If `While reading Data` is selected, in case of a downstream failure (while loading data into the destination), next sync would result in a full sync.
type SourcePostgresLSNCommitBehaviour string

const (
	SourcePostgresLSNCommitBehaviourWhileReadingData                 SourcePostgresLSNCommitBehaviour = "While reading Data"
	SourcePostgresLSNCommitBehaviourAfterLoadingDataInTheDestination SourcePostgresLSNCommitBehaviour = "After loading Data in the destination"
)

func (e SourcePostgresLSNCommitBehaviour) ToPointer() *SourcePostgresLSNCommitBehaviour {
	return &e
}
func (e *SourcePostgresLSNCommitBehaviour) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "While reading Data":
		fallthrough
	case "After loading Data in the destination":
		*e = SourcePostgresLSNCommitBehaviour(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresLSNCommitBehaviour: %v", v)
	}
}

type SourcePostgresMethod string

const (
	SourcePostgresMethodCdc SourcePostgresMethod = "CDC"
)

func (e SourcePostgresMethod) ToPointer() *SourcePostgresMethod {
	return &e
}
func (e *SourcePostgresMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CDC":
		*e = SourcePostgresMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresMethod: %v", v)
	}
}

// SourcePostgresPlugin - A logical decoding plugin installed on the PostgreSQL server.
type SourcePostgresPlugin string

const (
	SourcePostgresPluginPgoutput SourcePostgresPlugin = "pgoutput"
)

func (e SourcePostgresPlugin) ToPointer() *SourcePostgresPlugin {
	return &e
}
func (e *SourcePostgresPlugin) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "pgoutput":
		*e = SourcePostgresPlugin(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresPlugin: %v", v)
	}
}

// SourcePostgresReadChangesUsingWriteAheadLogCDC - <i>Recommended</i> - Incrementally reads new inserts, updates, and deletes using the Postgres <a href="https://docs.airbyte.com/integrations/sources/postgres/#cdc">write-ahead log (WAL)</a>. This needs to be configured on the source database itself. Recommended for tables of any size.
type SourcePostgresReadChangesUsingWriteAheadLogCDC struct {
	AdditionalProperties any `additionalProperties:"true" json:"-"`
	// Specifies a query that the connector executes on the source database when the connector sends a heartbeat message. Please see the <a href="https://docs.airbyte.com/integrations/sources/postgres/postgres-troubleshooting#advanced-wal-disk-consumption-and-heartbeat-action-query">setup guide</a> for how and when to configure this setting.
	HeartbeatActionQuery *string `default:"" json:"heartbeat_action_query"`
	// The amount of time an initial load is allowed to continue for before catching up on CDC logs.
	InitialLoadTimeoutHours *int64 `default:"8" json:"initial_load_timeout_hours"`
	// The amount of time the connector will wait when it launches to determine if there is new data to sync or not. Defaults to 1200 seconds. Valid range: 120 seconds to 2400 seconds. Read about <a href="https://docs.airbyte.com/integrations/sources/postgres/postgres-troubleshooting#advanced-setting-up-initial-cdc-waiting-time">initial waiting time</a>.
	InitialWaitingSeconds *int64 `default:"1200" json:"initial_waiting_seconds"`
	// Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value into the WAL. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss.
	InvalidCdcCursorPositionBehavior *SourcePostgresInvalidCDCPositionBehaviorAdvanced `default:"Fail sync" json:"invalid_cdc_cursor_position_behavior"`
	// Determines when Airbyte should flush the LSN of processed WAL logs in the source database. `After loading Data in the destination` is default. If `While reading Data` is selected, in case of a downstream failure (while loading data into the destination), next sync would result in a full sync.
	LsnCommitBehaviour *SourcePostgresLSNCommitBehaviour `default:"After loading Data in the destination" json:"lsn_commit_behaviour"`
	method             SourcePostgresMethod              `const:"CDC" json:"method"`
	// A logical decoding plugin installed on the PostgreSQL server.
	Plugin *SourcePostgresPlugin `default:"pgoutput" json:"plugin"`
	// A Postgres publication used for consuming changes. Read about <a href="https://docs.airbyte.com/integrations/sources/postgres#step-4-create-publications-and-replication-identities-for-tables">publications and replication identities</a>.
	Publication string `json:"publication"`
	// The size of the internal queue. This may interfere with memory consumption and efficiency of the connector, please be careful.
	QueueSize *int64 `default:"10000" json:"queue_size"`
	// A plugin logical replication slot. Read about <a href="https://docs.airbyte.com/integrations/sources/postgres#step-3-create-replication-slot">replication slots</a>.
	ReplicationSlot string `json:"replication_slot"`
}

func (s SourcePostgresReadChangesUsingWriteAheadLogCDC) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresReadChangesUsingWriteAheadLogCDC) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresReadChangesUsingWriteAheadLogCDC) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *SourcePostgresReadChangesUsingWriteAheadLogCDC) GetHeartbeatActionQuery() *string {
	if o == nil {
		return nil
	}
	return o.HeartbeatActionQuery
}

func (o *SourcePostgresReadChangesUsingWriteAheadLogCDC) GetInitialLoadTimeoutHours() *int64 {
	if o == nil {
		return nil
	}
	return o.InitialLoadTimeoutHours
}

func (o *SourcePostgresReadChangesUsingWriteAheadLogCDC) GetInitialWaitingSeconds() *int64 {
	if o == nil {
		return nil
	}
	return o.InitialWaitingSeconds
}

func (o *SourcePostgresReadChangesUsingWriteAheadLogCDC) GetInvalidCdcCursorPositionBehavior() *SourcePostgresInvalidCDCPositionBehaviorAdvanced {
	if o == nil {
		return nil
	}
	return o.InvalidCdcCursorPositionBehavior
}

func (o *SourcePostgresReadChangesUsingWriteAheadLogCDC) GetLsnCommitBehaviour() *SourcePostgresLSNCommitBehaviour {
	if o == nil {
		return nil
	}
	return o.LsnCommitBehaviour
}

func (o *SourcePostgresReadChangesUsingWriteAheadLogCDC) GetMethod() SourcePostgresMethod {
	return SourcePostgresMethodCdc
}

func (o *SourcePostgresReadChangesUsingWriteAheadLogCDC) GetPlugin() *SourcePostgresPlugin {
	if o == nil {
		return nil
	}
	return o.Plugin
}

func (o *SourcePostgresReadChangesUsingWriteAheadLogCDC) GetPublication() string {
	if o == nil {
		return ""
	}
	return o.Publication
}

func (o *SourcePostgresReadChangesUsingWriteAheadLogCDC) GetQueueSize() *int64 {
	if o == nil {
		return nil
	}
	return o.QueueSize
}

func (o *SourcePostgresReadChangesUsingWriteAheadLogCDC) GetReplicationSlot() string {
	if o == nil {
		return ""
	}
	return o.ReplicationSlot
}

type SourcePostgresUpdateMethodType string

const (
	SourcePostgresUpdateMethodTypeSourcePostgresReadChangesUsingWriteAheadLogCDC  SourcePostgresUpdateMethodType = "source-postgres_Read Changes using Write-Ahead Log (CDC)"
	SourcePostgresUpdateMethodTypeSourcePostgresDetectChangesWithXminSystemColumn SourcePostgresUpdateMethodType = "source-postgres_Detect Changes with Xmin System Column"
	SourcePostgresUpdateMethodTypeSourcePostgresScanChangesWithUserDefinedCursor  SourcePostgresUpdateMethodType = "source-postgres_Scan Changes with User Defined Cursor"
)

// SourcePostgresUpdateMethod - Configures how data is extracted from the database.
type SourcePostgresUpdateMethod struct {
	SourcePostgresReadChangesUsingWriteAheadLogCDC  *SourcePostgresReadChangesUsingWriteAheadLogCDC
	SourcePostgresDetectChangesWithXminSystemColumn *SourcePostgresDetectChangesWithXminSystemColumn
	SourcePostgresScanChangesWithUserDefinedCursor  *SourcePostgresScanChangesWithUserDefinedCursor

	Type SourcePostgresUpdateMethodType
}

func CreateSourcePostgresUpdateMethodSourcePostgresReadChangesUsingWriteAheadLogCDC(sourcePostgresReadChangesUsingWriteAheadLogCDC SourcePostgresReadChangesUsingWriteAheadLogCDC) SourcePostgresUpdateMethod {
	typ := SourcePostgresUpdateMethodTypeSourcePostgresReadChangesUsingWriteAheadLogCDC

	return SourcePostgresUpdateMethod{
		SourcePostgresReadChangesUsingWriteAheadLogCDC: &sourcePostgresReadChangesUsingWriteAheadLogCDC,
		Type: typ,
	}
}

func CreateSourcePostgresUpdateMethodSourcePostgresDetectChangesWithXminSystemColumn(sourcePostgresDetectChangesWithXminSystemColumn SourcePostgresDetectChangesWithXminSystemColumn) SourcePostgresUpdateMethod {
	typ := SourcePostgresUpdateMethodTypeSourcePostgresDetectChangesWithXminSystemColumn

	return SourcePostgresUpdateMethod{
		SourcePostgresDetectChangesWithXminSystemColumn: &sourcePostgresDetectChangesWithXminSystemColumn,
		Type: typ,
	}
}

func CreateSourcePostgresUpdateMethodSourcePostgresScanChangesWithUserDefinedCursor(sourcePostgresScanChangesWithUserDefinedCursor SourcePostgresScanChangesWithUserDefinedCursor) SourcePostgresUpdateMethod {
	typ := SourcePostgresUpdateMethodTypeSourcePostgresScanChangesWithUserDefinedCursor

	return SourcePostgresUpdateMethod{
		SourcePostgresScanChangesWithUserDefinedCursor: &sourcePostgresScanChangesWithUserDefinedCursor,
		Type: typ,
	}
}

func (u *SourcePostgresUpdateMethod) UnmarshalJSON(data []byte) error {

	var sourcePostgresDetectChangesWithXminSystemColumn SourcePostgresDetectChangesWithXminSystemColumn = SourcePostgresDetectChangesWithXminSystemColumn{}
	if err := utils.UnmarshalJSON(data, &sourcePostgresDetectChangesWithXminSystemColumn, "", true, true); err == nil {
		u.SourcePostgresDetectChangesWithXminSystemColumn = &sourcePostgresDetectChangesWithXminSystemColumn
		u.Type = SourcePostgresUpdateMethodTypeSourcePostgresDetectChangesWithXminSystemColumn
		return nil
	}

	var sourcePostgresScanChangesWithUserDefinedCursor SourcePostgresScanChangesWithUserDefinedCursor = SourcePostgresScanChangesWithUserDefinedCursor{}
	if err := utils.UnmarshalJSON(data, &sourcePostgresScanChangesWithUserDefinedCursor, "", true, true); err == nil {
		u.SourcePostgresScanChangesWithUserDefinedCursor = &sourcePostgresScanChangesWithUserDefinedCursor
		u.Type = SourcePostgresUpdateMethodTypeSourcePostgresScanChangesWithUserDefinedCursor
		return nil
	}

	var sourcePostgresReadChangesUsingWriteAheadLogCDC SourcePostgresReadChangesUsingWriteAheadLogCDC = SourcePostgresReadChangesUsingWriteAheadLogCDC{}
	if err := utils.UnmarshalJSON(data, &sourcePostgresReadChangesUsingWriteAheadLogCDC, "", true, true); err == nil {
		u.SourcePostgresReadChangesUsingWriteAheadLogCDC = &sourcePostgresReadChangesUsingWriteAheadLogCDC
		u.Type = SourcePostgresUpdateMethodTypeSourcePostgresReadChangesUsingWriteAheadLogCDC
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourcePostgresUpdateMethod", string(data))
}

func (u SourcePostgresUpdateMethod) MarshalJSON() ([]byte, error) {
	if u.SourcePostgresReadChangesUsingWriteAheadLogCDC != nil {
		return utils.MarshalJSON(u.SourcePostgresReadChangesUsingWriteAheadLogCDC, "", true)
	}

	if u.SourcePostgresDetectChangesWithXminSystemColumn != nil {
		return utils.MarshalJSON(u.SourcePostgresDetectChangesWithXminSystemColumn, "", true)
	}

	if u.SourcePostgresScanChangesWithUserDefinedCursor != nil {
		return utils.MarshalJSON(u.SourcePostgresScanChangesWithUserDefinedCursor, "", true)
	}

	return nil, errors.New("could not marshal union type SourcePostgresUpdateMethod: all fields are null")
}

type SourcePostgresPostgres string

const (
	SourcePostgresPostgresPostgres SourcePostgresPostgres = "postgres"
)

func (e SourcePostgresPostgres) ToPointer() *SourcePostgresPostgres {
	return &e
}
func (e *SourcePostgresPostgres) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "postgres":
		*e = SourcePostgresPostgres(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresPostgres: %v", v)
	}
}

type SourcePostgresSchemasSSLModeSSLModes6Mode string

const (
	SourcePostgresSchemasSSLModeSSLModes6ModeVerifyFull SourcePostgresSchemasSSLModeSSLModes6Mode = "verify-full"
)

func (e SourcePostgresSchemasSSLModeSSLModes6Mode) ToPointer() *SourcePostgresSchemasSSLModeSSLModes6Mode {
	return &e
}
func (e *SourcePostgresSchemasSSLModeSSLModes6Mode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "verify-full":
		*e = SourcePostgresSchemasSSLModeSSLModes6Mode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresSchemasSSLModeSSLModes6Mode: %v", v)
	}
}

// SourcePostgresVerifyFull - This is the most secure mode. Always require encryption and verifies the identity of the source database server.
type SourcePostgresVerifyFull struct {
	AdditionalProperties any `additionalProperties:"true" json:"-"`
	// CA certificate
	CaCertificate string `json:"ca_certificate"`
	// Client certificate
	ClientCertificate *string `json:"client_certificate,omitempty"`
	// Client key
	ClientKey *string `json:"client_key,omitempty"`
	// Password for keystorage. If you do not add it - the password will be generated automatically.
	ClientKeyPassword *string                                   `json:"client_key_password,omitempty"`
	mode              SourcePostgresSchemasSSLModeSSLModes6Mode `const:"verify-full" json:"mode"`
}

func (s SourcePostgresVerifyFull) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresVerifyFull) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresVerifyFull) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *SourcePostgresVerifyFull) GetCaCertificate() string {
	if o == nil {
		return ""
	}
	return o.CaCertificate
}

func (o *SourcePostgresVerifyFull) GetClientCertificate() *string {
	if o == nil {
		return nil
	}
	return o.ClientCertificate
}

func (o *SourcePostgresVerifyFull) GetClientKey() *string {
	if o == nil {
		return nil
	}
	return o.ClientKey
}

func (o *SourcePostgresVerifyFull) GetClientKeyPassword() *string {
	if o == nil {
		return nil
	}
	return o.ClientKeyPassword
}

func (o *SourcePostgresVerifyFull) GetMode() SourcePostgresSchemasSSLModeSSLModes6Mode {
	return SourcePostgresSchemasSSLModeSSLModes6ModeVerifyFull
}

type SourcePostgresSchemasSSLModeSSLModes5Mode string

const (
	SourcePostgresSchemasSSLModeSSLModes5ModeVerifyCa SourcePostgresSchemasSSLModeSSLModes5Mode = "verify-ca"
)

func (e SourcePostgresSchemasSSLModeSSLModes5Mode) ToPointer() *SourcePostgresSchemasSSLModeSSLModes5Mode {
	return &e
}
func (e *SourcePostgresSchemasSSLModeSSLModes5Mode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "verify-ca":
		*e = SourcePostgresSchemasSSLModeSSLModes5Mode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresSchemasSSLModeSSLModes5Mode: %v", v)
	}
}

// SourcePostgresVerifyCa - Always require encryption and verifies that the source database server has a valid SSL certificate.
type SourcePostgresVerifyCa struct {
	AdditionalProperties any `additionalProperties:"true" json:"-"`
	// CA certificate
	CaCertificate string `json:"ca_certificate"`
	// Client certificate
	ClientCertificate *string `json:"client_certificate,omitempty"`
	// Client key
	ClientKey *string `json:"client_key,omitempty"`
	// Password for keystorage. If you do not add it - the password will be generated automatically.
	ClientKeyPassword *string                                   `json:"client_key_password,omitempty"`
	mode              SourcePostgresSchemasSSLModeSSLModes5Mode `const:"verify-ca" json:"mode"`
}

func (s SourcePostgresVerifyCa) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresVerifyCa) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresVerifyCa) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *SourcePostgresVerifyCa) GetCaCertificate() string {
	if o == nil {
		return ""
	}
	return o.CaCertificate
}

func (o *SourcePostgresVerifyCa) GetClientCertificate() *string {
	if o == nil {
		return nil
	}
	return o.ClientCertificate
}

func (o *SourcePostgresVerifyCa) GetClientKey() *string {
	if o == nil {
		return nil
	}
	return o.ClientKey
}

func (o *SourcePostgresVerifyCa) GetClientKeyPassword() *string {
	if o == nil {
		return nil
	}
	return o.ClientKeyPassword
}

func (o *SourcePostgresVerifyCa) GetMode() SourcePostgresSchemasSSLModeSSLModes5Mode {
	return SourcePostgresSchemasSSLModeSSLModes5ModeVerifyCa
}

type SourcePostgresSchemasSSLModeSSLModesMode string

const (
	SourcePostgresSchemasSSLModeSSLModesModeRequire SourcePostgresSchemasSSLModeSSLModesMode = "require"
)

func (e SourcePostgresSchemasSSLModeSSLModesMode) ToPointer() *SourcePostgresSchemasSSLModeSSLModesMode {
	return &e
}
func (e *SourcePostgresSchemasSSLModeSSLModesMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "require":
		*e = SourcePostgresSchemasSSLModeSSLModesMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresSchemasSSLModeSSLModesMode: %v", v)
	}
}

// SourcePostgresRequire - Always require encryption. If the source database server does not support encryption, connection will fail.
type SourcePostgresRequire struct {
	AdditionalProperties any                                      `additionalProperties:"true" json:"-"`
	mode                 SourcePostgresSchemasSSLModeSSLModesMode `const:"require" json:"mode"`
}

func (s SourcePostgresRequire) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresRequire) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresRequire) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *SourcePostgresRequire) GetMode() SourcePostgresSchemasSSLModeSSLModesMode {
	return SourcePostgresSchemasSSLModeSSLModesModeRequire
}

type SourcePostgresSchemasSslModeMode string

const (
	SourcePostgresSchemasSslModeModePrefer SourcePostgresSchemasSslModeMode = "prefer"
)

func (e SourcePostgresSchemasSslModeMode) ToPointer() *SourcePostgresSchemasSslModeMode {
	return &e
}
func (e *SourcePostgresSchemasSslModeMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "prefer":
		*e = SourcePostgresSchemasSslModeMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresSchemasSslModeMode: %v", v)
	}
}

// SourcePostgresPrefer - Allows unencrypted connection only if the source database does not support encryption.
type SourcePostgresPrefer struct {
	AdditionalProperties any                              `additionalProperties:"true" json:"-"`
	mode                 SourcePostgresSchemasSslModeMode `const:"prefer" json:"mode"`
}

func (s SourcePostgresPrefer) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresPrefer) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresPrefer) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *SourcePostgresPrefer) GetMode() SourcePostgresSchemasSslModeMode {
	return SourcePostgresSchemasSslModeModePrefer
}

type SourcePostgresSchemasMode string

const (
	SourcePostgresSchemasModeAllow SourcePostgresSchemasMode = "allow"
)

func (e SourcePostgresSchemasMode) ToPointer() *SourcePostgresSchemasMode {
	return &e
}
func (e *SourcePostgresSchemasMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "allow":
		*e = SourcePostgresSchemasMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresSchemasMode: %v", v)
	}
}

// SourcePostgresAllow - Enables encryption only when required by the source database.
type SourcePostgresAllow struct {
	AdditionalProperties any                       `additionalProperties:"true" json:"-"`
	mode                 SourcePostgresSchemasMode `const:"allow" json:"mode"`
}

func (s SourcePostgresAllow) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresAllow) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresAllow) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *SourcePostgresAllow) GetMode() SourcePostgresSchemasMode {
	return SourcePostgresSchemasModeAllow
}

type SourcePostgresMode string

const (
	SourcePostgresModeDisable SourcePostgresMode = "disable"
)

func (e SourcePostgresMode) ToPointer() *SourcePostgresMode {
	return &e
}
func (e *SourcePostgresMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "disable":
		*e = SourcePostgresMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresMode: %v", v)
	}
}

// SourcePostgresDisable - Disables encryption of communication between Airbyte and source database.
type SourcePostgresDisable struct {
	AdditionalProperties any                `additionalProperties:"true" json:"-"`
	mode                 SourcePostgresMode `const:"disable" json:"mode"`
}

func (s SourcePostgresDisable) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresDisable) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresDisable) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *SourcePostgresDisable) GetMode() SourcePostgresMode {
	return SourcePostgresModeDisable
}

type SourcePostgresSSLModesType string

const (
	SourcePostgresSSLModesTypeSourcePostgresDisable    SourcePostgresSSLModesType = "source-postgres_disable"
	SourcePostgresSSLModesTypeSourcePostgresAllow      SourcePostgresSSLModesType = "source-postgres_allow"
	SourcePostgresSSLModesTypeSourcePostgresPrefer     SourcePostgresSSLModesType = "source-postgres_prefer"
	SourcePostgresSSLModesTypeSourcePostgresRequire    SourcePostgresSSLModesType = "source-postgres_require"
	SourcePostgresSSLModesTypeSourcePostgresVerifyCa   SourcePostgresSSLModesType = "source-postgres_verify-ca"
	SourcePostgresSSLModesTypeSourcePostgresVerifyFull SourcePostgresSSLModesType = "source-postgres_verify-full"
)

// SourcePostgresSSLModes - SSL connection modes.
//
//	Read more <a href="https://jdbc.postgresql.org/documentation/head/ssl-client.html"> in the docs</a>.
type SourcePostgresSSLModes struct {
	SourcePostgresDisable    *SourcePostgresDisable
	SourcePostgresAllow      *SourcePostgresAllow
	SourcePostgresPrefer     *SourcePostgresPrefer
	SourcePostgresRequire    *SourcePostgresRequire
	SourcePostgresVerifyCa   *SourcePostgresVerifyCa
	SourcePostgresVerifyFull *SourcePostgresVerifyFull

	Type SourcePostgresSSLModesType
}

func CreateSourcePostgresSSLModesSourcePostgresDisable(sourcePostgresDisable SourcePostgresDisable) SourcePostgresSSLModes {
	typ := SourcePostgresSSLModesTypeSourcePostgresDisable

	return SourcePostgresSSLModes{
		SourcePostgresDisable: &sourcePostgresDisable,
		Type:                  typ,
	}
}

func CreateSourcePostgresSSLModesSourcePostgresAllow(sourcePostgresAllow SourcePostgresAllow) SourcePostgresSSLModes {
	typ := SourcePostgresSSLModesTypeSourcePostgresAllow

	return SourcePostgresSSLModes{
		SourcePostgresAllow: &sourcePostgresAllow,
		Type:                typ,
	}
}

func CreateSourcePostgresSSLModesSourcePostgresPrefer(sourcePostgresPrefer SourcePostgresPrefer) SourcePostgresSSLModes {
	typ := SourcePostgresSSLModesTypeSourcePostgresPrefer

	return SourcePostgresSSLModes{
		SourcePostgresPrefer: &sourcePostgresPrefer,
		Type:                 typ,
	}
}

func CreateSourcePostgresSSLModesSourcePostgresRequire(sourcePostgresRequire SourcePostgresRequire) SourcePostgresSSLModes {
	typ := SourcePostgresSSLModesTypeSourcePostgresRequire

	return SourcePostgresSSLModes{
		SourcePostgresRequire: &sourcePostgresRequire,
		Type:                  typ,
	}
}

func CreateSourcePostgresSSLModesSourcePostgresVerifyCa(sourcePostgresVerifyCa SourcePostgresVerifyCa) SourcePostgresSSLModes {
	typ := SourcePostgresSSLModesTypeSourcePostgresVerifyCa

	return SourcePostgresSSLModes{
		SourcePostgresVerifyCa: &sourcePostgresVerifyCa,
		Type:                   typ,
	}
}

func CreateSourcePostgresSSLModesSourcePostgresVerifyFull(sourcePostgresVerifyFull SourcePostgresVerifyFull) SourcePostgresSSLModes {
	typ := SourcePostgresSSLModesTypeSourcePostgresVerifyFull

	return SourcePostgresSSLModes{
		SourcePostgresVerifyFull: &sourcePostgresVerifyFull,
		Type:                     typ,
	}
}

func (u *SourcePostgresSSLModes) UnmarshalJSON(data []byte) error {

	var sourcePostgresDisable SourcePostgresDisable = SourcePostgresDisable{}
	if err := utils.UnmarshalJSON(data, &sourcePostgresDisable, "", true, true); err == nil {
		u.SourcePostgresDisable = &sourcePostgresDisable
		u.Type = SourcePostgresSSLModesTypeSourcePostgresDisable
		return nil
	}

	var sourcePostgresAllow SourcePostgresAllow = SourcePostgresAllow{}
	if err := utils.UnmarshalJSON(data, &sourcePostgresAllow, "", true, true); err == nil {
		u.SourcePostgresAllow = &sourcePostgresAllow
		u.Type = SourcePostgresSSLModesTypeSourcePostgresAllow
		return nil
	}

	var sourcePostgresPrefer SourcePostgresPrefer = SourcePostgresPrefer{}
	if err := utils.UnmarshalJSON(data, &sourcePostgresPrefer, "", true, true); err == nil {
		u.SourcePostgresPrefer = &sourcePostgresPrefer
		u.Type = SourcePostgresSSLModesTypeSourcePostgresPrefer
		return nil
	}

	var sourcePostgresRequire SourcePostgresRequire = SourcePostgresRequire{}
	if err := utils.UnmarshalJSON(data, &sourcePostgresRequire, "", true, true); err == nil {
		u.SourcePostgresRequire = &sourcePostgresRequire
		u.Type = SourcePostgresSSLModesTypeSourcePostgresRequire
		return nil
	}

	var sourcePostgresVerifyCa SourcePostgresVerifyCa = SourcePostgresVerifyCa{}
	if err := utils.UnmarshalJSON(data, &sourcePostgresVerifyCa, "", true, true); err == nil {
		u.SourcePostgresVerifyCa = &sourcePostgresVerifyCa
		u.Type = SourcePostgresSSLModesTypeSourcePostgresVerifyCa
		return nil
	}

	var sourcePostgresVerifyFull SourcePostgresVerifyFull = SourcePostgresVerifyFull{}
	if err := utils.UnmarshalJSON(data, &sourcePostgresVerifyFull, "", true, true); err == nil {
		u.SourcePostgresVerifyFull = &sourcePostgresVerifyFull
		u.Type = SourcePostgresSSLModesTypeSourcePostgresVerifyFull
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourcePostgresSSLModes", string(data))
}

func (u SourcePostgresSSLModes) MarshalJSON() ([]byte, error) {
	if u.SourcePostgresDisable != nil {
		return utils.MarshalJSON(u.SourcePostgresDisable, "", true)
	}

	if u.SourcePostgresAllow != nil {
		return utils.MarshalJSON(u.SourcePostgresAllow, "", true)
	}

	if u.SourcePostgresPrefer != nil {
		return utils.MarshalJSON(u.SourcePostgresPrefer, "", true)
	}

	if u.SourcePostgresRequire != nil {
		return utils.MarshalJSON(u.SourcePostgresRequire, "", true)
	}

	if u.SourcePostgresVerifyCa != nil {
		return utils.MarshalJSON(u.SourcePostgresVerifyCa, "", true)
	}

	if u.SourcePostgresVerifyFull != nil {
		return utils.MarshalJSON(u.SourcePostgresVerifyFull, "", true)
	}

	return nil, errors.New("could not marshal union type SourcePostgresSSLModes: all fields are null")
}

// SourcePostgresSchemasTunnelMethodTunnelMethod - Connect through a jump server tunnel host using username and password authentication
type SourcePostgresSchemasTunnelMethodTunnelMethod string

const (
	SourcePostgresSchemasTunnelMethodTunnelMethodSSHPasswordAuth SourcePostgresSchemasTunnelMethodTunnelMethod = "SSH_PASSWORD_AUTH"
)

func (e SourcePostgresSchemasTunnelMethodTunnelMethod) ToPointer() *SourcePostgresSchemasTunnelMethodTunnelMethod {
	return &e
}
func (e *SourcePostgresSchemasTunnelMethodTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_PASSWORD_AUTH":
		*e = SourcePostgresSchemasTunnelMethodTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresSchemasTunnelMethodTunnelMethod: %v", v)
	}
}

type SourcePostgresPasswordAuthentication struct {
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and password authentication
	tunnelMethod SourcePostgresSchemasTunnelMethodTunnelMethod `const:"SSH_PASSWORD_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser string `json:"tunnel_user"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword string `json:"tunnel_user_password"`
}

func (s SourcePostgresPasswordAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresPasswordAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresPasswordAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *SourcePostgresPasswordAuthentication) GetTunnelMethod() SourcePostgresSchemasTunnelMethodTunnelMethod {
	return SourcePostgresSchemasTunnelMethodTunnelMethodSSHPasswordAuth
}

func (o *SourcePostgresPasswordAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *SourcePostgresPasswordAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

func (o *SourcePostgresPasswordAuthentication) GetTunnelUserPassword() string {
	if o == nil {
		return ""
	}
	return o.TunnelUserPassword
}

// SourcePostgresSchemasTunnelMethod - Connect through a jump server tunnel host using username and ssh key
type SourcePostgresSchemasTunnelMethod string

const (
	SourcePostgresSchemasTunnelMethodSSHKeyAuth SourcePostgresSchemasTunnelMethod = "SSH_KEY_AUTH"
)

func (e SourcePostgresSchemasTunnelMethod) ToPointer() *SourcePostgresSchemasTunnelMethod {
	return &e
}
func (e *SourcePostgresSchemasTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_KEY_AUTH":
		*e = SourcePostgresSchemasTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresSchemasTunnelMethod: %v", v)
	}
}

type SourcePostgresSSHKeyAuthentication struct {
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey string `json:"ssh_key"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and ssh key
	tunnelMethod SourcePostgresSchemasTunnelMethod `const:"SSH_KEY_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host.
	TunnelUser string `json:"tunnel_user"`
}

func (s SourcePostgresSSHKeyAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresSSHKeyAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresSSHKeyAuthentication) GetSSHKey() string {
	if o == nil {
		return ""
	}
	return o.SSHKey
}

func (o *SourcePostgresSSHKeyAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *SourcePostgresSSHKeyAuthentication) GetTunnelMethod() SourcePostgresSchemasTunnelMethod {
	return SourcePostgresSchemasTunnelMethodSSHKeyAuth
}

func (o *SourcePostgresSSHKeyAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *SourcePostgresSSHKeyAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

// SourcePostgresTunnelMethod - No ssh tunnel needed to connect to database
type SourcePostgresTunnelMethod string

const (
	SourcePostgresTunnelMethodNoTunnel SourcePostgresTunnelMethod = "NO_TUNNEL"
)

func (e SourcePostgresTunnelMethod) ToPointer() *SourcePostgresTunnelMethod {
	return &e
}
func (e *SourcePostgresTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NO_TUNNEL":
		*e = SourcePostgresTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresTunnelMethod: %v", v)
	}
}

type SourcePostgresNoTunnel struct {
	// No ssh tunnel needed to connect to database
	tunnelMethod SourcePostgresTunnelMethod `const:"NO_TUNNEL" json:"tunnel_method"`
}

func (s SourcePostgresNoTunnel) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresNoTunnel) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresNoTunnel) GetTunnelMethod() SourcePostgresTunnelMethod {
	return SourcePostgresTunnelMethodNoTunnel
}

type SourcePostgresSSHTunnelMethodType string

const (
	SourcePostgresSSHTunnelMethodTypeSourcePostgresNoTunnel               SourcePostgresSSHTunnelMethodType = "source-postgres_No Tunnel"
	SourcePostgresSSHTunnelMethodTypeSourcePostgresSSHKeyAuthentication   SourcePostgresSSHTunnelMethodType = "source-postgres_SSH Key Authentication"
	SourcePostgresSSHTunnelMethodTypeSourcePostgresPasswordAuthentication SourcePostgresSSHTunnelMethodType = "source-postgres_Password Authentication"
)

// SourcePostgresSSHTunnelMethod - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourcePostgresSSHTunnelMethod struct {
	SourcePostgresNoTunnel               *SourcePostgresNoTunnel
	SourcePostgresSSHKeyAuthentication   *SourcePostgresSSHKeyAuthentication
	SourcePostgresPasswordAuthentication *SourcePostgresPasswordAuthentication

	Type SourcePostgresSSHTunnelMethodType
}

func CreateSourcePostgresSSHTunnelMethodSourcePostgresNoTunnel(sourcePostgresNoTunnel SourcePostgresNoTunnel) SourcePostgresSSHTunnelMethod {
	typ := SourcePostgresSSHTunnelMethodTypeSourcePostgresNoTunnel

	return SourcePostgresSSHTunnelMethod{
		SourcePostgresNoTunnel: &sourcePostgresNoTunnel,
		Type:                   typ,
	}
}

func CreateSourcePostgresSSHTunnelMethodSourcePostgresSSHKeyAuthentication(sourcePostgresSSHKeyAuthentication SourcePostgresSSHKeyAuthentication) SourcePostgresSSHTunnelMethod {
	typ := SourcePostgresSSHTunnelMethodTypeSourcePostgresSSHKeyAuthentication

	return SourcePostgresSSHTunnelMethod{
		SourcePostgresSSHKeyAuthentication: &sourcePostgresSSHKeyAuthentication,
		Type:                               typ,
	}
}

func CreateSourcePostgresSSHTunnelMethodSourcePostgresPasswordAuthentication(sourcePostgresPasswordAuthentication SourcePostgresPasswordAuthentication) SourcePostgresSSHTunnelMethod {
	typ := SourcePostgresSSHTunnelMethodTypeSourcePostgresPasswordAuthentication

	return SourcePostgresSSHTunnelMethod{
		SourcePostgresPasswordAuthentication: &sourcePostgresPasswordAuthentication,
		Type:                                 typ,
	}
}

func (u *SourcePostgresSSHTunnelMethod) UnmarshalJSON(data []byte) error {

	var sourcePostgresNoTunnel SourcePostgresNoTunnel = SourcePostgresNoTunnel{}
	if err := utils.UnmarshalJSON(data, &sourcePostgresNoTunnel, "", true, true); err == nil {
		u.SourcePostgresNoTunnel = &sourcePostgresNoTunnel
		u.Type = SourcePostgresSSHTunnelMethodTypeSourcePostgresNoTunnel
		return nil
	}

	var sourcePostgresSSHKeyAuthentication SourcePostgresSSHKeyAuthentication = SourcePostgresSSHKeyAuthentication{}
	if err := utils.UnmarshalJSON(data, &sourcePostgresSSHKeyAuthentication, "", true, true); err == nil {
		u.SourcePostgresSSHKeyAuthentication = &sourcePostgresSSHKeyAuthentication
		u.Type = SourcePostgresSSHTunnelMethodTypeSourcePostgresSSHKeyAuthentication
		return nil
	}

	var sourcePostgresPasswordAuthentication SourcePostgresPasswordAuthentication = SourcePostgresPasswordAuthentication{}
	if err := utils.UnmarshalJSON(data, &sourcePostgresPasswordAuthentication, "", true, true); err == nil {
		u.SourcePostgresPasswordAuthentication = &sourcePostgresPasswordAuthentication
		u.Type = SourcePostgresSSHTunnelMethodTypeSourcePostgresPasswordAuthentication
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourcePostgresSSHTunnelMethod", string(data))
}

func (u SourcePostgresSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.SourcePostgresNoTunnel != nil {
		return utils.MarshalJSON(u.SourcePostgresNoTunnel, "", true)
	}

	if u.SourcePostgresSSHKeyAuthentication != nil {
		return utils.MarshalJSON(u.SourcePostgresSSHKeyAuthentication, "", true)
	}

	if u.SourcePostgresPasswordAuthentication != nil {
		return utils.MarshalJSON(u.SourcePostgresPasswordAuthentication, "", true)
	}

	return nil, errors.New("could not marshal union type SourcePostgresSSHTunnelMethod: all fields are null")
}

type SourcePostgres struct {
	// Name of the database.
	Database string `json:"database"`
	// Hostname of the database.
	Host string `json:"host"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (Eg. key1=value1&key2=value2&key3=value3). For more information read about <a href="https://jdbc.postgresql.org/documentation/head/connect.html">JDBC URL parameters</a>.
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// Password associated with the username.
	Password *string `json:"password,omitempty"`
	// Port of the database.
	Port *int64 `default:"5432" json:"port"`
	// Configures how data is extracted from the database.
	ReplicationMethod *SourcePostgresUpdateMethod `json:"replication_method,omitempty"`
	// The list of schemas (case sensitive) to sync from. Defaults to public.
	Schemas    []string               `json:"schemas,omitempty"`
	sourceType SourcePostgresPostgres `const:"postgres" json:"sourceType"`
	// SSL connection modes.
	//   Read more <a href="https://jdbc.postgresql.org/documentation/head/ssl-client.html"> in the docs</a>.
	SslMode *SourcePostgresSSLModes `json:"ssl_mode,omitempty"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod *SourcePostgresSSHTunnelMethod `json:"tunnel_method,omitempty"`
	// Username to access the database.
	Username string `json:"username"`
}

func (s SourcePostgres) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgres) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgres) GetDatabase() string {
	if o == nil {
		return ""
	}
	return o.Database
}

func (o *SourcePostgres) GetHost() string {
	if o == nil {
		return ""
	}
	return o.Host
}

func (o *SourcePostgres) GetJdbcURLParams() *string {
	if o == nil {
		return nil
	}
	return o.JdbcURLParams
}

func (o *SourcePostgres) GetPassword() *string {
	if o == nil {
		return nil
	}
	return o.Password
}

func (o *SourcePostgres) GetPort() *int64 {
	if o == nil {
		return nil
	}
	return o.Port
}

func (o *SourcePostgres) GetReplicationMethod() *SourcePostgresUpdateMethod {
	if o == nil {
		return nil
	}
	return o.ReplicationMethod
}

func (o *SourcePostgres) GetSchemas() []string {
	if o == nil {
		return nil
	}
	return o.Schemas
}

func (o *SourcePostgres) GetSourceType() SourcePostgresPostgres {
	return SourcePostgresPostgresPostgres
}

func (o *SourcePostgres) GetSslMode() *SourcePostgresSSLModes {
	if o == nil {
		return nil
	}
	return o.SslMode
}

func (o *SourcePostgres) GetTunnelMethod() *SourcePostgresSSHTunnelMethod {
	if o == nil {
		return nil
	}
	return o.TunnelMethod
}

func (o *SourcePostgres) GetUsername() string {
	if o == nil {
		return ""
	}
	return o.Username
}
