// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

// SourcePostgresScanChangesWithUserDefinedCursor - Incrementally detects new inserts and updates using the <a href="https://docs.airbyte.com/understanding-airbyte/connections/incremental-append/#user-defined-cursor">cursor column</a> chosen when configuring a connection (e.g. created_at, updated_at).
type SourcePostgresScanChangesWithUserDefinedCursor struct {
	method string `const:"Standard" json:"method"`
}

func (s SourcePostgresScanChangesWithUserDefinedCursor) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresScanChangesWithUserDefinedCursor) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourcePostgresScanChangesWithUserDefinedCursor) GetMethod() string {
	return "Standard"
}

// DetectChangesWithXminSystemColumn - <i>Recommended</i> - Incrementally reads new inserts and updates via Postgres <a href="https://docs.airbyte.com/integrations/sources/postgres/#xmin">Xmin system column</a>. Suitable for databases that have low transaction pressure.
type DetectChangesWithXminSystemColumn struct {
	method string `const:"Xmin" json:"method"`
}

func (d DetectChangesWithXminSystemColumn) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DetectChangesWithXminSystemColumn) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DetectChangesWithXminSystemColumn) GetMethod() string {
	return "Xmin"
}

// SourcePostgresInvalidCDCPositionBehaviorAdvanced - Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value into the WAL. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss.
type SourcePostgresInvalidCDCPositionBehaviorAdvanced string

const (
	SourcePostgresInvalidCDCPositionBehaviorAdvancedFailSync   SourcePostgresInvalidCDCPositionBehaviorAdvanced = "Fail sync"
	SourcePostgresInvalidCDCPositionBehaviorAdvancedReSyncData SourcePostgresInvalidCDCPositionBehaviorAdvanced = "Re-sync data"
)

func (e SourcePostgresInvalidCDCPositionBehaviorAdvanced) ToPointer() *SourcePostgresInvalidCDCPositionBehaviorAdvanced {
	return &e
}
func (e *SourcePostgresInvalidCDCPositionBehaviorAdvanced) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Fail sync":
		fallthrough
	case "Re-sync data":
		*e = SourcePostgresInvalidCDCPositionBehaviorAdvanced(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresInvalidCDCPositionBehaviorAdvanced: %v", v)
	}
}

// LSNCommitBehaviour - Determines when Airbyte should flush the LSN of processed WAL logs in the source database. `After loading Data in the destination` is default. If `While reading Data` is selected, in case of a downstream failure (while loading data into the destination), next sync would result in a full sync.
type LSNCommitBehaviour string

const (
	LSNCommitBehaviourWhileReadingData                 LSNCommitBehaviour = "While reading Data"
	LSNCommitBehaviourAfterLoadingDataInTheDestination LSNCommitBehaviour = "After loading Data in the destination"
)

func (e LSNCommitBehaviour) ToPointer() *LSNCommitBehaviour {
	return &e
}
func (e *LSNCommitBehaviour) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "While reading Data":
		fallthrough
	case "After loading Data in the destination":
		*e = LSNCommitBehaviour(v)
		return nil
	default:
		return fmt.Errorf("invalid value for LSNCommitBehaviour: %v", v)
	}
}

// Plugin - A logical decoding plugin installed on the PostgreSQL server.
type Plugin string

const (
	PluginPgoutput Plugin = "pgoutput"
)

func (e Plugin) ToPointer() *Plugin {
	return &e
}
func (e *Plugin) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "pgoutput":
		*e = Plugin(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Plugin: %v", v)
	}
}

// ReadChangesUsingWriteAheadLogCDC - <i>Recommended</i> - Incrementally reads new inserts, updates, and deletes using the Postgres <a href="https://docs.airbyte.com/integrations/sources/postgres/#cdc">write-ahead log (WAL)</a>. This needs to be configured on the source database itself. Recommended for tables of any size.
type ReadChangesUsingWriteAheadLogCDC struct {
	// Specifies a query that the connector executes on the source database when the connector sends a heartbeat message. Please see the <a href="https://docs.airbyte.com/integrations/sources/postgres/postgres-troubleshooting#advanced-wal-disk-consumption-and-heartbeat-action-query">setup guide</a> for how and when to configure this setting.
	HeartbeatActionQuery *string `default:"" json:"heartbeat_action_query"`
	// The amount of time an initial load is allowed to continue for before catching up on CDC logs.
	InitialLoadTimeoutHours *int64 `default:"8" json:"initial_load_timeout_hours"`
	// The amount of time the connector will wait when it launches to determine if there is new data to sync or not. Defaults to 1200 seconds. Valid range: 120 seconds to 2400 seconds. Read about <a href="https://docs.airbyte.com/integrations/sources/postgres/postgres-troubleshooting#advanced-setting-up-initial-cdc-waiting-time">initial waiting time</a>.
	InitialWaitingSeconds *int64 `default:"1200" json:"initial_waiting_seconds"`
	// Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value into the WAL. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss.
	InvalidCdcCursorPositionBehavior *SourcePostgresInvalidCDCPositionBehaviorAdvanced `default:"Fail sync" json:"invalid_cdc_cursor_position_behavior"`
	// Determines when Airbyte should flush the LSN of processed WAL logs in the source database. `After loading Data in the destination` is default. If `While reading Data` is selected, in case of a downstream failure (while loading data into the destination), next sync would result in a full sync.
	LsnCommitBehaviour *LSNCommitBehaviour `default:"After loading Data in the destination" json:"lsn_commit_behaviour"`
	method             string              `const:"CDC" json:"method"`
	// A logical decoding plugin installed on the PostgreSQL server.
	Plugin *Plugin `default:"pgoutput" json:"plugin"`
	// A Postgres publication used for consuming changes. Read about <a href="https://docs.airbyte.com/integrations/sources/postgres#step-4-create-publications-and-replication-identities-for-tables">publications and replication identities</a>.
	Publication string `json:"publication"`
	// The size of the internal queue. This may interfere with memory consumption and efficiency of the connector, please be careful.
	QueueSize *int64 `default:"10000" json:"queue_size"`
	// A plugin logical replication slot. Read about <a href="https://docs.airbyte.com/integrations/sources/postgres#step-3-create-replication-slot">replication slots</a>.
	ReplicationSlot      string `json:"replication_slot"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (r ReadChangesUsingWriteAheadLogCDC) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(r, "", false)
}

func (r *ReadChangesUsingWriteAheadLogCDC) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &r, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (r *ReadChangesUsingWriteAheadLogCDC) GetHeartbeatActionQuery() *string {
	if r == nil {
		return nil
	}
	return r.HeartbeatActionQuery
}

func (r *ReadChangesUsingWriteAheadLogCDC) GetInitialLoadTimeoutHours() *int64 {
	if r == nil {
		return nil
	}
	return r.InitialLoadTimeoutHours
}

func (r *ReadChangesUsingWriteAheadLogCDC) GetInitialWaitingSeconds() *int64 {
	if r == nil {
		return nil
	}
	return r.InitialWaitingSeconds
}

func (r *ReadChangesUsingWriteAheadLogCDC) GetInvalidCdcCursorPositionBehavior() *SourcePostgresInvalidCDCPositionBehaviorAdvanced {
	if r == nil {
		return nil
	}
	return r.InvalidCdcCursorPositionBehavior
}

func (r *ReadChangesUsingWriteAheadLogCDC) GetLsnCommitBehaviour() *LSNCommitBehaviour {
	if r == nil {
		return nil
	}
	return r.LsnCommitBehaviour
}

func (r *ReadChangesUsingWriteAheadLogCDC) GetMethod() string {
	return "CDC"
}

func (r *ReadChangesUsingWriteAheadLogCDC) GetPlugin() *Plugin {
	if r == nil {
		return nil
	}
	return r.Plugin
}

func (r *ReadChangesUsingWriteAheadLogCDC) GetPublication() string {
	if r == nil {
		return ""
	}
	return r.Publication
}

func (r *ReadChangesUsingWriteAheadLogCDC) GetQueueSize() *int64 {
	if r == nil {
		return nil
	}
	return r.QueueSize
}

func (r *ReadChangesUsingWriteAheadLogCDC) GetReplicationSlot() string {
	if r == nil {
		return ""
	}
	return r.ReplicationSlot
}

func (r *ReadChangesUsingWriteAheadLogCDC) GetAdditionalProperties() any {
	if r == nil {
		return nil
	}
	return r.AdditionalProperties
}

type SourcePostgresUpdateMethodType string

const (
	SourcePostgresUpdateMethodTypeReadChangesUsingWriteAheadLogCDC               SourcePostgresUpdateMethodType = "Read Changes using Write-Ahead Log (CDC)"
	SourcePostgresUpdateMethodTypeDetectChangesWithXminSystemColumn              SourcePostgresUpdateMethodType = "Detect Changes with Xmin System Column"
	SourcePostgresUpdateMethodTypeSourcePostgresScanChangesWithUserDefinedCursor SourcePostgresUpdateMethodType = "source-postgres_Scan Changes with User Defined Cursor"
)

// SourcePostgresUpdateMethod - Configures how data is extracted from the database.
type SourcePostgresUpdateMethod struct {
	ReadChangesUsingWriteAheadLogCDC               *ReadChangesUsingWriteAheadLogCDC               `queryParam:"inline" union:"member"`
	DetectChangesWithXminSystemColumn              *DetectChangesWithXminSystemColumn              `queryParam:"inline" union:"member"`
	SourcePostgresScanChangesWithUserDefinedCursor *SourcePostgresScanChangesWithUserDefinedCursor `queryParam:"inline" union:"member"`

	Type SourcePostgresUpdateMethodType
}

func CreateSourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDC(readChangesUsingWriteAheadLogCDC ReadChangesUsingWriteAheadLogCDC) SourcePostgresUpdateMethod {
	typ := SourcePostgresUpdateMethodTypeReadChangesUsingWriteAheadLogCDC

	return SourcePostgresUpdateMethod{
		ReadChangesUsingWriteAheadLogCDC: &readChangesUsingWriteAheadLogCDC,
		Type:                             typ,
	}
}

func CreateSourcePostgresUpdateMethodDetectChangesWithXminSystemColumn(detectChangesWithXminSystemColumn DetectChangesWithXminSystemColumn) SourcePostgresUpdateMethod {
	typ := SourcePostgresUpdateMethodTypeDetectChangesWithXminSystemColumn

	return SourcePostgresUpdateMethod{
		DetectChangesWithXminSystemColumn: &detectChangesWithXminSystemColumn,
		Type:                              typ,
	}
}

func CreateSourcePostgresUpdateMethodSourcePostgresScanChangesWithUserDefinedCursor(sourcePostgresScanChangesWithUserDefinedCursor SourcePostgresScanChangesWithUserDefinedCursor) SourcePostgresUpdateMethod {
	typ := SourcePostgresUpdateMethodTypeSourcePostgresScanChangesWithUserDefinedCursor

	return SourcePostgresUpdateMethod{
		SourcePostgresScanChangesWithUserDefinedCursor: &sourcePostgresScanChangesWithUserDefinedCursor,
		Type: typ,
	}
}

func (u *SourcePostgresUpdateMethod) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var readChangesUsingWriteAheadLogCDC ReadChangesUsingWriteAheadLogCDC = ReadChangesUsingWriteAheadLogCDC{}
	if err := utils.UnmarshalJSON(data, &readChangesUsingWriteAheadLogCDC, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourcePostgresUpdateMethodTypeReadChangesUsingWriteAheadLogCDC,
			Value: &readChangesUsingWriteAheadLogCDC,
		})
	}

	var detectChangesWithXminSystemColumn DetectChangesWithXminSystemColumn = DetectChangesWithXminSystemColumn{}
	if err := utils.UnmarshalJSON(data, &detectChangesWithXminSystemColumn, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourcePostgresUpdateMethodTypeDetectChangesWithXminSystemColumn,
			Value: &detectChangesWithXminSystemColumn,
		})
	}

	var sourcePostgresScanChangesWithUserDefinedCursor SourcePostgresScanChangesWithUserDefinedCursor = SourcePostgresScanChangesWithUserDefinedCursor{}
	if err := utils.UnmarshalJSON(data, &sourcePostgresScanChangesWithUserDefinedCursor, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourcePostgresUpdateMethodTypeSourcePostgresScanChangesWithUserDefinedCursor,
			Value: &sourcePostgresScanChangesWithUserDefinedCursor,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourcePostgresUpdateMethod", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourcePostgresUpdateMethod", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourcePostgresUpdateMethodType)
	switch best.Type {
	case SourcePostgresUpdateMethodTypeReadChangesUsingWriteAheadLogCDC:
		u.ReadChangesUsingWriteAheadLogCDC = best.Value.(*ReadChangesUsingWriteAheadLogCDC)
		return nil
	case SourcePostgresUpdateMethodTypeDetectChangesWithXminSystemColumn:
		u.DetectChangesWithXminSystemColumn = best.Value.(*DetectChangesWithXminSystemColumn)
		return nil
	case SourcePostgresUpdateMethodTypeSourcePostgresScanChangesWithUserDefinedCursor:
		u.SourcePostgresScanChangesWithUserDefinedCursor = best.Value.(*SourcePostgresScanChangesWithUserDefinedCursor)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourcePostgresUpdateMethod", string(data))
}

func (u SourcePostgresUpdateMethod) MarshalJSON() ([]byte, error) {
	if u.ReadChangesUsingWriteAheadLogCDC != nil {
		return utils.MarshalJSON(u.ReadChangesUsingWriteAheadLogCDC, "", true)
	}

	if u.DetectChangesWithXminSystemColumn != nil {
		return utils.MarshalJSON(u.DetectChangesWithXminSystemColumn, "", true)
	}

	if u.SourcePostgresScanChangesWithUserDefinedCursor != nil {
		return utils.MarshalJSON(u.SourcePostgresScanChangesWithUserDefinedCursor, "", true)
	}

	return nil, errors.New("could not marshal union type SourcePostgresUpdateMethod: all fields are null")
}

// VerifyFull - This is the most secure mode. Always require encryption and verifies the identity of the source database server.
type VerifyFull struct {
	// CA certificate
	CaCertificate string `json:"ca_certificate"`
	// Client certificate
	ClientCertificate *string `json:"client_certificate,omitempty"`
	// Client key
	ClientKey *string `json:"client_key,omitempty"`
	// Password for keystorage. If you do not add it - the password will be generated automatically.
	ClientKeyPassword    *string `json:"client_key_password,omitempty"`
	mode                 string  `const:"verify-full" json:"mode"`
	AdditionalProperties any     `additionalProperties:"true" json:"-"`
}

func (v VerifyFull) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(v, "", false)
}

func (v *VerifyFull) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &v, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (v *VerifyFull) GetCaCertificate() string {
	if v == nil {
		return ""
	}
	return v.CaCertificate
}

func (v *VerifyFull) GetClientCertificate() *string {
	if v == nil {
		return nil
	}
	return v.ClientCertificate
}

func (v *VerifyFull) GetClientKey() *string {
	if v == nil {
		return nil
	}
	return v.ClientKey
}

func (v *VerifyFull) GetClientKeyPassword() *string {
	if v == nil {
		return nil
	}
	return v.ClientKeyPassword
}

func (v *VerifyFull) GetMode() string {
	return "verify-full"
}

func (v *VerifyFull) GetAdditionalProperties() any {
	if v == nil {
		return nil
	}
	return v.AdditionalProperties
}

// SourcePostgresVerifyCa - Always require encryption and verifies that the source database server has a valid SSL certificate.
type SourcePostgresVerifyCa struct {
	// CA certificate
	CaCertificate string `json:"ca_certificate"`
	// Client certificate
	ClientCertificate *string `json:"client_certificate,omitempty"`
	// Client key
	ClientKey *string `json:"client_key,omitempty"`
	// Password for keystorage. If you do not add it - the password will be generated automatically.
	ClientKeyPassword    *string `json:"client_key_password,omitempty"`
	mode                 string  `const:"verify-ca" json:"mode"`
	AdditionalProperties any     `additionalProperties:"true" json:"-"`
}

func (s SourcePostgresVerifyCa) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresVerifyCa) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourcePostgresVerifyCa) GetCaCertificate() string {
	if s == nil {
		return ""
	}
	return s.CaCertificate
}

func (s *SourcePostgresVerifyCa) GetClientCertificate() *string {
	if s == nil {
		return nil
	}
	return s.ClientCertificate
}

func (s *SourcePostgresVerifyCa) GetClientKey() *string {
	if s == nil {
		return nil
	}
	return s.ClientKey
}

func (s *SourcePostgresVerifyCa) GetClientKeyPassword() *string {
	if s == nil {
		return nil
	}
	return s.ClientKeyPassword
}

func (s *SourcePostgresVerifyCa) GetMode() string {
	return "verify-ca"
}

func (s *SourcePostgresVerifyCa) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

// Require - Always require encryption. If the source database server does not support encryption, connection will fail.
type Require struct {
	mode                 string `const:"require" json:"mode"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (r Require) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(r, "", false)
}

func (r *Require) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &r, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (r *Require) GetMode() string {
	return "require"
}

func (r *Require) GetAdditionalProperties() any {
	if r == nil {
		return nil
	}
	return r.AdditionalProperties
}

// Prefer - Allows unencrypted connection only if the source database does not support encryption.
type Prefer struct {
	mode                 string `const:"prefer" json:"mode"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (p Prefer) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *Prefer) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (p *Prefer) GetMode() string {
	return "prefer"
}

func (p *Prefer) GetAdditionalProperties() any {
	if p == nil {
		return nil
	}
	return p.AdditionalProperties
}

// Allow - Enables encryption only when required by the source database.
type Allow struct {
	mode                 string `const:"allow" json:"mode"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (a Allow) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *Allow) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (a *Allow) GetMode() string {
	return "allow"
}

func (a *Allow) GetAdditionalProperties() any {
	if a == nil {
		return nil
	}
	return a.AdditionalProperties
}

// Disable - Disables encryption of communication between Airbyte and source database.
type Disable struct {
	mode                 string `const:"disable" json:"mode"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (d Disable) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *Disable) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *Disable) GetMode() string {
	return "disable"
}

func (d *Disable) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type SSLModesType string

const (
	SSLModesTypeDisable                SSLModesType = "disable"
	SSLModesTypeAllow                  SSLModesType = "allow"
	SSLModesTypePrefer                 SSLModesType = "prefer"
	SSLModesTypeRequire                SSLModesType = "require"
	SSLModesTypeSourcePostgresVerifyCa SSLModesType = "source-postgres_verify-ca"
	SSLModesTypeVerifyFull             SSLModesType = "verify-full"
)

// SSLModes - SSL connection modes.
//
//	Read more <a href="https://jdbc.postgresql.org/documentation/head/ssl-client.html"> in the docs</a>.
type SSLModes struct {
	Disable                *Disable                `queryParam:"inline" union:"member"`
	Allow                  *Allow                  `queryParam:"inline" union:"member"`
	Prefer                 *Prefer                 `queryParam:"inline" union:"member"`
	Require                *Require                `queryParam:"inline" union:"member"`
	SourcePostgresVerifyCa *SourcePostgresVerifyCa `queryParam:"inline" union:"member"`
	VerifyFull             *VerifyFull             `queryParam:"inline" union:"member"`

	Type SSLModesType
}

func CreateSSLModesDisable(disable Disable) SSLModes {
	typ := SSLModesTypeDisable

	return SSLModes{
		Disable: &disable,
		Type:    typ,
	}
}

func CreateSSLModesAllow(allow Allow) SSLModes {
	typ := SSLModesTypeAllow

	return SSLModes{
		Allow: &allow,
		Type:  typ,
	}
}

func CreateSSLModesPrefer(prefer Prefer) SSLModes {
	typ := SSLModesTypePrefer

	return SSLModes{
		Prefer: &prefer,
		Type:   typ,
	}
}

func CreateSSLModesRequire(require Require) SSLModes {
	typ := SSLModesTypeRequire

	return SSLModes{
		Require: &require,
		Type:    typ,
	}
}

func CreateSSLModesSourcePostgresVerifyCa(sourcePostgresVerifyCa SourcePostgresVerifyCa) SSLModes {
	typ := SSLModesTypeSourcePostgresVerifyCa

	return SSLModes{
		SourcePostgresVerifyCa: &sourcePostgresVerifyCa,
		Type:                   typ,
	}
}

func CreateSSLModesVerifyFull(verifyFull VerifyFull) SSLModes {
	typ := SSLModesTypeVerifyFull

	return SSLModes{
		VerifyFull: &verifyFull,
		Type:       typ,
	}
}

func (u *SSLModes) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var disable Disable = Disable{}
	if err := utils.UnmarshalJSON(data, &disable, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SSLModesTypeDisable,
			Value: &disable,
		})
	}

	var allow Allow = Allow{}
	if err := utils.UnmarshalJSON(data, &allow, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SSLModesTypeAllow,
			Value: &allow,
		})
	}

	var prefer Prefer = Prefer{}
	if err := utils.UnmarshalJSON(data, &prefer, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SSLModesTypePrefer,
			Value: &prefer,
		})
	}

	var require Require = Require{}
	if err := utils.UnmarshalJSON(data, &require, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SSLModesTypeRequire,
			Value: &require,
		})
	}

	var sourcePostgresVerifyCa SourcePostgresVerifyCa = SourcePostgresVerifyCa{}
	if err := utils.UnmarshalJSON(data, &sourcePostgresVerifyCa, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SSLModesTypeSourcePostgresVerifyCa,
			Value: &sourcePostgresVerifyCa,
		})
	}

	var verifyFull VerifyFull = VerifyFull{}
	if err := utils.UnmarshalJSON(data, &verifyFull, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SSLModesTypeVerifyFull,
			Value: &verifyFull,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SSLModes", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SSLModes", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SSLModesType)
	switch best.Type {
	case SSLModesTypeDisable:
		u.Disable = best.Value.(*Disable)
		return nil
	case SSLModesTypeAllow:
		u.Allow = best.Value.(*Allow)
		return nil
	case SSLModesTypePrefer:
		u.Prefer = best.Value.(*Prefer)
		return nil
	case SSLModesTypeRequire:
		u.Require = best.Value.(*Require)
		return nil
	case SSLModesTypeSourcePostgresVerifyCa:
		u.SourcePostgresVerifyCa = best.Value.(*SourcePostgresVerifyCa)
		return nil
	case SSLModesTypeVerifyFull:
		u.VerifyFull = best.Value.(*VerifyFull)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SSLModes", string(data))
}

func (u SSLModes) MarshalJSON() ([]byte, error) {
	if u.Disable != nil {
		return utils.MarshalJSON(u.Disable, "", true)
	}

	if u.Allow != nil {
		return utils.MarshalJSON(u.Allow, "", true)
	}

	if u.Prefer != nil {
		return utils.MarshalJSON(u.Prefer, "", true)
	}

	if u.Require != nil {
		return utils.MarshalJSON(u.Require, "", true)
	}

	if u.SourcePostgresVerifyCa != nil {
		return utils.MarshalJSON(u.SourcePostgresVerifyCa, "", true)
	}

	if u.VerifyFull != nil {
		return utils.MarshalJSON(u.VerifyFull, "", true)
	}

	return nil, errors.New("could not marshal union type SSLModes: all fields are null")
}

type SourcePostgresPasswordAuthentication struct {
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and password authentication
	tunnelMethod string `const:"SSH_PASSWORD_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser string `json:"tunnel_user"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword string `json:"tunnel_user_password"`
}

func (s SourcePostgresPasswordAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresPasswordAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourcePostgresPasswordAuthentication) GetTunnelHost() string {
	if s == nil {
		return ""
	}
	return s.TunnelHost
}

func (s *SourcePostgresPasswordAuthentication) GetTunnelMethod() string {
	return "SSH_PASSWORD_AUTH"
}

func (s *SourcePostgresPasswordAuthentication) GetTunnelPort() *int64 {
	if s == nil {
		return nil
	}
	return s.TunnelPort
}

func (s *SourcePostgresPasswordAuthentication) GetTunnelUser() string {
	if s == nil {
		return ""
	}
	return s.TunnelUser
}

func (s *SourcePostgresPasswordAuthentication) GetTunnelUserPassword() string {
	if s == nil {
		return ""
	}
	return s.TunnelUserPassword
}

type SourcePostgresSSHKeyAuthentication struct {
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey string `json:"ssh_key"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and ssh key
	tunnelMethod string `const:"SSH_KEY_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host.
	TunnelUser string `json:"tunnel_user"`
}

func (s SourcePostgresSSHKeyAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresSSHKeyAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourcePostgresSSHKeyAuthentication) GetSSHKey() string {
	if s == nil {
		return ""
	}
	return s.SSHKey
}

func (s *SourcePostgresSSHKeyAuthentication) GetTunnelHost() string {
	if s == nil {
		return ""
	}
	return s.TunnelHost
}

func (s *SourcePostgresSSHKeyAuthentication) GetTunnelMethod() string {
	return "SSH_KEY_AUTH"
}

func (s *SourcePostgresSSHKeyAuthentication) GetTunnelPort() *int64 {
	if s == nil {
		return nil
	}
	return s.TunnelPort
}

func (s *SourcePostgresSSHKeyAuthentication) GetTunnelUser() string {
	if s == nil {
		return ""
	}
	return s.TunnelUser
}

type SourcePostgresNoTunnel struct {
	// No ssh tunnel needed to connect to database
	tunnelMethod string `const:"NO_TUNNEL" json:"tunnel_method"`
}

func (s SourcePostgresNoTunnel) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresNoTunnel) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourcePostgresNoTunnel) GetTunnelMethod() string {
	return "NO_TUNNEL"
}

type SourcePostgresSSHTunnelMethodType string

const (
	SourcePostgresSSHTunnelMethodTypeSourcePostgresNoTunnel               SourcePostgresSSHTunnelMethodType = "source-postgres_No Tunnel"
	SourcePostgresSSHTunnelMethodTypeSourcePostgresSSHKeyAuthentication   SourcePostgresSSHTunnelMethodType = "source-postgres_SSH Key Authentication"
	SourcePostgresSSHTunnelMethodTypeSourcePostgresPasswordAuthentication SourcePostgresSSHTunnelMethodType = "source-postgres_Password Authentication"
)

// SourcePostgresSSHTunnelMethod - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourcePostgresSSHTunnelMethod struct {
	SourcePostgresNoTunnel               *SourcePostgresNoTunnel               `queryParam:"inline" union:"member"`
	SourcePostgresSSHKeyAuthentication   *SourcePostgresSSHKeyAuthentication   `queryParam:"inline" union:"member"`
	SourcePostgresPasswordAuthentication *SourcePostgresPasswordAuthentication `queryParam:"inline" union:"member"`

	Type SourcePostgresSSHTunnelMethodType
}

func CreateSourcePostgresSSHTunnelMethodSourcePostgresNoTunnel(sourcePostgresNoTunnel SourcePostgresNoTunnel) SourcePostgresSSHTunnelMethod {
	typ := SourcePostgresSSHTunnelMethodTypeSourcePostgresNoTunnel

	return SourcePostgresSSHTunnelMethod{
		SourcePostgresNoTunnel: &sourcePostgresNoTunnel,
		Type:                   typ,
	}
}

func CreateSourcePostgresSSHTunnelMethodSourcePostgresSSHKeyAuthentication(sourcePostgresSSHKeyAuthentication SourcePostgresSSHKeyAuthentication) SourcePostgresSSHTunnelMethod {
	typ := SourcePostgresSSHTunnelMethodTypeSourcePostgresSSHKeyAuthentication

	return SourcePostgresSSHTunnelMethod{
		SourcePostgresSSHKeyAuthentication: &sourcePostgresSSHKeyAuthentication,
		Type:                               typ,
	}
}

func CreateSourcePostgresSSHTunnelMethodSourcePostgresPasswordAuthentication(sourcePostgresPasswordAuthentication SourcePostgresPasswordAuthentication) SourcePostgresSSHTunnelMethod {
	typ := SourcePostgresSSHTunnelMethodTypeSourcePostgresPasswordAuthentication

	return SourcePostgresSSHTunnelMethod{
		SourcePostgresPasswordAuthentication: &sourcePostgresPasswordAuthentication,
		Type:                                 typ,
	}
}

func (u *SourcePostgresSSHTunnelMethod) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var sourcePostgresNoTunnel SourcePostgresNoTunnel = SourcePostgresNoTunnel{}
	if err := utils.UnmarshalJSON(data, &sourcePostgresNoTunnel, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourcePostgresSSHTunnelMethodTypeSourcePostgresNoTunnel,
			Value: &sourcePostgresNoTunnel,
		})
	}

	var sourcePostgresSSHKeyAuthentication SourcePostgresSSHKeyAuthentication = SourcePostgresSSHKeyAuthentication{}
	if err := utils.UnmarshalJSON(data, &sourcePostgresSSHKeyAuthentication, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourcePostgresSSHTunnelMethodTypeSourcePostgresSSHKeyAuthentication,
			Value: &sourcePostgresSSHKeyAuthentication,
		})
	}

	var sourcePostgresPasswordAuthentication SourcePostgresPasswordAuthentication = SourcePostgresPasswordAuthentication{}
	if err := utils.UnmarshalJSON(data, &sourcePostgresPasswordAuthentication, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourcePostgresSSHTunnelMethodTypeSourcePostgresPasswordAuthentication,
			Value: &sourcePostgresPasswordAuthentication,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourcePostgresSSHTunnelMethod", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourcePostgresSSHTunnelMethod", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourcePostgresSSHTunnelMethodType)
	switch best.Type {
	case SourcePostgresSSHTunnelMethodTypeSourcePostgresNoTunnel:
		u.SourcePostgresNoTunnel = best.Value.(*SourcePostgresNoTunnel)
		return nil
	case SourcePostgresSSHTunnelMethodTypeSourcePostgresSSHKeyAuthentication:
		u.SourcePostgresSSHKeyAuthentication = best.Value.(*SourcePostgresSSHKeyAuthentication)
		return nil
	case SourcePostgresSSHTunnelMethodTypeSourcePostgresPasswordAuthentication:
		u.SourcePostgresPasswordAuthentication = best.Value.(*SourcePostgresPasswordAuthentication)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourcePostgresSSHTunnelMethod", string(data))
}

func (u SourcePostgresSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.SourcePostgresNoTunnel != nil {
		return utils.MarshalJSON(u.SourcePostgresNoTunnel, "", true)
	}

	if u.SourcePostgresSSHKeyAuthentication != nil {
		return utils.MarshalJSON(u.SourcePostgresSSHKeyAuthentication, "", true)
	}

	if u.SourcePostgresPasswordAuthentication != nil {
		return utils.MarshalJSON(u.SourcePostgresPasswordAuthentication, "", true)
	}

	return nil, errors.New("could not marshal union type SourcePostgresSSHTunnelMethod: all fields are null")
}

type SourcePostgresSourceType string

const (
	SourcePostgresSourceTypePostgres SourcePostgresSourceType = "postgres"
)

func (e SourcePostgresSourceType) ToPointer() *SourcePostgresSourceType {
	return &e
}
func (e *SourcePostgresSourceType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "postgres":
		*e = SourcePostgresSourceType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresSourceType: %v", v)
	}
}

type SourcePostgres struct {
	// Name of the database.
	Database string `json:"database"`
	// If using Entra service principal, the application ID of the service principal
	EntraClientID *string `json:"entra_client_id,omitempty"`
	// Interpret password as a client secret for a Microsft Entra service principal
	EntraServicePrincipalAuth *bool `default:"false" json:"entra_service_principal_auth"`
	// If using Entra service principal, the ID of the tenant
	EntraTenantID *string `json:"entra_tenant_id,omitempty"`
	// Hostname of the database.
	Host string `json:"host"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (Eg. key1=value1&key2=value2&key3=value3). For more information read about <a href="https://jdbc.postgresql.org/documentation/head/connect.html">JDBC URL parameters</a>.
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// Password associated with the username.
	Password *string `json:"password,omitempty"`
	// Port of the database.
	Port *int64 `default:"5432" json:"port"`
	// Configures how data is extracted from the database.
	ReplicationMethod *SourcePostgresUpdateMethod `json:"replication_method,omitempty"`
	// The list of schemas (case sensitive) to sync from. Defaults to public.
	Schemas []string `json:"schemas,omitempty"`
	// SSL connection modes.
	//   Read more <a href="https://jdbc.postgresql.org/documentation/head/ssl-client.html"> in the docs</a>.
	SslMode *SSLModes `json:"ssl_mode,omitempty"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod *SourcePostgresSSHTunnelMethod `json:"tunnel_method,omitempty"`
	// Username to access the database.
	Username   string                    `json:"username"`
	sourceType *SourcePostgresSourceType `const:"postgres" json:"sourceType"`
}

func (s SourcePostgres) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgres) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourcePostgres) GetDatabase() string {
	if s == nil {
		return ""
	}
	return s.Database
}

func (s *SourcePostgres) GetEntraClientID() *string {
	if s == nil {
		return nil
	}
	return s.EntraClientID
}

func (s *SourcePostgres) GetEntraServicePrincipalAuth() *bool {
	if s == nil {
		return nil
	}
	return s.EntraServicePrincipalAuth
}

func (s *SourcePostgres) GetEntraTenantID() *string {
	if s == nil {
		return nil
	}
	return s.EntraTenantID
}

func (s *SourcePostgres) GetHost() string {
	if s == nil {
		return ""
	}
	return s.Host
}

func (s *SourcePostgres) GetJdbcURLParams() *string {
	if s == nil {
		return nil
	}
	return s.JdbcURLParams
}

func (s *SourcePostgres) GetPassword() *string {
	if s == nil {
		return nil
	}
	return s.Password
}

func (s *SourcePostgres) GetPort() *int64 {
	if s == nil {
		return nil
	}
	return s.Port
}

func (s *SourcePostgres) GetReplicationMethod() *SourcePostgresUpdateMethod {
	if s == nil {
		return nil
	}
	return s.ReplicationMethod
}

func (s *SourcePostgres) GetSchemas() []string {
	if s == nil {
		return nil
	}
	return s.Schemas
}

func (s *SourcePostgres) GetSslMode() *SSLModes {
	if s == nil {
		return nil
	}
	return s.SslMode
}

func (s *SourcePostgres) GetTunnelMethod() *SourcePostgresSSHTunnelMethod {
	if s == nil {
		return nil
	}
	return s.TunnelMethod
}

func (s *SourcePostgres) GetUsername() string {
	if s == nil {
		return ""
	}
	return s.Username
}

func (s *SourcePostgres) GetSourceType() *SourcePostgresSourceType {
	return SourcePostgresSourceTypePostgres.ToPointer()
}
