// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

type SourcePostgresSchemasSSLModeSSLModes6Mode string

const (
	SourcePostgresSchemasSSLModeSSLModes6ModeVerifyFull SourcePostgresSchemasSSLModeSSLModes6Mode = "verify-full"
)

func (e SourcePostgresSchemasSSLModeSSLModes6Mode) ToPointer() *SourcePostgresSchemasSSLModeSSLModes6Mode {
	return &e
}
func (e *SourcePostgresSchemasSSLModeSSLModes6Mode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "verify-full":
		*e = SourcePostgresSchemasSSLModeSSLModes6Mode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresSchemasSSLModeSSLModes6Mode: %v", v)
	}
}

// VerifyFull - This is the most secure mode. Always require encryption and verifies the identity of the source database server.
type VerifyFull struct {
	mode SourcePostgresSchemasSSLModeSSLModes6Mode `const:"verify-full" json:"mode"`
	// CA certificate
	CaCertificate string `json:"ca_certificate"`
	// Client certificate
	ClientCertificate *string `json:"client_certificate,omitempty"`
	// Client key
	ClientKey *string `json:"client_key,omitempty"`
	// Password for keystorage. If you do not add it - the password will be generated automatically.
	ClientKeyPassword    *string `json:"client_key_password,omitempty"`
	AdditionalProperties any     `additionalProperties:"true" json:"-"`
}

func (v VerifyFull) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(v, "", false)
}

func (v *VerifyFull) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &v, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *VerifyFull) GetMode() SourcePostgresSchemasSSLModeSSLModes6Mode {
	return SourcePostgresSchemasSSLModeSSLModes6ModeVerifyFull
}

func (o *VerifyFull) GetCaCertificate() string {
	if o == nil {
		return ""
	}
	return o.CaCertificate
}

func (o *VerifyFull) GetClientCertificate() *string {
	if o == nil {
		return nil
	}
	return o.ClientCertificate
}

func (o *VerifyFull) GetClientKey() *string {
	if o == nil {
		return nil
	}
	return o.ClientKey
}

func (o *VerifyFull) GetClientKeyPassword() *string {
	if o == nil {
		return nil
	}
	return o.ClientKeyPassword
}

func (o *VerifyFull) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

type SourcePostgresSchemasSSLModeSSLModes5Mode string

const (
	SourcePostgresSchemasSSLModeSSLModes5ModeVerifyCa SourcePostgresSchemasSSLModeSSLModes5Mode = "verify-ca"
)

func (e SourcePostgresSchemasSSLModeSSLModes5Mode) ToPointer() *SourcePostgresSchemasSSLModeSSLModes5Mode {
	return &e
}
func (e *SourcePostgresSchemasSSLModeSSLModes5Mode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "verify-ca":
		*e = SourcePostgresSchemasSSLModeSSLModes5Mode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresSchemasSSLModeSSLModes5Mode: %v", v)
	}
}

// SourcePostgresVerifyCa - Always require encryption and verifies that the source database server has a valid SSL certificate.
type SourcePostgresVerifyCa struct {
	mode SourcePostgresSchemasSSLModeSSLModes5Mode `const:"verify-ca" json:"mode"`
	// CA certificate
	CaCertificate string `json:"ca_certificate"`
	// Client certificate
	ClientCertificate *string `json:"client_certificate,omitempty"`
	// Client key
	ClientKey *string `json:"client_key,omitempty"`
	// Password for keystorage. If you do not add it - the password will be generated automatically.
	ClientKeyPassword    *string `json:"client_key_password,omitempty"`
	AdditionalProperties any     `additionalProperties:"true" json:"-"`
}

func (s SourcePostgresVerifyCa) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresVerifyCa) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresVerifyCa) GetMode() SourcePostgresSchemasSSLModeSSLModes5Mode {
	return SourcePostgresSchemasSSLModeSSLModes5ModeVerifyCa
}

func (o *SourcePostgresVerifyCa) GetCaCertificate() string {
	if o == nil {
		return ""
	}
	return o.CaCertificate
}

func (o *SourcePostgresVerifyCa) GetClientCertificate() *string {
	if o == nil {
		return nil
	}
	return o.ClientCertificate
}

func (o *SourcePostgresVerifyCa) GetClientKey() *string {
	if o == nil {
		return nil
	}
	return o.ClientKey
}

func (o *SourcePostgresVerifyCa) GetClientKeyPassword() *string {
	if o == nil {
		return nil
	}
	return o.ClientKeyPassword
}

func (o *SourcePostgresVerifyCa) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

type SourcePostgresSchemasSSLModeSSLModesMode string

const (
	SourcePostgresSchemasSSLModeSSLModesModeRequire SourcePostgresSchemasSSLModeSSLModesMode = "require"
)

func (e SourcePostgresSchemasSSLModeSSLModesMode) ToPointer() *SourcePostgresSchemasSSLModeSSLModesMode {
	return &e
}
func (e *SourcePostgresSchemasSSLModeSSLModesMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "require":
		*e = SourcePostgresSchemasSSLModeSSLModesMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresSchemasSSLModeSSLModesMode: %v", v)
	}
}

// Require - Always require encryption. If the source database server does not support encryption, connection will fail.
type Require struct {
	mode                 SourcePostgresSchemasSSLModeSSLModesMode `const:"require" json:"mode"`
	AdditionalProperties any                                      `additionalProperties:"true" json:"-"`
}

func (r Require) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(r, "", false)
}

func (r *Require) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &r, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *Require) GetMode() SourcePostgresSchemasSSLModeSSLModesMode {
	return SourcePostgresSchemasSSLModeSSLModesModeRequire
}

func (o *Require) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

type SourcePostgresSchemasSslModeMode string

const (
	SourcePostgresSchemasSslModeModePrefer SourcePostgresSchemasSslModeMode = "prefer"
)

func (e SourcePostgresSchemasSslModeMode) ToPointer() *SourcePostgresSchemasSslModeMode {
	return &e
}
func (e *SourcePostgresSchemasSslModeMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "prefer":
		*e = SourcePostgresSchemasSslModeMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresSchemasSslModeMode: %v", v)
	}
}

// Prefer - Allows unencrypted connection only if the source database does not support encryption.
type Prefer struct {
	mode                 SourcePostgresSchemasSslModeMode `const:"prefer" json:"mode"`
	AdditionalProperties any                              `additionalProperties:"true" json:"-"`
}

func (p Prefer) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *Prefer) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *Prefer) GetMode() SourcePostgresSchemasSslModeMode {
	return SourcePostgresSchemasSslModeModePrefer
}

func (o *Prefer) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

type SourcePostgresSchemasMode string

const (
	SourcePostgresSchemasModeAllow SourcePostgresSchemasMode = "allow"
)

func (e SourcePostgresSchemasMode) ToPointer() *SourcePostgresSchemasMode {
	return &e
}
func (e *SourcePostgresSchemasMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "allow":
		*e = SourcePostgresSchemasMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresSchemasMode: %v", v)
	}
}

// Allow - Enables encryption only when required by the source database.
type Allow struct {
	mode                 SourcePostgresSchemasMode `const:"allow" json:"mode"`
	AdditionalProperties any                       `additionalProperties:"true" json:"-"`
}

func (a Allow) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *Allow) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *Allow) GetMode() SourcePostgresSchemasMode {
	return SourcePostgresSchemasModeAllow
}

func (o *Allow) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

type SourcePostgresMode string

const (
	SourcePostgresModeDisable SourcePostgresMode = "disable"
)

func (e SourcePostgresMode) ToPointer() *SourcePostgresMode {
	return &e
}
func (e *SourcePostgresMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "disable":
		*e = SourcePostgresMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresMode: %v", v)
	}
}

// Disable - Disables encryption of communication between Airbyte and source database.
type Disable struct {
	mode                 SourcePostgresMode `const:"disable" json:"mode"`
	AdditionalProperties any                `additionalProperties:"true" json:"-"`
}

func (d Disable) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *Disable) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *Disable) GetMode() SourcePostgresMode {
	return SourcePostgresModeDisable
}

func (o *Disable) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

type SSLModesType string

const (
	SSLModesTypeDisable                SSLModesType = "disable"
	SSLModesTypeAllow                  SSLModesType = "allow"
	SSLModesTypePrefer                 SSLModesType = "prefer"
	SSLModesTypeRequire                SSLModesType = "require"
	SSLModesTypeSourcePostgresVerifyCa SSLModesType = "source-postgres_verify-ca"
	SSLModesTypeVerifyFull             SSLModesType = "verify-full"
)

// SSLModes - SSL connection modes.
//
//	Read more <a href="https://jdbc.postgresql.org/documentation/head/ssl-client.html"> in the docs</a>.
type SSLModes struct {
	Disable                *Disable                `queryParam:"inline"`
	Allow                  *Allow                  `queryParam:"inline"`
	Prefer                 *Prefer                 `queryParam:"inline"`
	Require                *Require                `queryParam:"inline"`
	SourcePostgresVerifyCa *SourcePostgresVerifyCa `queryParam:"inline"`
	VerifyFull             *VerifyFull             `queryParam:"inline"`

	Type SSLModesType
}

func CreateSSLModesDisable(disable Disable) SSLModes {
	typ := SSLModesTypeDisable

	return SSLModes{
		Disable: &disable,
		Type:    typ,
	}
}

func CreateSSLModesAllow(allow Allow) SSLModes {
	typ := SSLModesTypeAllow

	return SSLModes{
		Allow: &allow,
		Type:  typ,
	}
}

func CreateSSLModesPrefer(prefer Prefer) SSLModes {
	typ := SSLModesTypePrefer

	return SSLModes{
		Prefer: &prefer,
		Type:   typ,
	}
}

func CreateSSLModesRequire(require Require) SSLModes {
	typ := SSLModesTypeRequire

	return SSLModes{
		Require: &require,
		Type:    typ,
	}
}

func CreateSSLModesSourcePostgresVerifyCa(sourcePostgresVerifyCa SourcePostgresVerifyCa) SSLModes {
	typ := SSLModesTypeSourcePostgresVerifyCa

	return SSLModes{
		SourcePostgresVerifyCa: &sourcePostgresVerifyCa,
		Type:                   typ,
	}
}

func CreateSSLModesVerifyFull(verifyFull VerifyFull) SSLModes {
	typ := SSLModesTypeVerifyFull

	return SSLModes{
		VerifyFull: &verifyFull,
		Type:       typ,
	}
}

func (u *SSLModes) UnmarshalJSON(data []byte) error {

	var disable Disable = Disable{}
	if err := utils.UnmarshalJSON(data, &disable, "", true, true); err == nil {
		u.Disable = &disable
		u.Type = SSLModesTypeDisable
		return nil
	}

	var allow Allow = Allow{}
	if err := utils.UnmarshalJSON(data, &allow, "", true, true); err == nil {
		u.Allow = &allow
		u.Type = SSLModesTypeAllow
		return nil
	}

	var prefer Prefer = Prefer{}
	if err := utils.UnmarshalJSON(data, &prefer, "", true, true); err == nil {
		u.Prefer = &prefer
		u.Type = SSLModesTypePrefer
		return nil
	}

	var require Require = Require{}
	if err := utils.UnmarshalJSON(data, &require, "", true, true); err == nil {
		u.Require = &require
		u.Type = SSLModesTypeRequire
		return nil
	}

	var sourcePostgresVerifyCa SourcePostgresVerifyCa = SourcePostgresVerifyCa{}
	if err := utils.UnmarshalJSON(data, &sourcePostgresVerifyCa, "", true, true); err == nil {
		u.SourcePostgresVerifyCa = &sourcePostgresVerifyCa
		u.Type = SSLModesTypeSourcePostgresVerifyCa
		return nil
	}

	var verifyFull VerifyFull = VerifyFull{}
	if err := utils.UnmarshalJSON(data, &verifyFull, "", true, true); err == nil {
		u.VerifyFull = &verifyFull
		u.Type = SSLModesTypeVerifyFull
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SSLModes", string(data))
}

func (u SSLModes) MarshalJSON() ([]byte, error) {
	if u.Disable != nil {
		return utils.MarshalJSON(u.Disable, "", true)
	}

	if u.Allow != nil {
		return utils.MarshalJSON(u.Allow, "", true)
	}

	if u.Prefer != nil {
		return utils.MarshalJSON(u.Prefer, "", true)
	}

	if u.Require != nil {
		return utils.MarshalJSON(u.Require, "", true)
	}

	if u.SourcePostgresVerifyCa != nil {
		return utils.MarshalJSON(u.SourcePostgresVerifyCa, "", true)
	}

	if u.VerifyFull != nil {
		return utils.MarshalJSON(u.VerifyFull, "", true)
	}

	return nil, errors.New("could not marshal union type SSLModes: all fields are null")
}

type SourcePostgresSchemasReplicationMethodMethod string

const (
	SourcePostgresSchemasReplicationMethodMethodStandard SourcePostgresSchemasReplicationMethodMethod = "Standard"
)

func (e SourcePostgresSchemasReplicationMethodMethod) ToPointer() *SourcePostgresSchemasReplicationMethodMethod {
	return &e
}
func (e *SourcePostgresSchemasReplicationMethodMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Standard":
		*e = SourcePostgresSchemasReplicationMethodMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresSchemasReplicationMethodMethod: %v", v)
	}
}

// SourcePostgresScanChangesWithUserDefinedCursor - Incrementally detects new inserts and updates using the <a href="https://docs.airbyte.com/understanding-airbyte/connections/incremental-append/#user-defined-cursor">cursor column</a> chosen when configuring a connection (e.g. created_at, updated_at).
type SourcePostgresScanChangesWithUserDefinedCursor struct {
	method SourcePostgresSchemasReplicationMethodMethod `const:"Standard" json:"method"`
}

func (s SourcePostgresScanChangesWithUserDefinedCursor) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresScanChangesWithUserDefinedCursor) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresScanChangesWithUserDefinedCursor) GetMethod() SourcePostgresSchemasReplicationMethodMethod {
	return SourcePostgresSchemasReplicationMethodMethodStandard
}

type SourcePostgresSchemasMethod string

const (
	SourcePostgresSchemasMethodXmin SourcePostgresSchemasMethod = "Xmin"
)

func (e SourcePostgresSchemasMethod) ToPointer() *SourcePostgresSchemasMethod {
	return &e
}
func (e *SourcePostgresSchemasMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Xmin":
		*e = SourcePostgresSchemasMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresSchemasMethod: %v", v)
	}
}

// DetectChangesWithXminSystemColumn - <i>Recommended</i> - Incrementally reads new inserts and updates via Postgres <a href="https://docs.airbyte.com/integrations/sources/postgres/#xmin">Xmin system column</a>. Suitable for databases that have low transaction pressure.
type DetectChangesWithXminSystemColumn struct {
	method SourcePostgresSchemasMethod `const:"Xmin" json:"method"`
}

func (d DetectChangesWithXminSystemColumn) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DetectChangesWithXminSystemColumn) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DetectChangesWithXminSystemColumn) GetMethod() SourcePostgresSchemasMethod {
	return SourcePostgresSchemasMethodXmin
}

type SourcePostgresMethod string

const (
	SourcePostgresMethodCdc SourcePostgresMethod = "CDC"
)

func (e SourcePostgresMethod) ToPointer() *SourcePostgresMethod {
	return &e
}
func (e *SourcePostgresMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CDC":
		*e = SourcePostgresMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresMethod: %v", v)
	}
}

// Plugin - A logical decoding plugin installed on the PostgreSQL server.
type Plugin string

const (
	PluginPgoutput Plugin = "pgoutput"
)

func (e Plugin) ToPointer() *Plugin {
	return &e
}
func (e *Plugin) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "pgoutput":
		*e = Plugin(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Plugin: %v", v)
	}
}

// LSNCommitBehaviour - Determines when Airbyte should flush the LSN of processed WAL logs in the source database. `After loading Data in the destination` is default. If `While reading Data` is selected, in case of a downstream failure (while loading data into the destination), next sync would result in a full sync.
type LSNCommitBehaviour string

const (
	LSNCommitBehaviourWhileReadingData                 LSNCommitBehaviour = "While reading Data"
	LSNCommitBehaviourAfterLoadingDataInTheDestination LSNCommitBehaviour = "After loading Data in the destination"
)

func (e LSNCommitBehaviour) ToPointer() *LSNCommitBehaviour {
	return &e
}
func (e *LSNCommitBehaviour) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "While reading Data":
		fallthrough
	case "After loading Data in the destination":
		*e = LSNCommitBehaviour(v)
		return nil
	default:
		return fmt.Errorf("invalid value for LSNCommitBehaviour: %v", v)
	}
}

// SourcePostgresInvalidCDCPositionBehaviorAdvanced - Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value into the WAL. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss.
type SourcePostgresInvalidCDCPositionBehaviorAdvanced string

const (
	SourcePostgresInvalidCDCPositionBehaviorAdvancedFailSync   SourcePostgresInvalidCDCPositionBehaviorAdvanced = "Fail sync"
	SourcePostgresInvalidCDCPositionBehaviorAdvancedReSyncData SourcePostgresInvalidCDCPositionBehaviorAdvanced = "Re-sync data"
)

func (e SourcePostgresInvalidCDCPositionBehaviorAdvanced) ToPointer() *SourcePostgresInvalidCDCPositionBehaviorAdvanced {
	return &e
}
func (e *SourcePostgresInvalidCDCPositionBehaviorAdvanced) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Fail sync":
		fallthrough
	case "Re-sync data":
		*e = SourcePostgresInvalidCDCPositionBehaviorAdvanced(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresInvalidCDCPositionBehaviorAdvanced: %v", v)
	}
}

// ReadChangesUsingWriteAheadLogCDC - <i>Recommended</i> - Incrementally reads new inserts, updates, and deletes using the Postgres <a href="https://docs.airbyte.com/integrations/sources/postgres/#cdc">write-ahead log (WAL)</a>. This needs to be configured on the source database itself. Recommended for tables of any size.
type ReadChangesUsingWriteAheadLogCDC struct {
	method SourcePostgresMethod `const:"CDC" json:"method"`
	// A logical decoding plugin installed on the PostgreSQL server.
	Plugin *Plugin `default:"pgoutput" json:"plugin"`
	// A plugin logical replication slot. Read about <a href="https://docs.airbyte.com/integrations/sources/postgres#step-3-create-replication-slot">replication slots</a>.
	ReplicationSlot string `json:"replication_slot"`
	// A Postgres publication used for consuming changes. Read about <a href="https://docs.airbyte.com/integrations/sources/postgres#step-4-create-publications-and-replication-identities-for-tables">publications and replication identities</a>.
	Publication string `json:"publication"`
	// The amount of time the connector will wait when it launches to determine if there is new data to sync or not. Defaults to 1200 seconds. Valid range: 120 seconds to 2400 seconds. Read about <a href="https://docs.airbyte.com/integrations/sources/postgres/postgres-troubleshooting#advanced-setting-up-initial-cdc-waiting-time">initial waiting time</a>.
	InitialWaitingSeconds *int64 `default:"1200" json:"initial_waiting_seconds"`
	// The size of the internal queue. This may interfere with memory consumption and efficiency of the connector, please be careful.
	QueueSize *int64 `default:"10000" json:"queue_size"`
	// Determines when Airbyte should flush the LSN of processed WAL logs in the source database. `After loading Data in the destination` is default. If `While reading Data` is selected, in case of a downstream failure (while loading data into the destination), next sync would result in a full sync.
	LsnCommitBehaviour *LSNCommitBehaviour `default:"After loading Data in the destination" json:"lsn_commit_behaviour"`
	// Specifies a query that the connector executes on the source database when the connector sends a heartbeat message. Please see the <a href="https://docs.airbyte.com/integrations/sources/postgres/postgres-troubleshooting#advanced-wal-disk-consumption-and-heartbeat-action-query">setup guide</a> for how and when to configure this setting.
	HeartbeatActionQuery *string `default:"" json:"heartbeat_action_query"`
	// Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value into the WAL. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss.
	InvalidCdcCursorPositionBehavior *SourcePostgresInvalidCDCPositionBehaviorAdvanced `default:"Fail sync" json:"invalid_cdc_cursor_position_behavior"`
	// The amount of time an initial load is allowed to continue for before catching up on CDC logs.
	InitialLoadTimeoutHours *int64 `default:"8" json:"initial_load_timeout_hours"`
	AdditionalProperties    any    `additionalProperties:"true" json:"-"`
}

func (r ReadChangesUsingWriteAheadLogCDC) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(r, "", false)
}

func (r *ReadChangesUsingWriteAheadLogCDC) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &r, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *ReadChangesUsingWriteAheadLogCDC) GetMethod() SourcePostgresMethod {
	return SourcePostgresMethodCdc
}

func (o *ReadChangesUsingWriteAheadLogCDC) GetPlugin() *Plugin {
	if o == nil {
		return nil
	}
	return o.Plugin
}

func (o *ReadChangesUsingWriteAheadLogCDC) GetReplicationSlot() string {
	if o == nil {
		return ""
	}
	return o.ReplicationSlot
}

func (o *ReadChangesUsingWriteAheadLogCDC) GetPublication() string {
	if o == nil {
		return ""
	}
	return o.Publication
}

func (o *ReadChangesUsingWriteAheadLogCDC) GetInitialWaitingSeconds() *int64 {
	if o == nil {
		return nil
	}
	return o.InitialWaitingSeconds
}

func (o *ReadChangesUsingWriteAheadLogCDC) GetQueueSize() *int64 {
	if o == nil {
		return nil
	}
	return o.QueueSize
}

func (o *ReadChangesUsingWriteAheadLogCDC) GetLsnCommitBehaviour() *LSNCommitBehaviour {
	if o == nil {
		return nil
	}
	return o.LsnCommitBehaviour
}

func (o *ReadChangesUsingWriteAheadLogCDC) GetHeartbeatActionQuery() *string {
	if o == nil {
		return nil
	}
	return o.HeartbeatActionQuery
}

func (o *ReadChangesUsingWriteAheadLogCDC) GetInvalidCdcCursorPositionBehavior() *SourcePostgresInvalidCDCPositionBehaviorAdvanced {
	if o == nil {
		return nil
	}
	return o.InvalidCdcCursorPositionBehavior
}

func (o *ReadChangesUsingWriteAheadLogCDC) GetInitialLoadTimeoutHours() *int64 {
	if o == nil {
		return nil
	}
	return o.InitialLoadTimeoutHours
}

func (o *ReadChangesUsingWriteAheadLogCDC) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

type SourcePostgresUpdateMethodType string

const (
	SourcePostgresUpdateMethodTypeReadChangesUsingWriteAheadLogCDC               SourcePostgresUpdateMethodType = "Read Changes using Write-Ahead Log (CDC)"
	SourcePostgresUpdateMethodTypeDetectChangesWithXminSystemColumn              SourcePostgresUpdateMethodType = "Detect Changes with Xmin System Column"
	SourcePostgresUpdateMethodTypeSourcePostgresScanChangesWithUserDefinedCursor SourcePostgresUpdateMethodType = "source-postgres_Scan Changes with User Defined Cursor"
)

// SourcePostgresUpdateMethod - Configures how data is extracted from the database.
type SourcePostgresUpdateMethod struct {
	ReadChangesUsingWriteAheadLogCDC               *ReadChangesUsingWriteAheadLogCDC               `queryParam:"inline"`
	DetectChangesWithXminSystemColumn              *DetectChangesWithXminSystemColumn              `queryParam:"inline"`
	SourcePostgresScanChangesWithUserDefinedCursor *SourcePostgresScanChangesWithUserDefinedCursor `queryParam:"inline"`

	Type SourcePostgresUpdateMethodType
}

func CreateSourcePostgresUpdateMethodReadChangesUsingWriteAheadLogCDC(readChangesUsingWriteAheadLogCDC ReadChangesUsingWriteAheadLogCDC) SourcePostgresUpdateMethod {
	typ := SourcePostgresUpdateMethodTypeReadChangesUsingWriteAheadLogCDC

	return SourcePostgresUpdateMethod{
		ReadChangesUsingWriteAheadLogCDC: &readChangesUsingWriteAheadLogCDC,
		Type:                             typ,
	}
}

func CreateSourcePostgresUpdateMethodDetectChangesWithXminSystemColumn(detectChangesWithXminSystemColumn DetectChangesWithXminSystemColumn) SourcePostgresUpdateMethod {
	typ := SourcePostgresUpdateMethodTypeDetectChangesWithXminSystemColumn

	return SourcePostgresUpdateMethod{
		DetectChangesWithXminSystemColumn: &detectChangesWithXminSystemColumn,
		Type:                              typ,
	}
}

func CreateSourcePostgresUpdateMethodSourcePostgresScanChangesWithUserDefinedCursor(sourcePostgresScanChangesWithUserDefinedCursor SourcePostgresScanChangesWithUserDefinedCursor) SourcePostgresUpdateMethod {
	typ := SourcePostgresUpdateMethodTypeSourcePostgresScanChangesWithUserDefinedCursor

	return SourcePostgresUpdateMethod{
		SourcePostgresScanChangesWithUserDefinedCursor: &sourcePostgresScanChangesWithUserDefinedCursor,
		Type: typ,
	}
}

func (u *SourcePostgresUpdateMethod) UnmarshalJSON(data []byte) error {

	var detectChangesWithXminSystemColumn DetectChangesWithXminSystemColumn = DetectChangesWithXminSystemColumn{}
	if err := utils.UnmarshalJSON(data, &detectChangesWithXminSystemColumn, "", true, true); err == nil {
		u.DetectChangesWithXminSystemColumn = &detectChangesWithXminSystemColumn
		u.Type = SourcePostgresUpdateMethodTypeDetectChangesWithXminSystemColumn
		return nil
	}

	var sourcePostgresScanChangesWithUserDefinedCursor SourcePostgresScanChangesWithUserDefinedCursor = SourcePostgresScanChangesWithUserDefinedCursor{}
	if err := utils.UnmarshalJSON(data, &sourcePostgresScanChangesWithUserDefinedCursor, "", true, true); err == nil {
		u.SourcePostgresScanChangesWithUserDefinedCursor = &sourcePostgresScanChangesWithUserDefinedCursor
		u.Type = SourcePostgresUpdateMethodTypeSourcePostgresScanChangesWithUserDefinedCursor
		return nil
	}

	var readChangesUsingWriteAheadLogCDC ReadChangesUsingWriteAheadLogCDC = ReadChangesUsingWriteAheadLogCDC{}
	if err := utils.UnmarshalJSON(data, &readChangesUsingWriteAheadLogCDC, "", true, true); err == nil {
		u.ReadChangesUsingWriteAheadLogCDC = &readChangesUsingWriteAheadLogCDC
		u.Type = SourcePostgresUpdateMethodTypeReadChangesUsingWriteAheadLogCDC
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourcePostgresUpdateMethod", string(data))
}

func (u SourcePostgresUpdateMethod) MarshalJSON() ([]byte, error) {
	if u.ReadChangesUsingWriteAheadLogCDC != nil {
		return utils.MarshalJSON(u.ReadChangesUsingWriteAheadLogCDC, "", true)
	}

	if u.DetectChangesWithXminSystemColumn != nil {
		return utils.MarshalJSON(u.DetectChangesWithXminSystemColumn, "", true)
	}

	if u.SourcePostgresScanChangesWithUserDefinedCursor != nil {
		return utils.MarshalJSON(u.SourcePostgresScanChangesWithUserDefinedCursor, "", true)
	}

	return nil, errors.New("could not marshal union type SourcePostgresUpdateMethod: all fields are null")
}

// SourcePostgresSchemasTunnelMethodTunnelMethod - Connect through a jump server tunnel host using username and password authentication
type SourcePostgresSchemasTunnelMethodTunnelMethod string

const (
	SourcePostgresSchemasTunnelMethodTunnelMethodSSHPasswordAuth SourcePostgresSchemasTunnelMethodTunnelMethod = "SSH_PASSWORD_AUTH"
)

func (e SourcePostgresSchemasTunnelMethodTunnelMethod) ToPointer() *SourcePostgresSchemasTunnelMethodTunnelMethod {
	return &e
}
func (e *SourcePostgresSchemasTunnelMethodTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_PASSWORD_AUTH":
		*e = SourcePostgresSchemasTunnelMethodTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresSchemasTunnelMethodTunnelMethod: %v", v)
	}
}

type SourcePostgresPasswordAuthentication struct {
	// Connect through a jump server tunnel host using username and password authentication
	tunnelMethod SourcePostgresSchemasTunnelMethodTunnelMethod `const:"SSH_PASSWORD_AUTH" json:"tunnel_method"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser string `json:"tunnel_user"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword string `json:"tunnel_user_password"`
}

func (s SourcePostgresPasswordAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresPasswordAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresPasswordAuthentication) GetTunnelMethod() SourcePostgresSchemasTunnelMethodTunnelMethod {
	return SourcePostgresSchemasTunnelMethodTunnelMethodSSHPasswordAuth
}

func (o *SourcePostgresPasswordAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *SourcePostgresPasswordAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *SourcePostgresPasswordAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

func (o *SourcePostgresPasswordAuthentication) GetTunnelUserPassword() string {
	if o == nil {
		return ""
	}
	return o.TunnelUserPassword
}

// SourcePostgresSchemasTunnelMethod - Connect through a jump server tunnel host using username and ssh key
type SourcePostgresSchemasTunnelMethod string

const (
	SourcePostgresSchemasTunnelMethodSSHKeyAuth SourcePostgresSchemasTunnelMethod = "SSH_KEY_AUTH"
)

func (e SourcePostgresSchemasTunnelMethod) ToPointer() *SourcePostgresSchemasTunnelMethod {
	return &e
}
func (e *SourcePostgresSchemasTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_KEY_AUTH":
		*e = SourcePostgresSchemasTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresSchemasTunnelMethod: %v", v)
	}
}

type SourcePostgresSSHKeyAuthentication struct {
	// Connect through a jump server tunnel host using username and ssh key
	tunnelMethod SourcePostgresSchemasTunnelMethod `const:"SSH_KEY_AUTH" json:"tunnel_method"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host.
	TunnelUser string `json:"tunnel_user"`
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey string `json:"ssh_key"`
}

func (s SourcePostgresSSHKeyAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresSSHKeyAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresSSHKeyAuthentication) GetTunnelMethod() SourcePostgresSchemasTunnelMethod {
	return SourcePostgresSchemasTunnelMethodSSHKeyAuth
}

func (o *SourcePostgresSSHKeyAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *SourcePostgresSSHKeyAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *SourcePostgresSSHKeyAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

func (o *SourcePostgresSSHKeyAuthentication) GetSSHKey() string {
	if o == nil {
		return ""
	}
	return o.SSHKey
}

// SourcePostgresTunnelMethod - No ssh tunnel needed to connect to database
type SourcePostgresTunnelMethod string

const (
	SourcePostgresTunnelMethodNoTunnel SourcePostgresTunnelMethod = "NO_TUNNEL"
)

func (e SourcePostgresTunnelMethod) ToPointer() *SourcePostgresTunnelMethod {
	return &e
}
func (e *SourcePostgresTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NO_TUNNEL":
		*e = SourcePostgresTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresTunnelMethod: %v", v)
	}
}

type SourcePostgresNoTunnel struct {
	// No ssh tunnel needed to connect to database
	tunnelMethod SourcePostgresTunnelMethod `const:"NO_TUNNEL" json:"tunnel_method"`
}

func (s SourcePostgresNoTunnel) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresNoTunnel) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresNoTunnel) GetTunnelMethod() SourcePostgresTunnelMethod {
	return SourcePostgresTunnelMethodNoTunnel
}

type SourcePostgresSSHTunnelMethodType string

const (
	SourcePostgresSSHTunnelMethodTypeSourcePostgresNoTunnel               SourcePostgresSSHTunnelMethodType = "source-postgres_No Tunnel"
	SourcePostgresSSHTunnelMethodTypeSourcePostgresSSHKeyAuthentication   SourcePostgresSSHTunnelMethodType = "source-postgres_SSH Key Authentication"
	SourcePostgresSSHTunnelMethodTypeSourcePostgresPasswordAuthentication SourcePostgresSSHTunnelMethodType = "source-postgres_Password Authentication"
)

// SourcePostgresSSHTunnelMethod - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourcePostgresSSHTunnelMethod struct {
	SourcePostgresNoTunnel               *SourcePostgresNoTunnel               `queryParam:"inline"`
	SourcePostgresSSHKeyAuthentication   *SourcePostgresSSHKeyAuthentication   `queryParam:"inline"`
	SourcePostgresPasswordAuthentication *SourcePostgresPasswordAuthentication `queryParam:"inline"`

	Type SourcePostgresSSHTunnelMethodType
}

func CreateSourcePostgresSSHTunnelMethodSourcePostgresNoTunnel(sourcePostgresNoTunnel SourcePostgresNoTunnel) SourcePostgresSSHTunnelMethod {
	typ := SourcePostgresSSHTunnelMethodTypeSourcePostgresNoTunnel

	return SourcePostgresSSHTunnelMethod{
		SourcePostgresNoTunnel: &sourcePostgresNoTunnel,
		Type:                   typ,
	}
}

func CreateSourcePostgresSSHTunnelMethodSourcePostgresSSHKeyAuthentication(sourcePostgresSSHKeyAuthentication SourcePostgresSSHKeyAuthentication) SourcePostgresSSHTunnelMethod {
	typ := SourcePostgresSSHTunnelMethodTypeSourcePostgresSSHKeyAuthentication

	return SourcePostgresSSHTunnelMethod{
		SourcePostgresSSHKeyAuthentication: &sourcePostgresSSHKeyAuthentication,
		Type:                               typ,
	}
}

func CreateSourcePostgresSSHTunnelMethodSourcePostgresPasswordAuthentication(sourcePostgresPasswordAuthentication SourcePostgresPasswordAuthentication) SourcePostgresSSHTunnelMethod {
	typ := SourcePostgresSSHTunnelMethodTypeSourcePostgresPasswordAuthentication

	return SourcePostgresSSHTunnelMethod{
		SourcePostgresPasswordAuthentication: &sourcePostgresPasswordAuthentication,
		Type:                                 typ,
	}
}

func (u *SourcePostgresSSHTunnelMethod) UnmarshalJSON(data []byte) error {

	var sourcePostgresNoTunnel SourcePostgresNoTunnel = SourcePostgresNoTunnel{}
	if err := utils.UnmarshalJSON(data, &sourcePostgresNoTunnel, "", true, true); err == nil {
		u.SourcePostgresNoTunnel = &sourcePostgresNoTunnel
		u.Type = SourcePostgresSSHTunnelMethodTypeSourcePostgresNoTunnel
		return nil
	}

	var sourcePostgresSSHKeyAuthentication SourcePostgresSSHKeyAuthentication = SourcePostgresSSHKeyAuthentication{}
	if err := utils.UnmarshalJSON(data, &sourcePostgresSSHKeyAuthentication, "", true, true); err == nil {
		u.SourcePostgresSSHKeyAuthentication = &sourcePostgresSSHKeyAuthentication
		u.Type = SourcePostgresSSHTunnelMethodTypeSourcePostgresSSHKeyAuthentication
		return nil
	}

	var sourcePostgresPasswordAuthentication SourcePostgresPasswordAuthentication = SourcePostgresPasswordAuthentication{}
	if err := utils.UnmarshalJSON(data, &sourcePostgresPasswordAuthentication, "", true, true); err == nil {
		u.SourcePostgresPasswordAuthentication = &sourcePostgresPasswordAuthentication
		u.Type = SourcePostgresSSHTunnelMethodTypeSourcePostgresPasswordAuthentication
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourcePostgresSSHTunnelMethod", string(data))
}

func (u SourcePostgresSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.SourcePostgresNoTunnel != nil {
		return utils.MarshalJSON(u.SourcePostgresNoTunnel, "", true)
	}

	if u.SourcePostgresSSHKeyAuthentication != nil {
		return utils.MarshalJSON(u.SourcePostgresSSHKeyAuthentication, "", true)
	}

	if u.SourcePostgresPasswordAuthentication != nil {
		return utils.MarshalJSON(u.SourcePostgresPasswordAuthentication, "", true)
	}

	return nil, errors.New("could not marshal union type SourcePostgresSSHTunnelMethod: all fields are null")
}

type Postgres string

const (
	PostgresPostgres Postgres = "postgres"
)

func (e Postgres) ToPointer() *Postgres {
	return &e
}
func (e *Postgres) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "postgres":
		*e = Postgres(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Postgres: %v", v)
	}
}

type SourcePostgres struct {
	// Hostname of the database.
	Host string `json:"host"`
	// Port of the database.
	Port *int64 `default:"5432" json:"port"`
	// Name of the database.
	Database string `json:"database"`
	// The list of schemas (case sensitive) to sync from. Defaults to public.
	Schemas []string `json:"schemas,omitempty"`
	// Username to access the database.
	Username string `json:"username"`
	// Password associated with the username.
	Password *string `json:"password,omitempty"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (Eg. key1=value1&key2=value2&key3=value3). For more information read about <a href="https://jdbc.postgresql.org/documentation/head/connect.html">JDBC URL parameters</a>.
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// SSL connection modes.
	//   Read more <a href="https://jdbc.postgresql.org/documentation/head/ssl-client.html"> in the docs</a>.
	SslMode *SSLModes `json:"ssl_mode,omitempty"`
	// Configures how data is extracted from the database.
	ReplicationMethod *SourcePostgresUpdateMethod `json:"replication_method,omitempty"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod *SourcePostgresSSHTunnelMethod `json:"tunnel_method,omitempty"`
	sourceType   Postgres                       `const:"postgres" json:"sourceType"`
}

func (s SourcePostgres) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgres) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgres) GetHost() string {
	if o == nil {
		return ""
	}
	return o.Host
}

func (o *SourcePostgres) GetPort() *int64 {
	if o == nil {
		return nil
	}
	return o.Port
}

func (o *SourcePostgres) GetDatabase() string {
	if o == nil {
		return ""
	}
	return o.Database
}

func (o *SourcePostgres) GetSchemas() []string {
	if o == nil {
		return nil
	}
	return o.Schemas
}

func (o *SourcePostgres) GetUsername() string {
	if o == nil {
		return ""
	}
	return o.Username
}

func (o *SourcePostgres) GetPassword() *string {
	if o == nil {
		return nil
	}
	return o.Password
}

func (o *SourcePostgres) GetJdbcURLParams() *string {
	if o == nil {
		return nil
	}
	return o.JdbcURLParams
}

func (o *SourcePostgres) GetSslMode() *SSLModes {
	if o == nil {
		return nil
	}
	return o.SslMode
}

func (o *SourcePostgres) GetReplicationMethod() *SourcePostgresUpdateMethod {
	if o == nil {
		return nil
	}
	return o.ReplicationMethod
}

func (o *SourcePostgres) GetTunnelMethod() *SourcePostgresSSHTunnelMethod {
	if o == nil {
		return nil
	}
	return o.TunnelMethod
}

func (o *SourcePostgres) GetSourceType() Postgres {
	return PostgresPostgres
}
