// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

type DestinationDatabricksPersonalAccessToken struct {
	authType            string `const:"BASIC" json:"auth_type"`
	PersonalAccessToken string `json:"personal_access_token"`
}

func (d DestinationDatabricksPersonalAccessToken) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationDatabricksPersonalAccessToken) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationDatabricksPersonalAccessToken) GetAuthType() string {
	return "BASIC"
}

func (d *DestinationDatabricksPersonalAccessToken) GetPersonalAccessToken() string {
	if d == nil {
		return ""
	}
	return d.PersonalAccessToken
}

type OAuth2Recommended struct {
	authType string `const:"OAUTH" json:"auth_type"`
	ClientID string `json:"client_id"`
	Secret   string `json:"secret"`
}

func (o OAuth2Recommended) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(o, "", false)
}

func (o *OAuth2Recommended) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &o, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *OAuth2Recommended) GetAuthType() string {
	return "OAUTH"
}

func (o *OAuth2Recommended) GetClientID() string {
	if o == nil {
		return ""
	}
	return o.ClientID
}

func (o *OAuth2Recommended) GetSecret() string {
	if o == nil {
		return ""
	}
	return o.Secret
}

type DestinationDatabricksAuthenticationType string

const (
	DestinationDatabricksAuthenticationTypeOAuth2Recommended                        DestinationDatabricksAuthenticationType = "OAuth2 (Recommended)"
	DestinationDatabricksAuthenticationTypeDestinationDatabricksPersonalAccessToken DestinationDatabricksAuthenticationType = "destination-databricks_Personal Access Token"
)

// DestinationDatabricksAuthentication - Authentication mechanism for Staging files and running queries
type DestinationDatabricksAuthentication struct {
	OAuth2Recommended                        *OAuth2Recommended                        `queryParam:"inline" union:"member"`
	DestinationDatabricksPersonalAccessToken *DestinationDatabricksPersonalAccessToken `queryParam:"inline" union:"member"`

	Type DestinationDatabricksAuthenticationType
}

func CreateDestinationDatabricksAuthenticationOAuth2Recommended(oAuth2Recommended OAuth2Recommended) DestinationDatabricksAuthentication {
	typ := DestinationDatabricksAuthenticationTypeOAuth2Recommended

	return DestinationDatabricksAuthentication{
		OAuth2Recommended: &oAuth2Recommended,
		Type:              typ,
	}
}

func CreateDestinationDatabricksAuthenticationDestinationDatabricksPersonalAccessToken(destinationDatabricksPersonalAccessToken DestinationDatabricksPersonalAccessToken) DestinationDatabricksAuthentication {
	typ := DestinationDatabricksAuthenticationTypeDestinationDatabricksPersonalAccessToken

	return DestinationDatabricksAuthentication{
		DestinationDatabricksPersonalAccessToken: &destinationDatabricksPersonalAccessToken,
		Type:                                     typ,
	}
}

func (u *DestinationDatabricksAuthentication) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var oAuth2Recommended OAuth2Recommended = OAuth2Recommended{}
	if err := utils.UnmarshalJSON(data, &oAuth2Recommended, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationDatabricksAuthenticationTypeOAuth2Recommended,
			Value: &oAuth2Recommended,
		})
	}

	var destinationDatabricksPersonalAccessToken DestinationDatabricksPersonalAccessToken = DestinationDatabricksPersonalAccessToken{}
	if err := utils.UnmarshalJSON(data, &destinationDatabricksPersonalAccessToken, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationDatabricksAuthenticationTypeDestinationDatabricksPersonalAccessToken,
			Value: &destinationDatabricksPersonalAccessToken,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationDatabricksAuthentication", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationDatabricksAuthentication", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(DestinationDatabricksAuthenticationType)
	switch best.Type {
	case DestinationDatabricksAuthenticationTypeOAuth2Recommended:
		u.OAuth2Recommended = best.Value.(*OAuth2Recommended)
		return nil
	case DestinationDatabricksAuthenticationTypeDestinationDatabricksPersonalAccessToken:
		u.DestinationDatabricksPersonalAccessToken = best.Value.(*DestinationDatabricksPersonalAccessToken)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationDatabricksAuthentication", string(data))
}

func (u DestinationDatabricksAuthentication) MarshalJSON() ([]byte, error) {
	if u.OAuth2Recommended != nil {
		return utils.MarshalJSON(u.OAuth2Recommended, "", true)
	}

	if u.DestinationDatabricksPersonalAccessToken != nil {
		return utils.MarshalJSON(u.DestinationDatabricksPersonalAccessToken, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationDatabricksAuthentication: all fields are null")
}

type DestinationDatabricksDestinationType string

const (
	DestinationDatabricksDestinationTypeDatabricks DestinationDatabricksDestinationType = "databricks"
)

func (e DestinationDatabricksDestinationType) ToPointer() *DestinationDatabricksDestinationType {
	return &e
}
func (e *DestinationDatabricksDestinationType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "databricks":
		*e = DestinationDatabricksDestinationType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationDatabricksDestinationType: %v", v)
	}
}

type DestinationDatabricks struct {
	// You must agree to the Databricks JDBC Driver <a href="https://databricks.com/jdbc-odbc-driver-license">Terms & Conditions</a> to use this connector.
	AcceptTerms *bool `default:"false" json:"accept_terms"`
	// Authentication mechanism for Staging files and running queries
	Authentication DestinationDatabricksAuthentication `json:"authentication"`
	// The name of the unity catalog for the database
	Database string `json:"database"`
	// Databricks Cluster Server Hostname.
	Hostname string `json:"hostname"`
	// Databricks Cluster HTTP Path.
	HTTPPath string `json:"http_path"`
	// Databricks Cluster Port.
	Port *string `default:"443" json:"port"`
	// Default to 'true'. Switch it to 'false' for debugging purpose.
	PurgeStagingData *bool `default:"true" json:"purge_staging_data"`
	// The schema to write raw tables into (default: airbyte_internal)
	RawSchemaOverride *string `default:"airbyte_internal" json:"raw_schema_override"`
	// The default schema tables are written. If not specified otherwise, the "default" will be used.
	Schema          *string                               `default:"default" json:"schema"`
	destinationType *DestinationDatabricksDestinationType `const:"databricks" json:"destinationType"`
}

func (d DestinationDatabricks) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationDatabricks) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationDatabricks) GetAcceptTerms() *bool {
	if d == nil {
		return nil
	}
	return d.AcceptTerms
}

func (d *DestinationDatabricks) GetAuthentication() DestinationDatabricksAuthentication {
	if d == nil {
		return DestinationDatabricksAuthentication{}
	}
	return d.Authentication
}

func (d *DestinationDatabricks) GetDatabase() string {
	if d == nil {
		return ""
	}
	return d.Database
}

func (d *DestinationDatabricks) GetHostname() string {
	if d == nil {
		return ""
	}
	return d.Hostname
}

func (d *DestinationDatabricks) GetHTTPPath() string {
	if d == nil {
		return ""
	}
	return d.HTTPPath
}

func (d *DestinationDatabricks) GetPort() *string {
	if d == nil {
		return nil
	}
	return d.Port
}

func (d *DestinationDatabricks) GetPurgeStagingData() *bool {
	if d == nil {
		return nil
	}
	return d.PurgeStagingData
}

func (d *DestinationDatabricks) GetRawSchemaOverride() *string {
	if d == nil {
		return nil
	}
	return d.RawSchemaOverride
}

func (d *DestinationDatabricks) GetSchema() *string {
	if d == nil {
		return nil
	}
	return d.Schema
}

func (d *DestinationDatabricks) GetDestinationType() *DestinationDatabricksDestinationType {
	return DestinationDatabricksDestinationTypeDatabricks.ToPointer()
}
