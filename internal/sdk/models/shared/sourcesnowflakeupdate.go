// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

type SourceSnowflakeUpdateSchemasAuthType string

const (
	SourceSnowflakeUpdateSchemasAuthTypeUsernamePassword SourceSnowflakeUpdateSchemasAuthType = "username/password"
)

func (e SourceSnowflakeUpdateSchemasAuthType) ToPointer() *SourceSnowflakeUpdateSchemasAuthType {
	return &e
}
func (e *SourceSnowflakeUpdateSchemasAuthType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "username/password":
		*e = SourceSnowflakeUpdateSchemasAuthType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceSnowflakeUpdateSchemasAuthType: %v", v)
	}
}

type SourceSnowflakeUpdateUsernameAndPassword struct {
	AuthType *SourceSnowflakeUpdateSchemasAuthType `default:"username/password" json:"auth_type"`
	// The password associated with the username.
	Password *string `json:"password,omitempty"`
	// The username you created to allow Airbyte to access the database.
	Username             *string `json:"username,omitempty"`
	AdditionalProperties any     `additionalProperties:"true" json:"-"`
}

func (s SourceSnowflakeUpdateUsernameAndPassword) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceSnowflakeUpdateUsernameAndPassword) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceSnowflakeUpdateUsernameAndPassword) GetAuthType() *SourceSnowflakeUpdateSchemasAuthType {
	if s == nil {
		return nil
	}
	return s.AuthType
}

func (s *SourceSnowflakeUpdateUsernameAndPassword) GetPassword() *string {
	if s == nil {
		return nil
	}
	return s.Password
}

func (s *SourceSnowflakeUpdateUsernameAndPassword) GetUsername() *string {
	if s == nil {
		return nil
	}
	return s.Username
}

func (s *SourceSnowflakeUpdateUsernameAndPassword) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceSnowflakeUpdateAuthType string

const (
	SourceSnowflakeUpdateAuthTypeKeyPairAuthentication SourceSnowflakeUpdateAuthType = "Key Pair Authentication"
)

func (e SourceSnowflakeUpdateAuthType) ToPointer() *SourceSnowflakeUpdateAuthType {
	return &e
}
func (e *SourceSnowflakeUpdateAuthType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Key Pair Authentication":
		*e = SourceSnowflakeUpdateAuthType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceSnowflakeUpdateAuthType: %v", v)
	}
}

type SourceSnowflakeUpdateKeyPairAuthentication struct {
	AuthType *SourceSnowflakeUpdateAuthType `default:"Key Pair Authentication" json:"auth_type"`
	// RSA Private key to use for Snowflake connection. See the <a href="https://docs.airbyte.com/integrations/sources/snowflake#key-pair-authentication">docs</a> for more information on how to obtain this key.
	PrivateKey *string `json:"private_key,omitempty"`
	// Passphrase for private key
	PrivateKeyPassword *string `json:"private_key_password,omitempty"`
	// The username you created to allow Airbyte to access the database.
	Username             *string `json:"username,omitempty"`
	AdditionalProperties any     `additionalProperties:"true" json:"-"`
}

func (s SourceSnowflakeUpdateKeyPairAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceSnowflakeUpdateKeyPairAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceSnowflakeUpdateKeyPairAuthentication) GetAuthType() *SourceSnowflakeUpdateAuthType {
	if s == nil {
		return nil
	}
	return s.AuthType
}

func (s *SourceSnowflakeUpdateKeyPairAuthentication) GetPrivateKey() *string {
	if s == nil {
		return nil
	}
	return s.PrivateKey
}

func (s *SourceSnowflakeUpdateKeyPairAuthentication) GetPrivateKeyPassword() *string {
	if s == nil {
		return nil
	}
	return s.PrivateKeyPassword
}

func (s *SourceSnowflakeUpdateKeyPairAuthentication) GetUsername() *string {
	if s == nil {
		return nil
	}
	return s.Username
}

func (s *SourceSnowflakeUpdateKeyPairAuthentication) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceSnowflakeUpdateAuthorizationMethodType string

const (
	SourceSnowflakeUpdateAuthorizationMethodTypeSourceSnowflakeUpdateKeyPairAuthentication SourceSnowflakeUpdateAuthorizationMethodType = "source-snowflake-update_Key Pair Authentication"
	SourceSnowflakeUpdateAuthorizationMethodTypeSourceSnowflakeUpdateUsernameAndPassword   SourceSnowflakeUpdateAuthorizationMethodType = "source-snowflake-update_Username and Password"
)

type SourceSnowflakeUpdateAuthorizationMethod struct {
	SourceSnowflakeUpdateKeyPairAuthentication *SourceSnowflakeUpdateKeyPairAuthentication `queryParam:"inline" union:"member"`
	SourceSnowflakeUpdateUsernameAndPassword   *SourceSnowflakeUpdateUsernameAndPassword   `queryParam:"inline" union:"member"`

	Type SourceSnowflakeUpdateAuthorizationMethodType
}

func CreateSourceSnowflakeUpdateAuthorizationMethodSourceSnowflakeUpdateKeyPairAuthentication(sourceSnowflakeUpdateKeyPairAuthentication SourceSnowflakeUpdateKeyPairAuthentication) SourceSnowflakeUpdateAuthorizationMethod {
	typ := SourceSnowflakeUpdateAuthorizationMethodTypeSourceSnowflakeUpdateKeyPairAuthentication

	return SourceSnowflakeUpdateAuthorizationMethod{
		SourceSnowflakeUpdateKeyPairAuthentication: &sourceSnowflakeUpdateKeyPairAuthentication,
		Type: typ,
	}
}

func CreateSourceSnowflakeUpdateAuthorizationMethodSourceSnowflakeUpdateUsernameAndPassword(sourceSnowflakeUpdateUsernameAndPassword SourceSnowflakeUpdateUsernameAndPassword) SourceSnowflakeUpdateAuthorizationMethod {
	typ := SourceSnowflakeUpdateAuthorizationMethodTypeSourceSnowflakeUpdateUsernameAndPassword

	return SourceSnowflakeUpdateAuthorizationMethod{
		SourceSnowflakeUpdateUsernameAndPassword: &sourceSnowflakeUpdateUsernameAndPassword,
		Type:                                     typ,
	}
}

func (u *SourceSnowflakeUpdateAuthorizationMethod) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var sourceSnowflakeUpdateKeyPairAuthentication SourceSnowflakeUpdateKeyPairAuthentication = SourceSnowflakeUpdateKeyPairAuthentication{}
	if err := utils.UnmarshalJSON(data, &sourceSnowflakeUpdateKeyPairAuthentication, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceSnowflakeUpdateAuthorizationMethodTypeSourceSnowflakeUpdateKeyPairAuthentication,
			Value: &sourceSnowflakeUpdateKeyPairAuthentication,
		})
	}

	var sourceSnowflakeUpdateUsernameAndPassword SourceSnowflakeUpdateUsernameAndPassword = SourceSnowflakeUpdateUsernameAndPassword{}
	if err := utils.UnmarshalJSON(data, &sourceSnowflakeUpdateUsernameAndPassword, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceSnowflakeUpdateAuthorizationMethodTypeSourceSnowflakeUpdateUsernameAndPassword,
			Value: &sourceSnowflakeUpdateUsernameAndPassword,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceSnowflakeUpdateAuthorizationMethod", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceSnowflakeUpdateAuthorizationMethod", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceSnowflakeUpdateAuthorizationMethodType)
	switch best.Type {
	case SourceSnowflakeUpdateAuthorizationMethodTypeSourceSnowflakeUpdateKeyPairAuthentication:
		u.SourceSnowflakeUpdateKeyPairAuthentication = best.Value.(*SourceSnowflakeUpdateKeyPairAuthentication)
		return nil
	case SourceSnowflakeUpdateAuthorizationMethodTypeSourceSnowflakeUpdateUsernameAndPassword:
		u.SourceSnowflakeUpdateUsernameAndPassword = best.Value.(*SourceSnowflakeUpdateUsernameAndPassword)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceSnowflakeUpdateAuthorizationMethod", string(data))
}

func (u SourceSnowflakeUpdateAuthorizationMethod) MarshalJSON() ([]byte, error) {
	if u.SourceSnowflakeUpdateKeyPairAuthentication != nil {
		return utils.MarshalJSON(u.SourceSnowflakeUpdateKeyPairAuthentication, "", true)
	}

	if u.SourceSnowflakeUpdateUsernameAndPassword != nil {
		return utils.MarshalJSON(u.SourceSnowflakeUpdateUsernameAndPassword, "", true)
	}

	return nil, errors.New("could not marshal union type SourceSnowflakeUpdateAuthorizationMethod: all fields are null")
}

type SourceSnowflakeUpdateCursorMethod string

const (
	SourceSnowflakeUpdateCursorMethodUserDefined SourceSnowflakeUpdateCursorMethod = "user_defined"
)

func (e SourceSnowflakeUpdateCursorMethod) ToPointer() *SourceSnowflakeUpdateCursorMethod {
	return &e
}
func (e *SourceSnowflakeUpdateCursorMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "user_defined":
		*e = SourceSnowflakeUpdateCursorMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceSnowflakeUpdateCursorMethod: %v", v)
	}
}

// SourceSnowflakeUpdateScanChangesWithUserDefinedCursor - Incrementally detects new inserts and updates using the <a href="https://docs.airbyte.com/understanding-airbyte/connections/incremental-append/#user-defined-cursor">cursor column</a> chosen when configuring a connection (e.g. created_at, updated_at).
type SourceSnowflakeUpdateScanChangesWithUserDefinedCursor struct {
	CursorMethod         *SourceSnowflakeUpdateCursorMethod `default:"user_defined" json:"cursor_method"`
	AdditionalProperties any                                `additionalProperties:"true" json:"-"`
}

func (s SourceSnowflakeUpdateScanChangesWithUserDefinedCursor) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceSnowflakeUpdateScanChangesWithUserDefinedCursor) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceSnowflakeUpdateScanChangesWithUserDefinedCursor) GetCursorMethod() *SourceSnowflakeUpdateCursorMethod {
	if s == nil {
		return nil
	}
	return s.CursorMethod
}

func (s *SourceSnowflakeUpdateScanChangesWithUserDefinedCursor) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceSnowflakeUpdateUpdateMethodType string

const (
	SourceSnowflakeUpdateUpdateMethodTypeSourceSnowflakeUpdateScanChangesWithUserDefinedCursor SourceSnowflakeUpdateUpdateMethodType = "source-snowflake-update_Scan Changes with User Defined Cursor"
)

// SourceSnowflakeUpdateUpdateMethod - Configures how data is extracted from the database.
type SourceSnowflakeUpdateUpdateMethod struct {
	SourceSnowflakeUpdateScanChangesWithUserDefinedCursor *SourceSnowflakeUpdateScanChangesWithUserDefinedCursor `queryParam:"inline" union:"member"`

	Type SourceSnowflakeUpdateUpdateMethodType
}

func CreateSourceSnowflakeUpdateUpdateMethodSourceSnowflakeUpdateScanChangesWithUserDefinedCursor(sourceSnowflakeUpdateScanChangesWithUserDefinedCursor SourceSnowflakeUpdateScanChangesWithUserDefinedCursor) SourceSnowflakeUpdateUpdateMethod {
	typ := SourceSnowflakeUpdateUpdateMethodTypeSourceSnowflakeUpdateScanChangesWithUserDefinedCursor

	return SourceSnowflakeUpdateUpdateMethod{
		SourceSnowflakeUpdateScanChangesWithUserDefinedCursor: &sourceSnowflakeUpdateScanChangesWithUserDefinedCursor,
		Type: typ,
	}
}

func (u *SourceSnowflakeUpdateUpdateMethod) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var sourceSnowflakeUpdateScanChangesWithUserDefinedCursor SourceSnowflakeUpdateScanChangesWithUserDefinedCursor = SourceSnowflakeUpdateScanChangesWithUserDefinedCursor{}
	if err := utils.UnmarshalJSON(data, &sourceSnowflakeUpdateScanChangesWithUserDefinedCursor, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceSnowflakeUpdateUpdateMethodTypeSourceSnowflakeUpdateScanChangesWithUserDefinedCursor,
			Value: &sourceSnowflakeUpdateScanChangesWithUserDefinedCursor,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceSnowflakeUpdateUpdateMethod", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceSnowflakeUpdateUpdateMethod", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceSnowflakeUpdateUpdateMethodType)
	switch best.Type {
	case SourceSnowflakeUpdateUpdateMethodTypeSourceSnowflakeUpdateScanChangesWithUserDefinedCursor:
		u.SourceSnowflakeUpdateScanChangesWithUserDefinedCursor = best.Value.(*SourceSnowflakeUpdateScanChangesWithUserDefinedCursor)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceSnowflakeUpdateUpdateMethod", string(data))
}

func (u SourceSnowflakeUpdateUpdateMethod) MarshalJSON() ([]byte, error) {
	if u.SourceSnowflakeUpdateScanChangesWithUserDefinedCursor != nil {
		return utils.MarshalJSON(u.SourceSnowflakeUpdateScanChangesWithUserDefinedCursor, "", true)
	}

	return nil, errors.New("could not marshal union type SourceSnowflakeUpdateUpdateMethod: all fields are null")
}

type SourceSnowflakeUpdateSourceType string

const (
	SourceSnowflakeUpdateSourceTypeSnowflake SourceSnowflakeUpdateSourceType = "snowflake"
)

func (e SourceSnowflakeUpdateSourceType) ToPointer() *SourceSnowflakeUpdateSourceType {
	return &e
}
func (e *SourceSnowflakeUpdateSourceType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "snowflake":
		*e = SourceSnowflakeUpdateSourceType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceSnowflakeUpdateSourceType: %v", v)
	}
}

type SourceSnowflakeUpdate struct {
	// When this feature is enabled, during schema discovery the connector will query each table or view individually to check access privileges and inaccessible tables, views, or columns therein will be removed. In large schemas, this might cause schema discovery to take too long, in which case it might be advisable to disable this feature.
	CheckPrivileges *bool `default:"true" json:"check_privileges"`
	// How often (in seconds) a stream should checkpoint, when possible.
	CheckpointTargetIntervalSeconds *int64 `default:"300" json:"checkpoint_target_interval_seconds"`
	// Maximum number of concurrent queries to the database.
	Concurrency *int64                                    `default:"1" json:"concurrency"`
	Credentials *SourceSnowflakeUpdateAuthorizationMethod `json:"credentials,omitempty"`
	// Configures how data is extracted from the database.
	Cursor *SourceSnowflakeUpdateUpdateMethod `json:"cursor,omitempty"`
	// The database you created for Airbyte to access data.
	Database *string `json:"database,omitempty"`
	// The host domain of the snowflake instance (must include the account, region, cloud environment, and end with snowflakecomputing.com).
	Host *string `json:"host,omitempty"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// The role you created for Airbyte to access Snowflake.
	Role *string `json:"role,omitempty"`
	// The source Snowflake schema tables. Leave empty to access tables from multiple schemas.
	Schema *string `json:"schema,omitempty"`
	// The warehouse you created for Airbyte to access data.
	Warehouse            *string                          `json:"warehouse,omitempty"`
	sourceType           *SourceSnowflakeUpdateSourceType `const:"snowflake" json:"sourceType"`
	AdditionalProperties any                              `additionalProperties:"true" json:"-"`
}

func (s SourceSnowflakeUpdate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceSnowflakeUpdate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceSnowflakeUpdate) GetCheckPrivileges() *bool {
	if s == nil {
		return nil
	}
	return s.CheckPrivileges
}

func (s *SourceSnowflakeUpdate) GetCheckpointTargetIntervalSeconds() *int64 {
	if s == nil {
		return nil
	}
	return s.CheckpointTargetIntervalSeconds
}

func (s *SourceSnowflakeUpdate) GetConcurrency() *int64 {
	if s == nil {
		return nil
	}
	return s.Concurrency
}

func (s *SourceSnowflakeUpdate) GetCredentials() *SourceSnowflakeUpdateAuthorizationMethod {
	if s == nil {
		return nil
	}
	return s.Credentials
}

func (s *SourceSnowflakeUpdate) GetCursor() *SourceSnowflakeUpdateUpdateMethod {
	if s == nil {
		return nil
	}
	return s.Cursor
}

func (s *SourceSnowflakeUpdate) GetDatabase() *string {
	if s == nil {
		return nil
	}
	return s.Database
}

func (s *SourceSnowflakeUpdate) GetHost() *string {
	if s == nil {
		return nil
	}
	return s.Host
}

func (s *SourceSnowflakeUpdate) GetJdbcURLParams() *string {
	if s == nil {
		return nil
	}
	return s.JdbcURLParams
}

func (s *SourceSnowflakeUpdate) GetRole() *string {
	if s == nil {
		return nil
	}
	return s.Role
}

func (s *SourceSnowflakeUpdate) GetSchema() *string {
	if s == nil {
		return nil
	}
	return s.Schema
}

func (s *SourceSnowflakeUpdate) GetWarehouse() *string {
	if s == nil {
		return nil
	}
	return s.Warehouse
}

func (s *SourceSnowflakeUpdate) GetSourceType() *SourceSnowflakeUpdateSourceType {
	return SourceSnowflakeUpdateSourceTypeSnowflake.ToPointer()
}

func (s *SourceSnowflakeUpdate) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}
