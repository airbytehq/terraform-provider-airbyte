// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/types"
)

// SystemIDSID - Use SID (Oracle System Identifier)
type SystemIDSID struct {
	connectionType *string `const:"sid" json:"connection_type,omitempty"`
	Sid            string  `json:"sid"`
}

func (s SystemIDSID) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SystemIDSID) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SystemIDSID) GetConnectionType() *string {
	return types.Pointer("sid")
}

func (s *SystemIDSID) GetSid() string {
	if s == nil {
		return ""
	}
	return s.Sid
}

// ServiceName - Use service name
type ServiceName struct {
	connectionType *string `const:"service_name" json:"connection_type,omitempty"`
	ServiceName    string  `json:"service_name"`
}

func (s ServiceName) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *ServiceName) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *ServiceName) GetConnectionType() *string {
	return types.Pointer("service_name")
}

func (s *ServiceName) GetServiceName() string {
	if s == nil {
		return ""
	}
	return s.ServiceName
}

type ConnectByType string

const (
	ConnectByTypeServiceName ConnectByType = "Service name"
	ConnectByTypeSystemIDSID ConnectByType = "System ID (SID)"
)

// ConnectBy - Connect data that will be used for DB connection
type ConnectBy struct {
	ServiceName *ServiceName `queryParam:"inline" union:"member"`
	SystemIDSID *SystemIDSID `queryParam:"inline" union:"member"`

	Type ConnectByType
}

func CreateConnectByServiceName(serviceName ServiceName) ConnectBy {
	typ := ConnectByTypeServiceName

	return ConnectBy{
		ServiceName: &serviceName,
		Type:        typ,
	}
}

func CreateConnectBySystemIDSID(systemIDSID SystemIDSID) ConnectBy {
	typ := ConnectByTypeSystemIDSID

	return ConnectBy{
		SystemIDSID: &systemIDSID,
		Type:        typ,
	}
}

func (u *ConnectBy) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var serviceName ServiceName = ServiceName{}
	if err := utils.UnmarshalJSON(data, &serviceName, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ConnectByTypeServiceName,
			Value: &serviceName,
		})
	}

	var systemIDSID SystemIDSID = SystemIDSID{}
	if err := utils.UnmarshalJSON(data, &systemIDSID, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ConnectByTypeSystemIDSID,
			Value: &systemIDSID,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for ConnectBy", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for ConnectBy", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(ConnectByType)
	switch best.Type {
	case ConnectByTypeServiceName:
		u.ServiceName = best.Value.(*ServiceName)
		return nil
	case ConnectByTypeSystemIDSID:
		u.SystemIDSID = best.Value.(*SystemIDSID)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ConnectBy", string(data))
}

func (u ConnectBy) MarshalJSON() ([]byte, error) {
	if u.ServiceName != nil {
		return utils.MarshalJSON(u.ServiceName, "", true)
	}

	if u.SystemIDSID != nil {
		return utils.MarshalJSON(u.SystemIDSID, "", true)
	}

	return nil, errors.New("could not marshal union type ConnectBy: all fields are null")
}

// SourceOracleTLSEncryptedVerifyCertificate - Verify and use the certificate provided by the server.
type SourceOracleTLSEncryptedVerifyCertificate struct {
	encryptionMethod string `const:"encrypted_verify_certificate" json:"encryption_method"`
	// Privacy Enhanced Mail (PEM) files are concatenated certificate containers frequently used in certificate installations.
	SslCertificate string `json:"ssl_certificate"`
}

func (s SourceOracleTLSEncryptedVerifyCertificate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceOracleTLSEncryptedVerifyCertificate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceOracleTLSEncryptedVerifyCertificate) GetEncryptionMethod() string {
	return "encrypted_verify_certificate"
}

func (s *SourceOracleTLSEncryptedVerifyCertificate) GetSslCertificate() string {
	if s == nil {
		return ""
	}
	return s.SslCertificate
}

// EncryptionAlgorithm - This parameter defines what encryption algorithm is used.
type EncryptionAlgorithm string

const (
	EncryptionAlgorithmAes256      EncryptionAlgorithm = "AES256"
	EncryptionAlgorithmRc456       EncryptionAlgorithm = "RC4_56"
	EncryptionAlgorithmThreeDes168 EncryptionAlgorithm = "3DES168"
)

func (e EncryptionAlgorithm) ToPointer() *EncryptionAlgorithm {
	return &e
}
func (e *EncryptionAlgorithm) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "AES256":
		fallthrough
	case "RC4_56":
		fallthrough
	case "3DES168":
		*e = EncryptionAlgorithm(v)
		return nil
	default:
		return fmt.Errorf("invalid value for EncryptionAlgorithm: %v", v)
	}
}

// NativeNetworkEncryptionNNE - The native network encryption gives you the ability to encrypt database connections, without the configuration overhead of TCP/IP and SSL/TLS and without the need to open and listen on different ports.
type NativeNetworkEncryptionNNE struct {
	// This parameter defines what encryption algorithm is used.
	EncryptionAlgorithm *EncryptionAlgorithm `default:"AES256" json:"encryption_algorithm"`
	encryptionMethod    string               `const:"client_nne" json:"encryption_method"`
}

func (n NativeNetworkEncryptionNNE) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(n, "", false)
}

func (n *NativeNetworkEncryptionNNE) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &n, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (n *NativeNetworkEncryptionNNE) GetEncryptionAlgorithm() *EncryptionAlgorithm {
	if n == nil {
		return nil
	}
	return n.EncryptionAlgorithm
}

func (n *NativeNetworkEncryptionNNE) GetEncryptionMethod() string {
	return "client_nne"
}

// SourceOracleUnencrypted - Data transfer will not be encrypted.
type SourceOracleUnencrypted struct {
	encryptionMethod string `const:"unencrypted" json:"encryption_method"`
}

func (s SourceOracleUnencrypted) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceOracleUnencrypted) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceOracleUnencrypted) GetEncryptionMethod() string {
	return "unencrypted"
}

type SourceOracleEncryptionType string

const (
	SourceOracleEncryptionTypeSourceOracleUnencrypted                   SourceOracleEncryptionType = "source-oracle_Unencrypted"
	SourceOracleEncryptionTypeNativeNetworkEncryptionNNE                SourceOracleEncryptionType = "Native Network Encryption (NNE)"
	SourceOracleEncryptionTypeSourceOracleTLSEncryptedVerifyCertificate SourceOracleEncryptionType = "source-oracle_TLS Encrypted (verify certificate)"
)

// SourceOracleEncryption - The encryption method with is used when communicating with the database.
type SourceOracleEncryption struct {
	SourceOracleUnencrypted                   *SourceOracleUnencrypted                   `queryParam:"inline" union:"member"`
	NativeNetworkEncryptionNNE                *NativeNetworkEncryptionNNE                `queryParam:"inline" union:"member"`
	SourceOracleTLSEncryptedVerifyCertificate *SourceOracleTLSEncryptedVerifyCertificate `queryParam:"inline" union:"member"`

	Type SourceOracleEncryptionType
}

func CreateSourceOracleEncryptionSourceOracleUnencrypted(sourceOracleUnencrypted SourceOracleUnencrypted) SourceOracleEncryption {
	typ := SourceOracleEncryptionTypeSourceOracleUnencrypted

	return SourceOracleEncryption{
		SourceOracleUnencrypted: &sourceOracleUnencrypted,
		Type:                    typ,
	}
}

func CreateSourceOracleEncryptionNativeNetworkEncryptionNNE(nativeNetworkEncryptionNNE NativeNetworkEncryptionNNE) SourceOracleEncryption {
	typ := SourceOracleEncryptionTypeNativeNetworkEncryptionNNE

	return SourceOracleEncryption{
		NativeNetworkEncryptionNNE: &nativeNetworkEncryptionNNE,
		Type:                       typ,
	}
}

func CreateSourceOracleEncryptionSourceOracleTLSEncryptedVerifyCertificate(sourceOracleTLSEncryptedVerifyCertificate SourceOracleTLSEncryptedVerifyCertificate) SourceOracleEncryption {
	typ := SourceOracleEncryptionTypeSourceOracleTLSEncryptedVerifyCertificate

	return SourceOracleEncryption{
		SourceOracleTLSEncryptedVerifyCertificate: &sourceOracleTLSEncryptedVerifyCertificate,
		Type: typ,
	}
}

func (u *SourceOracleEncryption) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var sourceOracleUnencrypted SourceOracleUnencrypted = SourceOracleUnencrypted{}
	if err := utils.UnmarshalJSON(data, &sourceOracleUnencrypted, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceOracleEncryptionTypeSourceOracleUnencrypted,
			Value: &sourceOracleUnencrypted,
		})
	}

	var nativeNetworkEncryptionNNE NativeNetworkEncryptionNNE = NativeNetworkEncryptionNNE{}
	if err := utils.UnmarshalJSON(data, &nativeNetworkEncryptionNNE, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceOracleEncryptionTypeNativeNetworkEncryptionNNE,
			Value: &nativeNetworkEncryptionNNE,
		})
	}

	var sourceOracleTLSEncryptedVerifyCertificate SourceOracleTLSEncryptedVerifyCertificate = SourceOracleTLSEncryptedVerifyCertificate{}
	if err := utils.UnmarshalJSON(data, &sourceOracleTLSEncryptedVerifyCertificate, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceOracleEncryptionTypeSourceOracleTLSEncryptedVerifyCertificate,
			Value: &sourceOracleTLSEncryptedVerifyCertificate,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceOracleEncryption", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceOracleEncryption", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceOracleEncryptionType)
	switch best.Type {
	case SourceOracleEncryptionTypeSourceOracleUnencrypted:
		u.SourceOracleUnencrypted = best.Value.(*SourceOracleUnencrypted)
		return nil
	case SourceOracleEncryptionTypeNativeNetworkEncryptionNNE:
		u.NativeNetworkEncryptionNNE = best.Value.(*NativeNetworkEncryptionNNE)
		return nil
	case SourceOracleEncryptionTypeSourceOracleTLSEncryptedVerifyCertificate:
		u.SourceOracleTLSEncryptedVerifyCertificate = best.Value.(*SourceOracleTLSEncryptedVerifyCertificate)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceOracleEncryption", string(data))
}

func (u SourceOracleEncryption) MarshalJSON() ([]byte, error) {
	if u.SourceOracleUnencrypted != nil {
		return utils.MarshalJSON(u.SourceOracleUnencrypted, "", true)
	}

	if u.NativeNetworkEncryptionNNE != nil {
		return utils.MarshalJSON(u.NativeNetworkEncryptionNNE, "", true)
	}

	if u.SourceOracleTLSEncryptedVerifyCertificate != nil {
		return utils.MarshalJSON(u.SourceOracleTLSEncryptedVerifyCertificate, "", true)
	}

	return nil, errors.New("could not marshal union type SourceOracleEncryption: all fields are null")
}

type SourceOraclePasswordAuthentication struct {
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and password authentication
	tunnelMethod string `const:"SSH_PASSWORD_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser string `json:"tunnel_user"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword string `json:"tunnel_user_password"`
}

func (s SourceOraclePasswordAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceOraclePasswordAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceOraclePasswordAuthentication) GetTunnelHost() string {
	if s == nil {
		return ""
	}
	return s.TunnelHost
}

func (s *SourceOraclePasswordAuthentication) GetTunnelMethod() string {
	return "SSH_PASSWORD_AUTH"
}

func (s *SourceOraclePasswordAuthentication) GetTunnelPort() *int64 {
	if s == nil {
		return nil
	}
	return s.TunnelPort
}

func (s *SourceOraclePasswordAuthentication) GetTunnelUser() string {
	if s == nil {
		return ""
	}
	return s.TunnelUser
}

func (s *SourceOraclePasswordAuthentication) GetTunnelUserPassword() string {
	if s == nil {
		return ""
	}
	return s.TunnelUserPassword
}

type SourceOracleSSHKeyAuthentication struct {
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey string `json:"ssh_key"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and ssh key
	tunnelMethod string `const:"SSH_KEY_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host.
	TunnelUser string `json:"tunnel_user"`
}

func (s SourceOracleSSHKeyAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceOracleSSHKeyAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceOracleSSHKeyAuthentication) GetSSHKey() string {
	if s == nil {
		return ""
	}
	return s.SSHKey
}

func (s *SourceOracleSSHKeyAuthentication) GetTunnelHost() string {
	if s == nil {
		return ""
	}
	return s.TunnelHost
}

func (s *SourceOracleSSHKeyAuthentication) GetTunnelMethod() string {
	return "SSH_KEY_AUTH"
}

func (s *SourceOracleSSHKeyAuthentication) GetTunnelPort() *int64 {
	if s == nil {
		return nil
	}
	return s.TunnelPort
}

func (s *SourceOracleSSHKeyAuthentication) GetTunnelUser() string {
	if s == nil {
		return ""
	}
	return s.TunnelUser
}

type SourceOracleNoTunnel struct {
	// No ssh tunnel needed to connect to database
	tunnelMethod string `const:"NO_TUNNEL" json:"tunnel_method"`
}

func (s SourceOracleNoTunnel) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceOracleNoTunnel) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceOracleNoTunnel) GetTunnelMethod() string {
	return "NO_TUNNEL"
}

type SourceOracleSSHTunnelMethodType string

const (
	SourceOracleSSHTunnelMethodTypeSourceOracleNoTunnel               SourceOracleSSHTunnelMethodType = "source-oracle_No Tunnel"
	SourceOracleSSHTunnelMethodTypeSourceOracleSSHKeyAuthentication   SourceOracleSSHTunnelMethodType = "source-oracle_SSH Key Authentication"
	SourceOracleSSHTunnelMethodTypeSourceOraclePasswordAuthentication SourceOracleSSHTunnelMethodType = "source-oracle_Password Authentication"
)

// SourceOracleSSHTunnelMethod - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceOracleSSHTunnelMethod struct {
	SourceOracleNoTunnel               *SourceOracleNoTunnel               `queryParam:"inline" union:"member"`
	SourceOracleSSHKeyAuthentication   *SourceOracleSSHKeyAuthentication   `queryParam:"inline" union:"member"`
	SourceOraclePasswordAuthentication *SourceOraclePasswordAuthentication `queryParam:"inline" union:"member"`

	Type SourceOracleSSHTunnelMethodType
}

func CreateSourceOracleSSHTunnelMethodSourceOracleNoTunnel(sourceOracleNoTunnel SourceOracleNoTunnel) SourceOracleSSHTunnelMethod {
	typ := SourceOracleSSHTunnelMethodTypeSourceOracleNoTunnel

	return SourceOracleSSHTunnelMethod{
		SourceOracleNoTunnel: &sourceOracleNoTunnel,
		Type:                 typ,
	}
}

func CreateSourceOracleSSHTunnelMethodSourceOracleSSHKeyAuthentication(sourceOracleSSHKeyAuthentication SourceOracleSSHKeyAuthentication) SourceOracleSSHTunnelMethod {
	typ := SourceOracleSSHTunnelMethodTypeSourceOracleSSHKeyAuthentication

	return SourceOracleSSHTunnelMethod{
		SourceOracleSSHKeyAuthentication: &sourceOracleSSHKeyAuthentication,
		Type:                             typ,
	}
}

func CreateSourceOracleSSHTunnelMethodSourceOraclePasswordAuthentication(sourceOraclePasswordAuthentication SourceOraclePasswordAuthentication) SourceOracleSSHTunnelMethod {
	typ := SourceOracleSSHTunnelMethodTypeSourceOraclePasswordAuthentication

	return SourceOracleSSHTunnelMethod{
		SourceOraclePasswordAuthentication: &sourceOraclePasswordAuthentication,
		Type:                               typ,
	}
}

func (u *SourceOracleSSHTunnelMethod) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var sourceOracleNoTunnel SourceOracleNoTunnel = SourceOracleNoTunnel{}
	if err := utils.UnmarshalJSON(data, &sourceOracleNoTunnel, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceOracleSSHTunnelMethodTypeSourceOracleNoTunnel,
			Value: &sourceOracleNoTunnel,
		})
	}

	var sourceOracleSSHKeyAuthentication SourceOracleSSHKeyAuthentication = SourceOracleSSHKeyAuthentication{}
	if err := utils.UnmarshalJSON(data, &sourceOracleSSHKeyAuthentication, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceOracleSSHTunnelMethodTypeSourceOracleSSHKeyAuthentication,
			Value: &sourceOracleSSHKeyAuthentication,
		})
	}

	var sourceOraclePasswordAuthentication SourceOraclePasswordAuthentication = SourceOraclePasswordAuthentication{}
	if err := utils.UnmarshalJSON(data, &sourceOraclePasswordAuthentication, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceOracleSSHTunnelMethodTypeSourceOraclePasswordAuthentication,
			Value: &sourceOraclePasswordAuthentication,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceOracleSSHTunnelMethod", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceOracleSSHTunnelMethod", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceOracleSSHTunnelMethodType)
	switch best.Type {
	case SourceOracleSSHTunnelMethodTypeSourceOracleNoTunnel:
		u.SourceOracleNoTunnel = best.Value.(*SourceOracleNoTunnel)
		return nil
	case SourceOracleSSHTunnelMethodTypeSourceOracleSSHKeyAuthentication:
		u.SourceOracleSSHKeyAuthentication = best.Value.(*SourceOracleSSHKeyAuthentication)
		return nil
	case SourceOracleSSHTunnelMethodTypeSourceOraclePasswordAuthentication:
		u.SourceOraclePasswordAuthentication = best.Value.(*SourceOraclePasswordAuthentication)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceOracleSSHTunnelMethod", string(data))
}

func (u SourceOracleSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.SourceOracleNoTunnel != nil {
		return utils.MarshalJSON(u.SourceOracleNoTunnel, "", true)
	}

	if u.SourceOracleSSHKeyAuthentication != nil {
		return utils.MarshalJSON(u.SourceOracleSSHKeyAuthentication, "", true)
	}

	if u.SourceOraclePasswordAuthentication != nil {
		return utils.MarshalJSON(u.SourceOraclePasswordAuthentication, "", true)
	}

	return nil, errors.New("could not marshal union type SourceOracleSSHTunnelMethod: all fields are null")
}

type SourceOracleSourceType string

const (
	SourceOracleSourceTypeOracle SourceOracleSourceType = "oracle"
)

func (e SourceOracleSourceType) ToPointer() *SourceOracleSourceType {
	return &e
}
func (e *SourceOracleSourceType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "oracle":
		*e = SourceOracleSourceType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceOracleSourceType: %v", v)
	}
}

type SourceOracle struct {
	// Connect data that will be used for DB connection
	ConnectionData *ConnectBy `json:"connection_data,omitempty"`
	// The encryption method with is used when communicating with the database.
	Encryption *SourceOracleEncryption `json:"encryption,omitempty"`
	// Hostname of the database.
	Host string `json:"host"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// The password associated with the username.
	Password *string `json:"password,omitempty"`
	// Port of the database.
	// Oracle Corporations recommends the following port numbers:
	// 1521 - Default listening port for client connections to the listener.
	// 2484 - Recommended and officially registered listening port for client connections to the listener using TCP/IP with SSL
	Port *int64 `default:"1521" json:"port"`
	// The list of schemas to sync from. Defaults to user. Case sensitive.
	Schemas []string `json:"schemas,omitempty"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod *SourceOracleSSHTunnelMethod `json:"tunnel_method,omitempty"`
	// The username which is used to access the database.
	Username   string                  `json:"username"`
	sourceType *SourceOracleSourceType `const:"oracle" json:"sourceType"`
}

func (s SourceOracle) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceOracle) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceOracle) GetConnectionData() *ConnectBy {
	if s == nil {
		return nil
	}
	return s.ConnectionData
}

func (s *SourceOracle) GetEncryption() *SourceOracleEncryption {
	if s == nil {
		return nil
	}
	return s.Encryption
}

func (s *SourceOracle) GetHost() string {
	if s == nil {
		return ""
	}
	return s.Host
}

func (s *SourceOracle) GetJdbcURLParams() *string {
	if s == nil {
		return nil
	}
	return s.JdbcURLParams
}

func (s *SourceOracle) GetPassword() *string {
	if s == nil {
		return nil
	}
	return s.Password
}

func (s *SourceOracle) GetPort() *int64 {
	if s == nil {
		return nil
	}
	return s.Port
}

func (s *SourceOracle) GetSchemas() []string {
	if s == nil {
		return nil
	}
	return s.Schemas
}

func (s *SourceOracle) GetTunnelMethod() *SourceOracleSSHTunnelMethod {
	if s == nil {
		return nil
	}
	return s.TunnelMethod
}

func (s *SourceOracle) GetUsername() string {
	if s == nil {
		return ""
	}
	return s.Username
}

func (s *SourceOracle) GetSourceType() *SourceOracleSourceType {
	return SourceOracleSourceTypeOracle.ToPointer()
}
