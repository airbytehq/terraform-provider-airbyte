// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/types"
	"time"
)

type SourceMailchimpUpdateAPIKey struct {
	// Mailchimp API Key. See the <a href="https://docs.airbyte.com/integrations/sources/mailchimp">docs</a> for information on how to generate this key.
	Apikey   *string `json:"apikey,omitempty"`
	authType *string `const:"apikey" json:"auth_type,omitempty"`
}

func (s SourceMailchimpUpdateAPIKey) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMailchimpUpdateAPIKey) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceMailchimpUpdateAPIKey) GetApikey() *string {
	if s == nil {
		return nil
	}
	return s.Apikey
}

func (s *SourceMailchimpUpdateAPIKey) GetAuthType() *string {
	return types.Pointer("apikey")
}

type SourceMailchimpUpdateOAuth20 struct {
	// An access token generated using the above client ID and secret.
	AccessToken *string `json:"access_token,omitempty"`
	authType    *string `const:"oauth2.0" json:"auth_type,omitempty"`
	// The Client ID of your OAuth application.
	ClientID *string `json:"client_id,omitempty"`
	// The Client Secret of your OAuth application.
	ClientSecret *string `json:"client_secret,omitempty"`
}

func (s SourceMailchimpUpdateOAuth20) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMailchimpUpdateOAuth20) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceMailchimpUpdateOAuth20) GetAccessToken() *string {
	if s == nil {
		return nil
	}
	return s.AccessToken
}

func (s *SourceMailchimpUpdateOAuth20) GetAuthType() *string {
	return types.Pointer("oauth2.0")
}

func (s *SourceMailchimpUpdateOAuth20) GetClientID() *string {
	if s == nil {
		return nil
	}
	return s.ClientID
}

func (s *SourceMailchimpUpdateOAuth20) GetClientSecret() *string {
	if s == nil {
		return nil
	}
	return s.ClientSecret
}

type SourceMailchimpUpdateAuthenticationType string

const (
	SourceMailchimpUpdateAuthenticationTypeSourceMailchimpUpdateOAuth20 SourceMailchimpUpdateAuthenticationType = "source-mailchimp-update_OAuth2.0"
	SourceMailchimpUpdateAuthenticationTypeSourceMailchimpUpdateAPIKey  SourceMailchimpUpdateAuthenticationType = "source-mailchimp-update_API Key"
)

type SourceMailchimpUpdateAuthentication struct {
	SourceMailchimpUpdateOAuth20 *SourceMailchimpUpdateOAuth20 `queryParam:"inline" union:"member"`
	SourceMailchimpUpdateAPIKey  *SourceMailchimpUpdateAPIKey  `queryParam:"inline" union:"member"`

	Type SourceMailchimpUpdateAuthenticationType
}

func CreateSourceMailchimpUpdateAuthenticationSourceMailchimpUpdateOAuth20(sourceMailchimpUpdateOAuth20 SourceMailchimpUpdateOAuth20) SourceMailchimpUpdateAuthentication {
	typ := SourceMailchimpUpdateAuthenticationTypeSourceMailchimpUpdateOAuth20

	return SourceMailchimpUpdateAuthentication{
		SourceMailchimpUpdateOAuth20: &sourceMailchimpUpdateOAuth20,
		Type:                         typ,
	}
}

func CreateSourceMailchimpUpdateAuthenticationSourceMailchimpUpdateAPIKey(sourceMailchimpUpdateAPIKey SourceMailchimpUpdateAPIKey) SourceMailchimpUpdateAuthentication {
	typ := SourceMailchimpUpdateAuthenticationTypeSourceMailchimpUpdateAPIKey

	return SourceMailchimpUpdateAuthentication{
		SourceMailchimpUpdateAPIKey: &sourceMailchimpUpdateAPIKey,
		Type:                        typ,
	}
}

func (u *SourceMailchimpUpdateAuthentication) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var sourceMailchimpUpdateOAuth20 SourceMailchimpUpdateOAuth20 = SourceMailchimpUpdateOAuth20{}
	if err := utils.UnmarshalJSON(data, &sourceMailchimpUpdateOAuth20, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceMailchimpUpdateAuthenticationTypeSourceMailchimpUpdateOAuth20,
			Value: &sourceMailchimpUpdateOAuth20,
		})
	}

	var sourceMailchimpUpdateAPIKey SourceMailchimpUpdateAPIKey = SourceMailchimpUpdateAPIKey{}
	if err := utils.UnmarshalJSON(data, &sourceMailchimpUpdateAPIKey, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceMailchimpUpdateAuthenticationTypeSourceMailchimpUpdateAPIKey,
			Value: &sourceMailchimpUpdateAPIKey,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMailchimpUpdateAuthentication", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMailchimpUpdateAuthentication", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceMailchimpUpdateAuthenticationType)
	switch best.Type {
	case SourceMailchimpUpdateAuthenticationTypeSourceMailchimpUpdateOAuth20:
		u.SourceMailchimpUpdateOAuth20 = best.Value.(*SourceMailchimpUpdateOAuth20)
		return nil
	case SourceMailchimpUpdateAuthenticationTypeSourceMailchimpUpdateAPIKey:
		u.SourceMailchimpUpdateAPIKey = best.Value.(*SourceMailchimpUpdateAPIKey)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMailchimpUpdateAuthentication", string(data))
}

func (u SourceMailchimpUpdateAuthentication) MarshalJSON() ([]byte, error) {
	if u.SourceMailchimpUpdateOAuth20 != nil {
		return utils.MarshalJSON(u.SourceMailchimpUpdateOAuth20, "", true)
	}

	if u.SourceMailchimpUpdateAPIKey != nil {
		return utils.MarshalJSON(u.SourceMailchimpUpdateAPIKey, "", true)
	}

	return nil, errors.New("could not marshal union type SourceMailchimpUpdateAuthentication: all fields are null")
}

type SourceMailchimpUpdateSourceType string

const (
	SourceMailchimpUpdateSourceTypeMailchimp SourceMailchimpUpdateSourceType = "mailchimp"
)

func (e SourceMailchimpUpdateSourceType) ToPointer() *SourceMailchimpUpdateSourceType {
	return &e
}
func (e *SourceMailchimpUpdateSourceType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "mailchimp":
		*e = SourceMailchimpUpdateSourceType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMailchimpUpdateSourceType: %v", v)
	}
}

type SourceMailchimpUpdate struct {
	Credentials *SourceMailchimpUpdateAuthentication `json:"credentials,omitempty"`
	// Technical fields used to identify datacenter to send request to
	DataCenter *string `json:"data_center,omitempty"`
	// The date from which you want to start syncing data for Incremental streams. Only records that have been created or modified since this date will be synced. If left blank, all data will by synced.
	StartDate            *time.Time                       `json:"start_date,omitempty"`
	sourceType           *SourceMailchimpUpdateSourceType `const:"mailchimp" json:"sourceType"`
	AdditionalProperties any                              `additionalProperties:"true" json:"-"`
}

func (s SourceMailchimpUpdate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMailchimpUpdate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceMailchimpUpdate) GetCredentials() *SourceMailchimpUpdateAuthentication {
	if s == nil {
		return nil
	}
	return s.Credentials
}

func (s *SourceMailchimpUpdate) GetDataCenter() *string {
	if s == nil {
		return nil
	}
	return s.DataCenter
}

func (s *SourceMailchimpUpdate) GetStartDate() *time.Time {
	if s == nil {
		return nil
	}
	return s.StartDate
}

func (s *SourceMailchimpUpdate) GetSourceType() *SourceMailchimpUpdateSourceType {
	return SourceMailchimpUpdateSourceTypeMailchimp.ToPointer()
}

func (s *SourceMailchimpUpdate) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}
