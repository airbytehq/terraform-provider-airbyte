// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

type DestinationS3DataLakeSchemasCatalogTypeCatalogTypeCatalogType string

const (
	DestinationS3DataLakeSchemasCatalogTypeCatalogTypeCatalogTypePolaris DestinationS3DataLakeSchemasCatalogTypeCatalogTypeCatalogType = "POLARIS"
)

func (e DestinationS3DataLakeSchemasCatalogTypeCatalogTypeCatalogType) ToPointer() *DestinationS3DataLakeSchemasCatalogTypeCatalogTypeCatalogType {
	return &e
}
func (e *DestinationS3DataLakeSchemasCatalogTypeCatalogTypeCatalogType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "POLARIS":
		*e = DestinationS3DataLakeSchemasCatalogTypeCatalogTypeCatalogType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3DataLakeSchemasCatalogTypeCatalogTypeCatalogType: %v", v)
	}
}

// DestinationS3DataLakePolarisCatalog - Configuration details for connecting to an Apache Polaris-based Iceberg catalog.
type DestinationS3DataLakePolarisCatalog struct {
	// The name of the catalog in Polaris. This corresponds to the catalog name created via the Polaris Management API.
	CatalogName string                                                         `json:"catalog_name"`
	CatalogType *DestinationS3DataLakeSchemasCatalogTypeCatalogTypeCatalogType `default:"POLARIS" json:"catalog_type"`
	// The OAuth Client ID for authenticating with the Polaris server.
	ClientID string `json:"client_id"`
	// The OAuth Client Secret for authenticating with the Polaris server.
	ClientSecret string `json:"client_secret"`
	// The Polaris namespace to be used in the Table identifier.
	//            This will ONLY be used if the `Destination Namespace` setting for the connection is set to
	//            `Destination-defined` or `Source-defined`
	Namespace string `json:"namespace"`
	// The OAuth2 token endpoint URI. If not provided, a deprecation warning may be issued as this will become required in future versions.
	Oauth2ServerURI *string `json:"oauth2_server_uri,omitempty"`
	// The OAuth scope for authentication. Must be in the format PRINCIPAL_ROLE:<role_name>.
	Scope string `json:"scope"`
	// The base URL of the Polaris server used to connect to the Polaris catalog.
	ServerURI            string `json:"server_uri"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (d DestinationS3DataLakePolarisCatalog) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationS3DataLakePolarisCatalog) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationS3DataLakePolarisCatalog) GetCatalogName() string {
	if d == nil {
		return ""
	}
	return d.CatalogName
}

func (d *DestinationS3DataLakePolarisCatalog) GetCatalogType() *DestinationS3DataLakeSchemasCatalogTypeCatalogTypeCatalogType {
	if d == nil {
		return nil
	}
	return d.CatalogType
}

func (d *DestinationS3DataLakePolarisCatalog) GetClientID() string {
	if d == nil {
		return ""
	}
	return d.ClientID
}

func (d *DestinationS3DataLakePolarisCatalog) GetClientSecret() string {
	if d == nil {
		return ""
	}
	return d.ClientSecret
}

func (d *DestinationS3DataLakePolarisCatalog) GetNamespace() string {
	if d == nil {
		return ""
	}
	return d.Namespace
}

func (d *DestinationS3DataLakePolarisCatalog) GetOauth2ServerURI() *string {
	if d == nil {
		return nil
	}
	return d.Oauth2ServerURI
}

func (d *DestinationS3DataLakePolarisCatalog) GetScope() string {
	if d == nil {
		return ""
	}
	return d.Scope
}

func (d *DestinationS3DataLakePolarisCatalog) GetServerURI() string {
	if d == nil {
		return ""
	}
	return d.ServerURI
}

func (d *DestinationS3DataLakePolarisCatalog) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationS3DataLakeSchemasCatalogTypeCatalogType string

const (
	DestinationS3DataLakeSchemasCatalogTypeCatalogTypeRest DestinationS3DataLakeSchemasCatalogTypeCatalogType = "REST"
)

func (e DestinationS3DataLakeSchemasCatalogTypeCatalogType) ToPointer() *DestinationS3DataLakeSchemasCatalogTypeCatalogType {
	return &e
}
func (e *DestinationS3DataLakeSchemasCatalogTypeCatalogType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "REST":
		*e = DestinationS3DataLakeSchemasCatalogTypeCatalogType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3DataLakeSchemasCatalogTypeCatalogType: %v", v)
	}
}

// RestCatalog - Configuration details for connecting to a REST catalog.
type RestCatalog struct {
	CatalogType *DestinationS3DataLakeSchemasCatalogTypeCatalogType `default:"REST" json:"catalog_type"`
	// The namespace to be used in the Table identifier.
	//            This will ONLY be used if the `Destination Namespace` setting for the connection is set to
	//            `Destination-defined` or `Source-defined`
	Namespace string `json:"namespace"`
	// The base URL of the Rest server used to connect to the Rest catalog.
	ServerURI            string `json:"server_uri"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (r RestCatalog) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(r, "", false)
}

func (r *RestCatalog) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &r, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (r *RestCatalog) GetCatalogType() *DestinationS3DataLakeSchemasCatalogTypeCatalogType {
	if r == nil {
		return nil
	}
	return r.CatalogType
}

func (r *RestCatalog) GetNamespace() string {
	if r == nil {
		return ""
	}
	return r.Namespace
}

func (r *RestCatalog) GetServerURI() string {
	if r == nil {
		return ""
	}
	return r.ServerURI
}

func (r *RestCatalog) GetAdditionalProperties() any {
	if r == nil {
		return nil
	}
	return r.AdditionalProperties
}

type DestinationS3DataLakeSchemasCatalogType string

const (
	DestinationS3DataLakeSchemasCatalogTypeGlue DestinationS3DataLakeSchemasCatalogType = "GLUE"
)

func (e DestinationS3DataLakeSchemasCatalogType) ToPointer() *DestinationS3DataLakeSchemasCatalogType {
	return &e
}
func (e *DestinationS3DataLakeSchemasCatalogType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "GLUE":
		*e = DestinationS3DataLakeSchemasCatalogType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3DataLakeSchemasCatalogType: %v", v)
	}
}

// GlueCatalog - Configuration details for connecting to an AWS Glue-based Iceberg catalog.
type GlueCatalog struct {
	CatalogType *DestinationS3DataLakeSchemasCatalogType `default:"GLUE" json:"catalog_type"`
	// The Glue database name. This will ONLY be used if the `Destination Namespace` setting for the connection is set to `Destination-defined` or `Source-defined`
	DatabaseName string `json:"database_name"`
	// The AWS Account ID associated with the Glue service used by the Iceberg catalog.
	GlueID string `json:"glue_id"`
	// The ARN of the AWS role to assume. Only usable in Airbyte Cloud.
	RoleArn              *string `json:"role_arn,omitempty"`
	AdditionalProperties any     `additionalProperties:"true" json:"-"`
}

func (g GlueCatalog) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GlueCatalog) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (g *GlueCatalog) GetCatalogType() *DestinationS3DataLakeSchemasCatalogType {
	if g == nil {
		return nil
	}
	return g.CatalogType
}

func (g *GlueCatalog) GetDatabaseName() string {
	if g == nil {
		return ""
	}
	return g.DatabaseName
}

func (g *GlueCatalog) GetGlueID() string {
	if g == nil {
		return ""
	}
	return g.GlueID
}

func (g *GlueCatalog) GetRoleArn() *string {
	if g == nil {
		return nil
	}
	return g.RoleArn
}

func (g *GlueCatalog) GetAdditionalProperties() any {
	if g == nil {
		return nil
	}
	return g.AdditionalProperties
}

type DestinationS3DataLakeSchemasCatalogTypeCatalogType1CatalogType string

const (
	DestinationS3DataLakeSchemasCatalogTypeCatalogType1CatalogTypeNessie DestinationS3DataLakeSchemasCatalogTypeCatalogType1CatalogType = "NESSIE"
)

func (e DestinationS3DataLakeSchemasCatalogTypeCatalogType1CatalogType) ToPointer() *DestinationS3DataLakeSchemasCatalogTypeCatalogType1CatalogType {
	return &e
}
func (e *DestinationS3DataLakeSchemasCatalogTypeCatalogType1CatalogType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NESSIE":
		*e = DestinationS3DataLakeSchemasCatalogTypeCatalogType1CatalogType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3DataLakeSchemasCatalogTypeCatalogType1CatalogType: %v", v)
	}
}

// NessieCatalog - Configuration details for connecting to a Nessie-based Iceberg catalog.
type NessieCatalog struct {
	// Optional token for authentication with the Nessie server.
	AccessToken *string                                                         `json:"access_token,omitempty"`
	CatalogType *DestinationS3DataLakeSchemasCatalogTypeCatalogType1CatalogType `default:"NESSIE" json:"catalog_type"`
	// The Nessie namespace to be used in the Table identifier.
	//            This will ONLY be used if the `Destination Namespace` setting for the connection is set to
	//            `Destination-defined` or `Source-defined`
	Namespace string `json:"namespace"`
	// The base URL of the Nessie server used to connect to the Nessie catalog.
	ServerURI            string `json:"server_uri"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (n NessieCatalog) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(n, "", false)
}

func (n *NessieCatalog) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &n, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (n *NessieCatalog) GetAccessToken() *string {
	if n == nil {
		return nil
	}
	return n.AccessToken
}

func (n *NessieCatalog) GetCatalogType() *DestinationS3DataLakeSchemasCatalogTypeCatalogType1CatalogType {
	if n == nil {
		return nil
	}
	return n.CatalogType
}

func (n *NessieCatalog) GetNamespace() string {
	if n == nil {
		return ""
	}
	return n.Namespace
}

func (n *NessieCatalog) GetServerURI() string {
	if n == nil {
		return ""
	}
	return n.ServerURI
}

func (n *NessieCatalog) GetAdditionalProperties() any {
	if n == nil {
		return nil
	}
	return n.AdditionalProperties
}

type DestinationS3DataLakeCatalogTypeType string

const (
	DestinationS3DataLakeCatalogTypeTypeNessieCatalog                       DestinationS3DataLakeCatalogTypeType = "Nessie Catalog"
	DestinationS3DataLakeCatalogTypeTypeGlueCatalog                         DestinationS3DataLakeCatalogTypeType = "Glue Catalog"
	DestinationS3DataLakeCatalogTypeTypeRestCatalog                         DestinationS3DataLakeCatalogTypeType = "Rest Catalog"
	DestinationS3DataLakeCatalogTypeTypeDestinationS3DataLakePolarisCatalog DestinationS3DataLakeCatalogTypeType = "destination-s3-data-lake_Polaris Catalog"
)

// DestinationS3DataLakeCatalogType - Specifies the type of Iceberg catalog (e.g., NESSIE, GLUE, REST, POLARIS) and its associated configuration.
type DestinationS3DataLakeCatalogType struct {
	NessieCatalog                       *NessieCatalog                       `queryParam:"inline" union:"member"`
	GlueCatalog                         *GlueCatalog                         `queryParam:"inline" union:"member"`
	RestCatalog                         *RestCatalog                         `queryParam:"inline" union:"member"`
	DestinationS3DataLakePolarisCatalog *DestinationS3DataLakePolarisCatalog `queryParam:"inline" union:"member"`

	Type DestinationS3DataLakeCatalogTypeType
}

func CreateDestinationS3DataLakeCatalogTypeNessieCatalog(nessieCatalog NessieCatalog) DestinationS3DataLakeCatalogType {
	typ := DestinationS3DataLakeCatalogTypeTypeNessieCatalog

	return DestinationS3DataLakeCatalogType{
		NessieCatalog: &nessieCatalog,
		Type:          typ,
	}
}

func CreateDestinationS3DataLakeCatalogTypeGlueCatalog(glueCatalog GlueCatalog) DestinationS3DataLakeCatalogType {
	typ := DestinationS3DataLakeCatalogTypeTypeGlueCatalog

	return DestinationS3DataLakeCatalogType{
		GlueCatalog: &glueCatalog,
		Type:        typ,
	}
}

func CreateDestinationS3DataLakeCatalogTypeRestCatalog(restCatalog RestCatalog) DestinationS3DataLakeCatalogType {
	typ := DestinationS3DataLakeCatalogTypeTypeRestCatalog

	return DestinationS3DataLakeCatalogType{
		RestCatalog: &restCatalog,
		Type:        typ,
	}
}

func CreateDestinationS3DataLakeCatalogTypeDestinationS3DataLakePolarisCatalog(destinationS3DataLakePolarisCatalog DestinationS3DataLakePolarisCatalog) DestinationS3DataLakeCatalogType {
	typ := DestinationS3DataLakeCatalogTypeTypeDestinationS3DataLakePolarisCatalog

	return DestinationS3DataLakeCatalogType{
		DestinationS3DataLakePolarisCatalog: &destinationS3DataLakePolarisCatalog,
		Type:                                typ,
	}
}

func (u *DestinationS3DataLakeCatalogType) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var nessieCatalog NessieCatalog = NessieCatalog{}
	if err := utils.UnmarshalJSON(data, &nessieCatalog, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationS3DataLakeCatalogTypeTypeNessieCatalog,
			Value: &nessieCatalog,
		})
	}

	var glueCatalog GlueCatalog = GlueCatalog{}
	if err := utils.UnmarshalJSON(data, &glueCatalog, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationS3DataLakeCatalogTypeTypeGlueCatalog,
			Value: &glueCatalog,
		})
	}

	var restCatalog RestCatalog = RestCatalog{}
	if err := utils.UnmarshalJSON(data, &restCatalog, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationS3DataLakeCatalogTypeTypeRestCatalog,
			Value: &restCatalog,
		})
	}

	var destinationS3DataLakePolarisCatalog DestinationS3DataLakePolarisCatalog = DestinationS3DataLakePolarisCatalog{}
	if err := utils.UnmarshalJSON(data, &destinationS3DataLakePolarisCatalog, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationS3DataLakeCatalogTypeTypeDestinationS3DataLakePolarisCatalog,
			Value: &destinationS3DataLakePolarisCatalog,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationS3DataLakeCatalogType", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationS3DataLakeCatalogType", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(DestinationS3DataLakeCatalogTypeType)
	switch best.Type {
	case DestinationS3DataLakeCatalogTypeTypeNessieCatalog:
		u.NessieCatalog = best.Value.(*NessieCatalog)
		return nil
	case DestinationS3DataLakeCatalogTypeTypeGlueCatalog:
		u.GlueCatalog = best.Value.(*GlueCatalog)
		return nil
	case DestinationS3DataLakeCatalogTypeTypeRestCatalog:
		u.RestCatalog = best.Value.(*RestCatalog)
		return nil
	case DestinationS3DataLakeCatalogTypeTypeDestinationS3DataLakePolarisCatalog:
		u.DestinationS3DataLakePolarisCatalog = best.Value.(*DestinationS3DataLakePolarisCatalog)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationS3DataLakeCatalogType", string(data))
}

func (u DestinationS3DataLakeCatalogType) MarshalJSON() ([]byte, error) {
	if u.NessieCatalog != nil {
		return utils.MarshalJSON(u.NessieCatalog, "", true)
	}

	if u.GlueCatalog != nil {
		return utils.MarshalJSON(u.GlueCatalog, "", true)
	}

	if u.RestCatalog != nil {
		return utils.MarshalJSON(u.RestCatalog, "", true)
	}

	if u.DestinationS3DataLakePolarisCatalog != nil {
		return utils.MarshalJSON(u.DestinationS3DataLakePolarisCatalog, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationS3DataLakeCatalogType: all fields are null")
}

// DestinationS3DataLakeS3BucketRegion - The region of the S3 bucket. See <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-available-regions">here</a> for all region codes.
type DestinationS3DataLakeS3BucketRegion string

const (
	DestinationS3DataLakeS3BucketRegionUnknown      DestinationS3DataLakeS3BucketRegion = ""
	DestinationS3DataLakeS3BucketRegionAfSouth1     DestinationS3DataLakeS3BucketRegion = "af-south-1"
	DestinationS3DataLakeS3BucketRegionApEast1      DestinationS3DataLakeS3BucketRegion = "ap-east-1"
	DestinationS3DataLakeS3BucketRegionApNortheast1 DestinationS3DataLakeS3BucketRegion = "ap-northeast-1"
	DestinationS3DataLakeS3BucketRegionApNortheast2 DestinationS3DataLakeS3BucketRegion = "ap-northeast-2"
	DestinationS3DataLakeS3BucketRegionApNortheast3 DestinationS3DataLakeS3BucketRegion = "ap-northeast-3"
	DestinationS3DataLakeS3BucketRegionApSouth1     DestinationS3DataLakeS3BucketRegion = "ap-south-1"
	DestinationS3DataLakeS3BucketRegionApSouth2     DestinationS3DataLakeS3BucketRegion = "ap-south-2"
	DestinationS3DataLakeS3BucketRegionApSoutheast1 DestinationS3DataLakeS3BucketRegion = "ap-southeast-1"
	DestinationS3DataLakeS3BucketRegionApSoutheast2 DestinationS3DataLakeS3BucketRegion = "ap-southeast-2"
	DestinationS3DataLakeS3BucketRegionApSoutheast3 DestinationS3DataLakeS3BucketRegion = "ap-southeast-3"
	DestinationS3DataLakeS3BucketRegionApSoutheast4 DestinationS3DataLakeS3BucketRegion = "ap-southeast-4"
	DestinationS3DataLakeS3BucketRegionCaCentral1   DestinationS3DataLakeS3BucketRegion = "ca-central-1"
	DestinationS3DataLakeS3BucketRegionCaWest1      DestinationS3DataLakeS3BucketRegion = "ca-west-1"
	DestinationS3DataLakeS3BucketRegionCnNorth1     DestinationS3DataLakeS3BucketRegion = "cn-north-1"
	DestinationS3DataLakeS3BucketRegionCnNorthwest1 DestinationS3DataLakeS3BucketRegion = "cn-northwest-1"
	DestinationS3DataLakeS3BucketRegionEuCentral1   DestinationS3DataLakeS3BucketRegion = "eu-central-1"
	DestinationS3DataLakeS3BucketRegionEuCentral2   DestinationS3DataLakeS3BucketRegion = "eu-central-2"
	DestinationS3DataLakeS3BucketRegionEuNorth1     DestinationS3DataLakeS3BucketRegion = "eu-north-1"
	DestinationS3DataLakeS3BucketRegionEuSouth1     DestinationS3DataLakeS3BucketRegion = "eu-south-1"
	DestinationS3DataLakeS3BucketRegionEuSouth2     DestinationS3DataLakeS3BucketRegion = "eu-south-2"
	DestinationS3DataLakeS3BucketRegionEuWest1      DestinationS3DataLakeS3BucketRegion = "eu-west-1"
	DestinationS3DataLakeS3BucketRegionEuWest2      DestinationS3DataLakeS3BucketRegion = "eu-west-2"
	DestinationS3DataLakeS3BucketRegionEuWest3      DestinationS3DataLakeS3BucketRegion = "eu-west-3"
	DestinationS3DataLakeS3BucketRegionIlCentral1   DestinationS3DataLakeS3BucketRegion = "il-central-1"
	DestinationS3DataLakeS3BucketRegionMeCentral1   DestinationS3DataLakeS3BucketRegion = "me-central-1"
	DestinationS3DataLakeS3BucketRegionMeSouth1     DestinationS3DataLakeS3BucketRegion = "me-south-1"
	DestinationS3DataLakeS3BucketRegionSaEast1      DestinationS3DataLakeS3BucketRegion = "sa-east-1"
	DestinationS3DataLakeS3BucketRegionUsEast1      DestinationS3DataLakeS3BucketRegion = "us-east-1"
	DestinationS3DataLakeS3BucketRegionUsEast2      DestinationS3DataLakeS3BucketRegion = "us-east-2"
	DestinationS3DataLakeS3BucketRegionUsGovEast1   DestinationS3DataLakeS3BucketRegion = "us-gov-east-1"
	DestinationS3DataLakeS3BucketRegionUsGovWest1   DestinationS3DataLakeS3BucketRegion = "us-gov-west-1"
	DestinationS3DataLakeS3BucketRegionUsWest1      DestinationS3DataLakeS3BucketRegion = "us-west-1"
	DestinationS3DataLakeS3BucketRegionUsWest2      DestinationS3DataLakeS3BucketRegion = "us-west-2"
)

func (e DestinationS3DataLakeS3BucketRegion) ToPointer() *DestinationS3DataLakeS3BucketRegion {
	return &e
}
func (e *DestinationS3DataLakeS3BucketRegion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "":
		fallthrough
	case "af-south-1":
		fallthrough
	case "ap-east-1":
		fallthrough
	case "ap-northeast-1":
		fallthrough
	case "ap-northeast-2":
		fallthrough
	case "ap-northeast-3":
		fallthrough
	case "ap-south-1":
		fallthrough
	case "ap-south-2":
		fallthrough
	case "ap-southeast-1":
		fallthrough
	case "ap-southeast-2":
		fallthrough
	case "ap-southeast-3":
		fallthrough
	case "ap-southeast-4":
		fallthrough
	case "ca-central-1":
		fallthrough
	case "ca-west-1":
		fallthrough
	case "cn-north-1":
		fallthrough
	case "cn-northwest-1":
		fallthrough
	case "eu-central-1":
		fallthrough
	case "eu-central-2":
		fallthrough
	case "eu-north-1":
		fallthrough
	case "eu-south-1":
		fallthrough
	case "eu-south-2":
		fallthrough
	case "eu-west-1":
		fallthrough
	case "eu-west-2":
		fallthrough
	case "eu-west-3":
		fallthrough
	case "il-central-1":
		fallthrough
	case "me-central-1":
		fallthrough
	case "me-south-1":
		fallthrough
	case "sa-east-1":
		fallthrough
	case "us-east-1":
		fallthrough
	case "us-east-2":
		fallthrough
	case "us-gov-east-1":
		fallthrough
	case "us-gov-west-1":
		fallthrough
	case "us-west-1":
		fallthrough
	case "us-west-2":
		*e = DestinationS3DataLakeS3BucketRegion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3DataLakeS3BucketRegion: %v", v)
	}
}

type DestinationS3DataLakeDestinationType string

const (
	DestinationS3DataLakeDestinationTypeS3DataLake DestinationS3DataLakeDestinationType = "s3-data-lake"
)

func (e DestinationS3DataLakeDestinationType) ToPointer() *DestinationS3DataLakeDestinationType {
	return &e
}
func (e *DestinationS3DataLakeDestinationType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "s3-data-lake":
		*e = DestinationS3DataLakeDestinationType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationS3DataLakeDestinationType: %v", v)
	}
}

// DestinationS3DataLake - Defines the configurations required to connect to an Iceberg catalog, including warehouse location, main branch name, and catalog type specifics.
type DestinationS3DataLake struct {
	// The AWS Access Key ID with permissions for S3 and Glue operations.
	AccessKeyID *string `json:"access_key_id,omitempty"`
	// Specifies the type of Iceberg catalog (e.g., NESSIE, GLUE, REST, POLARIS) and its associated configuration.
	CatalogType DestinationS3DataLakeCatalogType `json:"catalog_type"`
	// The primary or default branch name in the catalog. Most query engines will use "main" by default. See <a href="https://iceberg.apache.org/docs/latest/branching/">Iceberg documentation</a> for more information.
	MainBranchName *string `default:"main" json:"main_branch_name"`
	// The name of the S3 bucket that will host the Iceberg data.
	S3BucketName string `json:"s3_bucket_name"`
	// The region of the S3 bucket. See <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-available-regions">here</a> for all region codes.
	S3BucketRegion DestinationS3DataLakeS3BucketRegion `json:"s3_bucket_region"`
	// Your S3 endpoint url. Read more <a href="https://docs.aws.amazon.com/general/latest/gr/s3.html#:~:text=Service%20endpoints-,Amazon%20S3%20endpoints,-When%20you%20use">here</a>
	S3Endpoint *string `json:"s3_endpoint,omitempty"`
	// The AWS Secret Access Key paired with the Access Key ID for AWS authentication.
	SecretAccessKey *string `json:"secret_access_key,omitempty"`
	// The root location of the data warehouse used by the Iceberg catalog. Typically includes a bucket name and path within that bucket. For AWS Glue and Nessie, must include the storage protocol (such as "s3://" for Amazon S3).
	WarehouseLocation    string                                `json:"warehouse_location"`
	destinationType      *DestinationS3DataLakeDestinationType `const:"s3-data-lake" json:"destinationType"`
	AdditionalProperties any                                   `additionalProperties:"true" json:"-"`
}

func (d DestinationS3DataLake) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationS3DataLake) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationS3DataLake) GetAccessKeyID() *string {
	if d == nil {
		return nil
	}
	return d.AccessKeyID
}

func (d *DestinationS3DataLake) GetCatalogType() DestinationS3DataLakeCatalogType {
	if d == nil {
		return DestinationS3DataLakeCatalogType{}
	}
	return d.CatalogType
}

func (d *DestinationS3DataLake) GetMainBranchName() *string {
	if d == nil {
		return nil
	}
	return d.MainBranchName
}

func (d *DestinationS3DataLake) GetS3BucketName() string {
	if d == nil {
		return ""
	}
	return d.S3BucketName
}

func (d *DestinationS3DataLake) GetS3BucketRegion() DestinationS3DataLakeS3BucketRegion {
	if d == nil {
		return DestinationS3DataLakeS3BucketRegion("")
	}
	return d.S3BucketRegion
}

func (d *DestinationS3DataLake) GetS3Endpoint() *string {
	if d == nil {
		return nil
	}
	return d.S3Endpoint
}

func (d *DestinationS3DataLake) GetSecretAccessKey() *string {
	if d == nil {
		return nil
	}
	return d.SecretAccessKey
}

func (d *DestinationS3DataLake) GetWarehouseLocation() string {
	if d == nil {
		return ""
	}
	return d.WarehouseLocation
}

func (d *DestinationS3DataLake) GetDestinationType() *DestinationS3DataLakeDestinationType {
	return DestinationS3DataLakeDestinationTypeS3DataLake.ToPointer()
}

func (d *DestinationS3DataLake) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}
