// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

// DestinationPostgresUpdateCDCDeletionMode - Whether to execute CDC deletions as hard deletes (i.e. propagate source deletions to the destination), or soft deletes (i.e. leave a tombstone record in the destination). Defaults to hard deletes.
type DestinationPostgresUpdateCDCDeletionMode string

const (
	DestinationPostgresUpdateCDCDeletionModeHardDelete DestinationPostgresUpdateCDCDeletionMode = "Hard delete"
	DestinationPostgresUpdateCDCDeletionModeSoftDelete DestinationPostgresUpdateCDCDeletionMode = "Soft delete"
)

func (e DestinationPostgresUpdateCDCDeletionMode) ToPointer() *DestinationPostgresUpdateCDCDeletionMode {
	return &e
}
func (e *DestinationPostgresUpdateCDCDeletionMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Hard delete":
		fallthrough
	case "Soft delete":
		*e = DestinationPostgresUpdateCDCDeletionMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationPostgresUpdateCDCDeletionMode: %v", v)
	}
}

type DestinationPostgresUpdateSchemasSSLModeSSLModes6Mode string

const (
	DestinationPostgresUpdateSchemasSSLModeSSLModes6ModeVerifyFull DestinationPostgresUpdateSchemasSSLModeSSLModes6Mode = "verify-full"
)

func (e DestinationPostgresUpdateSchemasSSLModeSSLModes6Mode) ToPointer() *DestinationPostgresUpdateSchemasSSLModeSSLModes6Mode {
	return &e
}
func (e *DestinationPostgresUpdateSchemasSSLModeSSLModes6Mode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "verify-full":
		*e = DestinationPostgresUpdateSchemasSSLModeSSLModes6Mode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationPostgresUpdateSchemasSSLModeSSLModes6Mode: %v", v)
	}
}

// DestinationPostgresUpdateVerifyFull - Verify-full SSL mode.
type DestinationPostgresUpdateVerifyFull struct {
	// CA certificate
	CaCertificate *string `json:"ca_certificate,omitempty"`
	// Client certificate
	ClientCertificate *string `json:"client_certificate,omitempty"`
	// Client key
	ClientKey *string `json:"client_key,omitempty"`
	// Password for keystorage. This field is optional. If you do not add it - the password will be generated automatically.
	ClientKeyPassword    *string                                               `json:"client_key_password,omitempty"`
	Mode                 *DestinationPostgresUpdateSchemasSSLModeSSLModes6Mode `default:"verify-full" json:"mode"`
	AdditionalProperties any                                                   `additionalProperties:"true" json:"-"`
}

func (d DestinationPostgresUpdateVerifyFull) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationPostgresUpdateVerifyFull) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationPostgresUpdateVerifyFull) GetCaCertificate() *string {
	if d == nil {
		return nil
	}
	return d.CaCertificate
}

func (d *DestinationPostgresUpdateVerifyFull) GetClientCertificate() *string {
	if d == nil {
		return nil
	}
	return d.ClientCertificate
}

func (d *DestinationPostgresUpdateVerifyFull) GetClientKey() *string {
	if d == nil {
		return nil
	}
	return d.ClientKey
}

func (d *DestinationPostgresUpdateVerifyFull) GetClientKeyPassword() *string {
	if d == nil {
		return nil
	}
	return d.ClientKeyPassword
}

func (d *DestinationPostgresUpdateVerifyFull) GetMode() *DestinationPostgresUpdateSchemasSSLModeSSLModes6Mode {
	if d == nil {
		return nil
	}
	return d.Mode
}

func (d *DestinationPostgresUpdateVerifyFull) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationPostgresUpdateSchemasSSLModeSSLModes5Mode string

const (
	DestinationPostgresUpdateSchemasSSLModeSSLModes5ModeVerifyCa DestinationPostgresUpdateSchemasSSLModeSSLModes5Mode = "verify-ca"
)

func (e DestinationPostgresUpdateSchemasSSLModeSSLModes5Mode) ToPointer() *DestinationPostgresUpdateSchemasSSLModeSSLModes5Mode {
	return &e
}
func (e *DestinationPostgresUpdateSchemasSSLModeSSLModes5Mode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "verify-ca":
		*e = DestinationPostgresUpdateSchemasSSLModeSSLModes5Mode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationPostgresUpdateSchemasSSLModeSSLModes5Mode: %v", v)
	}
}

// DestinationPostgresUpdateVerifyCa - Verify-ca SSL mode.
type DestinationPostgresUpdateVerifyCa struct {
	// CA certificate
	CaCertificate *string `json:"ca_certificate,omitempty"`
	// Password for keystorage. This field is optional. If you do not add it - the password will be generated automatically.
	ClientKeyPassword    *string                                               `json:"client_key_password,omitempty"`
	Mode                 *DestinationPostgresUpdateSchemasSSLModeSSLModes5Mode `default:"verify-ca" json:"mode"`
	AdditionalProperties any                                                   `additionalProperties:"true" json:"-"`
}

func (d DestinationPostgresUpdateVerifyCa) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationPostgresUpdateVerifyCa) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationPostgresUpdateVerifyCa) GetCaCertificate() *string {
	if d == nil {
		return nil
	}
	return d.CaCertificate
}

func (d *DestinationPostgresUpdateVerifyCa) GetClientKeyPassword() *string {
	if d == nil {
		return nil
	}
	return d.ClientKeyPassword
}

func (d *DestinationPostgresUpdateVerifyCa) GetMode() *DestinationPostgresUpdateSchemasSSLModeSSLModes5Mode {
	if d == nil {
		return nil
	}
	return d.Mode
}

func (d *DestinationPostgresUpdateVerifyCa) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationPostgresUpdateSchemasSSLModeSSLModesMode string

const (
	DestinationPostgresUpdateSchemasSSLModeSSLModesModeRequire DestinationPostgresUpdateSchemasSSLModeSSLModesMode = "require"
)

func (e DestinationPostgresUpdateSchemasSSLModeSSLModesMode) ToPointer() *DestinationPostgresUpdateSchemasSSLModeSSLModesMode {
	return &e
}
func (e *DestinationPostgresUpdateSchemasSSLModeSSLModesMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "require":
		*e = DestinationPostgresUpdateSchemasSSLModeSSLModesMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationPostgresUpdateSchemasSSLModeSSLModesMode: %v", v)
	}
}

// DestinationPostgresUpdateRequire - Require SSL mode.
type DestinationPostgresUpdateRequire struct {
	Mode                 *DestinationPostgresUpdateSchemasSSLModeSSLModesMode `default:"require" json:"mode"`
	AdditionalProperties any                                                  `additionalProperties:"true" json:"-"`
}

func (d DestinationPostgresUpdateRequire) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationPostgresUpdateRequire) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationPostgresUpdateRequire) GetMode() *DestinationPostgresUpdateSchemasSSLModeSSLModesMode {
	if d == nil {
		return nil
	}
	return d.Mode
}

func (d *DestinationPostgresUpdateRequire) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationPostgresUpdateSchemasSslModeMode string

const (
	DestinationPostgresUpdateSchemasSslModeModePrefer DestinationPostgresUpdateSchemasSslModeMode = "prefer"
)

func (e DestinationPostgresUpdateSchemasSslModeMode) ToPointer() *DestinationPostgresUpdateSchemasSslModeMode {
	return &e
}
func (e *DestinationPostgresUpdateSchemasSslModeMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "prefer":
		*e = DestinationPostgresUpdateSchemasSslModeMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationPostgresUpdateSchemasSslModeMode: %v", v)
	}
}

// DestinationPostgresUpdatePrefer - Prefer SSL mode.
type DestinationPostgresUpdatePrefer struct {
	Mode                 *DestinationPostgresUpdateSchemasSslModeMode `default:"prefer" json:"mode"`
	AdditionalProperties any                                          `additionalProperties:"true" json:"-"`
}

func (d DestinationPostgresUpdatePrefer) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationPostgresUpdatePrefer) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationPostgresUpdatePrefer) GetMode() *DestinationPostgresUpdateSchemasSslModeMode {
	if d == nil {
		return nil
	}
	return d.Mode
}

func (d *DestinationPostgresUpdatePrefer) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationPostgresUpdateSchemasMode string

const (
	DestinationPostgresUpdateSchemasModeAllow DestinationPostgresUpdateSchemasMode = "allow"
)

func (e DestinationPostgresUpdateSchemasMode) ToPointer() *DestinationPostgresUpdateSchemasMode {
	return &e
}
func (e *DestinationPostgresUpdateSchemasMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "allow":
		*e = DestinationPostgresUpdateSchemasMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationPostgresUpdateSchemasMode: %v", v)
	}
}

// DestinationPostgresUpdateAllow - Allow SSL mode.
type DestinationPostgresUpdateAllow struct {
	Mode                 *DestinationPostgresUpdateSchemasMode `default:"allow" json:"mode"`
	AdditionalProperties any                                   `additionalProperties:"true" json:"-"`
}

func (d DestinationPostgresUpdateAllow) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationPostgresUpdateAllow) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationPostgresUpdateAllow) GetMode() *DestinationPostgresUpdateSchemasMode {
	if d == nil {
		return nil
	}
	return d.Mode
}

func (d *DestinationPostgresUpdateAllow) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationPostgresUpdateMode string

const (
	DestinationPostgresUpdateModeDisable DestinationPostgresUpdateMode = "disable"
)

func (e DestinationPostgresUpdateMode) ToPointer() *DestinationPostgresUpdateMode {
	return &e
}
func (e *DestinationPostgresUpdateMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "disable":
		*e = DestinationPostgresUpdateMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationPostgresUpdateMode: %v", v)
	}
}

// DestinationPostgresUpdateDisable - Disable SSL.
type DestinationPostgresUpdateDisable struct {
	Mode                 *DestinationPostgresUpdateMode `default:"disable" json:"mode"`
	AdditionalProperties any                            `additionalProperties:"true" json:"-"`
}

func (d DestinationPostgresUpdateDisable) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationPostgresUpdateDisable) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationPostgresUpdateDisable) GetMode() *DestinationPostgresUpdateMode {
	if d == nil {
		return nil
	}
	return d.Mode
}

func (d *DestinationPostgresUpdateDisable) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationPostgresUpdateSSLModesType string

const (
	DestinationPostgresUpdateSSLModesTypeDestinationPostgresUpdateDisable    DestinationPostgresUpdateSSLModesType = "destination-postgres-update_disable"
	DestinationPostgresUpdateSSLModesTypeDestinationPostgresUpdateAllow      DestinationPostgresUpdateSSLModesType = "destination-postgres-update_allow"
	DestinationPostgresUpdateSSLModesTypeDestinationPostgresUpdatePrefer     DestinationPostgresUpdateSSLModesType = "destination-postgres-update_prefer"
	DestinationPostgresUpdateSSLModesTypeDestinationPostgresUpdateRequire    DestinationPostgresUpdateSSLModesType = "destination-postgres-update_require"
	DestinationPostgresUpdateSSLModesTypeDestinationPostgresUpdateVerifyCa   DestinationPostgresUpdateSSLModesType = "destination-postgres-update_verify-ca"
	DestinationPostgresUpdateSSLModesTypeDestinationPostgresUpdateVerifyFull DestinationPostgresUpdateSSLModesType = "destination-postgres-update_verify-full"
)

// DestinationPostgresUpdateSSLModes - SSL connection modes.
//
//	 <b>disable</b> - Disables encryption of communication between Airbyte and destination database.
//	 <b>allow</b> - Enables encryption only when required by the destination database.
//	 <b>prefer</b> - Allows unencrypted connections only if the destination database does not support encryption.
//	 <b>require</b> - Always require encryption. If the destination database server does not support encryption, connection will fail.
//	 <b>verify-ca</b> - Always require encryption and verifies that the destination database server has a valid SSL certificate.
//	 <b>verify-full</b> - This is the most secure mode. Always require encryption and verifies the identity of the destination database server.
//	See more information - <a href="https://jdbc.postgresql.org/documentation/head/ssl-client.html"> in the docs</a>.
type DestinationPostgresUpdateSSLModes struct {
	DestinationPostgresUpdateDisable    *DestinationPostgresUpdateDisable    `queryParam:"inline" union:"member"`
	DestinationPostgresUpdateAllow      *DestinationPostgresUpdateAllow      `queryParam:"inline" union:"member"`
	DestinationPostgresUpdatePrefer     *DestinationPostgresUpdatePrefer     `queryParam:"inline" union:"member"`
	DestinationPostgresUpdateRequire    *DestinationPostgresUpdateRequire    `queryParam:"inline" union:"member"`
	DestinationPostgresUpdateVerifyCa   *DestinationPostgresUpdateVerifyCa   `queryParam:"inline" union:"member"`
	DestinationPostgresUpdateVerifyFull *DestinationPostgresUpdateVerifyFull `queryParam:"inline" union:"member"`

	Type DestinationPostgresUpdateSSLModesType
}

func CreateDestinationPostgresUpdateSSLModesDestinationPostgresUpdateDisable(destinationPostgresUpdateDisable DestinationPostgresUpdateDisable) DestinationPostgresUpdateSSLModes {
	typ := DestinationPostgresUpdateSSLModesTypeDestinationPostgresUpdateDisable

	return DestinationPostgresUpdateSSLModes{
		DestinationPostgresUpdateDisable: &destinationPostgresUpdateDisable,
		Type:                             typ,
	}
}

func CreateDestinationPostgresUpdateSSLModesDestinationPostgresUpdateAllow(destinationPostgresUpdateAllow DestinationPostgresUpdateAllow) DestinationPostgresUpdateSSLModes {
	typ := DestinationPostgresUpdateSSLModesTypeDestinationPostgresUpdateAllow

	return DestinationPostgresUpdateSSLModes{
		DestinationPostgresUpdateAllow: &destinationPostgresUpdateAllow,
		Type:                           typ,
	}
}

func CreateDestinationPostgresUpdateSSLModesDestinationPostgresUpdatePrefer(destinationPostgresUpdatePrefer DestinationPostgresUpdatePrefer) DestinationPostgresUpdateSSLModes {
	typ := DestinationPostgresUpdateSSLModesTypeDestinationPostgresUpdatePrefer

	return DestinationPostgresUpdateSSLModes{
		DestinationPostgresUpdatePrefer: &destinationPostgresUpdatePrefer,
		Type:                            typ,
	}
}

func CreateDestinationPostgresUpdateSSLModesDestinationPostgresUpdateRequire(destinationPostgresUpdateRequire DestinationPostgresUpdateRequire) DestinationPostgresUpdateSSLModes {
	typ := DestinationPostgresUpdateSSLModesTypeDestinationPostgresUpdateRequire

	return DestinationPostgresUpdateSSLModes{
		DestinationPostgresUpdateRequire: &destinationPostgresUpdateRequire,
		Type:                             typ,
	}
}

func CreateDestinationPostgresUpdateSSLModesDestinationPostgresUpdateVerifyCa(destinationPostgresUpdateVerifyCa DestinationPostgresUpdateVerifyCa) DestinationPostgresUpdateSSLModes {
	typ := DestinationPostgresUpdateSSLModesTypeDestinationPostgresUpdateVerifyCa

	return DestinationPostgresUpdateSSLModes{
		DestinationPostgresUpdateVerifyCa: &destinationPostgresUpdateVerifyCa,
		Type:                              typ,
	}
}

func CreateDestinationPostgresUpdateSSLModesDestinationPostgresUpdateVerifyFull(destinationPostgresUpdateVerifyFull DestinationPostgresUpdateVerifyFull) DestinationPostgresUpdateSSLModes {
	typ := DestinationPostgresUpdateSSLModesTypeDestinationPostgresUpdateVerifyFull

	return DestinationPostgresUpdateSSLModes{
		DestinationPostgresUpdateVerifyFull: &destinationPostgresUpdateVerifyFull,
		Type:                                typ,
	}
}

func (u *DestinationPostgresUpdateSSLModes) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var destinationPostgresUpdateDisable DestinationPostgresUpdateDisable = DestinationPostgresUpdateDisable{}
	if err := utils.UnmarshalJSON(data, &destinationPostgresUpdateDisable, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationPostgresUpdateSSLModesTypeDestinationPostgresUpdateDisable,
			Value: &destinationPostgresUpdateDisable,
		})
	}

	var destinationPostgresUpdateAllow DestinationPostgresUpdateAllow = DestinationPostgresUpdateAllow{}
	if err := utils.UnmarshalJSON(data, &destinationPostgresUpdateAllow, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationPostgresUpdateSSLModesTypeDestinationPostgresUpdateAllow,
			Value: &destinationPostgresUpdateAllow,
		})
	}

	var destinationPostgresUpdatePrefer DestinationPostgresUpdatePrefer = DestinationPostgresUpdatePrefer{}
	if err := utils.UnmarshalJSON(data, &destinationPostgresUpdatePrefer, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationPostgresUpdateSSLModesTypeDestinationPostgresUpdatePrefer,
			Value: &destinationPostgresUpdatePrefer,
		})
	}

	var destinationPostgresUpdateRequire DestinationPostgresUpdateRequire = DestinationPostgresUpdateRequire{}
	if err := utils.UnmarshalJSON(data, &destinationPostgresUpdateRequire, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationPostgresUpdateSSLModesTypeDestinationPostgresUpdateRequire,
			Value: &destinationPostgresUpdateRequire,
		})
	}

	var destinationPostgresUpdateVerifyCa DestinationPostgresUpdateVerifyCa = DestinationPostgresUpdateVerifyCa{}
	if err := utils.UnmarshalJSON(data, &destinationPostgresUpdateVerifyCa, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationPostgresUpdateSSLModesTypeDestinationPostgresUpdateVerifyCa,
			Value: &destinationPostgresUpdateVerifyCa,
		})
	}

	var destinationPostgresUpdateVerifyFull DestinationPostgresUpdateVerifyFull = DestinationPostgresUpdateVerifyFull{}
	if err := utils.UnmarshalJSON(data, &destinationPostgresUpdateVerifyFull, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationPostgresUpdateSSLModesTypeDestinationPostgresUpdateVerifyFull,
			Value: &destinationPostgresUpdateVerifyFull,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationPostgresUpdateSSLModes", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationPostgresUpdateSSLModes", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(DestinationPostgresUpdateSSLModesType)
	switch best.Type {
	case DestinationPostgresUpdateSSLModesTypeDestinationPostgresUpdateDisable:
		u.DestinationPostgresUpdateDisable = best.Value.(*DestinationPostgresUpdateDisable)
		return nil
	case DestinationPostgresUpdateSSLModesTypeDestinationPostgresUpdateAllow:
		u.DestinationPostgresUpdateAllow = best.Value.(*DestinationPostgresUpdateAllow)
		return nil
	case DestinationPostgresUpdateSSLModesTypeDestinationPostgresUpdatePrefer:
		u.DestinationPostgresUpdatePrefer = best.Value.(*DestinationPostgresUpdatePrefer)
		return nil
	case DestinationPostgresUpdateSSLModesTypeDestinationPostgresUpdateRequire:
		u.DestinationPostgresUpdateRequire = best.Value.(*DestinationPostgresUpdateRequire)
		return nil
	case DestinationPostgresUpdateSSLModesTypeDestinationPostgresUpdateVerifyCa:
		u.DestinationPostgresUpdateVerifyCa = best.Value.(*DestinationPostgresUpdateVerifyCa)
		return nil
	case DestinationPostgresUpdateSSLModesTypeDestinationPostgresUpdateVerifyFull:
		u.DestinationPostgresUpdateVerifyFull = best.Value.(*DestinationPostgresUpdateVerifyFull)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationPostgresUpdateSSLModes", string(data))
}

func (u DestinationPostgresUpdateSSLModes) MarshalJSON() ([]byte, error) {
	if u.DestinationPostgresUpdateDisable != nil {
		return utils.MarshalJSON(u.DestinationPostgresUpdateDisable, "", true)
	}

	if u.DestinationPostgresUpdateAllow != nil {
		return utils.MarshalJSON(u.DestinationPostgresUpdateAllow, "", true)
	}

	if u.DestinationPostgresUpdatePrefer != nil {
		return utils.MarshalJSON(u.DestinationPostgresUpdatePrefer, "", true)
	}

	if u.DestinationPostgresUpdateRequire != nil {
		return utils.MarshalJSON(u.DestinationPostgresUpdateRequire, "", true)
	}

	if u.DestinationPostgresUpdateVerifyCa != nil {
		return utils.MarshalJSON(u.DestinationPostgresUpdateVerifyCa, "", true)
	}

	if u.DestinationPostgresUpdateVerifyFull != nil {
		return utils.MarshalJSON(u.DestinationPostgresUpdateVerifyFull, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationPostgresUpdateSSLModes: all fields are null")
}

type DestinationPostgresUpdateSchemasTunnelMethodTunnelMethod string

const (
	DestinationPostgresUpdateSchemasTunnelMethodTunnelMethodSSHPasswordAuth DestinationPostgresUpdateSchemasTunnelMethodTunnelMethod = "SSH_PASSWORD_AUTH"
)

func (e DestinationPostgresUpdateSchemasTunnelMethodTunnelMethod) ToPointer() *DestinationPostgresUpdateSchemasTunnelMethodTunnelMethod {
	return &e
}
func (e *DestinationPostgresUpdateSchemasTunnelMethodTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_PASSWORD_AUTH":
		*e = DestinationPostgresUpdateSchemasTunnelMethodTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationPostgresUpdateSchemasTunnelMethodTunnelMethod: %v", v)
	}
}

// DestinationPostgresUpdatePasswordAuthentication - Connect through a jump server tunnel host using username and password authentication
type DestinationPostgresUpdatePasswordAuthentication struct {
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost   *string                                                   `json:"tunnel_host,omitempty"`
	TunnelMethod *DestinationPostgresUpdateSchemasTunnelMethodTunnelMethod `default:"SSH_PASSWORD_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser *string `json:"tunnel_user,omitempty"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword   *string `json:"tunnel_user_password,omitempty"`
	AdditionalProperties any     `additionalProperties:"true" json:"-"`
}

func (d DestinationPostgresUpdatePasswordAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationPostgresUpdatePasswordAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationPostgresUpdatePasswordAuthentication) GetTunnelHost() *string {
	if d == nil {
		return nil
	}
	return d.TunnelHost
}

func (d *DestinationPostgresUpdatePasswordAuthentication) GetTunnelMethod() *DestinationPostgresUpdateSchemasTunnelMethodTunnelMethod {
	if d == nil {
		return nil
	}
	return d.TunnelMethod
}

func (d *DestinationPostgresUpdatePasswordAuthentication) GetTunnelPort() *int64 {
	if d == nil {
		return nil
	}
	return d.TunnelPort
}

func (d *DestinationPostgresUpdatePasswordAuthentication) GetTunnelUser() *string {
	if d == nil {
		return nil
	}
	return d.TunnelUser
}

func (d *DestinationPostgresUpdatePasswordAuthentication) GetTunnelUserPassword() *string {
	if d == nil {
		return nil
	}
	return d.TunnelUserPassword
}

func (d *DestinationPostgresUpdatePasswordAuthentication) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationPostgresUpdateSchemasTunnelMethod string

const (
	DestinationPostgresUpdateSchemasTunnelMethodSSHKeyAuth DestinationPostgresUpdateSchemasTunnelMethod = "SSH_KEY_AUTH"
)

func (e DestinationPostgresUpdateSchemasTunnelMethod) ToPointer() *DestinationPostgresUpdateSchemasTunnelMethod {
	return &e
}
func (e *DestinationPostgresUpdateSchemasTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_KEY_AUTH":
		*e = DestinationPostgresUpdateSchemasTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationPostgresUpdateSchemasTunnelMethod: %v", v)
	}
}

// DestinationPostgresUpdateSSHKeyAuthentication - Connect through a jump server tunnel host using username and ssh key
type DestinationPostgresUpdateSSHKeyAuthentication struct {
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey *string `json:"ssh_key,omitempty"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost   *string                                       `json:"tunnel_host,omitempty"`
	TunnelMethod *DestinationPostgresUpdateSchemasTunnelMethod `default:"SSH_KEY_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser           *string `json:"tunnel_user,omitempty"`
	AdditionalProperties any     `additionalProperties:"true" json:"-"`
}

func (d DestinationPostgresUpdateSSHKeyAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationPostgresUpdateSSHKeyAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationPostgresUpdateSSHKeyAuthentication) GetSSHKey() *string {
	if d == nil {
		return nil
	}
	return d.SSHKey
}

func (d *DestinationPostgresUpdateSSHKeyAuthentication) GetTunnelHost() *string {
	if d == nil {
		return nil
	}
	return d.TunnelHost
}

func (d *DestinationPostgresUpdateSSHKeyAuthentication) GetTunnelMethod() *DestinationPostgresUpdateSchemasTunnelMethod {
	if d == nil {
		return nil
	}
	return d.TunnelMethod
}

func (d *DestinationPostgresUpdateSSHKeyAuthentication) GetTunnelPort() *int64 {
	if d == nil {
		return nil
	}
	return d.TunnelPort
}

func (d *DestinationPostgresUpdateSSHKeyAuthentication) GetTunnelUser() *string {
	if d == nil {
		return nil
	}
	return d.TunnelUser
}

func (d *DestinationPostgresUpdateSSHKeyAuthentication) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationPostgresUpdateTunnelMethod string

const (
	DestinationPostgresUpdateTunnelMethodNoTunnel DestinationPostgresUpdateTunnelMethod = "NO_TUNNEL"
)

func (e DestinationPostgresUpdateTunnelMethod) ToPointer() *DestinationPostgresUpdateTunnelMethod {
	return &e
}
func (e *DestinationPostgresUpdateTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NO_TUNNEL":
		*e = DestinationPostgresUpdateTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationPostgresUpdateTunnelMethod: %v", v)
	}
}

// DestinationPostgresUpdateNoTunnel - No ssh tunnel needed to connect to database
type DestinationPostgresUpdateNoTunnel struct {
	TunnelMethod         *DestinationPostgresUpdateTunnelMethod `default:"NO_TUNNEL" json:"tunnel_method"`
	AdditionalProperties any                                    `additionalProperties:"true" json:"-"`
}

func (d DestinationPostgresUpdateNoTunnel) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationPostgresUpdateNoTunnel) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationPostgresUpdateNoTunnel) GetTunnelMethod() *DestinationPostgresUpdateTunnelMethod {
	if d == nil {
		return nil
	}
	return d.TunnelMethod
}

func (d *DestinationPostgresUpdateNoTunnel) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationPostgresUpdateSSHTunnelMethodType string

const (
	DestinationPostgresUpdateSSHTunnelMethodTypeDestinationPostgresUpdateNoTunnel               DestinationPostgresUpdateSSHTunnelMethodType = "destination-postgres-update_No Tunnel"
	DestinationPostgresUpdateSSHTunnelMethodTypeDestinationPostgresUpdateSSHKeyAuthentication   DestinationPostgresUpdateSSHTunnelMethodType = "destination-postgres-update_SSH Key Authentication"
	DestinationPostgresUpdateSSHTunnelMethodTypeDestinationPostgresUpdatePasswordAuthentication DestinationPostgresUpdateSSHTunnelMethodType = "destination-postgres-update_Password Authentication"
)

// DestinationPostgresUpdateSSHTunnelMethod - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type DestinationPostgresUpdateSSHTunnelMethod struct {
	DestinationPostgresUpdateNoTunnel               *DestinationPostgresUpdateNoTunnel               `queryParam:"inline" union:"member"`
	DestinationPostgresUpdateSSHKeyAuthentication   *DestinationPostgresUpdateSSHKeyAuthentication   `queryParam:"inline" union:"member"`
	DestinationPostgresUpdatePasswordAuthentication *DestinationPostgresUpdatePasswordAuthentication `queryParam:"inline" union:"member"`

	Type DestinationPostgresUpdateSSHTunnelMethodType
}

func CreateDestinationPostgresUpdateSSHTunnelMethodDestinationPostgresUpdateNoTunnel(destinationPostgresUpdateNoTunnel DestinationPostgresUpdateNoTunnel) DestinationPostgresUpdateSSHTunnelMethod {
	typ := DestinationPostgresUpdateSSHTunnelMethodTypeDestinationPostgresUpdateNoTunnel

	return DestinationPostgresUpdateSSHTunnelMethod{
		DestinationPostgresUpdateNoTunnel: &destinationPostgresUpdateNoTunnel,
		Type:                              typ,
	}
}

func CreateDestinationPostgresUpdateSSHTunnelMethodDestinationPostgresUpdateSSHKeyAuthentication(destinationPostgresUpdateSSHKeyAuthentication DestinationPostgresUpdateSSHKeyAuthentication) DestinationPostgresUpdateSSHTunnelMethod {
	typ := DestinationPostgresUpdateSSHTunnelMethodTypeDestinationPostgresUpdateSSHKeyAuthentication

	return DestinationPostgresUpdateSSHTunnelMethod{
		DestinationPostgresUpdateSSHKeyAuthentication: &destinationPostgresUpdateSSHKeyAuthentication,
		Type: typ,
	}
}

func CreateDestinationPostgresUpdateSSHTunnelMethodDestinationPostgresUpdatePasswordAuthentication(destinationPostgresUpdatePasswordAuthentication DestinationPostgresUpdatePasswordAuthentication) DestinationPostgresUpdateSSHTunnelMethod {
	typ := DestinationPostgresUpdateSSHTunnelMethodTypeDestinationPostgresUpdatePasswordAuthentication

	return DestinationPostgresUpdateSSHTunnelMethod{
		DestinationPostgresUpdatePasswordAuthentication: &destinationPostgresUpdatePasswordAuthentication,
		Type: typ,
	}
}

func (u *DestinationPostgresUpdateSSHTunnelMethod) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var destinationPostgresUpdateNoTunnel DestinationPostgresUpdateNoTunnel = DestinationPostgresUpdateNoTunnel{}
	if err := utils.UnmarshalJSON(data, &destinationPostgresUpdateNoTunnel, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationPostgresUpdateSSHTunnelMethodTypeDestinationPostgresUpdateNoTunnel,
			Value: &destinationPostgresUpdateNoTunnel,
		})
	}

	var destinationPostgresUpdateSSHKeyAuthentication DestinationPostgresUpdateSSHKeyAuthentication = DestinationPostgresUpdateSSHKeyAuthentication{}
	if err := utils.UnmarshalJSON(data, &destinationPostgresUpdateSSHKeyAuthentication, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationPostgresUpdateSSHTunnelMethodTypeDestinationPostgresUpdateSSHKeyAuthentication,
			Value: &destinationPostgresUpdateSSHKeyAuthentication,
		})
	}

	var destinationPostgresUpdatePasswordAuthentication DestinationPostgresUpdatePasswordAuthentication = DestinationPostgresUpdatePasswordAuthentication{}
	if err := utils.UnmarshalJSON(data, &destinationPostgresUpdatePasswordAuthentication, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationPostgresUpdateSSHTunnelMethodTypeDestinationPostgresUpdatePasswordAuthentication,
			Value: &destinationPostgresUpdatePasswordAuthentication,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationPostgresUpdateSSHTunnelMethod", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationPostgresUpdateSSHTunnelMethod", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(DestinationPostgresUpdateSSHTunnelMethodType)
	switch best.Type {
	case DestinationPostgresUpdateSSHTunnelMethodTypeDestinationPostgresUpdateNoTunnel:
		u.DestinationPostgresUpdateNoTunnel = best.Value.(*DestinationPostgresUpdateNoTunnel)
		return nil
	case DestinationPostgresUpdateSSHTunnelMethodTypeDestinationPostgresUpdateSSHKeyAuthentication:
		u.DestinationPostgresUpdateSSHKeyAuthentication = best.Value.(*DestinationPostgresUpdateSSHKeyAuthentication)
		return nil
	case DestinationPostgresUpdateSSHTunnelMethodTypeDestinationPostgresUpdatePasswordAuthentication:
		u.DestinationPostgresUpdatePasswordAuthentication = best.Value.(*DestinationPostgresUpdatePasswordAuthentication)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationPostgresUpdateSSHTunnelMethod", string(data))
}

func (u DestinationPostgresUpdateSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.DestinationPostgresUpdateNoTunnel != nil {
		return utils.MarshalJSON(u.DestinationPostgresUpdateNoTunnel, "", true)
	}

	if u.DestinationPostgresUpdateSSHKeyAuthentication != nil {
		return utils.MarshalJSON(u.DestinationPostgresUpdateSSHKeyAuthentication, "", true)
	}

	if u.DestinationPostgresUpdatePasswordAuthentication != nil {
		return utils.MarshalJSON(u.DestinationPostgresUpdatePasswordAuthentication, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationPostgresUpdateSSHTunnelMethod: all fields are null")
}

type DestinationPostgresUpdateDestinationType string

const (
	DestinationPostgresUpdateDestinationTypePostgres DestinationPostgresUpdateDestinationType = "postgres"
)

func (e DestinationPostgresUpdateDestinationType) ToPointer() *DestinationPostgresUpdateDestinationType {
	return &e
}
func (e *DestinationPostgresUpdateDestinationType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "postgres":
		*e = DestinationPostgresUpdateDestinationType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationPostgresUpdateDestinationType: %v", v)
	}
}

type DestinationPostgresUpdate struct {
	// Whether to execute CDC deletions as hard deletes (i.e. propagate source deletions to the destination), or soft deletes (i.e. leave a tombstone record in the destination). Defaults to hard deletes.
	CdcDeletionMode *DestinationPostgresUpdateCDCDeletionMode `default:"Hard delete" json:"cdc_deletion_mode"`
	// Name of the database.
	Database *string `json:"database,omitempty"`
	// Disable Writing Final Tables. WARNING! The data format in _airbyte_data is likely stable but there are no guarantees that other metadata columns will remain the same in future versions
	DisableTypeDedupe *bool `json:"disable_type_dedupe,omitempty"`
	// Drop tables with CASCADE. WARNING! This will delete all data in all dependent objects (views, etc.). Use with caution. This option is intended for usecases which can easily rebuild the dependent objects.
	DropCascade *bool `json:"drop_cascade,omitempty"`
	// Hostname of the database.
	Host *string `json:"host,omitempty"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// Password associated with the username.
	Password *string `json:"password,omitempty"`
	// Port of the database.
	Port *int64 `json:"port,omitempty"`
	// Airbyte will use this schema for various internal tables. In legacy raw tables mode, the raw tables will be stored in this schema. Defaults to "airbyte_internal".
	RawDataSchema *string `json:"raw_data_schema,omitempty"`
	// The default schema tables are written. If not specified otherwise, the "public" schema will be used.
	Schema *string `default:"public" json:"schema"`
	// Encrypt data using SSL. When activating SSL, please select one of the connection modes.
	Ssl *bool `default:"true" json:"ssl"`
	// SSL connection modes.
	//   <b>disable</b> - Disables encryption of communication between Airbyte and destination database.
	//   <b>allow</b> - Enables encryption only when required by the destination database.
	//   <b>prefer</b> - Allows unencrypted connections only if the destination database does not support encryption.
	//   <b>require</b> - Always require encryption. If the destination database server does not support encryption, connection will fail.
	//   <b>verify-ca</b> - Always require encryption and verifies that the destination database server has a valid SSL certificate.
	//   <b>verify-full</b> - This is the most secure mode. Always require encryption and verifies the identity of the destination database server.
	//  See more information - <a href="https://jdbc.postgresql.org/documentation/head/ssl-client.html"> in the docs</a>.
	SslMode *DestinationPostgresUpdateSSLModes `json:"ssl_mode,omitempty"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod *DestinationPostgresUpdateSSHTunnelMethod `json:"tunnel_method,omitempty"`
	// Create numeric columns as unconstrained DECIMAL instead of NUMBER(38, 9). This will allow increased precision in numeric values. (this is disabled by default for backwards compatibility, but is recommended to enable)
	UnconstrainedNumber *bool `json:"unconstrained_number,omitempty"`
	// Username to access the database.
	Username             *string                                   `json:"username,omitempty"`
	destinationType      *DestinationPostgresUpdateDestinationType `const:"postgres" json:"destinationType"`
	AdditionalProperties any                                       `additionalProperties:"true" json:"-"`
}

func (d DestinationPostgresUpdate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationPostgresUpdate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationPostgresUpdate) GetCdcDeletionMode() *DestinationPostgresUpdateCDCDeletionMode {
	if d == nil {
		return nil
	}
	return d.CdcDeletionMode
}

func (d *DestinationPostgresUpdate) GetDatabase() *string {
	if d == nil {
		return nil
	}
	return d.Database
}

func (d *DestinationPostgresUpdate) GetDisableTypeDedupe() *bool {
	if d == nil {
		return nil
	}
	return d.DisableTypeDedupe
}

func (d *DestinationPostgresUpdate) GetDropCascade() *bool {
	if d == nil {
		return nil
	}
	return d.DropCascade
}

func (d *DestinationPostgresUpdate) GetHost() *string {
	if d == nil {
		return nil
	}
	return d.Host
}

func (d *DestinationPostgresUpdate) GetJdbcURLParams() *string {
	if d == nil {
		return nil
	}
	return d.JdbcURLParams
}

func (d *DestinationPostgresUpdate) GetPassword() *string {
	if d == nil {
		return nil
	}
	return d.Password
}

func (d *DestinationPostgresUpdate) GetPort() *int64 {
	if d == nil {
		return nil
	}
	return d.Port
}

func (d *DestinationPostgresUpdate) GetRawDataSchema() *string {
	if d == nil {
		return nil
	}
	return d.RawDataSchema
}

func (d *DestinationPostgresUpdate) GetSchema() *string {
	if d == nil {
		return nil
	}
	return d.Schema
}

func (d *DestinationPostgresUpdate) GetSsl() *bool {
	if d == nil {
		return nil
	}
	return d.Ssl
}

func (d *DestinationPostgresUpdate) GetSslMode() *DestinationPostgresUpdateSSLModes {
	if d == nil {
		return nil
	}
	return d.SslMode
}

func (d *DestinationPostgresUpdate) GetTunnelMethod() *DestinationPostgresUpdateSSHTunnelMethod {
	if d == nil {
		return nil
	}
	return d.TunnelMethod
}

func (d *DestinationPostgresUpdate) GetUnconstrainedNumber() *bool {
	if d == nil {
		return nil
	}
	return d.UnconstrainedNumber
}

func (d *DestinationPostgresUpdate) GetUsername() *string {
	if d == nil {
		return nil
	}
	return d.Username
}

func (d *DestinationPostgresUpdate) GetDestinationType() *DestinationPostgresUpdateDestinationType {
	return DestinationPostgresUpdateDestinationTypePostgres.ToPointer()
}

func (d *DestinationPostgresUpdate) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}
