// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

type DestinationPostgresUpdateSchemasSSLModeSSLModes6Mode string

const (
	DestinationPostgresUpdateSchemasSSLModeSSLModes6ModeVerifyFull DestinationPostgresUpdateSchemasSSLModeSSLModes6Mode = "verify-full"
)

func (e DestinationPostgresUpdateSchemasSSLModeSSLModes6Mode) ToPointer() *DestinationPostgresUpdateSchemasSSLModeSSLModes6Mode {
	return &e
}
func (e *DestinationPostgresUpdateSchemasSSLModeSSLModes6Mode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "verify-full":
		*e = DestinationPostgresUpdateSchemasSSLModeSSLModes6Mode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationPostgresUpdateSchemasSSLModeSSLModes6Mode: %v", v)
	}
}

// DestinationPostgresUpdateVerifyFull - Verify-full SSL mode.
type DestinationPostgresUpdateVerifyFull struct {
	mode *DestinationPostgresUpdateSchemasSSLModeSSLModes6Mode `const:"verify-full" json:"mode"`
	// CA certificate
	CaCertificate string `json:"ca_certificate"`
	// Client certificate
	ClientCertificate string `json:"client_certificate"`
	// Client key
	ClientKey string `json:"client_key"`
	// Password for keystorage. This field is optional. If you do not add it - the password will be generated automatically.
	ClientKeyPassword *string `json:"client_key_password,omitempty"`
}

func (d DestinationPostgresUpdateVerifyFull) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationPostgresUpdateVerifyFull) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationPostgresUpdateVerifyFull) GetMode() *DestinationPostgresUpdateSchemasSSLModeSSLModes6Mode {
	return DestinationPostgresUpdateSchemasSSLModeSSLModes6ModeVerifyFull.ToPointer()
}

func (o *DestinationPostgresUpdateVerifyFull) GetCaCertificate() string {
	if o == nil {
		return ""
	}
	return o.CaCertificate
}

func (o *DestinationPostgresUpdateVerifyFull) GetClientCertificate() string {
	if o == nil {
		return ""
	}
	return o.ClientCertificate
}

func (o *DestinationPostgresUpdateVerifyFull) GetClientKey() string {
	if o == nil {
		return ""
	}
	return o.ClientKey
}

func (o *DestinationPostgresUpdateVerifyFull) GetClientKeyPassword() *string {
	if o == nil {
		return nil
	}
	return o.ClientKeyPassword
}

type DestinationPostgresUpdateSchemasSSLModeSSLModes5Mode string

const (
	DestinationPostgresUpdateSchemasSSLModeSSLModes5ModeVerifyCa DestinationPostgresUpdateSchemasSSLModeSSLModes5Mode = "verify-ca"
)

func (e DestinationPostgresUpdateSchemasSSLModeSSLModes5Mode) ToPointer() *DestinationPostgresUpdateSchemasSSLModeSSLModes5Mode {
	return &e
}
func (e *DestinationPostgresUpdateSchemasSSLModeSSLModes5Mode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "verify-ca":
		*e = DestinationPostgresUpdateSchemasSSLModeSSLModes5Mode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationPostgresUpdateSchemasSSLModeSSLModes5Mode: %v", v)
	}
}

// DestinationPostgresUpdateVerifyCa - Verify-ca SSL mode.
type DestinationPostgresUpdateVerifyCa struct {
	mode *DestinationPostgresUpdateSchemasSSLModeSSLModes5Mode `const:"verify-ca" json:"mode"`
	// CA certificate
	CaCertificate string `json:"ca_certificate"`
	// Password for keystorage. This field is optional. If you do not add it - the password will be generated automatically.
	ClientKeyPassword *string `json:"client_key_password,omitempty"`
}

func (d DestinationPostgresUpdateVerifyCa) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationPostgresUpdateVerifyCa) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationPostgresUpdateVerifyCa) GetMode() *DestinationPostgresUpdateSchemasSSLModeSSLModes5Mode {
	return DestinationPostgresUpdateSchemasSSLModeSSLModes5ModeVerifyCa.ToPointer()
}

func (o *DestinationPostgresUpdateVerifyCa) GetCaCertificate() string {
	if o == nil {
		return ""
	}
	return o.CaCertificate
}

func (o *DestinationPostgresUpdateVerifyCa) GetClientKeyPassword() *string {
	if o == nil {
		return nil
	}
	return o.ClientKeyPassword
}

type DestinationPostgresUpdateSchemasSSLModeSSLModesMode string

const (
	DestinationPostgresUpdateSchemasSSLModeSSLModesModeRequire DestinationPostgresUpdateSchemasSSLModeSSLModesMode = "require"
)

func (e DestinationPostgresUpdateSchemasSSLModeSSLModesMode) ToPointer() *DestinationPostgresUpdateSchemasSSLModeSSLModesMode {
	return &e
}
func (e *DestinationPostgresUpdateSchemasSSLModeSSLModesMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "require":
		*e = DestinationPostgresUpdateSchemasSSLModeSSLModesMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationPostgresUpdateSchemasSSLModeSSLModesMode: %v", v)
	}
}

// DestinationPostgresUpdateRequire - Require SSL mode.
type DestinationPostgresUpdateRequire struct {
	mode *DestinationPostgresUpdateSchemasSSLModeSSLModesMode `const:"require" json:"mode"`
}

func (d DestinationPostgresUpdateRequire) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationPostgresUpdateRequire) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationPostgresUpdateRequire) GetMode() *DestinationPostgresUpdateSchemasSSLModeSSLModesMode {
	return DestinationPostgresUpdateSchemasSSLModeSSLModesModeRequire.ToPointer()
}

type DestinationPostgresUpdateSchemasSslModeMode string

const (
	DestinationPostgresUpdateSchemasSslModeModePrefer DestinationPostgresUpdateSchemasSslModeMode = "prefer"
)

func (e DestinationPostgresUpdateSchemasSslModeMode) ToPointer() *DestinationPostgresUpdateSchemasSslModeMode {
	return &e
}
func (e *DestinationPostgresUpdateSchemasSslModeMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "prefer":
		*e = DestinationPostgresUpdateSchemasSslModeMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationPostgresUpdateSchemasSslModeMode: %v", v)
	}
}

// DestinationPostgresUpdatePrefer - Prefer SSL mode.
type DestinationPostgresUpdatePrefer struct {
	mode *DestinationPostgresUpdateSchemasSslModeMode `const:"prefer" json:"mode"`
}

func (d DestinationPostgresUpdatePrefer) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationPostgresUpdatePrefer) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationPostgresUpdatePrefer) GetMode() *DestinationPostgresUpdateSchemasSslModeMode {
	return DestinationPostgresUpdateSchemasSslModeModePrefer.ToPointer()
}

type DestinationPostgresUpdateSchemasMode string

const (
	DestinationPostgresUpdateSchemasModeAllow DestinationPostgresUpdateSchemasMode = "allow"
)

func (e DestinationPostgresUpdateSchemasMode) ToPointer() *DestinationPostgresUpdateSchemasMode {
	return &e
}
func (e *DestinationPostgresUpdateSchemasMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "allow":
		*e = DestinationPostgresUpdateSchemasMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationPostgresUpdateSchemasMode: %v", v)
	}
}

// DestinationPostgresUpdateAllow - Allow SSL mode.
type DestinationPostgresUpdateAllow struct {
	mode *DestinationPostgresUpdateSchemasMode `const:"allow" json:"mode"`
}

func (d DestinationPostgresUpdateAllow) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationPostgresUpdateAllow) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationPostgresUpdateAllow) GetMode() *DestinationPostgresUpdateSchemasMode {
	return DestinationPostgresUpdateSchemasModeAllow.ToPointer()
}

type DestinationPostgresUpdateMode string

const (
	DestinationPostgresUpdateModeDisable DestinationPostgresUpdateMode = "disable"
)

func (e DestinationPostgresUpdateMode) ToPointer() *DestinationPostgresUpdateMode {
	return &e
}
func (e *DestinationPostgresUpdateMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "disable":
		*e = DestinationPostgresUpdateMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationPostgresUpdateMode: %v", v)
	}
}

// DestinationPostgresUpdateDisable - Disable SSL.
type DestinationPostgresUpdateDisable struct {
	mode *DestinationPostgresUpdateMode `const:"disable" json:"mode"`
}

func (d DestinationPostgresUpdateDisable) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationPostgresUpdateDisable) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationPostgresUpdateDisable) GetMode() *DestinationPostgresUpdateMode {
	return DestinationPostgresUpdateModeDisable.ToPointer()
}

type DestinationPostgresUpdateSSLModesType string

const (
	DestinationPostgresUpdateSSLModesTypeDestinationPostgresUpdateDisable    DestinationPostgresUpdateSSLModesType = "destination-postgres-update_disable"
	DestinationPostgresUpdateSSLModesTypeDestinationPostgresUpdateAllow      DestinationPostgresUpdateSSLModesType = "destination-postgres-update_allow"
	DestinationPostgresUpdateSSLModesTypeDestinationPostgresUpdatePrefer     DestinationPostgresUpdateSSLModesType = "destination-postgres-update_prefer"
	DestinationPostgresUpdateSSLModesTypeDestinationPostgresUpdateRequire    DestinationPostgresUpdateSSLModesType = "destination-postgres-update_require"
	DestinationPostgresUpdateSSLModesTypeDestinationPostgresUpdateVerifyCa   DestinationPostgresUpdateSSLModesType = "destination-postgres-update_verify-ca"
	DestinationPostgresUpdateSSLModesTypeDestinationPostgresUpdateVerifyFull DestinationPostgresUpdateSSLModesType = "destination-postgres-update_verify-full"
)

// DestinationPostgresUpdateSSLModes - SSL connection modes.
//
//	<b>disable</b> - Chose this mode to disable encryption of communication between Airbyte and destination database
//	<b>allow</b> - Chose this mode to enable encryption only when required by the source database
//	<b>prefer</b> - Chose this mode to allow unencrypted connection only if the source database does not support encryption
//	<b>require</b> - Chose this mode to always require encryption. If the source database server does not support encryption, connection will fail
//	 <b>verify-ca</b> - Chose this mode to always require encryption and to verify that the source database server has a valid SSL certificate
//	 <b>verify-full</b> - This is the most secure mode. Chose this mode to always require encryption and to verify the identity of the source database server
//	See more information - <a href="https://jdbc.postgresql.org/documentation/head/ssl-client.html"> in the docs</a>.
type DestinationPostgresUpdateSSLModes struct {
	DestinationPostgresUpdateDisable    *DestinationPostgresUpdateDisable    `queryParam:"inline"`
	DestinationPostgresUpdateAllow      *DestinationPostgresUpdateAllow      `queryParam:"inline"`
	DestinationPostgresUpdatePrefer     *DestinationPostgresUpdatePrefer     `queryParam:"inline"`
	DestinationPostgresUpdateRequire    *DestinationPostgresUpdateRequire    `queryParam:"inline"`
	DestinationPostgresUpdateVerifyCa   *DestinationPostgresUpdateVerifyCa   `queryParam:"inline"`
	DestinationPostgresUpdateVerifyFull *DestinationPostgresUpdateVerifyFull `queryParam:"inline"`

	Type DestinationPostgresUpdateSSLModesType
}

func CreateDestinationPostgresUpdateSSLModesDestinationPostgresUpdateDisable(destinationPostgresUpdateDisable DestinationPostgresUpdateDisable) DestinationPostgresUpdateSSLModes {
	typ := DestinationPostgresUpdateSSLModesTypeDestinationPostgresUpdateDisable

	return DestinationPostgresUpdateSSLModes{
		DestinationPostgresUpdateDisable: &destinationPostgresUpdateDisable,
		Type:                             typ,
	}
}

func CreateDestinationPostgresUpdateSSLModesDestinationPostgresUpdateAllow(destinationPostgresUpdateAllow DestinationPostgresUpdateAllow) DestinationPostgresUpdateSSLModes {
	typ := DestinationPostgresUpdateSSLModesTypeDestinationPostgresUpdateAllow

	return DestinationPostgresUpdateSSLModes{
		DestinationPostgresUpdateAllow: &destinationPostgresUpdateAllow,
		Type:                           typ,
	}
}

func CreateDestinationPostgresUpdateSSLModesDestinationPostgresUpdatePrefer(destinationPostgresUpdatePrefer DestinationPostgresUpdatePrefer) DestinationPostgresUpdateSSLModes {
	typ := DestinationPostgresUpdateSSLModesTypeDestinationPostgresUpdatePrefer

	return DestinationPostgresUpdateSSLModes{
		DestinationPostgresUpdatePrefer: &destinationPostgresUpdatePrefer,
		Type:                            typ,
	}
}

func CreateDestinationPostgresUpdateSSLModesDestinationPostgresUpdateRequire(destinationPostgresUpdateRequire DestinationPostgresUpdateRequire) DestinationPostgresUpdateSSLModes {
	typ := DestinationPostgresUpdateSSLModesTypeDestinationPostgresUpdateRequire

	return DestinationPostgresUpdateSSLModes{
		DestinationPostgresUpdateRequire: &destinationPostgresUpdateRequire,
		Type:                             typ,
	}
}

func CreateDestinationPostgresUpdateSSLModesDestinationPostgresUpdateVerifyCa(destinationPostgresUpdateVerifyCa DestinationPostgresUpdateVerifyCa) DestinationPostgresUpdateSSLModes {
	typ := DestinationPostgresUpdateSSLModesTypeDestinationPostgresUpdateVerifyCa

	return DestinationPostgresUpdateSSLModes{
		DestinationPostgresUpdateVerifyCa: &destinationPostgresUpdateVerifyCa,
		Type:                              typ,
	}
}

func CreateDestinationPostgresUpdateSSLModesDestinationPostgresUpdateVerifyFull(destinationPostgresUpdateVerifyFull DestinationPostgresUpdateVerifyFull) DestinationPostgresUpdateSSLModes {
	typ := DestinationPostgresUpdateSSLModesTypeDestinationPostgresUpdateVerifyFull

	return DestinationPostgresUpdateSSLModes{
		DestinationPostgresUpdateVerifyFull: &destinationPostgresUpdateVerifyFull,
		Type:                                typ,
	}
}

func (u *DestinationPostgresUpdateSSLModes) UnmarshalJSON(data []byte) error {

	var destinationPostgresUpdateDisable DestinationPostgresUpdateDisable = DestinationPostgresUpdateDisable{}
	if err := utils.UnmarshalJSON(data, &destinationPostgresUpdateDisable, "", true, true); err == nil {
		u.DestinationPostgresUpdateDisable = &destinationPostgresUpdateDisable
		u.Type = DestinationPostgresUpdateSSLModesTypeDestinationPostgresUpdateDisable
		return nil
	}

	var destinationPostgresUpdateAllow DestinationPostgresUpdateAllow = DestinationPostgresUpdateAllow{}
	if err := utils.UnmarshalJSON(data, &destinationPostgresUpdateAllow, "", true, true); err == nil {
		u.DestinationPostgresUpdateAllow = &destinationPostgresUpdateAllow
		u.Type = DestinationPostgresUpdateSSLModesTypeDestinationPostgresUpdateAllow
		return nil
	}

	var destinationPostgresUpdatePrefer DestinationPostgresUpdatePrefer = DestinationPostgresUpdatePrefer{}
	if err := utils.UnmarshalJSON(data, &destinationPostgresUpdatePrefer, "", true, true); err == nil {
		u.DestinationPostgresUpdatePrefer = &destinationPostgresUpdatePrefer
		u.Type = DestinationPostgresUpdateSSLModesTypeDestinationPostgresUpdatePrefer
		return nil
	}

	var destinationPostgresUpdateRequire DestinationPostgresUpdateRequire = DestinationPostgresUpdateRequire{}
	if err := utils.UnmarshalJSON(data, &destinationPostgresUpdateRequire, "", true, true); err == nil {
		u.DestinationPostgresUpdateRequire = &destinationPostgresUpdateRequire
		u.Type = DestinationPostgresUpdateSSLModesTypeDestinationPostgresUpdateRequire
		return nil
	}

	var destinationPostgresUpdateVerifyCa DestinationPostgresUpdateVerifyCa = DestinationPostgresUpdateVerifyCa{}
	if err := utils.UnmarshalJSON(data, &destinationPostgresUpdateVerifyCa, "", true, true); err == nil {
		u.DestinationPostgresUpdateVerifyCa = &destinationPostgresUpdateVerifyCa
		u.Type = DestinationPostgresUpdateSSLModesTypeDestinationPostgresUpdateVerifyCa
		return nil
	}

	var destinationPostgresUpdateVerifyFull DestinationPostgresUpdateVerifyFull = DestinationPostgresUpdateVerifyFull{}
	if err := utils.UnmarshalJSON(data, &destinationPostgresUpdateVerifyFull, "", true, true); err == nil {
		u.DestinationPostgresUpdateVerifyFull = &destinationPostgresUpdateVerifyFull
		u.Type = DestinationPostgresUpdateSSLModesTypeDestinationPostgresUpdateVerifyFull
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationPostgresUpdateSSLModes", string(data))
}

func (u DestinationPostgresUpdateSSLModes) MarshalJSON() ([]byte, error) {
	if u.DestinationPostgresUpdateDisable != nil {
		return utils.MarshalJSON(u.DestinationPostgresUpdateDisable, "", true)
	}

	if u.DestinationPostgresUpdateAllow != nil {
		return utils.MarshalJSON(u.DestinationPostgresUpdateAllow, "", true)
	}

	if u.DestinationPostgresUpdatePrefer != nil {
		return utils.MarshalJSON(u.DestinationPostgresUpdatePrefer, "", true)
	}

	if u.DestinationPostgresUpdateRequire != nil {
		return utils.MarshalJSON(u.DestinationPostgresUpdateRequire, "", true)
	}

	if u.DestinationPostgresUpdateVerifyCa != nil {
		return utils.MarshalJSON(u.DestinationPostgresUpdateVerifyCa, "", true)
	}

	if u.DestinationPostgresUpdateVerifyFull != nil {
		return utils.MarshalJSON(u.DestinationPostgresUpdateVerifyFull, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationPostgresUpdateSSLModes: all fields are null")
}

// DestinationPostgresUpdateSchemasTunnelMethodTunnelMethod - Connect through a jump server tunnel host using username and password authentication
type DestinationPostgresUpdateSchemasTunnelMethodTunnelMethod string

const (
	DestinationPostgresUpdateSchemasTunnelMethodTunnelMethodSSHPasswordAuth DestinationPostgresUpdateSchemasTunnelMethodTunnelMethod = "SSH_PASSWORD_AUTH"
)

func (e DestinationPostgresUpdateSchemasTunnelMethodTunnelMethod) ToPointer() *DestinationPostgresUpdateSchemasTunnelMethodTunnelMethod {
	return &e
}
func (e *DestinationPostgresUpdateSchemasTunnelMethodTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_PASSWORD_AUTH":
		*e = DestinationPostgresUpdateSchemasTunnelMethodTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationPostgresUpdateSchemasTunnelMethodTunnelMethod: %v", v)
	}
}

type DestinationPostgresUpdatePasswordAuthentication struct {
	// Connect through a jump server tunnel host using username and password authentication
	tunnelMethod DestinationPostgresUpdateSchemasTunnelMethodTunnelMethod `const:"SSH_PASSWORD_AUTH" json:"tunnel_method"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser string `json:"tunnel_user"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword string `json:"tunnel_user_password"`
}

func (d DestinationPostgresUpdatePasswordAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationPostgresUpdatePasswordAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationPostgresUpdatePasswordAuthentication) GetTunnelMethod() DestinationPostgresUpdateSchemasTunnelMethodTunnelMethod {
	return DestinationPostgresUpdateSchemasTunnelMethodTunnelMethodSSHPasswordAuth
}

func (o *DestinationPostgresUpdatePasswordAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *DestinationPostgresUpdatePasswordAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *DestinationPostgresUpdatePasswordAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

func (o *DestinationPostgresUpdatePasswordAuthentication) GetTunnelUserPassword() string {
	if o == nil {
		return ""
	}
	return o.TunnelUserPassword
}

// DestinationPostgresUpdateSchemasTunnelMethod - Connect through a jump server tunnel host using username and ssh key
type DestinationPostgresUpdateSchemasTunnelMethod string

const (
	DestinationPostgresUpdateSchemasTunnelMethodSSHKeyAuth DestinationPostgresUpdateSchemasTunnelMethod = "SSH_KEY_AUTH"
)

func (e DestinationPostgresUpdateSchemasTunnelMethod) ToPointer() *DestinationPostgresUpdateSchemasTunnelMethod {
	return &e
}
func (e *DestinationPostgresUpdateSchemasTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_KEY_AUTH":
		*e = DestinationPostgresUpdateSchemasTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationPostgresUpdateSchemasTunnelMethod: %v", v)
	}
}

type DestinationPostgresUpdateSSHKeyAuthentication struct {
	// Connect through a jump server tunnel host using username and ssh key
	tunnelMethod DestinationPostgresUpdateSchemasTunnelMethod `const:"SSH_KEY_AUTH" json:"tunnel_method"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host.
	TunnelUser string `json:"tunnel_user"`
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey string `json:"ssh_key"`
}

func (d DestinationPostgresUpdateSSHKeyAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationPostgresUpdateSSHKeyAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationPostgresUpdateSSHKeyAuthentication) GetTunnelMethod() DestinationPostgresUpdateSchemasTunnelMethod {
	return DestinationPostgresUpdateSchemasTunnelMethodSSHKeyAuth
}

func (o *DestinationPostgresUpdateSSHKeyAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *DestinationPostgresUpdateSSHKeyAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *DestinationPostgresUpdateSSHKeyAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

func (o *DestinationPostgresUpdateSSHKeyAuthentication) GetSSHKey() string {
	if o == nil {
		return ""
	}
	return o.SSHKey
}

// DestinationPostgresUpdateTunnelMethod - No ssh tunnel needed to connect to database
type DestinationPostgresUpdateTunnelMethod string

const (
	DestinationPostgresUpdateTunnelMethodNoTunnel DestinationPostgresUpdateTunnelMethod = "NO_TUNNEL"
)

func (e DestinationPostgresUpdateTunnelMethod) ToPointer() *DestinationPostgresUpdateTunnelMethod {
	return &e
}
func (e *DestinationPostgresUpdateTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NO_TUNNEL":
		*e = DestinationPostgresUpdateTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationPostgresUpdateTunnelMethod: %v", v)
	}
}

type DestinationPostgresUpdateNoTunnel struct {
	// No ssh tunnel needed to connect to database
	tunnelMethod DestinationPostgresUpdateTunnelMethod `const:"NO_TUNNEL" json:"tunnel_method"`
}

func (d DestinationPostgresUpdateNoTunnel) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationPostgresUpdateNoTunnel) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationPostgresUpdateNoTunnel) GetTunnelMethod() DestinationPostgresUpdateTunnelMethod {
	return DestinationPostgresUpdateTunnelMethodNoTunnel
}

type DestinationPostgresUpdateSSHTunnelMethodType string

const (
	DestinationPostgresUpdateSSHTunnelMethodTypeDestinationPostgresUpdateNoTunnel               DestinationPostgresUpdateSSHTunnelMethodType = "destination-postgres-update_No Tunnel"
	DestinationPostgresUpdateSSHTunnelMethodTypeDestinationPostgresUpdateSSHKeyAuthentication   DestinationPostgresUpdateSSHTunnelMethodType = "destination-postgres-update_SSH Key Authentication"
	DestinationPostgresUpdateSSHTunnelMethodTypeDestinationPostgresUpdatePasswordAuthentication DestinationPostgresUpdateSSHTunnelMethodType = "destination-postgres-update_Password Authentication"
)

// DestinationPostgresUpdateSSHTunnelMethod - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type DestinationPostgresUpdateSSHTunnelMethod struct {
	DestinationPostgresUpdateNoTunnel               *DestinationPostgresUpdateNoTunnel               `queryParam:"inline"`
	DestinationPostgresUpdateSSHKeyAuthentication   *DestinationPostgresUpdateSSHKeyAuthentication   `queryParam:"inline"`
	DestinationPostgresUpdatePasswordAuthentication *DestinationPostgresUpdatePasswordAuthentication `queryParam:"inline"`

	Type DestinationPostgresUpdateSSHTunnelMethodType
}

func CreateDestinationPostgresUpdateSSHTunnelMethodDestinationPostgresUpdateNoTunnel(destinationPostgresUpdateNoTunnel DestinationPostgresUpdateNoTunnel) DestinationPostgresUpdateSSHTunnelMethod {
	typ := DestinationPostgresUpdateSSHTunnelMethodTypeDestinationPostgresUpdateNoTunnel

	return DestinationPostgresUpdateSSHTunnelMethod{
		DestinationPostgresUpdateNoTunnel: &destinationPostgresUpdateNoTunnel,
		Type:                              typ,
	}
}

func CreateDestinationPostgresUpdateSSHTunnelMethodDestinationPostgresUpdateSSHKeyAuthentication(destinationPostgresUpdateSSHKeyAuthentication DestinationPostgresUpdateSSHKeyAuthentication) DestinationPostgresUpdateSSHTunnelMethod {
	typ := DestinationPostgresUpdateSSHTunnelMethodTypeDestinationPostgresUpdateSSHKeyAuthentication

	return DestinationPostgresUpdateSSHTunnelMethod{
		DestinationPostgresUpdateSSHKeyAuthentication: &destinationPostgresUpdateSSHKeyAuthentication,
		Type: typ,
	}
}

func CreateDestinationPostgresUpdateSSHTunnelMethodDestinationPostgresUpdatePasswordAuthentication(destinationPostgresUpdatePasswordAuthentication DestinationPostgresUpdatePasswordAuthentication) DestinationPostgresUpdateSSHTunnelMethod {
	typ := DestinationPostgresUpdateSSHTunnelMethodTypeDestinationPostgresUpdatePasswordAuthentication

	return DestinationPostgresUpdateSSHTunnelMethod{
		DestinationPostgresUpdatePasswordAuthentication: &destinationPostgresUpdatePasswordAuthentication,
		Type: typ,
	}
}

func (u *DestinationPostgresUpdateSSHTunnelMethod) UnmarshalJSON(data []byte) error {

	var destinationPostgresUpdateNoTunnel DestinationPostgresUpdateNoTunnel = DestinationPostgresUpdateNoTunnel{}
	if err := utils.UnmarshalJSON(data, &destinationPostgresUpdateNoTunnel, "", true, true); err == nil {
		u.DestinationPostgresUpdateNoTunnel = &destinationPostgresUpdateNoTunnel
		u.Type = DestinationPostgresUpdateSSHTunnelMethodTypeDestinationPostgresUpdateNoTunnel
		return nil
	}

	var destinationPostgresUpdateSSHKeyAuthentication DestinationPostgresUpdateSSHKeyAuthentication = DestinationPostgresUpdateSSHKeyAuthentication{}
	if err := utils.UnmarshalJSON(data, &destinationPostgresUpdateSSHKeyAuthentication, "", true, true); err == nil {
		u.DestinationPostgresUpdateSSHKeyAuthentication = &destinationPostgresUpdateSSHKeyAuthentication
		u.Type = DestinationPostgresUpdateSSHTunnelMethodTypeDestinationPostgresUpdateSSHKeyAuthentication
		return nil
	}

	var destinationPostgresUpdatePasswordAuthentication DestinationPostgresUpdatePasswordAuthentication = DestinationPostgresUpdatePasswordAuthentication{}
	if err := utils.UnmarshalJSON(data, &destinationPostgresUpdatePasswordAuthentication, "", true, true); err == nil {
		u.DestinationPostgresUpdatePasswordAuthentication = &destinationPostgresUpdatePasswordAuthentication
		u.Type = DestinationPostgresUpdateSSHTunnelMethodTypeDestinationPostgresUpdatePasswordAuthentication
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationPostgresUpdateSSHTunnelMethod", string(data))
}

func (u DestinationPostgresUpdateSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.DestinationPostgresUpdateNoTunnel != nil {
		return utils.MarshalJSON(u.DestinationPostgresUpdateNoTunnel, "", true)
	}

	if u.DestinationPostgresUpdateSSHKeyAuthentication != nil {
		return utils.MarshalJSON(u.DestinationPostgresUpdateSSHKeyAuthentication, "", true)
	}

	if u.DestinationPostgresUpdatePasswordAuthentication != nil {
		return utils.MarshalJSON(u.DestinationPostgresUpdatePasswordAuthentication, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationPostgresUpdateSSHTunnelMethod: all fields are null")
}

type DestinationPostgresUpdate struct {
	// Hostname of the database.
	Host string `json:"host"`
	// Port of the database.
	Port *int64 `default:"5432" json:"port"`
	// Name of the database.
	Database string `json:"database"`
	// The default schema tables are written to if the source does not specify a namespace. The usual value for this field is "public".
	Schema *string `default:"public" json:"schema"`
	// Username to use to access the database.
	Username string `json:"username"`
	// Password associated with the username.
	Password *string `json:"password,omitempty"`
	// Encrypt data using SSL. When activating SSL, please select one of the connection modes.
	Ssl *bool `default:"false" json:"ssl"`
	// SSL connection modes.
	//  <b>disable</b> - Chose this mode to disable encryption of communication between Airbyte and destination database
	//  <b>allow</b> - Chose this mode to enable encryption only when required by the source database
	//  <b>prefer</b> - Chose this mode to allow unencrypted connection only if the source database does not support encryption
	//  <b>require</b> - Chose this mode to always require encryption. If the source database server does not support encryption, connection will fail
	//   <b>verify-ca</b> - Chose this mode to always require encryption and to verify that the source database server has a valid SSL certificate
	//   <b>verify-full</b> - This is the most secure mode. Chose this mode to always require encryption and to verify the identity of the source database server
	//  See more information - <a href="https://jdbc.postgresql.org/documentation/head/ssl-client.html"> in the docs</a>.
	SslMode *DestinationPostgresUpdateSSLModes `json:"ssl_mode,omitempty"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// The schema to write raw tables into
	RawDataSchema *string `json:"raw_data_schema,omitempty"`
	// Disable Writing Final Tables. WARNING! The data format in _airbyte_data is likely stable but there are no guarantees that other metadata columns will remain the same in future versions
	DisableTypeDedupe *bool `default:"false" json:"disable_type_dedupe"`
	// Drop tables with CASCADE. WARNING! This will delete all data in all dependent objects (views, etc.). Use with caution. This option is intended for usecases which can easily rebuild the dependent objects.
	DropCascade *bool `default:"false" json:"drop_cascade"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod *DestinationPostgresUpdateSSHTunnelMethod `json:"tunnel_method,omitempty"`
}

func (d DestinationPostgresUpdate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationPostgresUpdate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *DestinationPostgresUpdate) GetHost() string {
	if o == nil {
		return ""
	}
	return o.Host
}

func (o *DestinationPostgresUpdate) GetPort() *int64 {
	if o == nil {
		return nil
	}
	return o.Port
}

func (o *DestinationPostgresUpdate) GetDatabase() string {
	if o == nil {
		return ""
	}
	return o.Database
}

func (o *DestinationPostgresUpdate) GetSchema() *string {
	if o == nil {
		return nil
	}
	return o.Schema
}

func (o *DestinationPostgresUpdate) GetUsername() string {
	if o == nil {
		return ""
	}
	return o.Username
}

func (o *DestinationPostgresUpdate) GetPassword() *string {
	if o == nil {
		return nil
	}
	return o.Password
}

func (o *DestinationPostgresUpdate) GetSsl() *bool {
	if o == nil {
		return nil
	}
	return o.Ssl
}

func (o *DestinationPostgresUpdate) GetSslMode() *DestinationPostgresUpdateSSLModes {
	if o == nil {
		return nil
	}
	return o.SslMode
}

func (o *DestinationPostgresUpdate) GetJdbcURLParams() *string {
	if o == nil {
		return nil
	}
	return o.JdbcURLParams
}

func (o *DestinationPostgresUpdate) GetRawDataSchema() *string {
	if o == nil {
		return nil
	}
	return o.RawDataSchema
}

func (o *DestinationPostgresUpdate) GetDisableTypeDedupe() *bool {
	if o == nil {
		return nil
	}
	return o.DisableTypeDedupe
}

func (o *DestinationPostgresUpdate) GetDropCascade() *bool {
	if o == nil {
		return nil
	}
	return o.DropCascade
}

func (o *DestinationPostgresUpdate) GetTunnelMethod() *DestinationPostgresUpdateSSHTunnelMethod {
	if o == nil {
		return nil
	}
	return o.TunnelMethod
}
