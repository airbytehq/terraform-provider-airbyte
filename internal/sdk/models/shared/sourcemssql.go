// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

type SourceMssqlSchemasMethod string

const (
	SourceMssqlSchemasMethodStandard SourceMssqlSchemasMethod = "STANDARD"
)

func (e SourceMssqlSchemasMethod) ToPointer() *SourceMssqlSchemasMethod {
	return &e
}
func (e *SourceMssqlSchemasMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "STANDARD":
		*e = SourceMssqlSchemasMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMssqlSchemasMethod: %v", v)
	}
}

// SourceMssqlScanChangesWithUserDefinedCursor - Incrementally detects new inserts and updates using the <a href="https://docs.airbyte.com/understanding-airbyte/connections/incremental-append/#user-defined-cursor">cursor column</a> chosen when configuring a connection (e.g. created_at, updated_at).
type SourceMssqlScanChangesWithUserDefinedCursor struct {
	method SourceMssqlSchemasMethod `const:"STANDARD" json:"method"`
}

func (s SourceMssqlScanChangesWithUserDefinedCursor) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMssqlScanChangesWithUserDefinedCursor) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceMssqlScanChangesWithUserDefinedCursor) GetMethod() SourceMssqlSchemasMethod {
	return SourceMssqlSchemasMethodStandard
}

// SourceMssqlInvalidCDCPositionBehaviorAdvanced - Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value into the WAL. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss.
type SourceMssqlInvalidCDCPositionBehaviorAdvanced string

const (
	SourceMssqlInvalidCDCPositionBehaviorAdvancedFailSync   SourceMssqlInvalidCDCPositionBehaviorAdvanced = "Fail sync"
	SourceMssqlInvalidCDCPositionBehaviorAdvancedReSyncData SourceMssqlInvalidCDCPositionBehaviorAdvanced = "Re-sync data"
)

func (e SourceMssqlInvalidCDCPositionBehaviorAdvanced) ToPointer() *SourceMssqlInvalidCDCPositionBehaviorAdvanced {
	return &e
}
func (e *SourceMssqlInvalidCDCPositionBehaviorAdvanced) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Fail sync":
		fallthrough
	case "Re-sync data":
		*e = SourceMssqlInvalidCDCPositionBehaviorAdvanced(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMssqlInvalidCDCPositionBehaviorAdvanced: %v", v)
	}
}

type SourceMssqlMethod string

const (
	SourceMssqlMethodCdc SourceMssqlMethod = "CDC"
)

func (e SourceMssqlMethod) ToPointer() *SourceMssqlMethod {
	return &e
}
func (e *SourceMssqlMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CDC":
		*e = SourceMssqlMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMssqlMethod: %v", v)
	}
}

// SourceMssqlReadChangesUsingChangeDataCaptureCDC - <i>Recommended</i> - Incrementally reads new inserts, updates, and deletes using the SQL Server's <a href="https://docs.airbyte.com/integrations/sources/mssql/#change-data-capture-cdc">change data capture feature</a>. This must be enabled on your database.
type SourceMssqlReadChangesUsingChangeDataCaptureCDC struct {
	// The amount of time the connector will wait when it launches to determine if there is new data to sync or not. Defaults to 300 seconds. Valid range: 120 seconds to 3600 seconds. Read about <a href="https://docs.airbyte.com/integrations/sources/mysql/#change-data-capture-cdc">initial waiting time</a>.
	InitialWaitingSeconds *int64 `default:"300" json:"initial_waiting_seconds"`
	// Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value into the WAL. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss.
	InvalidCdcCursorPositionBehavior *SourceMssqlInvalidCDCPositionBehaviorAdvanced `default:"Fail sync" json:"invalid_cdc_cursor_position_behavior"`
	method                           SourceMssqlMethod                              `const:"CDC" json:"method"`
	// The size of the internal queue. This may interfere with memory consumption and efficiency of the connector, please be careful.
	QueueSize *int64 `default:"10000" json:"queue_size"`
}

func (s SourceMssqlReadChangesUsingChangeDataCaptureCDC) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMssqlReadChangesUsingChangeDataCaptureCDC) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceMssqlReadChangesUsingChangeDataCaptureCDC) GetInitialWaitingSeconds() *int64 {
	if o == nil {
		return nil
	}
	return o.InitialWaitingSeconds
}

func (o *SourceMssqlReadChangesUsingChangeDataCaptureCDC) GetInvalidCdcCursorPositionBehavior() *SourceMssqlInvalidCDCPositionBehaviorAdvanced {
	if o == nil {
		return nil
	}
	return o.InvalidCdcCursorPositionBehavior
}

func (o *SourceMssqlReadChangesUsingChangeDataCaptureCDC) GetMethod() SourceMssqlMethod {
	return SourceMssqlMethodCdc
}

func (o *SourceMssqlReadChangesUsingChangeDataCaptureCDC) GetQueueSize() *int64 {
	if o == nil {
		return nil
	}
	return o.QueueSize
}

type SourceMssqlUpdateMethodType string

const (
	SourceMssqlUpdateMethodTypeSourceMssqlReadChangesUsingChangeDataCaptureCDC SourceMssqlUpdateMethodType = "source-mssql_Read Changes using Change Data Capture (CDC)"
	SourceMssqlUpdateMethodTypeSourceMssqlScanChangesWithUserDefinedCursor     SourceMssqlUpdateMethodType = "source-mssql_Scan Changes with User Defined Cursor"
)

// SourceMssqlUpdateMethod - Configures how data is extracted from the database.
type SourceMssqlUpdateMethod struct {
	SourceMssqlReadChangesUsingChangeDataCaptureCDC *SourceMssqlReadChangesUsingChangeDataCaptureCDC
	SourceMssqlScanChangesWithUserDefinedCursor     *SourceMssqlScanChangesWithUserDefinedCursor

	Type SourceMssqlUpdateMethodType
}

func CreateSourceMssqlUpdateMethodSourceMssqlReadChangesUsingChangeDataCaptureCDC(sourceMssqlReadChangesUsingChangeDataCaptureCDC SourceMssqlReadChangesUsingChangeDataCaptureCDC) SourceMssqlUpdateMethod {
	typ := SourceMssqlUpdateMethodTypeSourceMssqlReadChangesUsingChangeDataCaptureCDC

	return SourceMssqlUpdateMethod{
		SourceMssqlReadChangesUsingChangeDataCaptureCDC: &sourceMssqlReadChangesUsingChangeDataCaptureCDC,
		Type: typ,
	}
}

func CreateSourceMssqlUpdateMethodSourceMssqlScanChangesWithUserDefinedCursor(sourceMssqlScanChangesWithUserDefinedCursor SourceMssqlScanChangesWithUserDefinedCursor) SourceMssqlUpdateMethod {
	typ := SourceMssqlUpdateMethodTypeSourceMssqlScanChangesWithUserDefinedCursor

	return SourceMssqlUpdateMethod{
		SourceMssqlScanChangesWithUserDefinedCursor: &sourceMssqlScanChangesWithUserDefinedCursor,
		Type: typ,
	}
}

func (u *SourceMssqlUpdateMethod) UnmarshalJSON(data []byte) error {

	var sourceMssqlScanChangesWithUserDefinedCursor SourceMssqlScanChangesWithUserDefinedCursor = SourceMssqlScanChangesWithUserDefinedCursor{}
	if err := utils.UnmarshalJSON(data, &sourceMssqlScanChangesWithUserDefinedCursor, "", true, true); err == nil {
		u.SourceMssqlScanChangesWithUserDefinedCursor = &sourceMssqlScanChangesWithUserDefinedCursor
		u.Type = SourceMssqlUpdateMethodTypeSourceMssqlScanChangesWithUserDefinedCursor
		return nil
	}

	var sourceMssqlReadChangesUsingChangeDataCaptureCDC SourceMssqlReadChangesUsingChangeDataCaptureCDC = SourceMssqlReadChangesUsingChangeDataCaptureCDC{}
	if err := utils.UnmarshalJSON(data, &sourceMssqlReadChangesUsingChangeDataCaptureCDC, "", true, true); err == nil {
		u.SourceMssqlReadChangesUsingChangeDataCaptureCDC = &sourceMssqlReadChangesUsingChangeDataCaptureCDC
		u.Type = SourceMssqlUpdateMethodTypeSourceMssqlReadChangesUsingChangeDataCaptureCDC
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMssqlUpdateMethod", string(data))
}

func (u SourceMssqlUpdateMethod) MarshalJSON() ([]byte, error) {
	if u.SourceMssqlReadChangesUsingChangeDataCaptureCDC != nil {
		return utils.MarshalJSON(u.SourceMssqlReadChangesUsingChangeDataCaptureCDC, "", true)
	}

	if u.SourceMssqlScanChangesWithUserDefinedCursor != nil {
		return utils.MarshalJSON(u.SourceMssqlScanChangesWithUserDefinedCursor, "", true)
	}

	return nil, errors.New("could not marshal union type SourceMssqlUpdateMethod: all fields are null")
}

type SourceMssqlMssql string

const (
	SourceMssqlMssqlMssql SourceMssqlMssql = "mssql"
)

func (e SourceMssqlMssql) ToPointer() *SourceMssqlMssql {
	return &e
}
func (e *SourceMssqlMssql) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "mssql":
		*e = SourceMssqlMssql(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMssqlMssql: %v", v)
	}
}

type SourceMssqlSchemasSSLMethodSSLMethodSSLMethod string

const (
	SourceMssqlSchemasSSLMethodSSLMethodSSLMethodEncryptedVerifyCertificate SourceMssqlSchemasSSLMethodSSLMethodSSLMethod = "encrypted_verify_certificate"
)

func (e SourceMssqlSchemasSSLMethodSSLMethodSSLMethod) ToPointer() *SourceMssqlSchemasSSLMethodSSLMethodSSLMethod {
	return &e
}
func (e *SourceMssqlSchemasSSLMethodSSLMethodSSLMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "encrypted_verify_certificate":
		*e = SourceMssqlSchemasSSLMethodSSLMethodSSLMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMssqlSchemasSSLMethodSSLMethodSSLMethod: %v", v)
	}
}

// SourceMssqlEncryptedVerifyCertificate - Verify and use the certificate provided by the server.
type SourceMssqlEncryptedVerifyCertificate struct {
	// certificate of the server, or of the CA that signed the server certificate
	Certificate *string `json:"certificate,omitempty"`
	// Specifies the host name of the server. The value of this property must match the subject property of the certificate.
	HostNameInCertificate *string                                       `json:"hostNameInCertificate,omitempty"`
	sslMethod             SourceMssqlSchemasSSLMethodSSLMethodSSLMethod `const:"encrypted_verify_certificate" json:"ssl_method"`
}

func (s SourceMssqlEncryptedVerifyCertificate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMssqlEncryptedVerifyCertificate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceMssqlEncryptedVerifyCertificate) GetCertificate() *string {
	if o == nil {
		return nil
	}
	return o.Certificate
}

func (o *SourceMssqlEncryptedVerifyCertificate) GetHostNameInCertificate() *string {
	if o == nil {
		return nil
	}
	return o.HostNameInCertificate
}

func (o *SourceMssqlEncryptedVerifyCertificate) GetSslMethod() SourceMssqlSchemasSSLMethodSSLMethodSSLMethod {
	return SourceMssqlSchemasSSLMethodSSLMethodSSLMethodEncryptedVerifyCertificate
}

type SourceMssqlSchemasSslMethodSslMethod string

const (
	SourceMssqlSchemasSslMethodSslMethodEncryptedTrustServerCertificate SourceMssqlSchemasSslMethodSslMethod = "encrypted_trust_server_certificate"
)

func (e SourceMssqlSchemasSslMethodSslMethod) ToPointer() *SourceMssqlSchemasSslMethodSslMethod {
	return &e
}
func (e *SourceMssqlSchemasSslMethodSslMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "encrypted_trust_server_certificate":
		*e = SourceMssqlSchemasSslMethodSslMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMssqlSchemasSslMethodSslMethod: %v", v)
	}
}

// SourceMssqlEncryptedTrustServerCertificate - Use the certificate provided by the server without verification. (For testing purposes only!)
type SourceMssqlEncryptedTrustServerCertificate struct {
	sslMethod SourceMssqlSchemasSslMethodSslMethod `const:"encrypted_trust_server_certificate" json:"ssl_method"`
}

func (s SourceMssqlEncryptedTrustServerCertificate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMssqlEncryptedTrustServerCertificate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceMssqlEncryptedTrustServerCertificate) GetSslMethod() SourceMssqlSchemasSslMethodSslMethod {
	return SourceMssqlSchemasSslMethodSslMethodEncryptedTrustServerCertificate
}

type SourceMssqlSchemasSslMethod string

const (
	SourceMssqlSchemasSslMethodUnencrypted SourceMssqlSchemasSslMethod = "unencrypted"
)

func (e SourceMssqlSchemasSslMethod) ToPointer() *SourceMssqlSchemasSslMethod {
	return &e
}
func (e *SourceMssqlSchemasSslMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "unencrypted":
		*e = SourceMssqlSchemasSslMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMssqlSchemasSslMethod: %v", v)
	}
}

// SourceMssqlUnencrypted - Data transfer will not be encrypted.
type SourceMssqlUnencrypted struct {
	sslMethod SourceMssqlSchemasSslMethod `const:"unencrypted" json:"ssl_method"`
}

func (s SourceMssqlUnencrypted) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMssqlUnencrypted) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceMssqlUnencrypted) GetSslMethod() SourceMssqlSchemasSslMethod {
	return SourceMssqlSchemasSslMethodUnencrypted
}

type SourceMssqlSSLMethodType string

const (
	SourceMssqlSSLMethodTypeSourceMssqlUnencrypted                     SourceMssqlSSLMethodType = "source-mssql_Unencrypted"
	SourceMssqlSSLMethodTypeSourceMssqlEncryptedTrustServerCertificate SourceMssqlSSLMethodType = "source-mssql_Encrypted (trust server certificate)"
	SourceMssqlSSLMethodTypeSourceMssqlEncryptedVerifyCertificate      SourceMssqlSSLMethodType = "source-mssql_Encrypted (verify certificate)"
)

// SourceMssqlSSLMethod - The encryption method which is used when communicating with the database.
type SourceMssqlSSLMethod struct {
	SourceMssqlUnencrypted                     *SourceMssqlUnencrypted
	SourceMssqlEncryptedTrustServerCertificate *SourceMssqlEncryptedTrustServerCertificate
	SourceMssqlEncryptedVerifyCertificate      *SourceMssqlEncryptedVerifyCertificate

	Type SourceMssqlSSLMethodType
}

func CreateSourceMssqlSSLMethodSourceMssqlUnencrypted(sourceMssqlUnencrypted SourceMssqlUnencrypted) SourceMssqlSSLMethod {
	typ := SourceMssqlSSLMethodTypeSourceMssqlUnencrypted

	return SourceMssqlSSLMethod{
		SourceMssqlUnencrypted: &sourceMssqlUnencrypted,
		Type:                   typ,
	}
}

func CreateSourceMssqlSSLMethodSourceMssqlEncryptedTrustServerCertificate(sourceMssqlEncryptedTrustServerCertificate SourceMssqlEncryptedTrustServerCertificate) SourceMssqlSSLMethod {
	typ := SourceMssqlSSLMethodTypeSourceMssqlEncryptedTrustServerCertificate

	return SourceMssqlSSLMethod{
		SourceMssqlEncryptedTrustServerCertificate: &sourceMssqlEncryptedTrustServerCertificate,
		Type: typ,
	}
}

func CreateSourceMssqlSSLMethodSourceMssqlEncryptedVerifyCertificate(sourceMssqlEncryptedVerifyCertificate SourceMssqlEncryptedVerifyCertificate) SourceMssqlSSLMethod {
	typ := SourceMssqlSSLMethodTypeSourceMssqlEncryptedVerifyCertificate

	return SourceMssqlSSLMethod{
		SourceMssqlEncryptedVerifyCertificate: &sourceMssqlEncryptedVerifyCertificate,
		Type:                                  typ,
	}
}

func (u *SourceMssqlSSLMethod) UnmarshalJSON(data []byte) error {

	var sourceMssqlUnencrypted SourceMssqlUnencrypted = SourceMssqlUnencrypted{}
	if err := utils.UnmarshalJSON(data, &sourceMssqlUnencrypted, "", true, true); err == nil {
		u.SourceMssqlUnencrypted = &sourceMssqlUnencrypted
		u.Type = SourceMssqlSSLMethodTypeSourceMssqlUnencrypted
		return nil
	}

	var sourceMssqlEncryptedTrustServerCertificate SourceMssqlEncryptedTrustServerCertificate = SourceMssqlEncryptedTrustServerCertificate{}
	if err := utils.UnmarshalJSON(data, &sourceMssqlEncryptedTrustServerCertificate, "", true, true); err == nil {
		u.SourceMssqlEncryptedTrustServerCertificate = &sourceMssqlEncryptedTrustServerCertificate
		u.Type = SourceMssqlSSLMethodTypeSourceMssqlEncryptedTrustServerCertificate
		return nil
	}

	var sourceMssqlEncryptedVerifyCertificate SourceMssqlEncryptedVerifyCertificate = SourceMssqlEncryptedVerifyCertificate{}
	if err := utils.UnmarshalJSON(data, &sourceMssqlEncryptedVerifyCertificate, "", true, true); err == nil {
		u.SourceMssqlEncryptedVerifyCertificate = &sourceMssqlEncryptedVerifyCertificate
		u.Type = SourceMssqlSSLMethodTypeSourceMssqlEncryptedVerifyCertificate
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMssqlSSLMethod", string(data))
}

func (u SourceMssqlSSLMethod) MarshalJSON() ([]byte, error) {
	if u.SourceMssqlUnencrypted != nil {
		return utils.MarshalJSON(u.SourceMssqlUnencrypted, "", true)
	}

	if u.SourceMssqlEncryptedTrustServerCertificate != nil {
		return utils.MarshalJSON(u.SourceMssqlEncryptedTrustServerCertificate, "", true)
	}

	if u.SourceMssqlEncryptedVerifyCertificate != nil {
		return utils.MarshalJSON(u.SourceMssqlEncryptedVerifyCertificate, "", true)
	}

	return nil, errors.New("could not marshal union type SourceMssqlSSLMethod: all fields are null")
}

// SourceMssqlSchemasTunnelMethodTunnelMethod - Connect through a jump server tunnel host using username and password authentication
type SourceMssqlSchemasTunnelMethodTunnelMethod string

const (
	SourceMssqlSchemasTunnelMethodTunnelMethodSSHPasswordAuth SourceMssqlSchemasTunnelMethodTunnelMethod = "SSH_PASSWORD_AUTH"
)

func (e SourceMssqlSchemasTunnelMethodTunnelMethod) ToPointer() *SourceMssqlSchemasTunnelMethodTunnelMethod {
	return &e
}
func (e *SourceMssqlSchemasTunnelMethodTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_PASSWORD_AUTH":
		*e = SourceMssqlSchemasTunnelMethodTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMssqlSchemasTunnelMethodTunnelMethod: %v", v)
	}
}

type SourceMssqlPasswordAuthentication struct {
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and password authentication
	tunnelMethod SourceMssqlSchemasTunnelMethodTunnelMethod `const:"SSH_PASSWORD_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser string `json:"tunnel_user"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword string `json:"tunnel_user_password"`
}

func (s SourceMssqlPasswordAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMssqlPasswordAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceMssqlPasswordAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *SourceMssqlPasswordAuthentication) GetTunnelMethod() SourceMssqlSchemasTunnelMethodTunnelMethod {
	return SourceMssqlSchemasTunnelMethodTunnelMethodSSHPasswordAuth
}

func (o *SourceMssqlPasswordAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *SourceMssqlPasswordAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

func (o *SourceMssqlPasswordAuthentication) GetTunnelUserPassword() string {
	if o == nil {
		return ""
	}
	return o.TunnelUserPassword
}

// SourceMssqlSchemasTunnelMethod - Connect through a jump server tunnel host using username and ssh key
type SourceMssqlSchemasTunnelMethod string

const (
	SourceMssqlSchemasTunnelMethodSSHKeyAuth SourceMssqlSchemasTunnelMethod = "SSH_KEY_AUTH"
)

func (e SourceMssqlSchemasTunnelMethod) ToPointer() *SourceMssqlSchemasTunnelMethod {
	return &e
}
func (e *SourceMssqlSchemasTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_KEY_AUTH":
		*e = SourceMssqlSchemasTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMssqlSchemasTunnelMethod: %v", v)
	}
}

type SourceMssqlSSHKeyAuthentication struct {
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey string `json:"ssh_key"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and ssh key
	tunnelMethod SourceMssqlSchemasTunnelMethod `const:"SSH_KEY_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host.
	TunnelUser string `json:"tunnel_user"`
}

func (s SourceMssqlSSHKeyAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMssqlSSHKeyAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceMssqlSSHKeyAuthentication) GetSSHKey() string {
	if o == nil {
		return ""
	}
	return o.SSHKey
}

func (o *SourceMssqlSSHKeyAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *SourceMssqlSSHKeyAuthentication) GetTunnelMethod() SourceMssqlSchemasTunnelMethod {
	return SourceMssqlSchemasTunnelMethodSSHKeyAuth
}

func (o *SourceMssqlSSHKeyAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *SourceMssqlSSHKeyAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

// SourceMssqlTunnelMethod - No ssh tunnel needed to connect to database
type SourceMssqlTunnelMethod string

const (
	SourceMssqlTunnelMethodNoTunnel SourceMssqlTunnelMethod = "NO_TUNNEL"
)

func (e SourceMssqlTunnelMethod) ToPointer() *SourceMssqlTunnelMethod {
	return &e
}
func (e *SourceMssqlTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NO_TUNNEL":
		*e = SourceMssqlTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMssqlTunnelMethod: %v", v)
	}
}

type SourceMssqlNoTunnel struct {
	// No ssh tunnel needed to connect to database
	tunnelMethod SourceMssqlTunnelMethod `const:"NO_TUNNEL" json:"tunnel_method"`
}

func (s SourceMssqlNoTunnel) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMssqlNoTunnel) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceMssqlNoTunnel) GetTunnelMethod() SourceMssqlTunnelMethod {
	return SourceMssqlTunnelMethodNoTunnel
}

type SourceMssqlSSHTunnelMethodType string

const (
	SourceMssqlSSHTunnelMethodTypeSourceMssqlNoTunnel               SourceMssqlSSHTunnelMethodType = "source-mssql_No Tunnel"
	SourceMssqlSSHTunnelMethodTypeSourceMssqlSSHKeyAuthentication   SourceMssqlSSHTunnelMethodType = "source-mssql_SSH Key Authentication"
	SourceMssqlSSHTunnelMethodTypeSourceMssqlPasswordAuthentication SourceMssqlSSHTunnelMethodType = "source-mssql_Password Authentication"
)

// SourceMssqlSSHTunnelMethod - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceMssqlSSHTunnelMethod struct {
	SourceMssqlNoTunnel               *SourceMssqlNoTunnel
	SourceMssqlSSHKeyAuthentication   *SourceMssqlSSHKeyAuthentication
	SourceMssqlPasswordAuthentication *SourceMssqlPasswordAuthentication

	Type SourceMssqlSSHTunnelMethodType
}

func CreateSourceMssqlSSHTunnelMethodSourceMssqlNoTunnel(sourceMssqlNoTunnel SourceMssqlNoTunnel) SourceMssqlSSHTunnelMethod {
	typ := SourceMssqlSSHTunnelMethodTypeSourceMssqlNoTunnel

	return SourceMssqlSSHTunnelMethod{
		SourceMssqlNoTunnel: &sourceMssqlNoTunnel,
		Type:                typ,
	}
}

func CreateSourceMssqlSSHTunnelMethodSourceMssqlSSHKeyAuthentication(sourceMssqlSSHKeyAuthentication SourceMssqlSSHKeyAuthentication) SourceMssqlSSHTunnelMethod {
	typ := SourceMssqlSSHTunnelMethodTypeSourceMssqlSSHKeyAuthentication

	return SourceMssqlSSHTunnelMethod{
		SourceMssqlSSHKeyAuthentication: &sourceMssqlSSHKeyAuthentication,
		Type:                            typ,
	}
}

func CreateSourceMssqlSSHTunnelMethodSourceMssqlPasswordAuthentication(sourceMssqlPasswordAuthentication SourceMssqlPasswordAuthentication) SourceMssqlSSHTunnelMethod {
	typ := SourceMssqlSSHTunnelMethodTypeSourceMssqlPasswordAuthentication

	return SourceMssqlSSHTunnelMethod{
		SourceMssqlPasswordAuthentication: &sourceMssqlPasswordAuthentication,
		Type:                              typ,
	}
}

func (u *SourceMssqlSSHTunnelMethod) UnmarshalJSON(data []byte) error {

	var sourceMssqlNoTunnel SourceMssqlNoTunnel = SourceMssqlNoTunnel{}
	if err := utils.UnmarshalJSON(data, &sourceMssqlNoTunnel, "", true, true); err == nil {
		u.SourceMssqlNoTunnel = &sourceMssqlNoTunnel
		u.Type = SourceMssqlSSHTunnelMethodTypeSourceMssqlNoTunnel
		return nil
	}

	var sourceMssqlSSHKeyAuthentication SourceMssqlSSHKeyAuthentication = SourceMssqlSSHKeyAuthentication{}
	if err := utils.UnmarshalJSON(data, &sourceMssqlSSHKeyAuthentication, "", true, true); err == nil {
		u.SourceMssqlSSHKeyAuthentication = &sourceMssqlSSHKeyAuthentication
		u.Type = SourceMssqlSSHTunnelMethodTypeSourceMssqlSSHKeyAuthentication
		return nil
	}

	var sourceMssqlPasswordAuthentication SourceMssqlPasswordAuthentication = SourceMssqlPasswordAuthentication{}
	if err := utils.UnmarshalJSON(data, &sourceMssqlPasswordAuthentication, "", true, true); err == nil {
		u.SourceMssqlPasswordAuthentication = &sourceMssqlPasswordAuthentication
		u.Type = SourceMssqlSSHTunnelMethodTypeSourceMssqlPasswordAuthentication
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMssqlSSHTunnelMethod", string(data))
}

func (u SourceMssqlSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.SourceMssqlNoTunnel != nil {
		return utils.MarshalJSON(u.SourceMssqlNoTunnel, "", true)
	}

	if u.SourceMssqlSSHKeyAuthentication != nil {
		return utils.MarshalJSON(u.SourceMssqlSSHKeyAuthentication, "", true)
	}

	if u.SourceMssqlPasswordAuthentication != nil {
		return utils.MarshalJSON(u.SourceMssqlPasswordAuthentication, "", true)
	}

	return nil, errors.New("could not marshal union type SourceMssqlSSHTunnelMethod: all fields are null")
}

type SourceMssql struct {
	// The name of the database.
	Database string `json:"database"`
	// The hostname of the database.
	Host string `json:"host"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// The password associated with the username.
	Password string `json:"password"`
	// The port of the database.
	Port int64 `json:"port"`
	// Configures how data is extracted from the database.
	ReplicationMethod *SourceMssqlUpdateMethod `json:"replication_method,omitempty"`
	// The list of schemas to sync from. Defaults to user. Case sensitive.
	Schemas    []string         `json:"schemas,omitempty"`
	sourceType SourceMssqlMssql `const:"mssql" json:"sourceType"`
	// The encryption method which is used when communicating with the database.
	SslMethod *SourceMssqlSSLMethod `json:"ssl_method,omitempty"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod *SourceMssqlSSHTunnelMethod `json:"tunnel_method,omitempty"`
	// The username which is used to access the database.
	Username string `json:"username"`
}

func (s SourceMssql) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMssql) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *SourceMssql) GetDatabase() string {
	if o == nil {
		return ""
	}
	return o.Database
}

func (o *SourceMssql) GetHost() string {
	if o == nil {
		return ""
	}
	return o.Host
}

func (o *SourceMssql) GetJdbcURLParams() *string {
	if o == nil {
		return nil
	}
	return o.JdbcURLParams
}

func (o *SourceMssql) GetPassword() string {
	if o == nil {
		return ""
	}
	return o.Password
}

func (o *SourceMssql) GetPort() int64 {
	if o == nil {
		return 0
	}
	return o.Port
}

func (o *SourceMssql) GetReplicationMethod() *SourceMssqlUpdateMethod {
	if o == nil {
		return nil
	}
	return o.ReplicationMethod
}

func (o *SourceMssql) GetSchemas() []string {
	if o == nil {
		return nil
	}
	return o.Schemas
}

func (o *SourceMssql) GetSourceType() SourceMssqlMssql {
	return SourceMssqlMssqlMssql
}

func (o *SourceMssql) GetSslMethod() *SourceMssqlSSLMethod {
	if o == nil {
		return nil
	}
	return o.SslMethod
}

func (o *SourceMssql) GetTunnelMethod() *SourceMssqlSSHTunnelMethod {
	if o == nil {
		return nil
	}
	return o.TunnelMethod
}

func (o *SourceMssql) GetUsername() string {
	if o == nil {
		return ""
	}
	return o.Username
}
