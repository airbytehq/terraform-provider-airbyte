// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

// SourceMssqlInvalidCDCPositionBehaviorAdvanced - Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value in the mined logs. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss.
type SourceMssqlInvalidCDCPositionBehaviorAdvanced string

const (
	SourceMssqlInvalidCDCPositionBehaviorAdvancedFailSync   SourceMssqlInvalidCDCPositionBehaviorAdvanced = "Fail sync"
	SourceMssqlInvalidCDCPositionBehaviorAdvancedReSyncData SourceMssqlInvalidCDCPositionBehaviorAdvanced = "Re-sync data"
)

func (e SourceMssqlInvalidCDCPositionBehaviorAdvanced) ToPointer() *SourceMssqlInvalidCDCPositionBehaviorAdvanced {
	return &e
}
func (e *SourceMssqlInvalidCDCPositionBehaviorAdvanced) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Fail sync":
		fallthrough
	case "Re-sync data":
		*e = SourceMssqlInvalidCDCPositionBehaviorAdvanced(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMssqlInvalidCDCPositionBehaviorAdvanced: %v", v)
	}
}

type SourceMssqlMethod string

const (
	SourceMssqlMethodCdc SourceMssqlMethod = "CDC"
)

func (e SourceMssqlMethod) ToPointer() *SourceMssqlMethod {
	return &e
}
func (e *SourceMssqlMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CDC":
		*e = SourceMssqlMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMssqlMethod: %v", v)
	}
}

// SourceMssqlReadChangesUsingChangeDataCaptureCDC - <i>Recommended</i> - Incrementally reads new inserts, updates, and deletes using MSSQL's <a href="https://docs.airbyte.com/integrations/sources/mssql/#change-data-capture-cdc"> change data capture feature</a>. This must be enabled on your database.
type SourceMssqlReadChangesUsingChangeDataCaptureCDC struct {
	// The amount of time an initial load is allowed to continue for before catching up on CDC logs.
	InitialLoadTimeoutHours *int64 `default:"8" json:"initial_load_timeout_hours"`
	// The amount of time the connector will wait when it launches to determine if there is new data to sync or not. Defaults to 300 seconds. Valid range: 120 seconds to 3600 seconds. Read about <a href="https://docs.airbyte.com/integrations/sources/mssql#setting-up-cdc-for-mssql">initial waiting time</a>
	InitialWaitingSeconds *int64 `json:"initial_waiting_seconds,omitempty"`
	// Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value in the mined logs. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss.
	InvalidCdcCursorPositionBehavior *SourceMssqlInvalidCDCPositionBehaviorAdvanced `default:"Fail sync" json:"invalid_cdc_cursor_position_behavior"`
	Method                           *SourceMssqlMethod                             `default:"CDC" json:"method"`
	// How often (in milliseconds) Debezium should poll for new data. Must be smaller than heartbeat interval (15000ms). Lower values provide more responsive data capture but may increase database load.
	PollIntervalMs       *int64 `default:"500" json:"poll_interval_ms"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (s SourceMssqlReadChangesUsingChangeDataCaptureCDC) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMssqlReadChangesUsingChangeDataCaptureCDC) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceMssqlReadChangesUsingChangeDataCaptureCDC) GetInitialLoadTimeoutHours() *int64 {
	if s == nil {
		return nil
	}
	return s.InitialLoadTimeoutHours
}

func (s *SourceMssqlReadChangesUsingChangeDataCaptureCDC) GetInitialWaitingSeconds() *int64 {
	if s == nil {
		return nil
	}
	return s.InitialWaitingSeconds
}

func (s *SourceMssqlReadChangesUsingChangeDataCaptureCDC) GetInvalidCdcCursorPositionBehavior() *SourceMssqlInvalidCDCPositionBehaviorAdvanced {
	if s == nil {
		return nil
	}
	return s.InvalidCdcCursorPositionBehavior
}

func (s *SourceMssqlReadChangesUsingChangeDataCaptureCDC) GetMethod() *SourceMssqlMethod {
	if s == nil {
		return nil
	}
	return s.Method
}

func (s *SourceMssqlReadChangesUsingChangeDataCaptureCDC) GetPollIntervalMs() *int64 {
	if s == nil {
		return nil
	}
	return s.PollIntervalMs
}

func (s *SourceMssqlReadChangesUsingChangeDataCaptureCDC) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type Method string

const (
	MethodStandard Method = "STANDARD"
)

func (e Method) ToPointer() *Method {
	return &e
}
func (e *Method) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "STANDARD":
		*e = Method(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Method: %v", v)
	}
}

// SourceMssqlScanChangesWithUserDefinedCursor - Incrementally detects new inserts and updates using the <a href="https://docs.airbyte.com/understanding-airbyte/connections/incremental-append/#user-defined-cursor">cursor column</a> chosen when configuring a connection (e.g. created_at, updated_at).
type SourceMssqlScanChangesWithUserDefinedCursor struct {
	// When enabled incremental syncs using a cursor of a temporal type (date or datetime) will include cursor values only up until the previous midnight UTC
	ExcludeTodaysData    *bool   `default:"false" json:"exclude_todays_data"`
	Method               *Method `default:"STANDARD" json:"method"`
	AdditionalProperties any     `additionalProperties:"true" json:"-"`
}

func (s SourceMssqlScanChangesWithUserDefinedCursor) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMssqlScanChangesWithUserDefinedCursor) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceMssqlScanChangesWithUserDefinedCursor) GetExcludeTodaysData() *bool {
	if s == nil {
		return nil
	}
	return s.ExcludeTodaysData
}

func (s *SourceMssqlScanChangesWithUserDefinedCursor) GetMethod() *Method {
	if s == nil {
		return nil
	}
	return s.Method
}

func (s *SourceMssqlScanChangesWithUserDefinedCursor) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceMssqlUpdateMethodType string

const (
	SourceMssqlUpdateMethodTypeSourceMssqlScanChangesWithUserDefinedCursor     SourceMssqlUpdateMethodType = "source-mssql_Scan Changes with User Defined Cursor"
	SourceMssqlUpdateMethodTypeSourceMssqlReadChangesUsingChangeDataCaptureCDC SourceMssqlUpdateMethodType = "source-mssql_Read Changes using Change Data Capture (CDC)"
)

// SourceMssqlUpdateMethod - Configures how data is extracted from the database.
type SourceMssqlUpdateMethod struct {
	SourceMssqlScanChangesWithUserDefinedCursor     *SourceMssqlScanChangesWithUserDefinedCursor     `queryParam:"inline" union:"member"`
	SourceMssqlReadChangesUsingChangeDataCaptureCDC *SourceMssqlReadChangesUsingChangeDataCaptureCDC `queryParam:"inline" union:"member"`

	Type SourceMssqlUpdateMethodType
}

func CreateSourceMssqlUpdateMethodSourceMssqlScanChangesWithUserDefinedCursor(sourceMssqlScanChangesWithUserDefinedCursor SourceMssqlScanChangesWithUserDefinedCursor) SourceMssqlUpdateMethod {
	typ := SourceMssqlUpdateMethodTypeSourceMssqlScanChangesWithUserDefinedCursor

	return SourceMssqlUpdateMethod{
		SourceMssqlScanChangesWithUserDefinedCursor: &sourceMssqlScanChangesWithUserDefinedCursor,
		Type: typ,
	}
}

func CreateSourceMssqlUpdateMethodSourceMssqlReadChangesUsingChangeDataCaptureCDC(sourceMssqlReadChangesUsingChangeDataCaptureCDC SourceMssqlReadChangesUsingChangeDataCaptureCDC) SourceMssqlUpdateMethod {
	typ := SourceMssqlUpdateMethodTypeSourceMssqlReadChangesUsingChangeDataCaptureCDC

	return SourceMssqlUpdateMethod{
		SourceMssqlReadChangesUsingChangeDataCaptureCDC: &sourceMssqlReadChangesUsingChangeDataCaptureCDC,
		Type: typ,
	}
}

func (u *SourceMssqlUpdateMethod) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var sourceMssqlScanChangesWithUserDefinedCursor SourceMssqlScanChangesWithUserDefinedCursor = SourceMssqlScanChangesWithUserDefinedCursor{}
	if err := utils.UnmarshalJSON(data, &sourceMssqlScanChangesWithUserDefinedCursor, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceMssqlUpdateMethodTypeSourceMssqlScanChangesWithUserDefinedCursor,
			Value: &sourceMssqlScanChangesWithUserDefinedCursor,
		})
	}

	var sourceMssqlReadChangesUsingChangeDataCaptureCDC SourceMssqlReadChangesUsingChangeDataCaptureCDC = SourceMssqlReadChangesUsingChangeDataCaptureCDC{}
	if err := utils.UnmarshalJSON(data, &sourceMssqlReadChangesUsingChangeDataCaptureCDC, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceMssqlUpdateMethodTypeSourceMssqlReadChangesUsingChangeDataCaptureCDC,
			Value: &sourceMssqlReadChangesUsingChangeDataCaptureCDC,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMssqlUpdateMethod", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMssqlUpdateMethod", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceMssqlUpdateMethodType)
	switch best.Type {
	case SourceMssqlUpdateMethodTypeSourceMssqlScanChangesWithUserDefinedCursor:
		u.SourceMssqlScanChangesWithUserDefinedCursor = best.Value.(*SourceMssqlScanChangesWithUserDefinedCursor)
		return nil
	case SourceMssqlUpdateMethodTypeSourceMssqlReadChangesUsingChangeDataCaptureCDC:
		u.SourceMssqlReadChangesUsingChangeDataCaptureCDC = best.Value.(*SourceMssqlReadChangesUsingChangeDataCaptureCDC)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMssqlUpdateMethod", string(data))
}

func (u SourceMssqlUpdateMethod) MarshalJSON() ([]byte, error) {
	if u.SourceMssqlScanChangesWithUserDefinedCursor != nil {
		return utils.MarshalJSON(u.SourceMssqlScanChangesWithUserDefinedCursor, "", true)
	}

	if u.SourceMssqlReadChangesUsingChangeDataCaptureCDC != nil {
		return utils.MarshalJSON(u.SourceMssqlReadChangesUsingChangeDataCaptureCDC, "", true)
	}

	return nil, errors.New("could not marshal union type SourceMssqlUpdateMethod: all fields are null")
}

type SourceMssqlSchemasSslModeMode string

const (
	SourceMssqlSchemasSslModeModeEncryptedVerifyCertificate SourceMssqlSchemasSslModeMode = "encrypted_verify_certificate"
)

func (e SourceMssqlSchemasSslModeMode) ToPointer() *SourceMssqlSchemasSslModeMode {
	return &e
}
func (e *SourceMssqlSchemasSslModeMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "encrypted_verify_certificate":
		*e = SourceMssqlSchemasSslModeMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMssqlSchemasSslModeMode: %v", v)
	}
}

// EncryptedVerifyCertificate - Verify and use the certificate provided by the server.
type EncryptedVerifyCertificate struct {
	// certificate of the server, or of the CA that signed the server certificate
	Certificate *string `json:"certificate,omitempty"`
	// Specifies the host name of the server. The value of this property must match the subject property of the certificate.
	HostNameInCertificate *string                        `json:"hostNameInCertificate,omitempty"`
	Mode                  *SourceMssqlSchemasSslModeMode `default:"encrypted_verify_certificate" json:"mode"`
	AdditionalProperties  any                            `additionalProperties:"true" json:"-"`
}

func (e EncryptedVerifyCertificate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *EncryptedVerifyCertificate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (e *EncryptedVerifyCertificate) GetCertificate() *string {
	if e == nil {
		return nil
	}
	return e.Certificate
}

func (e *EncryptedVerifyCertificate) GetHostNameInCertificate() *string {
	if e == nil {
		return nil
	}
	return e.HostNameInCertificate
}

func (e *EncryptedVerifyCertificate) GetMode() *SourceMssqlSchemasSslModeMode {
	if e == nil {
		return nil
	}
	return e.Mode
}

func (e *EncryptedVerifyCertificate) GetAdditionalProperties() any {
	if e == nil {
		return nil
	}
	return e.AdditionalProperties
}

type SourceMssqlSchemasMode string

const (
	SourceMssqlSchemasModeEncryptedTrustServerCertificate SourceMssqlSchemasMode = "encrypted_trust_server_certificate"
)

func (e SourceMssqlSchemasMode) ToPointer() *SourceMssqlSchemasMode {
	return &e
}
func (e *SourceMssqlSchemasMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "encrypted_trust_server_certificate":
		*e = SourceMssqlSchemasMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMssqlSchemasMode: %v", v)
	}
}

// EncryptedTrustServerCertificate - Use the certificate provided by the server without verification. (For testing purposes only!)
type EncryptedTrustServerCertificate struct {
	Mode                 *SourceMssqlSchemasMode `default:"encrypted_trust_server_certificate" json:"mode"`
	AdditionalProperties any                     `additionalProperties:"true" json:"-"`
}

func (e EncryptedTrustServerCertificate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *EncryptedTrustServerCertificate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (e *EncryptedTrustServerCertificate) GetMode() *SourceMssqlSchemasMode {
	if e == nil {
		return nil
	}
	return e.Mode
}

func (e *EncryptedTrustServerCertificate) GetAdditionalProperties() any {
	if e == nil {
		return nil
	}
	return e.AdditionalProperties
}

type SourceMssqlMode string

const (
	SourceMssqlModeUnencrypted SourceMssqlMode = "unencrypted"
)

func (e SourceMssqlMode) ToPointer() *SourceMssqlMode {
	return &e
}
func (e *SourceMssqlMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "unencrypted":
		*e = SourceMssqlMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMssqlMode: %v", v)
	}
}

// SourceMssqlUnencrypted - Data transfer will not be encrypted.
type SourceMssqlUnencrypted struct {
	Mode                 *SourceMssqlMode `default:"unencrypted" json:"mode"`
	AdditionalProperties any              `additionalProperties:"true" json:"-"`
}

func (s SourceMssqlUnencrypted) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMssqlUnencrypted) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceMssqlUnencrypted) GetMode() *SourceMssqlMode {
	if s == nil {
		return nil
	}
	return s.Mode
}

func (s *SourceMssqlUnencrypted) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceMssqlEncryptionType string

const (
	SourceMssqlEncryptionTypeSourceMssqlUnencrypted          SourceMssqlEncryptionType = "source-mssql_Unencrypted"
	SourceMssqlEncryptionTypeEncryptedTrustServerCertificate SourceMssqlEncryptionType = "Encrypted (trust server certificate)"
	SourceMssqlEncryptionTypeEncryptedVerifyCertificate      SourceMssqlEncryptionType = "Encrypted (verify certificate)"
)

// SourceMssqlEncryption - The encryption method which is used when communicating with the database.
type SourceMssqlEncryption struct {
	SourceMssqlUnencrypted          *SourceMssqlUnencrypted          `queryParam:"inline" union:"member"`
	EncryptedTrustServerCertificate *EncryptedTrustServerCertificate `queryParam:"inline" union:"member"`
	EncryptedVerifyCertificate      *EncryptedVerifyCertificate      `queryParam:"inline" union:"member"`

	Type SourceMssqlEncryptionType
}

func CreateSourceMssqlEncryptionSourceMssqlUnencrypted(sourceMssqlUnencrypted SourceMssqlUnencrypted) SourceMssqlEncryption {
	typ := SourceMssqlEncryptionTypeSourceMssqlUnencrypted

	return SourceMssqlEncryption{
		SourceMssqlUnencrypted: &sourceMssqlUnencrypted,
		Type:                   typ,
	}
}

func CreateSourceMssqlEncryptionEncryptedTrustServerCertificate(encryptedTrustServerCertificate EncryptedTrustServerCertificate) SourceMssqlEncryption {
	typ := SourceMssqlEncryptionTypeEncryptedTrustServerCertificate

	return SourceMssqlEncryption{
		EncryptedTrustServerCertificate: &encryptedTrustServerCertificate,
		Type:                            typ,
	}
}

func CreateSourceMssqlEncryptionEncryptedVerifyCertificate(encryptedVerifyCertificate EncryptedVerifyCertificate) SourceMssqlEncryption {
	typ := SourceMssqlEncryptionTypeEncryptedVerifyCertificate

	return SourceMssqlEncryption{
		EncryptedVerifyCertificate: &encryptedVerifyCertificate,
		Type:                       typ,
	}
}

func (u *SourceMssqlEncryption) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var sourceMssqlUnencrypted SourceMssqlUnencrypted = SourceMssqlUnencrypted{}
	if err := utils.UnmarshalJSON(data, &sourceMssqlUnencrypted, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceMssqlEncryptionTypeSourceMssqlUnencrypted,
			Value: &sourceMssqlUnencrypted,
		})
	}

	var encryptedTrustServerCertificate EncryptedTrustServerCertificate = EncryptedTrustServerCertificate{}
	if err := utils.UnmarshalJSON(data, &encryptedTrustServerCertificate, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceMssqlEncryptionTypeEncryptedTrustServerCertificate,
			Value: &encryptedTrustServerCertificate,
		})
	}

	var encryptedVerifyCertificate EncryptedVerifyCertificate = EncryptedVerifyCertificate{}
	if err := utils.UnmarshalJSON(data, &encryptedVerifyCertificate, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceMssqlEncryptionTypeEncryptedVerifyCertificate,
			Value: &encryptedVerifyCertificate,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMssqlEncryption", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMssqlEncryption", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceMssqlEncryptionType)
	switch best.Type {
	case SourceMssqlEncryptionTypeSourceMssqlUnencrypted:
		u.SourceMssqlUnencrypted = best.Value.(*SourceMssqlUnencrypted)
		return nil
	case SourceMssqlEncryptionTypeEncryptedTrustServerCertificate:
		u.EncryptedTrustServerCertificate = best.Value.(*EncryptedTrustServerCertificate)
		return nil
	case SourceMssqlEncryptionTypeEncryptedVerifyCertificate:
		u.EncryptedVerifyCertificate = best.Value.(*EncryptedVerifyCertificate)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMssqlEncryption", string(data))
}

func (u SourceMssqlEncryption) MarshalJSON() ([]byte, error) {
	if u.SourceMssqlUnencrypted != nil {
		return utils.MarshalJSON(u.SourceMssqlUnencrypted, "", true)
	}

	if u.EncryptedTrustServerCertificate != nil {
		return utils.MarshalJSON(u.EncryptedTrustServerCertificate, "", true)
	}

	if u.EncryptedVerifyCertificate != nil {
		return utils.MarshalJSON(u.EncryptedVerifyCertificate, "", true)
	}

	return nil, errors.New("could not marshal union type SourceMssqlEncryption: all fields are null")
}

type SourceMssqlSchemasTunnelMethodTunnelMethod string

const (
	SourceMssqlSchemasTunnelMethodTunnelMethodSSHPasswordAuth SourceMssqlSchemasTunnelMethodTunnelMethod = "SSH_PASSWORD_AUTH"
)

func (e SourceMssqlSchemasTunnelMethodTunnelMethod) ToPointer() *SourceMssqlSchemasTunnelMethodTunnelMethod {
	return &e
}
func (e *SourceMssqlSchemasTunnelMethodTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_PASSWORD_AUTH":
		*e = SourceMssqlSchemasTunnelMethodTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMssqlSchemasTunnelMethodTunnelMethod: %v", v)
	}
}

// SourceMssqlPasswordAuthentication - Connect through a jump server tunnel host using username and password authentication
type SourceMssqlPasswordAuthentication struct {
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost   string                                      `json:"tunnel_host"`
	TunnelMethod *SourceMssqlSchemasTunnelMethodTunnelMethod `default:"SSH_PASSWORD_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser string `json:"tunnel_user"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword   string `json:"tunnel_user_password"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (s SourceMssqlPasswordAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMssqlPasswordAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceMssqlPasswordAuthentication) GetTunnelHost() string {
	if s == nil {
		return ""
	}
	return s.TunnelHost
}

func (s *SourceMssqlPasswordAuthentication) GetTunnelMethod() *SourceMssqlSchemasTunnelMethodTunnelMethod {
	if s == nil {
		return nil
	}
	return s.TunnelMethod
}

func (s *SourceMssqlPasswordAuthentication) GetTunnelPort() *int64 {
	if s == nil {
		return nil
	}
	return s.TunnelPort
}

func (s *SourceMssqlPasswordAuthentication) GetTunnelUser() string {
	if s == nil {
		return ""
	}
	return s.TunnelUser
}

func (s *SourceMssqlPasswordAuthentication) GetTunnelUserPassword() string {
	if s == nil {
		return ""
	}
	return s.TunnelUserPassword
}

func (s *SourceMssqlPasswordAuthentication) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceMssqlSchemasTunnelMethod string

const (
	SourceMssqlSchemasTunnelMethodSSHKeyAuth SourceMssqlSchemasTunnelMethod = "SSH_KEY_AUTH"
)

func (e SourceMssqlSchemasTunnelMethod) ToPointer() *SourceMssqlSchemasTunnelMethod {
	return &e
}
func (e *SourceMssqlSchemasTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_KEY_AUTH":
		*e = SourceMssqlSchemasTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMssqlSchemasTunnelMethod: %v", v)
	}
}

// SourceMssqlSSHKeyAuthentication - Connect through a jump server tunnel host using username and ssh key
type SourceMssqlSSHKeyAuthentication struct {
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey string `json:"ssh_key"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost   string                          `json:"tunnel_host"`
	TunnelMethod *SourceMssqlSchemasTunnelMethod `default:"SSH_KEY_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser           string `json:"tunnel_user"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (s SourceMssqlSSHKeyAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMssqlSSHKeyAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceMssqlSSHKeyAuthentication) GetSSHKey() string {
	if s == nil {
		return ""
	}
	return s.SSHKey
}

func (s *SourceMssqlSSHKeyAuthentication) GetTunnelHost() string {
	if s == nil {
		return ""
	}
	return s.TunnelHost
}

func (s *SourceMssqlSSHKeyAuthentication) GetTunnelMethod() *SourceMssqlSchemasTunnelMethod {
	if s == nil {
		return nil
	}
	return s.TunnelMethod
}

func (s *SourceMssqlSSHKeyAuthentication) GetTunnelPort() *int64 {
	if s == nil {
		return nil
	}
	return s.TunnelPort
}

func (s *SourceMssqlSSHKeyAuthentication) GetTunnelUser() string {
	if s == nil {
		return ""
	}
	return s.TunnelUser
}

func (s *SourceMssqlSSHKeyAuthentication) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceMssqlTunnelMethod string

const (
	SourceMssqlTunnelMethodNoTunnel SourceMssqlTunnelMethod = "NO_TUNNEL"
)

func (e SourceMssqlTunnelMethod) ToPointer() *SourceMssqlTunnelMethod {
	return &e
}
func (e *SourceMssqlTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NO_TUNNEL":
		*e = SourceMssqlTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMssqlTunnelMethod: %v", v)
	}
}

// SourceMssqlNoTunnel - No ssh tunnel needed to connect to database
type SourceMssqlNoTunnel struct {
	TunnelMethod         *SourceMssqlTunnelMethod `default:"NO_TUNNEL" json:"tunnel_method"`
	AdditionalProperties any                      `additionalProperties:"true" json:"-"`
}

func (s SourceMssqlNoTunnel) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMssqlNoTunnel) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceMssqlNoTunnel) GetTunnelMethod() *SourceMssqlTunnelMethod {
	if s == nil {
		return nil
	}
	return s.TunnelMethod
}

func (s *SourceMssqlNoTunnel) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceMssqlSSHTunnelMethodType string

const (
	SourceMssqlSSHTunnelMethodTypeSourceMssqlNoTunnel               SourceMssqlSSHTunnelMethodType = "source-mssql_No Tunnel"
	SourceMssqlSSHTunnelMethodTypeSourceMssqlSSHKeyAuthentication   SourceMssqlSSHTunnelMethodType = "source-mssql_SSH Key Authentication"
	SourceMssqlSSHTunnelMethodTypeSourceMssqlPasswordAuthentication SourceMssqlSSHTunnelMethodType = "source-mssql_Password Authentication"
)

// SourceMssqlSSHTunnelMethod - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceMssqlSSHTunnelMethod struct {
	SourceMssqlNoTunnel               *SourceMssqlNoTunnel               `queryParam:"inline" union:"member"`
	SourceMssqlSSHKeyAuthentication   *SourceMssqlSSHKeyAuthentication   `queryParam:"inline" union:"member"`
	SourceMssqlPasswordAuthentication *SourceMssqlPasswordAuthentication `queryParam:"inline" union:"member"`

	Type SourceMssqlSSHTunnelMethodType
}

func CreateSourceMssqlSSHTunnelMethodSourceMssqlNoTunnel(sourceMssqlNoTunnel SourceMssqlNoTunnel) SourceMssqlSSHTunnelMethod {
	typ := SourceMssqlSSHTunnelMethodTypeSourceMssqlNoTunnel

	return SourceMssqlSSHTunnelMethod{
		SourceMssqlNoTunnel: &sourceMssqlNoTunnel,
		Type:                typ,
	}
}

func CreateSourceMssqlSSHTunnelMethodSourceMssqlSSHKeyAuthentication(sourceMssqlSSHKeyAuthentication SourceMssqlSSHKeyAuthentication) SourceMssqlSSHTunnelMethod {
	typ := SourceMssqlSSHTunnelMethodTypeSourceMssqlSSHKeyAuthentication

	return SourceMssqlSSHTunnelMethod{
		SourceMssqlSSHKeyAuthentication: &sourceMssqlSSHKeyAuthentication,
		Type:                            typ,
	}
}

func CreateSourceMssqlSSHTunnelMethodSourceMssqlPasswordAuthentication(sourceMssqlPasswordAuthentication SourceMssqlPasswordAuthentication) SourceMssqlSSHTunnelMethod {
	typ := SourceMssqlSSHTunnelMethodTypeSourceMssqlPasswordAuthentication

	return SourceMssqlSSHTunnelMethod{
		SourceMssqlPasswordAuthentication: &sourceMssqlPasswordAuthentication,
		Type:                              typ,
	}
}

func (u *SourceMssqlSSHTunnelMethod) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var sourceMssqlNoTunnel SourceMssqlNoTunnel = SourceMssqlNoTunnel{}
	if err := utils.UnmarshalJSON(data, &sourceMssqlNoTunnel, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceMssqlSSHTunnelMethodTypeSourceMssqlNoTunnel,
			Value: &sourceMssqlNoTunnel,
		})
	}

	var sourceMssqlSSHKeyAuthentication SourceMssqlSSHKeyAuthentication = SourceMssqlSSHKeyAuthentication{}
	if err := utils.UnmarshalJSON(data, &sourceMssqlSSHKeyAuthentication, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceMssqlSSHTunnelMethodTypeSourceMssqlSSHKeyAuthentication,
			Value: &sourceMssqlSSHKeyAuthentication,
		})
	}

	var sourceMssqlPasswordAuthentication SourceMssqlPasswordAuthentication = SourceMssqlPasswordAuthentication{}
	if err := utils.UnmarshalJSON(data, &sourceMssqlPasswordAuthentication, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceMssqlSSHTunnelMethodTypeSourceMssqlPasswordAuthentication,
			Value: &sourceMssqlPasswordAuthentication,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMssqlSSHTunnelMethod", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMssqlSSHTunnelMethod", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceMssqlSSHTunnelMethodType)
	switch best.Type {
	case SourceMssqlSSHTunnelMethodTypeSourceMssqlNoTunnel:
		u.SourceMssqlNoTunnel = best.Value.(*SourceMssqlNoTunnel)
		return nil
	case SourceMssqlSSHTunnelMethodTypeSourceMssqlSSHKeyAuthentication:
		u.SourceMssqlSSHKeyAuthentication = best.Value.(*SourceMssqlSSHKeyAuthentication)
		return nil
	case SourceMssqlSSHTunnelMethodTypeSourceMssqlPasswordAuthentication:
		u.SourceMssqlPasswordAuthentication = best.Value.(*SourceMssqlPasswordAuthentication)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMssqlSSHTunnelMethod", string(data))
}

func (u SourceMssqlSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.SourceMssqlNoTunnel != nil {
		return utils.MarshalJSON(u.SourceMssqlNoTunnel, "", true)
	}

	if u.SourceMssqlSSHKeyAuthentication != nil {
		return utils.MarshalJSON(u.SourceMssqlSSHKeyAuthentication, "", true)
	}

	if u.SourceMssqlPasswordAuthentication != nil {
		return utils.MarshalJSON(u.SourceMssqlPasswordAuthentication, "", true)
	}

	return nil, errors.New("could not marshal union type SourceMssqlSSHTunnelMethod: all fields are null")
}

type SourceMssqlSourceType string

const (
	SourceMssqlSourceTypeMssql SourceMssqlSourceType = "mssql"
)

func (e SourceMssqlSourceType) ToPointer() *SourceMssqlSourceType {
	return &e
}
func (e *SourceMssqlSourceType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "mssql":
		*e = SourceMssqlSourceType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMssqlSourceType: %v", v)
	}
}

type SourceMssql struct {
	AdditionalProperties map[string]map[string]any `json:"additionalProperties"`
	// When this feature is enabled, during schema discovery the connector will query each table or view individually to check access privileges and inaccessible tables, views, or columns therein will be removed. In large schemas, this might cause schema discovery to take too long, in which case it might be advisable to disable this feature.
	CheckPrivileges *bool `default:"true" json:"check_privileges"`
	// How often (in seconds) a stream should checkpoint, when possible.
	CheckpointTargetIntervalSeconds *int64 `default:"300" json:"checkpoint_target_interval_seconds"`
	// Maximum number of concurrent queries to the database.
	Concurrency *int64 `json:"concurrency,omitempty"`
	// The name of the database.
	Database string `json:"database"`
	// The hostname of the database.
	Host string `json:"host"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// The password associated with the username.
	Password string `json:"password"`
	// The port of the database.
	Port *int64 `default:"1433" json:"port"`
	// Configures how data is extracted from the database.
	ReplicationMethod SourceMssqlUpdateMethod `json:"replication_method"`
	// The list of schemas to sync from. If not specified, all schemas will be discovered. Case sensitive.
	Schemas []string `json:"schemas,omitempty"`
	// The encryption method which is used when communicating with the database.
	SslMode *SourceMssqlEncryption `json:"ssl_mode,omitempty"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod *SourceMssqlSSHTunnelMethod `json:"tunnel_method,omitempty"`
	// The username which is used to access the database.
	Username              string                 `json:"username"`
	sourceType            *SourceMssqlSourceType `const:"mssql" json:"sourceType"`
	AdditionalProperties1 any                    `additionalProperties:"true" json:"-"`
}

func (s SourceMssql) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMssql) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceMssql) GetAdditionalProperties() map[string]map[string]any {
	if s == nil {
		return map[string]map[string]any{}
	}
	return s.AdditionalProperties
}

func (s *SourceMssql) GetCheckPrivileges() *bool {
	if s == nil {
		return nil
	}
	return s.CheckPrivileges
}

func (s *SourceMssql) GetCheckpointTargetIntervalSeconds() *int64 {
	if s == nil {
		return nil
	}
	return s.CheckpointTargetIntervalSeconds
}

func (s *SourceMssql) GetConcurrency() *int64 {
	if s == nil {
		return nil
	}
	return s.Concurrency
}

func (s *SourceMssql) GetDatabase() string {
	if s == nil {
		return ""
	}
	return s.Database
}

func (s *SourceMssql) GetHost() string {
	if s == nil {
		return ""
	}
	return s.Host
}

func (s *SourceMssql) GetJdbcURLParams() *string {
	if s == nil {
		return nil
	}
	return s.JdbcURLParams
}

func (s *SourceMssql) GetPassword() string {
	if s == nil {
		return ""
	}
	return s.Password
}

func (s *SourceMssql) GetPort() *int64 {
	if s == nil {
		return nil
	}
	return s.Port
}

func (s *SourceMssql) GetReplicationMethod() SourceMssqlUpdateMethod {
	if s == nil {
		return SourceMssqlUpdateMethod{}
	}
	return s.ReplicationMethod
}

func (s *SourceMssql) GetSchemas() []string {
	if s == nil {
		return nil
	}
	return s.Schemas
}

func (s *SourceMssql) GetSslMode() *SourceMssqlEncryption {
	if s == nil {
		return nil
	}
	return s.SslMode
}

func (s *SourceMssql) GetTunnelMethod() *SourceMssqlSSHTunnelMethod {
	if s == nil {
		return nil
	}
	return s.TunnelMethod
}

func (s *SourceMssql) GetUsername() string {
	if s == nil {
		return ""
	}
	return s.Username
}

func (s *SourceMssql) GetSourceType() *SourceMssqlSourceType {
	return SourceMssqlSourceTypeMssql.ToPointer()
}

func (s *SourceMssql) GetAdditionalProperties1() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties1
}
