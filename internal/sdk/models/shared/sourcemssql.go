// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

type SourceMssqlSchemasMethod string

const (
	SourceMssqlSchemasMethodStandard SourceMssqlSchemasMethod = "STANDARD"
)

func (e SourceMssqlSchemasMethod) ToPointer() *SourceMssqlSchemasMethod {
	return &e
}
func (e *SourceMssqlSchemasMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "STANDARD":
		*e = SourceMssqlSchemasMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMssqlSchemasMethod: %v", v)
	}
}

// ScanChangesWithUserDefinedCursor - Incrementally detects new inserts and updates using the <a href="https://docs.airbyte.com/understanding-airbyte/connections/incremental-append/#user-defined-cursor">cursor column</a> chosen when configuring a connection (e.g. created_at, updated_at).
type ScanChangesWithUserDefinedCursor struct {
	method SourceMssqlSchemasMethod `const:"STANDARD" json:"method"`
}

func (s ScanChangesWithUserDefinedCursor) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *ScanChangesWithUserDefinedCursor) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *ScanChangesWithUserDefinedCursor) GetMethod() SourceMssqlSchemasMethod {
	return SourceMssqlSchemasMethodStandard
}

// SourceMssqlInvalidCDCPositionBehaviorAdvanced - Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value into the WAL. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss.
type SourceMssqlInvalidCDCPositionBehaviorAdvanced string

const (
	SourceMssqlInvalidCDCPositionBehaviorAdvancedFailSync   SourceMssqlInvalidCDCPositionBehaviorAdvanced = "Fail sync"
	SourceMssqlInvalidCDCPositionBehaviorAdvancedReSyncData SourceMssqlInvalidCDCPositionBehaviorAdvanced = "Re-sync data"
)

func (e SourceMssqlInvalidCDCPositionBehaviorAdvanced) ToPointer() *SourceMssqlInvalidCDCPositionBehaviorAdvanced {
	return &e
}
func (e *SourceMssqlInvalidCDCPositionBehaviorAdvanced) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Fail sync":
		fallthrough
	case "Re-sync data":
		*e = SourceMssqlInvalidCDCPositionBehaviorAdvanced(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMssqlInvalidCDCPositionBehaviorAdvanced: %v", v)
	}
}

type SourceMssqlMethod string

const (
	SourceMssqlMethodCdc SourceMssqlMethod = "CDC"
)

func (e SourceMssqlMethod) ToPointer() *SourceMssqlMethod {
	return &e
}
func (e *SourceMssqlMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CDC":
		*e = SourceMssqlMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMssqlMethod: %v", v)
	}
}

// ReadChangesUsingChangeDataCaptureCDC - <i>Recommended</i> - Incrementally reads new inserts, updates, and deletes using the SQL Server's <a href="https://docs.airbyte.com/integrations/sources/mssql/#change-data-capture-cdc">change data capture feature</a>. This must be enabled on your database.
type ReadChangesUsingChangeDataCaptureCDC struct {
	// The amount of time an initial load is allowed to continue for before catching up on CDC logs.
	InitialLoadTimeoutHours *int64 `default:"8" json:"initial_load_timeout_hours"`
	// The amount of time the connector will wait when it launches to determine if there is new data to sync or not. Defaults to 300 seconds. Valid range: 120 seconds to 3600 seconds. Read about <a href="https://docs.airbyte.com/integrations/sources/mysql/#change-data-capture-cdc">initial waiting time</a>.
	InitialWaitingSeconds *int64 `default:"300" json:"initial_waiting_seconds"`
	// Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value into the WAL. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss.
	InvalidCdcCursorPositionBehavior *SourceMssqlInvalidCDCPositionBehaviorAdvanced `default:"Fail sync" json:"invalid_cdc_cursor_position_behavior"`
	method                           SourceMssqlMethod                              `const:"CDC" json:"method"`
	// The size of the internal queue. This may interfere with memory consumption and efficiency of the connector, please be careful.
	QueueSize *int64 `default:"10000" json:"queue_size"`
}

func (r ReadChangesUsingChangeDataCaptureCDC) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(r, "", false)
}

func (r *ReadChangesUsingChangeDataCaptureCDC) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &r, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *ReadChangesUsingChangeDataCaptureCDC) GetInitialLoadTimeoutHours() *int64 {
	if o == nil {
		return nil
	}
	return o.InitialLoadTimeoutHours
}

func (o *ReadChangesUsingChangeDataCaptureCDC) GetInitialWaitingSeconds() *int64 {
	if o == nil {
		return nil
	}
	return o.InitialWaitingSeconds
}

func (o *ReadChangesUsingChangeDataCaptureCDC) GetInvalidCdcCursorPositionBehavior() *SourceMssqlInvalidCDCPositionBehaviorAdvanced {
	if o == nil {
		return nil
	}
	return o.InvalidCdcCursorPositionBehavior
}

func (o *ReadChangesUsingChangeDataCaptureCDC) GetMethod() SourceMssqlMethod {
	return SourceMssqlMethodCdc
}

func (o *ReadChangesUsingChangeDataCaptureCDC) GetQueueSize() *int64 {
	if o == nil {
		return nil
	}
	return o.QueueSize
}

type UpdateMethodType string

const (
	UpdateMethodTypeReadChangesUsingChangeDataCaptureCDC UpdateMethodType = "Read Changes using Change Data Capture (CDC)"
	UpdateMethodTypeScanChangesWithUserDefinedCursor     UpdateMethodType = "Scan Changes with User Defined Cursor"
)

// UpdateMethod - Configures how data is extracted from the database.
type UpdateMethod struct {
	ReadChangesUsingChangeDataCaptureCDC *ReadChangesUsingChangeDataCaptureCDC `queryParam:"inline"`
	ScanChangesWithUserDefinedCursor     *ScanChangesWithUserDefinedCursor     `queryParam:"inline"`

	Type UpdateMethodType
}

func CreateUpdateMethodReadChangesUsingChangeDataCaptureCDC(readChangesUsingChangeDataCaptureCDC ReadChangesUsingChangeDataCaptureCDC) UpdateMethod {
	typ := UpdateMethodTypeReadChangesUsingChangeDataCaptureCDC

	return UpdateMethod{
		ReadChangesUsingChangeDataCaptureCDC: &readChangesUsingChangeDataCaptureCDC,
		Type:                                 typ,
	}
}

func CreateUpdateMethodScanChangesWithUserDefinedCursor(scanChangesWithUserDefinedCursor ScanChangesWithUserDefinedCursor) UpdateMethod {
	typ := UpdateMethodTypeScanChangesWithUserDefinedCursor

	return UpdateMethod{
		ScanChangesWithUserDefinedCursor: &scanChangesWithUserDefinedCursor,
		Type:                             typ,
	}
}

func (u *UpdateMethod) UnmarshalJSON(data []byte) error {

	var scanChangesWithUserDefinedCursor ScanChangesWithUserDefinedCursor = ScanChangesWithUserDefinedCursor{}
	if err := utils.UnmarshalJSON(data, &scanChangesWithUserDefinedCursor, "", true, true); err == nil {
		u.ScanChangesWithUserDefinedCursor = &scanChangesWithUserDefinedCursor
		u.Type = UpdateMethodTypeScanChangesWithUserDefinedCursor
		return nil
	}

	var readChangesUsingChangeDataCaptureCDC ReadChangesUsingChangeDataCaptureCDC = ReadChangesUsingChangeDataCaptureCDC{}
	if err := utils.UnmarshalJSON(data, &readChangesUsingChangeDataCaptureCDC, "", true, true); err == nil {
		u.ReadChangesUsingChangeDataCaptureCDC = &readChangesUsingChangeDataCaptureCDC
		u.Type = UpdateMethodTypeReadChangesUsingChangeDataCaptureCDC
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for UpdateMethod", string(data))
}

func (u UpdateMethod) MarshalJSON() ([]byte, error) {
	if u.ReadChangesUsingChangeDataCaptureCDC != nil {
		return utils.MarshalJSON(u.ReadChangesUsingChangeDataCaptureCDC, "", true)
	}

	if u.ScanChangesWithUserDefinedCursor != nil {
		return utils.MarshalJSON(u.ScanChangesWithUserDefinedCursor, "", true)
	}

	return nil, errors.New("could not marshal union type UpdateMethod: all fields are null")
}

type SourceMssqlSchemasSslMethod string

const (
	SourceMssqlSchemasSslMethodEncryptedVerifyCertificate SourceMssqlSchemasSslMethod = "encrypted_verify_certificate"
)

func (e SourceMssqlSchemasSslMethod) ToPointer() *SourceMssqlSchemasSslMethod {
	return &e
}
func (e *SourceMssqlSchemasSslMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "encrypted_verify_certificate":
		*e = SourceMssqlSchemasSslMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMssqlSchemasSslMethod: %v", v)
	}
}

// EncryptedVerifyCertificate - Verify and use the certificate provided by the server.
type EncryptedVerifyCertificate struct {
	// certificate of the server, or of the CA that signed the server certificate
	Certificate *string `json:"certificate,omitempty"`
	// Specifies the host name of the server. The value of this property must match the subject property of the certificate.
	HostNameInCertificate *string                     `json:"hostNameInCertificate,omitempty"`
	sslMethod             SourceMssqlSchemasSslMethod `const:"encrypted_verify_certificate" json:"ssl_method"`
}

func (e EncryptedVerifyCertificate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *EncryptedVerifyCertificate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *EncryptedVerifyCertificate) GetCertificate() *string {
	if o == nil {
		return nil
	}
	return o.Certificate
}

func (o *EncryptedVerifyCertificate) GetHostNameInCertificate() *string {
	if o == nil {
		return nil
	}
	return o.HostNameInCertificate
}

func (o *EncryptedVerifyCertificate) GetSslMethod() SourceMssqlSchemasSslMethod {
	return SourceMssqlSchemasSslMethodEncryptedVerifyCertificate
}

type SourceMssqlSslMethod string

const (
	SourceMssqlSslMethodEncryptedTrustServerCertificate SourceMssqlSslMethod = "encrypted_trust_server_certificate"
)

func (e SourceMssqlSslMethod) ToPointer() *SourceMssqlSslMethod {
	return &e
}
func (e *SourceMssqlSslMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "encrypted_trust_server_certificate":
		*e = SourceMssqlSslMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMssqlSslMethod: %v", v)
	}
}

// EncryptedTrustServerCertificate - Use the certificate provided by the server without verification. (For testing purposes only!)
type EncryptedTrustServerCertificate struct {
	sslMethod SourceMssqlSslMethod `const:"encrypted_trust_server_certificate" json:"ssl_method"`
}

func (e EncryptedTrustServerCertificate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *EncryptedTrustServerCertificate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *EncryptedTrustServerCertificate) GetSslMethod() SourceMssqlSslMethod {
	return SourceMssqlSslMethodEncryptedTrustServerCertificate
}

type SourceMssqlSchemasSslMethodSslMethod string

const (
	SourceMssqlSchemasSslMethodSslMethodUnencrypted SourceMssqlSchemasSslMethodSslMethod = "unencrypted"
)

func (e SourceMssqlSchemasSslMethodSslMethod) ToPointer() *SourceMssqlSchemasSslMethodSslMethod {
	return &e
}
func (e *SourceMssqlSchemasSslMethodSslMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "unencrypted":
		*e = SourceMssqlSchemasSslMethodSslMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMssqlSchemasSslMethodSslMethod: %v", v)
	}
}

// Unencrypted - Data transfer will not be encrypted.
type Unencrypted struct {
	sslMethod SourceMssqlSchemasSslMethodSslMethod `const:"unencrypted" json:"ssl_method"`
}

func (u Unencrypted) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(u, "", false)
}

func (u *Unencrypted) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &u, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *Unencrypted) GetSslMethod() SourceMssqlSchemasSslMethodSslMethod {
	return SourceMssqlSchemasSslMethodSslMethodUnencrypted
}

type SSLMethodType string

const (
	SSLMethodTypeUnencrypted                     SSLMethodType = "Unencrypted"
	SSLMethodTypeEncryptedTrustServerCertificate SSLMethodType = "Encrypted (trust server certificate)"
	SSLMethodTypeEncryptedVerifyCertificate      SSLMethodType = "Encrypted (verify certificate)"
)

// SSLMethod - The encryption method which is used when communicating with the database.
type SSLMethod struct {
	Unencrypted                     *Unencrypted                     `queryParam:"inline"`
	EncryptedTrustServerCertificate *EncryptedTrustServerCertificate `queryParam:"inline"`
	EncryptedVerifyCertificate      *EncryptedVerifyCertificate      `queryParam:"inline"`

	Type SSLMethodType
}

func CreateSSLMethodUnencrypted(unencrypted Unencrypted) SSLMethod {
	typ := SSLMethodTypeUnencrypted

	return SSLMethod{
		Unencrypted: &unencrypted,
		Type:        typ,
	}
}

func CreateSSLMethodEncryptedTrustServerCertificate(encryptedTrustServerCertificate EncryptedTrustServerCertificate) SSLMethod {
	typ := SSLMethodTypeEncryptedTrustServerCertificate

	return SSLMethod{
		EncryptedTrustServerCertificate: &encryptedTrustServerCertificate,
		Type:                            typ,
	}
}

func CreateSSLMethodEncryptedVerifyCertificate(encryptedVerifyCertificate EncryptedVerifyCertificate) SSLMethod {
	typ := SSLMethodTypeEncryptedVerifyCertificate

	return SSLMethod{
		EncryptedVerifyCertificate: &encryptedVerifyCertificate,
		Type:                       typ,
	}
}

func (u *SSLMethod) UnmarshalJSON(data []byte) error {

	var unencrypted Unencrypted = Unencrypted{}
	if err := utils.UnmarshalJSON(data, &unencrypted, "", true, true); err == nil {
		u.Unencrypted = &unencrypted
		u.Type = SSLMethodTypeUnencrypted
		return nil
	}

	var encryptedTrustServerCertificate EncryptedTrustServerCertificate = EncryptedTrustServerCertificate{}
	if err := utils.UnmarshalJSON(data, &encryptedTrustServerCertificate, "", true, true); err == nil {
		u.EncryptedTrustServerCertificate = &encryptedTrustServerCertificate
		u.Type = SSLMethodTypeEncryptedTrustServerCertificate
		return nil
	}

	var encryptedVerifyCertificate EncryptedVerifyCertificate = EncryptedVerifyCertificate{}
	if err := utils.UnmarshalJSON(data, &encryptedVerifyCertificate, "", true, true); err == nil {
		u.EncryptedVerifyCertificate = &encryptedVerifyCertificate
		u.Type = SSLMethodTypeEncryptedVerifyCertificate
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SSLMethod", string(data))
}

func (u SSLMethod) MarshalJSON() ([]byte, error) {
	if u.Unencrypted != nil {
		return utils.MarshalJSON(u.Unencrypted, "", true)
	}

	if u.EncryptedTrustServerCertificate != nil {
		return utils.MarshalJSON(u.EncryptedTrustServerCertificate, "", true)
	}

	if u.EncryptedVerifyCertificate != nil {
		return utils.MarshalJSON(u.EncryptedVerifyCertificate, "", true)
	}

	return nil, errors.New("could not marshal union type SSLMethod: all fields are null")
}

// SourceMssqlSchemasTunnelMethodTunnelMethod - Connect through a jump server tunnel host using username and password authentication
type SourceMssqlSchemasTunnelMethodTunnelMethod string

const (
	SourceMssqlSchemasTunnelMethodTunnelMethodSSHPasswordAuth SourceMssqlSchemasTunnelMethodTunnelMethod = "SSH_PASSWORD_AUTH"
)

func (e SourceMssqlSchemasTunnelMethodTunnelMethod) ToPointer() *SourceMssqlSchemasTunnelMethodTunnelMethod {
	return &e
}
func (e *SourceMssqlSchemasTunnelMethodTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_PASSWORD_AUTH":
		*e = SourceMssqlSchemasTunnelMethodTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMssqlSchemasTunnelMethodTunnelMethod: %v", v)
	}
}

type SourceMssqlPasswordAuthentication struct {
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and password authentication
	tunnelMethod SourceMssqlSchemasTunnelMethodTunnelMethod `const:"SSH_PASSWORD_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser string `json:"tunnel_user"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword string `json:"tunnel_user_password"`
}

func (s SourceMssqlPasswordAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMssqlPasswordAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceMssqlPasswordAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *SourceMssqlPasswordAuthentication) GetTunnelMethod() SourceMssqlSchemasTunnelMethodTunnelMethod {
	return SourceMssqlSchemasTunnelMethodTunnelMethodSSHPasswordAuth
}

func (o *SourceMssqlPasswordAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *SourceMssqlPasswordAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

func (o *SourceMssqlPasswordAuthentication) GetTunnelUserPassword() string {
	if o == nil {
		return ""
	}
	return o.TunnelUserPassword
}

// SourceMssqlSchemasTunnelMethod - Connect through a jump server tunnel host using username and ssh key
type SourceMssqlSchemasTunnelMethod string

const (
	SourceMssqlSchemasTunnelMethodSSHKeyAuth SourceMssqlSchemasTunnelMethod = "SSH_KEY_AUTH"
)

func (e SourceMssqlSchemasTunnelMethod) ToPointer() *SourceMssqlSchemasTunnelMethod {
	return &e
}
func (e *SourceMssqlSchemasTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_KEY_AUTH":
		*e = SourceMssqlSchemasTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMssqlSchemasTunnelMethod: %v", v)
	}
}

type SourceMssqlSSHKeyAuthentication struct {
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey string `json:"ssh_key"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and ssh key
	tunnelMethod SourceMssqlSchemasTunnelMethod `const:"SSH_KEY_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host.
	TunnelUser string `json:"tunnel_user"`
}

func (s SourceMssqlSSHKeyAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMssqlSSHKeyAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceMssqlSSHKeyAuthentication) GetSSHKey() string {
	if o == nil {
		return ""
	}
	return o.SSHKey
}

func (o *SourceMssqlSSHKeyAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *SourceMssqlSSHKeyAuthentication) GetTunnelMethod() SourceMssqlSchemasTunnelMethod {
	return SourceMssqlSchemasTunnelMethodSSHKeyAuth
}

func (o *SourceMssqlSSHKeyAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *SourceMssqlSSHKeyAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

// SourceMssqlTunnelMethod - No ssh tunnel needed to connect to database
type SourceMssqlTunnelMethod string

const (
	SourceMssqlTunnelMethodNoTunnel SourceMssqlTunnelMethod = "NO_TUNNEL"
)

func (e SourceMssqlTunnelMethod) ToPointer() *SourceMssqlTunnelMethod {
	return &e
}
func (e *SourceMssqlTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NO_TUNNEL":
		*e = SourceMssqlTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMssqlTunnelMethod: %v", v)
	}
}

type SourceMssqlNoTunnel struct {
	// No ssh tunnel needed to connect to database
	tunnelMethod SourceMssqlTunnelMethod `const:"NO_TUNNEL" json:"tunnel_method"`
}

func (s SourceMssqlNoTunnel) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMssqlNoTunnel) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceMssqlNoTunnel) GetTunnelMethod() SourceMssqlTunnelMethod {
	return SourceMssqlTunnelMethodNoTunnel
}

type SourceMssqlSSHTunnelMethodType string

const (
	SourceMssqlSSHTunnelMethodTypeSourceMssqlNoTunnel               SourceMssqlSSHTunnelMethodType = "source-mssql_No Tunnel"
	SourceMssqlSSHTunnelMethodTypeSourceMssqlSSHKeyAuthentication   SourceMssqlSSHTunnelMethodType = "source-mssql_SSH Key Authentication"
	SourceMssqlSSHTunnelMethodTypeSourceMssqlPasswordAuthentication SourceMssqlSSHTunnelMethodType = "source-mssql_Password Authentication"
)

// SourceMssqlSSHTunnelMethod - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceMssqlSSHTunnelMethod struct {
	SourceMssqlNoTunnel               *SourceMssqlNoTunnel               `queryParam:"inline"`
	SourceMssqlSSHKeyAuthentication   *SourceMssqlSSHKeyAuthentication   `queryParam:"inline"`
	SourceMssqlPasswordAuthentication *SourceMssqlPasswordAuthentication `queryParam:"inline"`

	Type SourceMssqlSSHTunnelMethodType
}

func CreateSourceMssqlSSHTunnelMethodSourceMssqlNoTunnel(sourceMssqlNoTunnel SourceMssqlNoTunnel) SourceMssqlSSHTunnelMethod {
	typ := SourceMssqlSSHTunnelMethodTypeSourceMssqlNoTunnel

	return SourceMssqlSSHTunnelMethod{
		SourceMssqlNoTunnel: &sourceMssqlNoTunnel,
		Type:                typ,
	}
}

func CreateSourceMssqlSSHTunnelMethodSourceMssqlSSHKeyAuthentication(sourceMssqlSSHKeyAuthentication SourceMssqlSSHKeyAuthentication) SourceMssqlSSHTunnelMethod {
	typ := SourceMssqlSSHTunnelMethodTypeSourceMssqlSSHKeyAuthentication

	return SourceMssqlSSHTunnelMethod{
		SourceMssqlSSHKeyAuthentication: &sourceMssqlSSHKeyAuthentication,
		Type:                            typ,
	}
}

func CreateSourceMssqlSSHTunnelMethodSourceMssqlPasswordAuthentication(sourceMssqlPasswordAuthentication SourceMssqlPasswordAuthentication) SourceMssqlSSHTunnelMethod {
	typ := SourceMssqlSSHTunnelMethodTypeSourceMssqlPasswordAuthentication

	return SourceMssqlSSHTunnelMethod{
		SourceMssqlPasswordAuthentication: &sourceMssqlPasswordAuthentication,
		Type:                              typ,
	}
}

func (u *SourceMssqlSSHTunnelMethod) UnmarshalJSON(data []byte) error {

	var sourceMssqlNoTunnel SourceMssqlNoTunnel = SourceMssqlNoTunnel{}
	if err := utils.UnmarshalJSON(data, &sourceMssqlNoTunnel, "", true, true); err == nil {
		u.SourceMssqlNoTunnel = &sourceMssqlNoTunnel
		u.Type = SourceMssqlSSHTunnelMethodTypeSourceMssqlNoTunnel
		return nil
	}

	var sourceMssqlSSHKeyAuthentication SourceMssqlSSHKeyAuthentication = SourceMssqlSSHKeyAuthentication{}
	if err := utils.UnmarshalJSON(data, &sourceMssqlSSHKeyAuthentication, "", true, true); err == nil {
		u.SourceMssqlSSHKeyAuthentication = &sourceMssqlSSHKeyAuthentication
		u.Type = SourceMssqlSSHTunnelMethodTypeSourceMssqlSSHKeyAuthentication
		return nil
	}

	var sourceMssqlPasswordAuthentication SourceMssqlPasswordAuthentication = SourceMssqlPasswordAuthentication{}
	if err := utils.UnmarshalJSON(data, &sourceMssqlPasswordAuthentication, "", true, true); err == nil {
		u.SourceMssqlPasswordAuthentication = &sourceMssqlPasswordAuthentication
		u.Type = SourceMssqlSSHTunnelMethodTypeSourceMssqlPasswordAuthentication
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMssqlSSHTunnelMethod", string(data))
}

func (u SourceMssqlSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.SourceMssqlNoTunnel != nil {
		return utils.MarshalJSON(u.SourceMssqlNoTunnel, "", true)
	}

	if u.SourceMssqlSSHKeyAuthentication != nil {
		return utils.MarshalJSON(u.SourceMssqlSSHKeyAuthentication, "", true)
	}

	if u.SourceMssqlPasswordAuthentication != nil {
		return utils.MarshalJSON(u.SourceMssqlPasswordAuthentication, "", true)
	}

	return nil, errors.New("could not marshal union type SourceMssqlSSHTunnelMethod: all fields are null")
}

type Mssql string

const (
	MssqlMssql Mssql = "mssql"
)

func (e Mssql) ToPointer() *Mssql {
	return &e
}
func (e *Mssql) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "mssql":
		*e = Mssql(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Mssql: %v", v)
	}
}

type SourceMssql struct {
	// The name of the database.
	Database string `json:"database"`
	// The hostname of the database.
	Host string `json:"host"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// The password associated with the username.
	Password string `json:"password"`
	// The port of the database.
	Port int64 `json:"port"`
	// Configures how data is extracted from the database.
	ReplicationMethod *UpdateMethod `json:"replication_method,omitempty"`
	// The list of schemas to sync from. Defaults to user. Case sensitive.
	Schemas []string `json:"schemas,omitempty"`
	// The encryption method which is used when communicating with the database.
	SslMethod *SSLMethod `json:"ssl_method,omitempty"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod *SourceMssqlSSHTunnelMethod `json:"tunnel_method,omitempty"`
	// The username which is used to access the database.
	Username   string `json:"username"`
	sourceType Mssql  `const:"mssql" json:"sourceType"`
}

func (s SourceMssql) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMssql) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *SourceMssql) GetDatabase() string {
	if o == nil {
		return ""
	}
	return o.Database
}

func (o *SourceMssql) GetHost() string {
	if o == nil {
		return ""
	}
	return o.Host
}

func (o *SourceMssql) GetJdbcURLParams() *string {
	if o == nil {
		return nil
	}
	return o.JdbcURLParams
}

func (o *SourceMssql) GetPassword() string {
	if o == nil {
		return ""
	}
	return o.Password
}

func (o *SourceMssql) GetPort() int64 {
	if o == nil {
		return 0
	}
	return o.Port
}

func (o *SourceMssql) GetReplicationMethod() *UpdateMethod {
	if o == nil {
		return nil
	}
	return o.ReplicationMethod
}

func (o *SourceMssql) GetSchemas() []string {
	if o == nil {
		return nil
	}
	return o.Schemas
}

func (o *SourceMssql) GetSslMethod() *SSLMethod {
	if o == nil {
		return nil
	}
	return o.SslMethod
}

func (o *SourceMssql) GetTunnelMethod() *SourceMssqlSSHTunnelMethod {
	if o == nil {
		return nil
	}
	return o.TunnelMethod
}

func (o *SourceMssql) GetUsername() string {
	if o == nil {
		return ""
	}
	return o.Username
}

func (o *SourceMssql) GetSourceType() Mssql {
	return MssqlMssql
}
