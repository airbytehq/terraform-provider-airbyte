// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

// SourceMssqlInvalidCDCPositionBehaviorAdvanced - Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value in the mined logs. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss.
type SourceMssqlInvalidCDCPositionBehaviorAdvanced string

const (
	SourceMssqlInvalidCDCPositionBehaviorAdvancedFailSync   SourceMssqlInvalidCDCPositionBehaviorAdvanced = "Fail sync"
	SourceMssqlInvalidCDCPositionBehaviorAdvancedReSyncData SourceMssqlInvalidCDCPositionBehaviorAdvanced = "Re-sync data"
)

func (e SourceMssqlInvalidCDCPositionBehaviorAdvanced) ToPointer() *SourceMssqlInvalidCDCPositionBehaviorAdvanced {
	return &e
}
func (e *SourceMssqlInvalidCDCPositionBehaviorAdvanced) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Fail sync":
		fallthrough
	case "Re-sync data":
		*e = SourceMssqlInvalidCDCPositionBehaviorAdvanced(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMssqlInvalidCDCPositionBehaviorAdvanced: %v", v)
	}
}

type SourceMssqlMethod string

const (
	SourceMssqlMethodCdc SourceMssqlMethod = "CDC"
)

func (e SourceMssqlMethod) ToPointer() *SourceMssqlMethod {
	return &e
}
func (e *SourceMssqlMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CDC":
		*e = SourceMssqlMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMssqlMethod: %v", v)
	}
}

// ReadChangesUsingChangeDataCaptureCDC - <i>Recommended</i> - Incrementally reads new inserts, updates, and deletes using MSSQL's <a href="https://docs.airbyte.com/integrations/sources/mssql/#change-data-capture-cdc"> change data capture feature</a>. This must be enabled on your database.
type ReadChangesUsingChangeDataCaptureCDC struct {
	// The amount of time an initial load is allowed to continue for before catching up on CDC logs.
	InitialLoadTimeoutHours *int64 `default:"8" json:"initial_load_timeout_hours"`
	// The amount of time the connector will wait when it launches to determine if there is new data to sync or not. Defaults to 300 seconds. Valid range: 120 seconds to 3600 seconds. Read about <a href="https://docs.airbyte.com/integrations/sources/mssql#setting-up-cdc-for-mssql">initial waiting time</a>
	InitialWaitingSeconds *int64 `json:"initial_waiting_seconds,omitempty"`
	// Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value in the mined logs. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss.
	InvalidCdcCursorPositionBehavior *SourceMssqlInvalidCDCPositionBehaviorAdvanced `default:"Fail sync" json:"invalid_cdc_cursor_position_behavior"`
	Method                           *SourceMssqlMethod                             `default:"CDC" json:"method"`
	// How often (in milliseconds) Debezium should poll for new data. Must be smaller than heartbeat interval (15000ms). Lower values provide more responsive data capture but may increase database load.
	PollIntervalMs       *int64 `default:"500" json:"poll_interval_ms"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (r ReadChangesUsingChangeDataCaptureCDC) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(r, "", false)
}

func (r *ReadChangesUsingChangeDataCaptureCDC) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &r, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (r *ReadChangesUsingChangeDataCaptureCDC) GetInitialLoadTimeoutHours() *int64 {
	if r == nil {
		return nil
	}
	return r.InitialLoadTimeoutHours
}

func (r *ReadChangesUsingChangeDataCaptureCDC) GetInitialWaitingSeconds() *int64 {
	if r == nil {
		return nil
	}
	return r.InitialWaitingSeconds
}

func (r *ReadChangesUsingChangeDataCaptureCDC) GetInvalidCdcCursorPositionBehavior() *SourceMssqlInvalidCDCPositionBehaviorAdvanced {
	if r == nil {
		return nil
	}
	return r.InvalidCdcCursorPositionBehavior
}

func (r *ReadChangesUsingChangeDataCaptureCDC) GetMethod() *SourceMssqlMethod {
	if r == nil {
		return nil
	}
	return r.Method
}

func (r *ReadChangesUsingChangeDataCaptureCDC) GetPollIntervalMs() *int64 {
	if r == nil {
		return nil
	}
	return r.PollIntervalMs
}

func (r *ReadChangesUsingChangeDataCaptureCDC) GetAdditionalProperties() any {
	if r == nil {
		return nil
	}
	return r.AdditionalProperties
}

type Method string

const (
	MethodStandard Method = "STANDARD"
)

func (e Method) ToPointer() *Method {
	return &e
}
func (e *Method) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "STANDARD":
		*e = Method(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Method: %v", v)
	}
}

// ScanChangesWithUserDefinedCursor - Incrementally detects new inserts and updates using the <a href="https://docs.airbyte.com/understanding-airbyte/connections/incremental-append/#user-defined-cursor">cursor column</a> chosen when configuring a connection (e.g. created_at, updated_at).
type ScanChangesWithUserDefinedCursor struct {
	// When enabled incremental syncs using a cursor of a temporal type (date or datetime) will include cursor values only up until the previous midnight UTC
	ExcludeTodaysData    *bool   `default:"false" json:"exclude_todays_data"`
	Method               *Method `default:"STANDARD" json:"method"`
	AdditionalProperties any     `additionalProperties:"true" json:"-"`
}

func (s ScanChangesWithUserDefinedCursor) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *ScanChangesWithUserDefinedCursor) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *ScanChangesWithUserDefinedCursor) GetExcludeTodaysData() *bool {
	if s == nil {
		return nil
	}
	return s.ExcludeTodaysData
}

func (s *ScanChangesWithUserDefinedCursor) GetMethod() *Method {
	if s == nil {
		return nil
	}
	return s.Method
}

func (s *ScanChangesWithUserDefinedCursor) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type UpdateMethodType string

const (
	UpdateMethodTypeScanChangesWithUserDefinedCursor     UpdateMethodType = "Scan Changes with User Defined Cursor"
	UpdateMethodTypeReadChangesUsingChangeDataCaptureCDC UpdateMethodType = "Read Changes using Change Data Capture (CDC)"
)

// UpdateMethod - Configures how data is extracted from the database.
type UpdateMethod struct {
	ScanChangesWithUserDefinedCursor     *ScanChangesWithUserDefinedCursor     `queryParam:"inline" union:"member"`
	ReadChangesUsingChangeDataCaptureCDC *ReadChangesUsingChangeDataCaptureCDC `queryParam:"inline" union:"member"`

	Type UpdateMethodType
}

func CreateUpdateMethodScanChangesWithUserDefinedCursor(scanChangesWithUserDefinedCursor ScanChangesWithUserDefinedCursor) UpdateMethod {
	typ := UpdateMethodTypeScanChangesWithUserDefinedCursor

	return UpdateMethod{
		ScanChangesWithUserDefinedCursor: &scanChangesWithUserDefinedCursor,
		Type:                             typ,
	}
}

func CreateUpdateMethodReadChangesUsingChangeDataCaptureCDC(readChangesUsingChangeDataCaptureCDC ReadChangesUsingChangeDataCaptureCDC) UpdateMethod {
	typ := UpdateMethodTypeReadChangesUsingChangeDataCaptureCDC

	return UpdateMethod{
		ReadChangesUsingChangeDataCaptureCDC: &readChangesUsingChangeDataCaptureCDC,
		Type:                                 typ,
	}
}

func (u *UpdateMethod) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var scanChangesWithUserDefinedCursor ScanChangesWithUserDefinedCursor = ScanChangesWithUserDefinedCursor{}
	if err := utils.UnmarshalJSON(data, &scanChangesWithUserDefinedCursor, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  UpdateMethodTypeScanChangesWithUserDefinedCursor,
			Value: &scanChangesWithUserDefinedCursor,
		})
	}

	var readChangesUsingChangeDataCaptureCDC ReadChangesUsingChangeDataCaptureCDC = ReadChangesUsingChangeDataCaptureCDC{}
	if err := utils.UnmarshalJSON(data, &readChangesUsingChangeDataCaptureCDC, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  UpdateMethodTypeReadChangesUsingChangeDataCaptureCDC,
			Value: &readChangesUsingChangeDataCaptureCDC,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for UpdateMethod", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for UpdateMethod", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(UpdateMethodType)
	switch best.Type {
	case UpdateMethodTypeScanChangesWithUserDefinedCursor:
		u.ScanChangesWithUserDefinedCursor = best.Value.(*ScanChangesWithUserDefinedCursor)
		return nil
	case UpdateMethodTypeReadChangesUsingChangeDataCaptureCDC:
		u.ReadChangesUsingChangeDataCaptureCDC = best.Value.(*ReadChangesUsingChangeDataCaptureCDC)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for UpdateMethod", string(data))
}

func (u UpdateMethod) MarshalJSON() ([]byte, error) {
	if u.ScanChangesWithUserDefinedCursor != nil {
		return utils.MarshalJSON(u.ScanChangesWithUserDefinedCursor, "", true)
	}

	if u.ReadChangesUsingChangeDataCaptureCDC != nil {
		return utils.MarshalJSON(u.ReadChangesUsingChangeDataCaptureCDC, "", true)
	}

	return nil, errors.New("could not marshal union type UpdateMethod: all fields are null")
}

type SourceMssqlSchemasSslModeMode string

const (
	SourceMssqlSchemasSslModeModeEncryptedVerifyCertificate SourceMssqlSchemasSslModeMode = "encrypted_verify_certificate"
)

func (e SourceMssqlSchemasSslModeMode) ToPointer() *SourceMssqlSchemasSslModeMode {
	return &e
}
func (e *SourceMssqlSchemasSslModeMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "encrypted_verify_certificate":
		*e = SourceMssqlSchemasSslModeMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMssqlSchemasSslModeMode: %v", v)
	}
}

// EncryptedVerifyCertificate - Verify and use the certificate provided by the server.
type EncryptedVerifyCertificate struct {
	// certificate of the server, or of the CA that signed the server certificate
	Certificate *string `json:"certificate,omitempty"`
	// Specifies the host name of the server. The value of this property must match the subject property of the certificate.
	HostNameInCertificate *string                        `json:"hostNameInCertificate,omitempty"`
	Mode                  *SourceMssqlSchemasSslModeMode `default:"encrypted_verify_certificate" json:"mode"`
	AdditionalProperties  any                            `additionalProperties:"true" json:"-"`
}

func (e EncryptedVerifyCertificate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *EncryptedVerifyCertificate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (e *EncryptedVerifyCertificate) GetCertificate() *string {
	if e == nil {
		return nil
	}
	return e.Certificate
}

func (e *EncryptedVerifyCertificate) GetHostNameInCertificate() *string {
	if e == nil {
		return nil
	}
	return e.HostNameInCertificate
}

func (e *EncryptedVerifyCertificate) GetMode() *SourceMssqlSchemasSslModeMode {
	if e == nil {
		return nil
	}
	return e.Mode
}

func (e *EncryptedVerifyCertificate) GetAdditionalProperties() any {
	if e == nil {
		return nil
	}
	return e.AdditionalProperties
}

type SourceMssqlSchemasMode string

const (
	SourceMssqlSchemasModeEncryptedTrustServerCertificate SourceMssqlSchemasMode = "encrypted_trust_server_certificate"
)

func (e SourceMssqlSchemasMode) ToPointer() *SourceMssqlSchemasMode {
	return &e
}
func (e *SourceMssqlSchemasMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "encrypted_trust_server_certificate":
		*e = SourceMssqlSchemasMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMssqlSchemasMode: %v", v)
	}
}

// EncryptedTrustServerCertificate - Use the certificate provided by the server without verification. (For testing purposes only!)
type EncryptedTrustServerCertificate struct {
	Mode                 *SourceMssqlSchemasMode `default:"encrypted_trust_server_certificate" json:"mode"`
	AdditionalProperties any                     `additionalProperties:"true" json:"-"`
}

func (e EncryptedTrustServerCertificate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *EncryptedTrustServerCertificate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (e *EncryptedTrustServerCertificate) GetMode() *SourceMssqlSchemasMode {
	if e == nil {
		return nil
	}
	return e.Mode
}

func (e *EncryptedTrustServerCertificate) GetAdditionalProperties() any {
	if e == nil {
		return nil
	}
	return e.AdditionalProperties
}

type SourceMssqlMode string

const (
	SourceMssqlModeUnencrypted SourceMssqlMode = "unencrypted"
)

func (e SourceMssqlMode) ToPointer() *SourceMssqlMode {
	return &e
}
func (e *SourceMssqlMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "unencrypted":
		*e = SourceMssqlMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMssqlMode: %v", v)
	}
}

// Unencrypted - Data transfer will not be encrypted.
type Unencrypted struct {
	Mode                 *SourceMssqlMode `default:"unencrypted" json:"mode"`
	AdditionalProperties any              `additionalProperties:"true" json:"-"`
}

func (u Unencrypted) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(u, "", false)
}

func (u *Unencrypted) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &u, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (u *Unencrypted) GetMode() *SourceMssqlMode {
	if u == nil {
		return nil
	}
	return u.Mode
}

func (u *Unencrypted) GetAdditionalProperties() any {
	if u == nil {
		return nil
	}
	return u.AdditionalProperties
}

type SourceMssqlEncryptionType string

const (
	SourceMssqlEncryptionTypeUnencrypted                     SourceMssqlEncryptionType = "Unencrypted"
	SourceMssqlEncryptionTypeEncryptedTrustServerCertificate SourceMssqlEncryptionType = "Encrypted (trust server certificate)"
	SourceMssqlEncryptionTypeEncryptedVerifyCertificate      SourceMssqlEncryptionType = "Encrypted (verify certificate)"
)

// SourceMssqlEncryption - The encryption method which is used when communicating with the database.
type SourceMssqlEncryption struct {
	Unencrypted                     *Unencrypted                     `queryParam:"inline" union:"member"`
	EncryptedTrustServerCertificate *EncryptedTrustServerCertificate `queryParam:"inline" union:"member"`
	EncryptedVerifyCertificate      *EncryptedVerifyCertificate      `queryParam:"inline" union:"member"`

	Type SourceMssqlEncryptionType
}

func CreateSourceMssqlEncryptionUnencrypted(unencrypted Unencrypted) SourceMssqlEncryption {
	typ := SourceMssqlEncryptionTypeUnencrypted

	return SourceMssqlEncryption{
		Unencrypted: &unencrypted,
		Type:        typ,
	}
}

func CreateSourceMssqlEncryptionEncryptedTrustServerCertificate(encryptedTrustServerCertificate EncryptedTrustServerCertificate) SourceMssqlEncryption {
	typ := SourceMssqlEncryptionTypeEncryptedTrustServerCertificate

	return SourceMssqlEncryption{
		EncryptedTrustServerCertificate: &encryptedTrustServerCertificate,
		Type:                            typ,
	}
}

func CreateSourceMssqlEncryptionEncryptedVerifyCertificate(encryptedVerifyCertificate EncryptedVerifyCertificate) SourceMssqlEncryption {
	typ := SourceMssqlEncryptionTypeEncryptedVerifyCertificate

	return SourceMssqlEncryption{
		EncryptedVerifyCertificate: &encryptedVerifyCertificate,
		Type:                       typ,
	}
}

func (u *SourceMssqlEncryption) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var unencrypted Unencrypted = Unencrypted{}
	if err := utils.UnmarshalJSON(data, &unencrypted, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceMssqlEncryptionTypeUnencrypted,
			Value: &unencrypted,
		})
	}

	var encryptedTrustServerCertificate EncryptedTrustServerCertificate = EncryptedTrustServerCertificate{}
	if err := utils.UnmarshalJSON(data, &encryptedTrustServerCertificate, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceMssqlEncryptionTypeEncryptedTrustServerCertificate,
			Value: &encryptedTrustServerCertificate,
		})
	}

	var encryptedVerifyCertificate EncryptedVerifyCertificate = EncryptedVerifyCertificate{}
	if err := utils.UnmarshalJSON(data, &encryptedVerifyCertificate, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceMssqlEncryptionTypeEncryptedVerifyCertificate,
			Value: &encryptedVerifyCertificate,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMssqlEncryption", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMssqlEncryption", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceMssqlEncryptionType)
	switch best.Type {
	case SourceMssqlEncryptionTypeUnencrypted:
		u.Unencrypted = best.Value.(*Unencrypted)
		return nil
	case SourceMssqlEncryptionTypeEncryptedTrustServerCertificate:
		u.EncryptedTrustServerCertificate = best.Value.(*EncryptedTrustServerCertificate)
		return nil
	case SourceMssqlEncryptionTypeEncryptedVerifyCertificate:
		u.EncryptedVerifyCertificate = best.Value.(*EncryptedVerifyCertificate)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMssqlEncryption", string(data))
}

func (u SourceMssqlEncryption) MarshalJSON() ([]byte, error) {
	if u.Unencrypted != nil {
		return utils.MarshalJSON(u.Unencrypted, "", true)
	}

	if u.EncryptedTrustServerCertificate != nil {
		return utils.MarshalJSON(u.EncryptedTrustServerCertificate, "", true)
	}

	if u.EncryptedVerifyCertificate != nil {
		return utils.MarshalJSON(u.EncryptedVerifyCertificate, "", true)
	}

	return nil, errors.New("could not marshal union type SourceMssqlEncryption: all fields are null")
}

type SourceMssqlSchemasTunnelMethod string

const (
	SourceMssqlSchemasTunnelMethodSSHPasswordAuth SourceMssqlSchemasTunnelMethod = "SSH_PASSWORD_AUTH"
)

func (e SourceMssqlSchemasTunnelMethod) ToPointer() *SourceMssqlSchemasTunnelMethod {
	return &e
}
func (e *SourceMssqlSchemasTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_PASSWORD_AUTH":
		*e = SourceMssqlSchemasTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMssqlSchemasTunnelMethod: %v", v)
	}
}

// SourceMssqlPasswordAuthentication - Connect through a jump server tunnel host using username and password authentication
type SourceMssqlPasswordAuthentication struct {
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost   string                          `json:"tunnel_host"`
	TunnelMethod *SourceMssqlSchemasTunnelMethod `default:"SSH_PASSWORD_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser string `json:"tunnel_user"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword   string `json:"tunnel_user_password"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (s SourceMssqlPasswordAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMssqlPasswordAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceMssqlPasswordAuthentication) GetTunnelHost() string {
	if s == nil {
		return ""
	}
	return s.TunnelHost
}

func (s *SourceMssqlPasswordAuthentication) GetTunnelMethod() *SourceMssqlSchemasTunnelMethod {
	if s == nil {
		return nil
	}
	return s.TunnelMethod
}

func (s *SourceMssqlPasswordAuthentication) GetTunnelPort() *int64 {
	if s == nil {
		return nil
	}
	return s.TunnelPort
}

func (s *SourceMssqlPasswordAuthentication) GetTunnelUser() string {
	if s == nil {
		return ""
	}
	return s.TunnelUser
}

func (s *SourceMssqlPasswordAuthentication) GetTunnelUserPassword() string {
	if s == nil {
		return ""
	}
	return s.TunnelUserPassword
}

func (s *SourceMssqlPasswordAuthentication) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceMssqlTunnelMethod string

const (
	SourceMssqlTunnelMethodSSHKeyAuth SourceMssqlTunnelMethod = "SSH_KEY_AUTH"
)

func (e SourceMssqlTunnelMethod) ToPointer() *SourceMssqlTunnelMethod {
	return &e
}
func (e *SourceMssqlTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_KEY_AUTH":
		*e = SourceMssqlTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMssqlTunnelMethod: %v", v)
	}
}

// SourceMssqlSSHKeyAuthentication - Connect through a jump server tunnel host using username and ssh key
type SourceMssqlSSHKeyAuthentication struct {
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey string `json:"ssh_key"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost   string                   `json:"tunnel_host"`
	TunnelMethod *SourceMssqlTunnelMethod `default:"SSH_KEY_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser           string `json:"tunnel_user"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (s SourceMssqlSSHKeyAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMssqlSSHKeyAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceMssqlSSHKeyAuthentication) GetSSHKey() string {
	if s == nil {
		return ""
	}
	return s.SSHKey
}

func (s *SourceMssqlSSHKeyAuthentication) GetTunnelHost() string {
	if s == nil {
		return ""
	}
	return s.TunnelHost
}

func (s *SourceMssqlSSHKeyAuthentication) GetTunnelMethod() *SourceMssqlTunnelMethod {
	if s == nil {
		return nil
	}
	return s.TunnelMethod
}

func (s *SourceMssqlSSHKeyAuthentication) GetTunnelPort() *int64 {
	if s == nil {
		return nil
	}
	return s.TunnelPort
}

func (s *SourceMssqlSSHKeyAuthentication) GetTunnelUser() string {
	if s == nil {
		return ""
	}
	return s.TunnelUser
}

func (s *SourceMssqlSSHKeyAuthentication) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type TunnelMethod string

const (
	TunnelMethodNoTunnel TunnelMethod = "NO_TUNNEL"
)

func (e TunnelMethod) ToPointer() *TunnelMethod {
	return &e
}
func (e *TunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NO_TUNNEL":
		*e = TunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TunnelMethod: %v", v)
	}
}

// SourceMssqlNoTunnel - No ssh tunnel needed to connect to database
type SourceMssqlNoTunnel struct {
	TunnelMethod         *TunnelMethod `default:"NO_TUNNEL" json:"tunnel_method"`
	AdditionalProperties any           `additionalProperties:"true" json:"-"`
}

func (s SourceMssqlNoTunnel) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMssqlNoTunnel) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceMssqlNoTunnel) GetTunnelMethod() *TunnelMethod {
	if s == nil {
		return nil
	}
	return s.TunnelMethod
}

func (s *SourceMssqlNoTunnel) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceMssqlSSHTunnelMethodType string

const (
	SourceMssqlSSHTunnelMethodTypeSourceMssqlNoTunnel               SourceMssqlSSHTunnelMethodType = "source-mssql_No Tunnel"
	SourceMssqlSSHTunnelMethodTypeSourceMssqlSSHKeyAuthentication   SourceMssqlSSHTunnelMethodType = "source-mssql_SSH Key Authentication"
	SourceMssqlSSHTunnelMethodTypeSourceMssqlPasswordAuthentication SourceMssqlSSHTunnelMethodType = "source-mssql_Password Authentication"
)

// SourceMssqlSSHTunnelMethod - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceMssqlSSHTunnelMethod struct {
	SourceMssqlNoTunnel               *SourceMssqlNoTunnel               `queryParam:"inline" union:"member"`
	SourceMssqlSSHKeyAuthentication   *SourceMssqlSSHKeyAuthentication   `queryParam:"inline" union:"member"`
	SourceMssqlPasswordAuthentication *SourceMssqlPasswordAuthentication `queryParam:"inline" union:"member"`

	Type SourceMssqlSSHTunnelMethodType
}

func CreateSourceMssqlSSHTunnelMethodSourceMssqlNoTunnel(sourceMssqlNoTunnel SourceMssqlNoTunnel) SourceMssqlSSHTunnelMethod {
	typ := SourceMssqlSSHTunnelMethodTypeSourceMssqlNoTunnel

	return SourceMssqlSSHTunnelMethod{
		SourceMssqlNoTunnel: &sourceMssqlNoTunnel,
		Type:                typ,
	}
}

func CreateSourceMssqlSSHTunnelMethodSourceMssqlSSHKeyAuthentication(sourceMssqlSSHKeyAuthentication SourceMssqlSSHKeyAuthentication) SourceMssqlSSHTunnelMethod {
	typ := SourceMssqlSSHTunnelMethodTypeSourceMssqlSSHKeyAuthentication

	return SourceMssqlSSHTunnelMethod{
		SourceMssqlSSHKeyAuthentication: &sourceMssqlSSHKeyAuthentication,
		Type:                            typ,
	}
}

func CreateSourceMssqlSSHTunnelMethodSourceMssqlPasswordAuthentication(sourceMssqlPasswordAuthentication SourceMssqlPasswordAuthentication) SourceMssqlSSHTunnelMethod {
	typ := SourceMssqlSSHTunnelMethodTypeSourceMssqlPasswordAuthentication

	return SourceMssqlSSHTunnelMethod{
		SourceMssqlPasswordAuthentication: &sourceMssqlPasswordAuthentication,
		Type:                              typ,
	}
}

func (u *SourceMssqlSSHTunnelMethod) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var sourceMssqlNoTunnel SourceMssqlNoTunnel = SourceMssqlNoTunnel{}
	if err := utils.UnmarshalJSON(data, &sourceMssqlNoTunnel, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceMssqlSSHTunnelMethodTypeSourceMssqlNoTunnel,
			Value: &sourceMssqlNoTunnel,
		})
	}

	var sourceMssqlSSHKeyAuthentication SourceMssqlSSHKeyAuthentication = SourceMssqlSSHKeyAuthentication{}
	if err := utils.UnmarshalJSON(data, &sourceMssqlSSHKeyAuthentication, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceMssqlSSHTunnelMethodTypeSourceMssqlSSHKeyAuthentication,
			Value: &sourceMssqlSSHKeyAuthentication,
		})
	}

	var sourceMssqlPasswordAuthentication SourceMssqlPasswordAuthentication = SourceMssqlPasswordAuthentication{}
	if err := utils.UnmarshalJSON(data, &sourceMssqlPasswordAuthentication, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceMssqlSSHTunnelMethodTypeSourceMssqlPasswordAuthentication,
			Value: &sourceMssqlPasswordAuthentication,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMssqlSSHTunnelMethod", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMssqlSSHTunnelMethod", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceMssqlSSHTunnelMethodType)
	switch best.Type {
	case SourceMssqlSSHTunnelMethodTypeSourceMssqlNoTunnel:
		u.SourceMssqlNoTunnel = best.Value.(*SourceMssqlNoTunnel)
		return nil
	case SourceMssqlSSHTunnelMethodTypeSourceMssqlSSHKeyAuthentication:
		u.SourceMssqlSSHKeyAuthentication = best.Value.(*SourceMssqlSSHKeyAuthentication)
		return nil
	case SourceMssqlSSHTunnelMethodTypeSourceMssqlPasswordAuthentication:
		u.SourceMssqlPasswordAuthentication = best.Value.(*SourceMssqlPasswordAuthentication)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMssqlSSHTunnelMethod", string(data))
}

func (u SourceMssqlSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.SourceMssqlNoTunnel != nil {
		return utils.MarshalJSON(u.SourceMssqlNoTunnel, "", true)
	}

	if u.SourceMssqlSSHKeyAuthentication != nil {
		return utils.MarshalJSON(u.SourceMssqlSSHKeyAuthentication, "", true)
	}

	if u.SourceMssqlPasswordAuthentication != nil {
		return utils.MarshalJSON(u.SourceMssqlPasswordAuthentication, "", true)
	}

	return nil, errors.New("could not marshal union type SourceMssqlSSHTunnelMethod: all fields are null")
}

type SourceMssqlSourceType string

const (
	SourceMssqlSourceTypeMssql SourceMssqlSourceType = "mssql"
)

func (e SourceMssqlSourceType) ToPointer() *SourceMssqlSourceType {
	return &e
}
func (e *SourceMssqlSourceType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "mssql":
		*e = SourceMssqlSourceType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMssqlSourceType: %v", v)
	}
}

type SourceMssql struct {
	AdditionalProperties map[string]map[string]any `json:"additionalProperties"`
	// When this feature is enabled, during schema discovery the connector will query each table or view individually to check access privileges and inaccessible tables, views, or columns therein will be removed. In large schemas, this might cause schema discovery to take too long, in which case it might be advisable to disable this feature.
	CheckPrivileges *bool `default:"true" json:"check_privileges"`
	// How often (in seconds) a stream should checkpoint, when possible.
	CheckpointTargetIntervalSeconds *int64 `default:"300" json:"checkpoint_target_interval_seconds"`
	// Maximum number of concurrent queries to the database.
	Concurrency *int64 `json:"concurrency,omitempty"`
	// The name of the database.
	Database string `json:"database"`
	// The hostname of the database.
	Host string `json:"host"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// The password associated with the username.
	Password string `json:"password"`
	// The port of the database.
	Port *int64 `default:"1433" json:"port"`
	// Configures how data is extracted from the database.
	ReplicationMethod UpdateMethod `json:"replication_method"`
	// The list of schemas to sync from. If not specified, all schemas will be discovered. Case sensitive.
	Schemas []string `json:"schemas,omitempty"`
	// The encryption method which is used when communicating with the database.
	SslMode *SourceMssqlEncryption `json:"ssl_mode,omitempty"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod *SourceMssqlSSHTunnelMethod `json:"tunnel_method,omitempty"`
	// The username which is used to access the database.
	Username              string                 `json:"username"`
	sourceType            *SourceMssqlSourceType `const:"mssql" json:"sourceType"`
	AdditionalProperties1 any                    `additionalProperties:"true" json:"-"`
}

func (s SourceMssql) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMssql) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceMssql) GetAdditionalProperties() map[string]map[string]any {
	if s == nil {
		return map[string]map[string]any{}
	}
	return s.AdditionalProperties
}

func (s *SourceMssql) GetCheckPrivileges() *bool {
	if s == nil {
		return nil
	}
	return s.CheckPrivileges
}

func (s *SourceMssql) GetCheckpointTargetIntervalSeconds() *int64 {
	if s == nil {
		return nil
	}
	return s.CheckpointTargetIntervalSeconds
}

func (s *SourceMssql) GetConcurrency() *int64 {
	if s == nil {
		return nil
	}
	return s.Concurrency
}

func (s *SourceMssql) GetDatabase() string {
	if s == nil {
		return ""
	}
	return s.Database
}

func (s *SourceMssql) GetHost() string {
	if s == nil {
		return ""
	}
	return s.Host
}

func (s *SourceMssql) GetJdbcURLParams() *string {
	if s == nil {
		return nil
	}
	return s.JdbcURLParams
}

func (s *SourceMssql) GetPassword() string {
	if s == nil {
		return ""
	}
	return s.Password
}

func (s *SourceMssql) GetPort() *int64 {
	if s == nil {
		return nil
	}
	return s.Port
}

func (s *SourceMssql) GetReplicationMethod() UpdateMethod {
	if s == nil {
		return UpdateMethod{}
	}
	return s.ReplicationMethod
}

func (s *SourceMssql) GetSchemas() []string {
	if s == nil {
		return nil
	}
	return s.Schemas
}

func (s *SourceMssql) GetSslMode() *SourceMssqlEncryption {
	if s == nil {
		return nil
	}
	return s.SslMode
}

func (s *SourceMssql) GetTunnelMethod() *SourceMssqlSSHTunnelMethod {
	if s == nil {
		return nil
	}
	return s.TunnelMethod
}

func (s *SourceMssql) GetUsername() string {
	if s == nil {
		return ""
	}
	return s.Username
}

func (s *SourceMssql) GetSourceType() *SourceMssqlSourceType {
	return SourceMssqlSourceTypeMssql.ToPointer()
}

func (s *SourceMssql) GetAdditionalProperties1() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties1
}
