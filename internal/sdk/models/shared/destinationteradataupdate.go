// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

type DestinationTeradataUpdateSchemasAuthType string

const (
	DestinationTeradataUpdateSchemasAuthTypeLdap DestinationTeradataUpdateSchemasAuthType = "LDAP"
)

func (e DestinationTeradataUpdateSchemasAuthType) ToPointer() *DestinationTeradataUpdateSchemasAuthType {
	return &e
}
func (e *DestinationTeradataUpdateSchemasAuthType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "LDAP":
		*e = DestinationTeradataUpdateSchemasAuthType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationTeradataUpdateSchemasAuthType: %v", v)
	}
}

type DestinationTeradataUpdateLDAP struct {
	authType *DestinationTeradataUpdateSchemasAuthType `const:"LDAP" json:"auth_type"`
	// Enter the password associated with the username.
	Password *string `json:"password,omitempty"`
	// Username to use to access the database.
	Username *string `json:"username,omitempty"`
}

func (d DestinationTeradataUpdateLDAP) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationTeradataUpdateLDAP) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationTeradataUpdateLDAP) GetAuthType() *DestinationTeradataUpdateSchemasAuthType {
	return DestinationTeradataUpdateSchemasAuthTypeLdap.ToPointer()
}

func (d *DestinationTeradataUpdateLDAP) GetPassword() *string {
	if d == nil {
		return nil
	}
	return d.Password
}

func (d *DestinationTeradataUpdateLDAP) GetUsername() *string {
	if d == nil {
		return nil
	}
	return d.Username
}

type DestinationTeradataUpdateAuthType string

const (
	DestinationTeradataUpdateAuthTypeTd2 DestinationTeradataUpdateAuthType = "TD2"
)

func (e DestinationTeradataUpdateAuthType) ToPointer() *DestinationTeradataUpdateAuthType {
	return &e
}
func (e *DestinationTeradataUpdateAuthType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "TD2":
		*e = DestinationTeradataUpdateAuthType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationTeradataUpdateAuthType: %v", v)
	}
}

type DestinationTeradataUpdateTd2 struct {
	authType *DestinationTeradataUpdateAuthType `const:"TD2" json:"auth_type"`
	// Enter the password associated with the username.
	Password *string `json:"password,omitempty"`
	// Username to use to access the database.
	Username *string `json:"username,omitempty"`
}

func (d DestinationTeradataUpdateTd2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationTeradataUpdateTd2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationTeradataUpdateTd2) GetAuthType() *DestinationTeradataUpdateAuthType {
	return DestinationTeradataUpdateAuthTypeTd2.ToPointer()
}

func (d *DestinationTeradataUpdateTd2) GetPassword() *string {
	if d == nil {
		return nil
	}
	return d.Password
}

func (d *DestinationTeradataUpdateTd2) GetUsername() *string {
	if d == nil {
		return nil
	}
	return d.Username
}

type DestinationTeradataUpdateAuthorizationMechanismType string

const (
	DestinationTeradataUpdateAuthorizationMechanismTypeDestinationTeradataUpdateTd2  DestinationTeradataUpdateAuthorizationMechanismType = "destination-teradata-update_TD2"
	DestinationTeradataUpdateAuthorizationMechanismTypeDestinationTeradataUpdateLDAP DestinationTeradataUpdateAuthorizationMechanismType = "destination-teradata-update_LDAP"
)

type DestinationTeradataUpdateAuthorizationMechanism struct {
	DestinationTeradataUpdateTd2  *DestinationTeradataUpdateTd2  `queryParam:"inline" union:"member"`
	DestinationTeradataUpdateLDAP *DestinationTeradataUpdateLDAP `queryParam:"inline" union:"member"`

	Type DestinationTeradataUpdateAuthorizationMechanismType
}

func CreateDestinationTeradataUpdateAuthorizationMechanismDestinationTeradataUpdateTd2(destinationTeradataUpdateTd2 DestinationTeradataUpdateTd2) DestinationTeradataUpdateAuthorizationMechanism {
	typ := DestinationTeradataUpdateAuthorizationMechanismTypeDestinationTeradataUpdateTd2

	return DestinationTeradataUpdateAuthorizationMechanism{
		DestinationTeradataUpdateTd2: &destinationTeradataUpdateTd2,
		Type:                         typ,
	}
}

func CreateDestinationTeradataUpdateAuthorizationMechanismDestinationTeradataUpdateLDAP(destinationTeradataUpdateLDAP DestinationTeradataUpdateLDAP) DestinationTeradataUpdateAuthorizationMechanism {
	typ := DestinationTeradataUpdateAuthorizationMechanismTypeDestinationTeradataUpdateLDAP

	return DestinationTeradataUpdateAuthorizationMechanism{
		DestinationTeradataUpdateLDAP: &destinationTeradataUpdateLDAP,
		Type:                          typ,
	}
}

func (u *DestinationTeradataUpdateAuthorizationMechanism) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var destinationTeradataUpdateTd2 DestinationTeradataUpdateTd2 = DestinationTeradataUpdateTd2{}
	if err := utils.UnmarshalJSON(data, &destinationTeradataUpdateTd2, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationTeradataUpdateAuthorizationMechanismTypeDestinationTeradataUpdateTd2,
			Value: &destinationTeradataUpdateTd2,
		})
	}

	var destinationTeradataUpdateLDAP DestinationTeradataUpdateLDAP = DestinationTeradataUpdateLDAP{}
	if err := utils.UnmarshalJSON(data, &destinationTeradataUpdateLDAP, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationTeradataUpdateAuthorizationMechanismTypeDestinationTeradataUpdateLDAP,
			Value: &destinationTeradataUpdateLDAP,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationTeradataUpdateAuthorizationMechanism", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationTeradataUpdateAuthorizationMechanism", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(DestinationTeradataUpdateAuthorizationMechanismType)
	switch best.Type {
	case DestinationTeradataUpdateAuthorizationMechanismTypeDestinationTeradataUpdateTd2:
		u.DestinationTeradataUpdateTd2 = best.Value.(*DestinationTeradataUpdateTd2)
		return nil
	case DestinationTeradataUpdateAuthorizationMechanismTypeDestinationTeradataUpdateLDAP:
		u.DestinationTeradataUpdateLDAP = best.Value.(*DestinationTeradataUpdateLDAP)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationTeradataUpdateAuthorizationMechanism", string(data))
}

func (u DestinationTeradataUpdateAuthorizationMechanism) MarshalJSON() ([]byte, error) {
	if u.DestinationTeradataUpdateTd2 != nil {
		return utils.MarshalJSON(u.DestinationTeradataUpdateTd2, "", true)
	}

	if u.DestinationTeradataUpdateLDAP != nil {
		return utils.MarshalJSON(u.DestinationTeradataUpdateLDAP, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationTeradataUpdateAuthorizationMechanism: all fields are null")
}

type DestinationTeradataUpdateSchemasSSLModeSSLModes6Mode string

const (
	DestinationTeradataUpdateSchemasSSLModeSSLModes6ModeVerifyFull DestinationTeradataUpdateSchemasSSLModeSSLModes6Mode = "verify-full"
)

func (e DestinationTeradataUpdateSchemasSSLModeSSLModes6Mode) ToPointer() *DestinationTeradataUpdateSchemasSSLModeSSLModes6Mode {
	return &e
}
func (e *DestinationTeradataUpdateSchemasSSLModeSSLModes6Mode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "verify-full":
		*e = DestinationTeradataUpdateSchemasSSLModeSSLModes6Mode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationTeradataUpdateSchemasSSLModeSSLModes6Mode: %v", v)
	}
}

// DestinationTeradataUpdateVerifyFull - Verify-full SSL mode.
type DestinationTeradataUpdateVerifyFull struct {
	mode *DestinationTeradataUpdateSchemasSSLModeSSLModes6Mode `const:"verify-full" json:"mode"`
	// Specifies the file name of a PEM file that contains Certificate Authority (CA) certificates for use with SSLMODE=verify-full.
	//  See more information - <a href="https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/jdbcug_chapter_2.html#URL_SSLCA"> in the docs</a>.
	SslCaCertificate *string `json:"ssl_ca_certificate,omitempty"`
}

func (d DestinationTeradataUpdateVerifyFull) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationTeradataUpdateVerifyFull) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationTeradataUpdateVerifyFull) GetMode() *DestinationTeradataUpdateSchemasSSLModeSSLModes6Mode {
	return DestinationTeradataUpdateSchemasSSLModeSSLModes6ModeVerifyFull.ToPointer()
}

func (d *DestinationTeradataUpdateVerifyFull) GetSslCaCertificate() *string {
	if d == nil {
		return nil
	}
	return d.SslCaCertificate
}

type DestinationTeradataUpdateSchemasSSLModeSSLModes5Mode string

const (
	DestinationTeradataUpdateSchemasSSLModeSSLModes5ModeVerifyCa DestinationTeradataUpdateSchemasSSLModeSSLModes5Mode = "verify-ca"
)

func (e DestinationTeradataUpdateSchemasSSLModeSSLModes5Mode) ToPointer() *DestinationTeradataUpdateSchemasSSLModeSSLModes5Mode {
	return &e
}
func (e *DestinationTeradataUpdateSchemasSSLModeSSLModes5Mode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "verify-ca":
		*e = DestinationTeradataUpdateSchemasSSLModeSSLModes5Mode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationTeradataUpdateSchemasSSLModeSSLModes5Mode: %v", v)
	}
}

// DestinationTeradataUpdateVerifyCa - Verify-ca SSL mode.
type DestinationTeradataUpdateVerifyCa struct {
	mode *DestinationTeradataUpdateSchemasSSLModeSSLModes5Mode `const:"verify-ca" json:"mode"`
	// Specifies the file name of a PEM file that contains Certificate Authority (CA) certificates for use with SSLMODE=verify-ca.
	//  See more information - <a href="https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/jdbcug_chapter_2.html#URL_SSLCA"> in the docs</a>.
	SslCaCertificate *string `json:"ssl_ca_certificate,omitempty"`
}

func (d DestinationTeradataUpdateVerifyCa) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationTeradataUpdateVerifyCa) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationTeradataUpdateVerifyCa) GetMode() *DestinationTeradataUpdateSchemasSSLModeSSLModes5Mode {
	return DestinationTeradataUpdateSchemasSSLModeSSLModes5ModeVerifyCa.ToPointer()
}

func (d *DestinationTeradataUpdateVerifyCa) GetSslCaCertificate() *string {
	if d == nil {
		return nil
	}
	return d.SslCaCertificate
}

type DestinationTeradataUpdateSchemasSSLModeSSLModesMode string

const (
	DestinationTeradataUpdateSchemasSSLModeSSLModesModeRequire DestinationTeradataUpdateSchemasSSLModeSSLModesMode = "require"
)

func (e DestinationTeradataUpdateSchemasSSLModeSSLModesMode) ToPointer() *DestinationTeradataUpdateSchemasSSLModeSSLModesMode {
	return &e
}
func (e *DestinationTeradataUpdateSchemasSSLModeSSLModesMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "require":
		*e = DestinationTeradataUpdateSchemasSSLModeSSLModesMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationTeradataUpdateSchemasSSLModeSSLModesMode: %v", v)
	}
}

// DestinationTeradataUpdateRequire - Require SSL mode.
type DestinationTeradataUpdateRequire struct {
	mode *DestinationTeradataUpdateSchemasSSLModeSSLModesMode `const:"require" json:"mode"`
}

func (d DestinationTeradataUpdateRequire) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationTeradataUpdateRequire) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationTeradataUpdateRequire) GetMode() *DestinationTeradataUpdateSchemasSSLModeSSLModesMode {
	return DestinationTeradataUpdateSchemasSSLModeSSLModesModeRequire.ToPointer()
}

type DestinationTeradataUpdateSchemasSslModeMode string

const (
	DestinationTeradataUpdateSchemasSslModeModePrefer DestinationTeradataUpdateSchemasSslModeMode = "prefer"
)

func (e DestinationTeradataUpdateSchemasSslModeMode) ToPointer() *DestinationTeradataUpdateSchemasSslModeMode {
	return &e
}
func (e *DestinationTeradataUpdateSchemasSslModeMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "prefer":
		*e = DestinationTeradataUpdateSchemasSslModeMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationTeradataUpdateSchemasSslModeMode: %v", v)
	}
}

// DestinationTeradataUpdatePrefer - Prefer SSL mode.
type DestinationTeradataUpdatePrefer struct {
	mode *DestinationTeradataUpdateSchemasSslModeMode `const:"prefer" json:"mode"`
}

func (d DestinationTeradataUpdatePrefer) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationTeradataUpdatePrefer) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationTeradataUpdatePrefer) GetMode() *DestinationTeradataUpdateSchemasSslModeMode {
	return DestinationTeradataUpdateSchemasSslModeModePrefer.ToPointer()
}

type DestinationTeradataUpdateSchemasMode string

const (
	DestinationTeradataUpdateSchemasModeAllow DestinationTeradataUpdateSchemasMode = "allow"
)

func (e DestinationTeradataUpdateSchemasMode) ToPointer() *DestinationTeradataUpdateSchemasMode {
	return &e
}
func (e *DestinationTeradataUpdateSchemasMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "allow":
		*e = DestinationTeradataUpdateSchemasMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationTeradataUpdateSchemasMode: %v", v)
	}
}

// DestinationTeradataUpdateAllow - Allow SSL mode.
type DestinationTeradataUpdateAllow struct {
	mode *DestinationTeradataUpdateSchemasMode `const:"allow" json:"mode"`
}

func (d DestinationTeradataUpdateAllow) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationTeradataUpdateAllow) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationTeradataUpdateAllow) GetMode() *DestinationTeradataUpdateSchemasMode {
	return DestinationTeradataUpdateSchemasModeAllow.ToPointer()
}

type DestinationTeradataUpdateMode string

const (
	DestinationTeradataUpdateModeDisable DestinationTeradataUpdateMode = "disable"
)

func (e DestinationTeradataUpdateMode) ToPointer() *DestinationTeradataUpdateMode {
	return &e
}
func (e *DestinationTeradataUpdateMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "disable":
		*e = DestinationTeradataUpdateMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationTeradataUpdateMode: %v", v)
	}
}

// DestinationTeradataUpdateDisable - Disable SSL.
type DestinationTeradataUpdateDisable struct {
	mode *DestinationTeradataUpdateMode `const:"disable" json:"mode"`
}

func (d DestinationTeradataUpdateDisable) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationTeradataUpdateDisable) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationTeradataUpdateDisable) GetMode() *DestinationTeradataUpdateMode {
	return DestinationTeradataUpdateModeDisable.ToPointer()
}

type DestinationTeradataUpdateSSLModesType string

const (
	DestinationTeradataUpdateSSLModesTypeDestinationTeradataUpdateDisable    DestinationTeradataUpdateSSLModesType = "destination-teradata-update_disable"
	DestinationTeradataUpdateSSLModesTypeDestinationTeradataUpdateAllow      DestinationTeradataUpdateSSLModesType = "destination-teradata-update_allow"
	DestinationTeradataUpdateSSLModesTypeDestinationTeradataUpdatePrefer     DestinationTeradataUpdateSSLModesType = "destination-teradata-update_prefer"
	DestinationTeradataUpdateSSLModesTypeDestinationTeradataUpdateRequire    DestinationTeradataUpdateSSLModesType = "destination-teradata-update_require"
	DestinationTeradataUpdateSSLModesTypeDestinationTeradataUpdateVerifyCa   DestinationTeradataUpdateSSLModesType = "destination-teradata-update_verify-ca"
	DestinationTeradataUpdateSSLModesTypeDestinationTeradataUpdateVerifyFull DestinationTeradataUpdateSSLModesType = "destination-teradata-update_verify-full"
)

// DestinationTeradataUpdateSSLModes - SSL connection modes.
//
//	<b>disable</b> - Chose this mode to disable encryption of communication between Airbyte and destination database
//	<b>allow</b> - Chose this mode to enable encryption only when required by the destination database
//	<b>prefer</b> - Chose this mode to allow unencrypted connection only if the destination database does not support encryption
//	<b>require</b> - Chose this mode to always require encryption. If the destination database server does not support encryption, connection will fail
//	 <b>verify-ca</b> - Chose this mode to always require encryption and to verify that the destination database server has a valid SSL certificate
//	 <b>verify-full</b> - This is the most secure mode. Chose this mode to always require encryption and to verify the identity of the destination database server
//	See more information - <a href="https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/jdbcug_chapter_2.html#URL_SSLMODE"> in the docs</a>.
type DestinationTeradataUpdateSSLModes struct {
	DestinationTeradataUpdateDisable    *DestinationTeradataUpdateDisable    `queryParam:"inline" union:"member"`
	DestinationTeradataUpdateAllow      *DestinationTeradataUpdateAllow      `queryParam:"inline" union:"member"`
	DestinationTeradataUpdatePrefer     *DestinationTeradataUpdatePrefer     `queryParam:"inline" union:"member"`
	DestinationTeradataUpdateRequire    *DestinationTeradataUpdateRequire    `queryParam:"inline" union:"member"`
	DestinationTeradataUpdateVerifyCa   *DestinationTeradataUpdateVerifyCa   `queryParam:"inline" union:"member"`
	DestinationTeradataUpdateVerifyFull *DestinationTeradataUpdateVerifyFull `queryParam:"inline" union:"member"`

	Type DestinationTeradataUpdateSSLModesType
}

func CreateDestinationTeradataUpdateSSLModesDestinationTeradataUpdateDisable(destinationTeradataUpdateDisable DestinationTeradataUpdateDisable) DestinationTeradataUpdateSSLModes {
	typ := DestinationTeradataUpdateSSLModesTypeDestinationTeradataUpdateDisable

	return DestinationTeradataUpdateSSLModes{
		DestinationTeradataUpdateDisable: &destinationTeradataUpdateDisable,
		Type:                             typ,
	}
}

func CreateDestinationTeradataUpdateSSLModesDestinationTeradataUpdateAllow(destinationTeradataUpdateAllow DestinationTeradataUpdateAllow) DestinationTeradataUpdateSSLModes {
	typ := DestinationTeradataUpdateSSLModesTypeDestinationTeradataUpdateAllow

	return DestinationTeradataUpdateSSLModes{
		DestinationTeradataUpdateAllow: &destinationTeradataUpdateAllow,
		Type:                           typ,
	}
}

func CreateDestinationTeradataUpdateSSLModesDestinationTeradataUpdatePrefer(destinationTeradataUpdatePrefer DestinationTeradataUpdatePrefer) DestinationTeradataUpdateSSLModes {
	typ := DestinationTeradataUpdateSSLModesTypeDestinationTeradataUpdatePrefer

	return DestinationTeradataUpdateSSLModes{
		DestinationTeradataUpdatePrefer: &destinationTeradataUpdatePrefer,
		Type:                            typ,
	}
}

func CreateDestinationTeradataUpdateSSLModesDestinationTeradataUpdateRequire(destinationTeradataUpdateRequire DestinationTeradataUpdateRequire) DestinationTeradataUpdateSSLModes {
	typ := DestinationTeradataUpdateSSLModesTypeDestinationTeradataUpdateRequire

	return DestinationTeradataUpdateSSLModes{
		DestinationTeradataUpdateRequire: &destinationTeradataUpdateRequire,
		Type:                             typ,
	}
}

func CreateDestinationTeradataUpdateSSLModesDestinationTeradataUpdateVerifyCa(destinationTeradataUpdateVerifyCa DestinationTeradataUpdateVerifyCa) DestinationTeradataUpdateSSLModes {
	typ := DestinationTeradataUpdateSSLModesTypeDestinationTeradataUpdateVerifyCa

	return DestinationTeradataUpdateSSLModes{
		DestinationTeradataUpdateVerifyCa: &destinationTeradataUpdateVerifyCa,
		Type:                              typ,
	}
}

func CreateDestinationTeradataUpdateSSLModesDestinationTeradataUpdateVerifyFull(destinationTeradataUpdateVerifyFull DestinationTeradataUpdateVerifyFull) DestinationTeradataUpdateSSLModes {
	typ := DestinationTeradataUpdateSSLModesTypeDestinationTeradataUpdateVerifyFull

	return DestinationTeradataUpdateSSLModes{
		DestinationTeradataUpdateVerifyFull: &destinationTeradataUpdateVerifyFull,
		Type:                                typ,
	}
}

func (u *DestinationTeradataUpdateSSLModes) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var destinationTeradataUpdateDisable DestinationTeradataUpdateDisable = DestinationTeradataUpdateDisable{}
	if err := utils.UnmarshalJSON(data, &destinationTeradataUpdateDisable, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationTeradataUpdateSSLModesTypeDestinationTeradataUpdateDisable,
			Value: &destinationTeradataUpdateDisable,
		})
	}

	var destinationTeradataUpdateAllow DestinationTeradataUpdateAllow = DestinationTeradataUpdateAllow{}
	if err := utils.UnmarshalJSON(data, &destinationTeradataUpdateAllow, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationTeradataUpdateSSLModesTypeDestinationTeradataUpdateAllow,
			Value: &destinationTeradataUpdateAllow,
		})
	}

	var destinationTeradataUpdatePrefer DestinationTeradataUpdatePrefer = DestinationTeradataUpdatePrefer{}
	if err := utils.UnmarshalJSON(data, &destinationTeradataUpdatePrefer, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationTeradataUpdateSSLModesTypeDestinationTeradataUpdatePrefer,
			Value: &destinationTeradataUpdatePrefer,
		})
	}

	var destinationTeradataUpdateRequire DestinationTeradataUpdateRequire = DestinationTeradataUpdateRequire{}
	if err := utils.UnmarshalJSON(data, &destinationTeradataUpdateRequire, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationTeradataUpdateSSLModesTypeDestinationTeradataUpdateRequire,
			Value: &destinationTeradataUpdateRequire,
		})
	}

	var destinationTeradataUpdateVerifyCa DestinationTeradataUpdateVerifyCa = DestinationTeradataUpdateVerifyCa{}
	if err := utils.UnmarshalJSON(data, &destinationTeradataUpdateVerifyCa, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationTeradataUpdateSSLModesTypeDestinationTeradataUpdateVerifyCa,
			Value: &destinationTeradataUpdateVerifyCa,
		})
	}

	var destinationTeradataUpdateVerifyFull DestinationTeradataUpdateVerifyFull = DestinationTeradataUpdateVerifyFull{}
	if err := utils.UnmarshalJSON(data, &destinationTeradataUpdateVerifyFull, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationTeradataUpdateSSLModesTypeDestinationTeradataUpdateVerifyFull,
			Value: &destinationTeradataUpdateVerifyFull,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationTeradataUpdateSSLModes", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationTeradataUpdateSSLModes", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(DestinationTeradataUpdateSSLModesType)
	switch best.Type {
	case DestinationTeradataUpdateSSLModesTypeDestinationTeradataUpdateDisable:
		u.DestinationTeradataUpdateDisable = best.Value.(*DestinationTeradataUpdateDisable)
		return nil
	case DestinationTeradataUpdateSSLModesTypeDestinationTeradataUpdateAllow:
		u.DestinationTeradataUpdateAllow = best.Value.(*DestinationTeradataUpdateAllow)
		return nil
	case DestinationTeradataUpdateSSLModesTypeDestinationTeradataUpdatePrefer:
		u.DestinationTeradataUpdatePrefer = best.Value.(*DestinationTeradataUpdatePrefer)
		return nil
	case DestinationTeradataUpdateSSLModesTypeDestinationTeradataUpdateRequire:
		u.DestinationTeradataUpdateRequire = best.Value.(*DestinationTeradataUpdateRequire)
		return nil
	case DestinationTeradataUpdateSSLModesTypeDestinationTeradataUpdateVerifyCa:
		u.DestinationTeradataUpdateVerifyCa = best.Value.(*DestinationTeradataUpdateVerifyCa)
		return nil
	case DestinationTeradataUpdateSSLModesTypeDestinationTeradataUpdateVerifyFull:
		u.DestinationTeradataUpdateVerifyFull = best.Value.(*DestinationTeradataUpdateVerifyFull)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationTeradataUpdateSSLModes", string(data))
}

func (u DestinationTeradataUpdateSSLModes) MarshalJSON() ([]byte, error) {
	if u.DestinationTeradataUpdateDisable != nil {
		return utils.MarshalJSON(u.DestinationTeradataUpdateDisable, "", true)
	}

	if u.DestinationTeradataUpdateAllow != nil {
		return utils.MarshalJSON(u.DestinationTeradataUpdateAllow, "", true)
	}

	if u.DestinationTeradataUpdatePrefer != nil {
		return utils.MarshalJSON(u.DestinationTeradataUpdatePrefer, "", true)
	}

	if u.DestinationTeradataUpdateRequire != nil {
		return utils.MarshalJSON(u.DestinationTeradataUpdateRequire, "", true)
	}

	if u.DestinationTeradataUpdateVerifyCa != nil {
		return utils.MarshalJSON(u.DestinationTeradataUpdateVerifyCa, "", true)
	}

	if u.DestinationTeradataUpdateVerifyFull != nil {
		return utils.MarshalJSON(u.DestinationTeradataUpdateVerifyFull, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationTeradataUpdateSSLModes: all fields are null")
}

type DestinationTeradataUpdateDestinationType string

const (
	DestinationTeradataUpdateDestinationTypeTeradata DestinationTeradataUpdateDestinationType = "teradata"
)

func (e DestinationTeradataUpdateDestinationType) ToPointer() *DestinationTeradataUpdateDestinationType {
	return &e
}
func (e *DestinationTeradataUpdateDestinationType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "teradata":
		*e = DestinationTeradataUpdateDestinationType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationTeradataUpdateDestinationType: %v", v)
	}
}

type DestinationTeradataUpdate struct {
	// Disable Writing Final Tables. WARNING! The data format in _airbyte_data is likely stable but there are no guarantees that other metadata columns will remain the same in future versions
	DisableTypeDedupe *bool `default:"false" json:"disable_type_dedupe"`
	// Drop tables with CASCADE. WARNING! This will delete all data in all dependent objects (views, etc.). Use with caution. This option is intended for usecases which can easily rebuild the dependent objects.
	DropCascade *bool `default:"false" json:"drop_cascade"`
	// Hostname of the database.
	Host *string `json:"host,omitempty"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
	JdbcURLParams *string                                          `json:"jdbc_url_params,omitempty"`
	Logmech       *DestinationTeradataUpdateAuthorizationMechanism `json:"logmech,omitempty"`
	// Defines the custom session query band using name-value pairs. For example, 'org=Finance;report=Fin123;'
	QueryBand *string `json:"query_band,omitempty"`
	// The database to write raw tables into
	RawDataSchema *string `json:"raw_data_schema,omitempty"`
	// The default schema tables are written to if the source does not specify a namespace. The usual value for this field is "public".
	Schema *string `default:"airbyte_td" json:"schema"`
	// Encrypt data using SSL. When activating SSL, please select one of the SSL modes.
	Ssl *bool `default:"false" json:"ssl"`
	// SSL connection modes.
	//  <b>disable</b> - Chose this mode to disable encryption of communication between Airbyte and destination database
	//  <b>allow</b> - Chose this mode to enable encryption only when required by the destination database
	//  <b>prefer</b> - Chose this mode to allow unencrypted connection only if the destination database does not support encryption
	//  <b>require</b> - Chose this mode to always require encryption. If the destination database server does not support encryption, connection will fail
	//   <b>verify-ca</b> - Chose this mode to always require encryption and to verify that the destination database server has a valid SSL certificate
	//   <b>verify-full</b> - This is the most secure mode. Chose this mode to always require encryption and to verify the identity of the destination database server
	//  See more information - <a href="https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/jdbcug_chapter_2.html#URL_SSLMODE"> in the docs</a>.
	SslMode              *DestinationTeradataUpdateSSLModes        `json:"ssl_mode,omitempty"`
	destinationType      *DestinationTeradataUpdateDestinationType `const:"teradata" json:"destinationType"`
	AdditionalProperties any                                       `additionalProperties:"true" json:"-"`
}

func (d DestinationTeradataUpdate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationTeradataUpdate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationTeradataUpdate) GetDisableTypeDedupe() *bool {
	if d == nil {
		return nil
	}
	return d.DisableTypeDedupe
}

func (d *DestinationTeradataUpdate) GetDropCascade() *bool {
	if d == nil {
		return nil
	}
	return d.DropCascade
}

func (d *DestinationTeradataUpdate) GetHost() *string {
	if d == nil {
		return nil
	}
	return d.Host
}

func (d *DestinationTeradataUpdate) GetJdbcURLParams() *string {
	if d == nil {
		return nil
	}
	return d.JdbcURLParams
}

func (d *DestinationTeradataUpdate) GetLogmech() *DestinationTeradataUpdateAuthorizationMechanism {
	if d == nil {
		return nil
	}
	return d.Logmech
}

func (d *DestinationTeradataUpdate) GetQueryBand() *string {
	if d == nil {
		return nil
	}
	return d.QueryBand
}

func (d *DestinationTeradataUpdate) GetRawDataSchema() *string {
	if d == nil {
		return nil
	}
	return d.RawDataSchema
}

func (d *DestinationTeradataUpdate) GetSchema() *string {
	if d == nil {
		return nil
	}
	return d.Schema
}

func (d *DestinationTeradataUpdate) GetSsl() *bool {
	if d == nil {
		return nil
	}
	return d.Ssl
}

func (d *DestinationTeradataUpdate) GetSslMode() *DestinationTeradataUpdateSSLModes {
	if d == nil {
		return nil
	}
	return d.SslMode
}

func (d *DestinationTeradataUpdate) GetDestinationType() *DestinationTeradataUpdateDestinationType {
	return DestinationTeradataUpdateDestinationTypeTeradata.ToPointer()
}

func (d *DestinationTeradataUpdate) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}
