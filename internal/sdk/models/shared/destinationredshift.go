// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

type DestinationRedshiftPasswordAuthentication struct {
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and password authentication
	tunnelMethod string `const:"SSH_PASSWORD_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser string `json:"tunnel_user"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword string `json:"tunnel_user_password"`
}

func (d DestinationRedshiftPasswordAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationRedshiftPasswordAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationRedshiftPasswordAuthentication) GetTunnelHost() string {
	if d == nil {
		return ""
	}
	return d.TunnelHost
}

func (d *DestinationRedshiftPasswordAuthentication) GetTunnelMethod() string {
	return "SSH_PASSWORD_AUTH"
}

func (d *DestinationRedshiftPasswordAuthentication) GetTunnelPort() *int64 {
	if d == nil {
		return nil
	}
	return d.TunnelPort
}

func (d *DestinationRedshiftPasswordAuthentication) GetTunnelUser() string {
	if d == nil {
		return ""
	}
	return d.TunnelUser
}

func (d *DestinationRedshiftPasswordAuthentication) GetTunnelUserPassword() string {
	if d == nil {
		return ""
	}
	return d.TunnelUserPassword
}

type DestinationRedshiftSSHKeyAuthentication struct {
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey string `json:"ssh_key"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and ssh key
	tunnelMethod string `const:"SSH_KEY_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host.
	TunnelUser string `json:"tunnel_user"`
}

func (d DestinationRedshiftSSHKeyAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationRedshiftSSHKeyAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationRedshiftSSHKeyAuthentication) GetSSHKey() string {
	if d == nil {
		return ""
	}
	return d.SSHKey
}

func (d *DestinationRedshiftSSHKeyAuthentication) GetTunnelHost() string {
	if d == nil {
		return ""
	}
	return d.TunnelHost
}

func (d *DestinationRedshiftSSHKeyAuthentication) GetTunnelMethod() string {
	return "SSH_KEY_AUTH"
}

func (d *DestinationRedshiftSSHKeyAuthentication) GetTunnelPort() *int64 {
	if d == nil {
		return nil
	}
	return d.TunnelPort
}

func (d *DestinationRedshiftSSHKeyAuthentication) GetTunnelUser() string {
	if d == nil {
		return ""
	}
	return d.TunnelUser
}

type DestinationRedshiftNoTunnel struct {
	// No ssh tunnel needed to connect to database
	tunnelMethod string `const:"NO_TUNNEL" json:"tunnel_method"`
}

func (d DestinationRedshiftNoTunnel) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationRedshiftNoTunnel) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationRedshiftNoTunnel) GetTunnelMethod() string {
	return "NO_TUNNEL"
}

type DestinationRedshiftSSHTunnelMethodType string

const (
	DestinationRedshiftSSHTunnelMethodTypeDestinationRedshiftNoTunnel               DestinationRedshiftSSHTunnelMethodType = "destination-redshift_No Tunnel"
	DestinationRedshiftSSHTunnelMethodTypeDestinationRedshiftSSHKeyAuthentication   DestinationRedshiftSSHTunnelMethodType = "destination-redshift_SSH Key Authentication"
	DestinationRedshiftSSHTunnelMethodTypeDestinationRedshiftPasswordAuthentication DestinationRedshiftSSHTunnelMethodType = "destination-redshift_Password Authentication"
)

// DestinationRedshiftSSHTunnelMethod - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type DestinationRedshiftSSHTunnelMethod struct {
	DestinationRedshiftNoTunnel               *DestinationRedshiftNoTunnel               `queryParam:"inline" union:"member"`
	DestinationRedshiftSSHKeyAuthentication   *DestinationRedshiftSSHKeyAuthentication   `queryParam:"inline" union:"member"`
	DestinationRedshiftPasswordAuthentication *DestinationRedshiftPasswordAuthentication `queryParam:"inline" union:"member"`

	Type DestinationRedshiftSSHTunnelMethodType
}

func CreateDestinationRedshiftSSHTunnelMethodDestinationRedshiftNoTunnel(destinationRedshiftNoTunnel DestinationRedshiftNoTunnel) DestinationRedshiftSSHTunnelMethod {
	typ := DestinationRedshiftSSHTunnelMethodTypeDestinationRedshiftNoTunnel

	return DestinationRedshiftSSHTunnelMethod{
		DestinationRedshiftNoTunnel: &destinationRedshiftNoTunnel,
		Type:                        typ,
	}
}

func CreateDestinationRedshiftSSHTunnelMethodDestinationRedshiftSSHKeyAuthentication(destinationRedshiftSSHKeyAuthentication DestinationRedshiftSSHKeyAuthentication) DestinationRedshiftSSHTunnelMethod {
	typ := DestinationRedshiftSSHTunnelMethodTypeDestinationRedshiftSSHKeyAuthentication

	return DestinationRedshiftSSHTunnelMethod{
		DestinationRedshiftSSHKeyAuthentication: &destinationRedshiftSSHKeyAuthentication,
		Type:                                    typ,
	}
}

func CreateDestinationRedshiftSSHTunnelMethodDestinationRedshiftPasswordAuthentication(destinationRedshiftPasswordAuthentication DestinationRedshiftPasswordAuthentication) DestinationRedshiftSSHTunnelMethod {
	typ := DestinationRedshiftSSHTunnelMethodTypeDestinationRedshiftPasswordAuthentication

	return DestinationRedshiftSSHTunnelMethod{
		DestinationRedshiftPasswordAuthentication: &destinationRedshiftPasswordAuthentication,
		Type: typ,
	}
}

func (u *DestinationRedshiftSSHTunnelMethod) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var destinationRedshiftNoTunnel DestinationRedshiftNoTunnel = DestinationRedshiftNoTunnel{}
	if err := utils.UnmarshalJSON(data, &destinationRedshiftNoTunnel, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationRedshiftSSHTunnelMethodTypeDestinationRedshiftNoTunnel,
			Value: &destinationRedshiftNoTunnel,
		})
	}

	var destinationRedshiftSSHKeyAuthentication DestinationRedshiftSSHKeyAuthentication = DestinationRedshiftSSHKeyAuthentication{}
	if err := utils.UnmarshalJSON(data, &destinationRedshiftSSHKeyAuthentication, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationRedshiftSSHTunnelMethodTypeDestinationRedshiftSSHKeyAuthentication,
			Value: &destinationRedshiftSSHKeyAuthentication,
		})
	}

	var destinationRedshiftPasswordAuthentication DestinationRedshiftPasswordAuthentication = DestinationRedshiftPasswordAuthentication{}
	if err := utils.UnmarshalJSON(data, &destinationRedshiftPasswordAuthentication, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationRedshiftSSHTunnelMethodTypeDestinationRedshiftPasswordAuthentication,
			Value: &destinationRedshiftPasswordAuthentication,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationRedshiftSSHTunnelMethod", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationRedshiftSSHTunnelMethod", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(DestinationRedshiftSSHTunnelMethodType)
	switch best.Type {
	case DestinationRedshiftSSHTunnelMethodTypeDestinationRedshiftNoTunnel:
		u.DestinationRedshiftNoTunnel = best.Value.(*DestinationRedshiftNoTunnel)
		return nil
	case DestinationRedshiftSSHTunnelMethodTypeDestinationRedshiftSSHKeyAuthentication:
		u.DestinationRedshiftSSHKeyAuthentication = best.Value.(*DestinationRedshiftSSHKeyAuthentication)
		return nil
	case DestinationRedshiftSSHTunnelMethodTypeDestinationRedshiftPasswordAuthentication:
		u.DestinationRedshiftPasswordAuthentication = best.Value.(*DestinationRedshiftPasswordAuthentication)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationRedshiftSSHTunnelMethod", string(data))
}

func (u DestinationRedshiftSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.DestinationRedshiftNoTunnel != nil {
		return utils.MarshalJSON(u.DestinationRedshiftNoTunnel, "", true)
	}

	if u.DestinationRedshiftSSHKeyAuthentication != nil {
		return utils.MarshalJSON(u.DestinationRedshiftSSHKeyAuthentication, "", true)
	}

	if u.DestinationRedshiftPasswordAuthentication != nil {
		return utils.MarshalJSON(u.DestinationRedshiftPasswordAuthentication, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationRedshiftSSHTunnelMethod: all fields are null")
}

// DestinationRedshiftS3BucketRegion - The region of the S3 staging bucket.
type DestinationRedshiftS3BucketRegion string

const (
	DestinationRedshiftS3BucketRegionUnknown      DestinationRedshiftS3BucketRegion = ""
	DestinationRedshiftS3BucketRegionAfSouth1     DestinationRedshiftS3BucketRegion = "af-south-1"
	DestinationRedshiftS3BucketRegionApEast1      DestinationRedshiftS3BucketRegion = "ap-east-1"
	DestinationRedshiftS3BucketRegionApNortheast1 DestinationRedshiftS3BucketRegion = "ap-northeast-1"
	DestinationRedshiftS3BucketRegionApNortheast2 DestinationRedshiftS3BucketRegion = "ap-northeast-2"
	DestinationRedshiftS3BucketRegionApNortheast3 DestinationRedshiftS3BucketRegion = "ap-northeast-3"
	DestinationRedshiftS3BucketRegionApSouth1     DestinationRedshiftS3BucketRegion = "ap-south-1"
	DestinationRedshiftS3BucketRegionApSouth2     DestinationRedshiftS3BucketRegion = "ap-south-2"
	DestinationRedshiftS3BucketRegionApSoutheast1 DestinationRedshiftS3BucketRegion = "ap-southeast-1"
	DestinationRedshiftS3BucketRegionApSoutheast2 DestinationRedshiftS3BucketRegion = "ap-southeast-2"
	DestinationRedshiftS3BucketRegionApSoutheast3 DestinationRedshiftS3BucketRegion = "ap-southeast-3"
	DestinationRedshiftS3BucketRegionApSoutheast4 DestinationRedshiftS3BucketRegion = "ap-southeast-4"
	DestinationRedshiftS3BucketRegionCaCentral1   DestinationRedshiftS3BucketRegion = "ca-central-1"
	DestinationRedshiftS3BucketRegionCaWest1      DestinationRedshiftS3BucketRegion = "ca-west-1"
	DestinationRedshiftS3BucketRegionCnNorth1     DestinationRedshiftS3BucketRegion = "cn-north-1"
	DestinationRedshiftS3BucketRegionCnNorthwest1 DestinationRedshiftS3BucketRegion = "cn-northwest-1"
	DestinationRedshiftS3BucketRegionEuCentral1   DestinationRedshiftS3BucketRegion = "eu-central-1"
	DestinationRedshiftS3BucketRegionEuCentral2   DestinationRedshiftS3BucketRegion = "eu-central-2"
	DestinationRedshiftS3BucketRegionEuNorth1     DestinationRedshiftS3BucketRegion = "eu-north-1"
	DestinationRedshiftS3BucketRegionEuSouth1     DestinationRedshiftS3BucketRegion = "eu-south-1"
	DestinationRedshiftS3BucketRegionEuSouth2     DestinationRedshiftS3BucketRegion = "eu-south-2"
	DestinationRedshiftS3BucketRegionEuWest1      DestinationRedshiftS3BucketRegion = "eu-west-1"
	DestinationRedshiftS3BucketRegionEuWest2      DestinationRedshiftS3BucketRegion = "eu-west-2"
	DestinationRedshiftS3BucketRegionEuWest3      DestinationRedshiftS3BucketRegion = "eu-west-3"
	DestinationRedshiftS3BucketRegionIlCentral1   DestinationRedshiftS3BucketRegion = "il-central-1"
	DestinationRedshiftS3BucketRegionMeCentral1   DestinationRedshiftS3BucketRegion = "me-central-1"
	DestinationRedshiftS3BucketRegionMeSouth1     DestinationRedshiftS3BucketRegion = "me-south-1"
	DestinationRedshiftS3BucketRegionSaEast1      DestinationRedshiftS3BucketRegion = "sa-east-1"
	DestinationRedshiftS3BucketRegionUsEast1      DestinationRedshiftS3BucketRegion = "us-east-1"
	DestinationRedshiftS3BucketRegionUsEast2      DestinationRedshiftS3BucketRegion = "us-east-2"
	DestinationRedshiftS3BucketRegionUsGovEast1   DestinationRedshiftS3BucketRegion = "us-gov-east-1"
	DestinationRedshiftS3BucketRegionUsGovWest1   DestinationRedshiftS3BucketRegion = "us-gov-west-1"
	DestinationRedshiftS3BucketRegionUsWest1      DestinationRedshiftS3BucketRegion = "us-west-1"
	DestinationRedshiftS3BucketRegionUsWest2      DestinationRedshiftS3BucketRegion = "us-west-2"
)

func (e DestinationRedshiftS3BucketRegion) ToPointer() *DestinationRedshiftS3BucketRegion {
	return &e
}
func (e *DestinationRedshiftS3BucketRegion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "":
		fallthrough
	case "af-south-1":
		fallthrough
	case "ap-east-1":
		fallthrough
	case "ap-northeast-1":
		fallthrough
	case "ap-northeast-2":
		fallthrough
	case "ap-northeast-3":
		fallthrough
	case "ap-south-1":
		fallthrough
	case "ap-south-2":
		fallthrough
	case "ap-southeast-1":
		fallthrough
	case "ap-southeast-2":
		fallthrough
	case "ap-southeast-3":
		fallthrough
	case "ap-southeast-4":
		fallthrough
	case "ca-central-1":
		fallthrough
	case "ca-west-1":
		fallthrough
	case "cn-north-1":
		fallthrough
	case "cn-northwest-1":
		fallthrough
	case "eu-central-1":
		fallthrough
	case "eu-central-2":
		fallthrough
	case "eu-north-1":
		fallthrough
	case "eu-south-1":
		fallthrough
	case "eu-south-2":
		fallthrough
	case "eu-west-1":
		fallthrough
	case "eu-west-2":
		fallthrough
	case "eu-west-3":
		fallthrough
	case "il-central-1":
		fallthrough
	case "me-central-1":
		fallthrough
	case "me-south-1":
		fallthrough
	case "sa-east-1":
		fallthrough
	case "us-east-1":
		fallthrough
	case "us-east-2":
		fallthrough
	case "us-gov-east-1":
		fallthrough
	case "us-gov-west-1":
		fallthrough
	case "us-west-1":
		fallthrough
	case "us-west-2":
		*e = DestinationRedshiftS3BucketRegion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationRedshiftS3BucketRegion: %v", v)
	}
}

// AWSS3Staging - <i>(recommended)</i> Uploads data to S3 and then uses a COPY to insert the data into Redshift. COPY is recommended for production workloads for better speed and scalability. See <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/creating-bucket.html">AWS docs</a> for more details.
type AWSS3Staging struct {
	// This ID grants access to the above S3 staging bucket. Airbyte requires Read and Write permissions to the given bucket. See <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">AWS docs</a> on how to generate an access key ID and secret access key.
	AccessKeyID string `json:"access_key_id"`
	// The pattern allows you to set the file-name format for the S3 staging file(s)
	FileNamePattern *string `json:"file_name_pattern,omitempty"`
	method          string  `const:"S3 Staging" json:"method"`
	// Whether to delete the staging files from S3 after completing the sync. See <a href="https://docs.airbyte.com/integrations/destinations/redshift/#:~:text=the%20root%20directory.-,Purge%20Staging%20Data,-Whether%20to%20delete"> docs</a> for details.
	PurgeStagingData *bool `default:"true" json:"purge_staging_data"`
	// The name of the staging S3 bucket.
	S3BucketName string `json:"s3_bucket_name"`
	// The directory under the S3 bucket where data will be written. If not provided, then defaults to the root directory. See <a href="https://docs.aws.amazon.com/prescriptive-guidance/latest/defining-bucket-names-data-lakes/faq.html#:~:text=be%20globally%20unique.-,For%20S3%20bucket%20paths,-%2C%20you%20can%20use">path's name recommendations</a> for more details.
	S3BucketPath *string `json:"s3_bucket_path,omitempty"`
	// The region of the S3 staging bucket.
	S3BucketRegion *DestinationRedshiftS3BucketRegion `default:"" json:"s3_bucket_region"`
	// The corresponding secret to the above access key id. See <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">AWS docs</a> on how to generate an access key ID and secret access key.
	SecretAccessKey string `json:"secret_access_key"`
}

func (a AWSS3Staging) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AWSS3Staging) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (a *AWSS3Staging) GetAccessKeyID() string {
	if a == nil {
		return ""
	}
	return a.AccessKeyID
}

func (a *AWSS3Staging) GetFileNamePattern() *string {
	if a == nil {
		return nil
	}
	return a.FileNamePattern
}

func (a *AWSS3Staging) GetMethod() string {
	return "S3 Staging"
}

func (a *AWSS3Staging) GetPurgeStagingData() *bool {
	if a == nil {
		return nil
	}
	return a.PurgeStagingData
}

func (a *AWSS3Staging) GetS3BucketName() string {
	if a == nil {
		return ""
	}
	return a.S3BucketName
}

func (a *AWSS3Staging) GetS3BucketPath() *string {
	if a == nil {
		return nil
	}
	return a.S3BucketPath
}

func (a *AWSS3Staging) GetS3BucketRegion() *DestinationRedshiftS3BucketRegion {
	if a == nil {
		return nil
	}
	return a.S3BucketRegion
}

func (a *AWSS3Staging) GetSecretAccessKey() string {
	if a == nil {
		return ""
	}
	return a.SecretAccessKey
}

type UploadingMethodType string

const (
	UploadingMethodTypeAWSS3Staging UploadingMethodType = "AWS S3 Staging"
)

// UploadingMethod - The way data will be uploaded to Redshift.
type UploadingMethod struct {
	AWSS3Staging *AWSS3Staging `queryParam:"inline" union:"member"`

	Type UploadingMethodType
}

func CreateUploadingMethodAWSS3Staging(awsS3Staging AWSS3Staging) UploadingMethod {
	typ := UploadingMethodTypeAWSS3Staging

	return UploadingMethod{
		AWSS3Staging: &awsS3Staging,
		Type:         typ,
	}
}

func (u *UploadingMethod) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var awsS3Staging AWSS3Staging = AWSS3Staging{}
	if err := utils.UnmarshalJSON(data, &awsS3Staging, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  UploadingMethodTypeAWSS3Staging,
			Value: &awsS3Staging,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for UploadingMethod", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for UploadingMethod", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(UploadingMethodType)
	switch best.Type {
	case UploadingMethodTypeAWSS3Staging:
		u.AWSS3Staging = best.Value.(*AWSS3Staging)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for UploadingMethod", string(data))
}

func (u UploadingMethod) MarshalJSON() ([]byte, error) {
	if u.AWSS3Staging != nil {
		return utils.MarshalJSON(u.AWSS3Staging, "", true)
	}

	return nil, errors.New("could not marshal union type UploadingMethod: all fields are null")
}

type DestinationRedshiftDestinationType string

const (
	DestinationRedshiftDestinationTypeRedshift DestinationRedshiftDestinationType = "redshift"
)

func (e DestinationRedshiftDestinationType) ToPointer() *DestinationRedshiftDestinationType {
	return &e
}
func (e *DestinationRedshiftDestinationType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "redshift":
		*e = DestinationRedshiftDestinationType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationRedshiftDestinationType: %v", v)
	}
}

type DestinationRedshift struct {
	// Name of the database.
	Database string `json:"database"`
	// Disable Writing Final Tables. WARNING! The data format in _airbyte_data is likely stable but there are no guarantees that other metadata columns will remain the same in future versions
	DisableTypeDedupe *bool `default:"false" json:"disable_type_dedupe"`
	// Drop tables with CASCADE. WARNING! This will delete all data in all dependent objects (views, etc.). Use with caution. This option is intended for usecases which can easily rebuild the dependent objects.
	DropCascade *bool `default:"false" json:"drop_cascade"`
	// Host Endpoint of the Redshift Cluster (must include the cluster-id, region and end with .redshift.amazonaws.com)
	Host string `json:"host"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// Password associated with the username.
	Password string `json:"password"`
	// Port of the database.
	Port *int64 `default:"5439" json:"port"`
	// The schema to write raw tables into (default: airbyte_internal).
	RawDataSchema *string `json:"raw_data_schema,omitempty"`
	// The default schema tables are written to if the source does not specify a namespace. Unless specifically configured, the usual value for this field is "public".
	Schema *string `default:"public" json:"schema"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod *DestinationRedshiftSSHTunnelMethod `json:"tunnel_method,omitempty"`
	// The way data will be uploaded to Redshift.
	UploadingMethod *UploadingMethod `json:"uploading_method,omitempty"`
	// Username to use to access the database.
	Username             string                              `json:"username"`
	destinationType      *DestinationRedshiftDestinationType `const:"redshift" json:"destinationType"`
	AdditionalProperties any                                 `additionalProperties:"true" json:"-"`
}

func (d DestinationRedshift) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationRedshift) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationRedshift) GetDatabase() string {
	if d == nil {
		return ""
	}
	return d.Database
}

func (d *DestinationRedshift) GetDisableTypeDedupe() *bool {
	if d == nil {
		return nil
	}
	return d.DisableTypeDedupe
}

func (d *DestinationRedshift) GetDropCascade() *bool {
	if d == nil {
		return nil
	}
	return d.DropCascade
}

func (d *DestinationRedshift) GetHost() string {
	if d == nil {
		return ""
	}
	return d.Host
}

func (d *DestinationRedshift) GetJdbcURLParams() *string {
	if d == nil {
		return nil
	}
	return d.JdbcURLParams
}

func (d *DestinationRedshift) GetPassword() string {
	if d == nil {
		return ""
	}
	return d.Password
}

func (d *DestinationRedshift) GetPort() *int64 {
	if d == nil {
		return nil
	}
	return d.Port
}

func (d *DestinationRedshift) GetRawDataSchema() *string {
	if d == nil {
		return nil
	}
	return d.RawDataSchema
}

func (d *DestinationRedshift) GetSchema() *string {
	if d == nil {
		return nil
	}
	return d.Schema
}

func (d *DestinationRedshift) GetTunnelMethod() *DestinationRedshiftSSHTunnelMethod {
	if d == nil {
		return nil
	}
	return d.TunnelMethod
}

func (d *DestinationRedshift) GetUploadingMethod() *UploadingMethod {
	if d == nil {
		return nil
	}
	return d.UploadingMethod
}

func (d *DestinationRedshift) GetUsername() string {
	if d == nil {
		return ""
	}
	return d.Username
}

func (d *DestinationRedshift) GetDestinationType() *DestinationRedshiftDestinationType {
	return DestinationRedshiftDestinationTypeRedshift.ToPointer()
}

func (d *DestinationRedshift) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}
