// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

type DestinationRedshiftMethod string

const (
	DestinationRedshiftMethodS3Staging DestinationRedshiftMethod = "S3 Staging"
)

func (e DestinationRedshiftMethod) ToPointer() *DestinationRedshiftMethod {
	return &e
}
func (e *DestinationRedshiftMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "S3 Staging":
		*e = DestinationRedshiftMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationRedshiftMethod: %v", v)
	}
}

// DestinationRedshiftS3BucketRegion - The region of the S3 staging bucket.
type DestinationRedshiftS3BucketRegion string

const (
	DestinationRedshiftS3BucketRegionUnknown      DestinationRedshiftS3BucketRegion = ""
	DestinationRedshiftS3BucketRegionAfSouth1     DestinationRedshiftS3BucketRegion = "af-south-1"
	DestinationRedshiftS3BucketRegionApEast1      DestinationRedshiftS3BucketRegion = "ap-east-1"
	DestinationRedshiftS3BucketRegionApNortheast1 DestinationRedshiftS3BucketRegion = "ap-northeast-1"
	DestinationRedshiftS3BucketRegionApNortheast2 DestinationRedshiftS3BucketRegion = "ap-northeast-2"
	DestinationRedshiftS3BucketRegionApNortheast3 DestinationRedshiftS3BucketRegion = "ap-northeast-3"
	DestinationRedshiftS3BucketRegionApSouth1     DestinationRedshiftS3BucketRegion = "ap-south-1"
	DestinationRedshiftS3BucketRegionApSouth2     DestinationRedshiftS3BucketRegion = "ap-south-2"
	DestinationRedshiftS3BucketRegionApSoutheast1 DestinationRedshiftS3BucketRegion = "ap-southeast-1"
	DestinationRedshiftS3BucketRegionApSoutheast2 DestinationRedshiftS3BucketRegion = "ap-southeast-2"
	DestinationRedshiftS3BucketRegionApSoutheast3 DestinationRedshiftS3BucketRegion = "ap-southeast-3"
	DestinationRedshiftS3BucketRegionApSoutheast4 DestinationRedshiftS3BucketRegion = "ap-southeast-4"
	DestinationRedshiftS3BucketRegionCaCentral1   DestinationRedshiftS3BucketRegion = "ca-central-1"
	DestinationRedshiftS3BucketRegionCaWest1      DestinationRedshiftS3BucketRegion = "ca-west-1"
	DestinationRedshiftS3BucketRegionCnNorth1     DestinationRedshiftS3BucketRegion = "cn-north-1"
	DestinationRedshiftS3BucketRegionCnNorthwest1 DestinationRedshiftS3BucketRegion = "cn-northwest-1"
	DestinationRedshiftS3BucketRegionEuCentral1   DestinationRedshiftS3BucketRegion = "eu-central-1"
	DestinationRedshiftS3BucketRegionEuCentral2   DestinationRedshiftS3BucketRegion = "eu-central-2"
	DestinationRedshiftS3BucketRegionEuNorth1     DestinationRedshiftS3BucketRegion = "eu-north-1"
	DestinationRedshiftS3BucketRegionEuSouth1     DestinationRedshiftS3BucketRegion = "eu-south-1"
	DestinationRedshiftS3BucketRegionEuSouth2     DestinationRedshiftS3BucketRegion = "eu-south-2"
	DestinationRedshiftS3BucketRegionEuWest1      DestinationRedshiftS3BucketRegion = "eu-west-1"
	DestinationRedshiftS3BucketRegionEuWest2      DestinationRedshiftS3BucketRegion = "eu-west-2"
	DestinationRedshiftS3BucketRegionEuWest3      DestinationRedshiftS3BucketRegion = "eu-west-3"
	DestinationRedshiftS3BucketRegionIlCentral1   DestinationRedshiftS3BucketRegion = "il-central-1"
	DestinationRedshiftS3BucketRegionMeCentral1   DestinationRedshiftS3BucketRegion = "me-central-1"
	DestinationRedshiftS3BucketRegionMeSouth1     DestinationRedshiftS3BucketRegion = "me-south-1"
	DestinationRedshiftS3BucketRegionSaEast1      DestinationRedshiftS3BucketRegion = "sa-east-1"
	DestinationRedshiftS3BucketRegionUsEast1      DestinationRedshiftS3BucketRegion = "us-east-1"
	DestinationRedshiftS3BucketRegionUsEast2      DestinationRedshiftS3BucketRegion = "us-east-2"
	DestinationRedshiftS3BucketRegionUsGovEast1   DestinationRedshiftS3BucketRegion = "us-gov-east-1"
	DestinationRedshiftS3BucketRegionUsGovWest1   DestinationRedshiftS3BucketRegion = "us-gov-west-1"
	DestinationRedshiftS3BucketRegionUsWest1      DestinationRedshiftS3BucketRegion = "us-west-1"
	DestinationRedshiftS3BucketRegionUsWest2      DestinationRedshiftS3BucketRegion = "us-west-2"
)

func (e DestinationRedshiftS3BucketRegion) ToPointer() *DestinationRedshiftS3BucketRegion {
	return &e
}
func (e *DestinationRedshiftS3BucketRegion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "":
		fallthrough
	case "af-south-1":
		fallthrough
	case "ap-east-1":
		fallthrough
	case "ap-northeast-1":
		fallthrough
	case "ap-northeast-2":
		fallthrough
	case "ap-northeast-3":
		fallthrough
	case "ap-south-1":
		fallthrough
	case "ap-south-2":
		fallthrough
	case "ap-southeast-1":
		fallthrough
	case "ap-southeast-2":
		fallthrough
	case "ap-southeast-3":
		fallthrough
	case "ap-southeast-4":
		fallthrough
	case "ca-central-1":
		fallthrough
	case "ca-west-1":
		fallthrough
	case "cn-north-1":
		fallthrough
	case "cn-northwest-1":
		fallthrough
	case "eu-central-1":
		fallthrough
	case "eu-central-2":
		fallthrough
	case "eu-north-1":
		fallthrough
	case "eu-south-1":
		fallthrough
	case "eu-south-2":
		fallthrough
	case "eu-west-1":
		fallthrough
	case "eu-west-2":
		fallthrough
	case "eu-west-3":
		fallthrough
	case "il-central-1":
		fallthrough
	case "me-central-1":
		fallthrough
	case "me-south-1":
		fallthrough
	case "sa-east-1":
		fallthrough
	case "us-east-1":
		fallthrough
	case "us-east-2":
		fallthrough
	case "us-gov-east-1":
		fallthrough
	case "us-gov-west-1":
		fallthrough
	case "us-west-1":
		fallthrough
	case "us-west-2":
		*e = DestinationRedshiftS3BucketRegion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationRedshiftS3BucketRegion: %v", v)
	}
}

// AWSS3Staging - <i>(recommended)</i> Uploads data to S3 and then uses a COPY to insert the data into Redshift. COPY is recommended for production workloads for better speed and scalability. See <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/creating-bucket.html">AWS docs</a> for more details.
type AWSS3Staging struct {
	method DestinationRedshiftMethod `const:"S3 Staging" json:"method"`
	// The name of the staging S3 bucket.
	S3BucketName string `json:"s3_bucket_name"`
	// The directory under the S3 bucket where data will be written. If not provided, then defaults to the root directory. See <a href="https://docs.aws.amazon.com/prescriptive-guidance/latest/defining-bucket-names-data-lakes/faq.html#:~:text=be%20globally%20unique.-,For%20S3%20bucket%20paths,-%2C%20you%20can%20use">path's name recommendations</a> for more details.
	S3BucketPath *string `json:"s3_bucket_path,omitempty"`
	// The region of the S3 staging bucket.
	S3BucketRegion *DestinationRedshiftS3BucketRegion `default:"" json:"s3_bucket_region"`
	// This ID grants access to the above S3 staging bucket. Airbyte requires Read and Write permissions to the given bucket. See <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">AWS docs</a> on how to generate an access key ID and secret access key.
	AccessKeyID string `json:"access_key_id"`
	// The corresponding secret to the above access key id. See <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">AWS docs</a> on how to generate an access key ID and secret access key.
	SecretAccessKey string `json:"secret_access_key"`
	// The pattern allows you to set the file-name format for the S3 staging file(s)
	FileNamePattern *string `json:"file_name_pattern,omitempty"`
	// Whether to delete the staging files from S3 after completing the sync. See <a href="https://docs.airbyte.com/integrations/destinations/redshift/#:~:text=the%20root%20directory.-,Purge%20Staging%20Data,-Whether%20to%20delete"> docs</a> for details.
	PurgeStagingData *bool `default:"true" json:"purge_staging_data"`
}

func (a AWSS3Staging) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AWSS3Staging) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *AWSS3Staging) GetMethod() DestinationRedshiftMethod {
	return DestinationRedshiftMethodS3Staging
}

func (o *AWSS3Staging) GetS3BucketName() string {
	if o == nil {
		return ""
	}
	return o.S3BucketName
}

func (o *AWSS3Staging) GetS3BucketPath() *string {
	if o == nil {
		return nil
	}
	return o.S3BucketPath
}

func (o *AWSS3Staging) GetS3BucketRegion() *DestinationRedshiftS3BucketRegion {
	if o == nil {
		return nil
	}
	return o.S3BucketRegion
}

func (o *AWSS3Staging) GetAccessKeyID() string {
	if o == nil {
		return ""
	}
	return o.AccessKeyID
}

func (o *AWSS3Staging) GetSecretAccessKey() string {
	if o == nil {
		return ""
	}
	return o.SecretAccessKey
}

func (o *AWSS3Staging) GetFileNamePattern() *string {
	if o == nil {
		return nil
	}
	return o.FileNamePattern
}

func (o *AWSS3Staging) GetPurgeStagingData() *bool {
	if o == nil {
		return nil
	}
	return o.PurgeStagingData
}

type UploadingMethodType string

const (
	UploadingMethodTypeAWSS3Staging UploadingMethodType = "AWS S3 Staging"
)

// UploadingMethod - The way data will be uploaded to Redshift.
type UploadingMethod struct {
	AWSS3Staging *AWSS3Staging `queryParam:"inline"`

	Type UploadingMethodType
}

func CreateUploadingMethodAWSS3Staging(awsS3Staging AWSS3Staging) UploadingMethod {
	typ := UploadingMethodTypeAWSS3Staging

	return UploadingMethod{
		AWSS3Staging: &awsS3Staging,
		Type:         typ,
	}
}

func (u *UploadingMethod) UnmarshalJSON(data []byte) error {

	var awsS3Staging AWSS3Staging = AWSS3Staging{}
	if err := utils.UnmarshalJSON(data, &awsS3Staging, "", true, true); err == nil {
		u.AWSS3Staging = &awsS3Staging
		u.Type = UploadingMethodTypeAWSS3Staging
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for UploadingMethod", string(data))
}

func (u UploadingMethod) MarshalJSON() ([]byte, error) {
	if u.AWSS3Staging != nil {
		return utils.MarshalJSON(u.AWSS3Staging, "", true)
	}

	return nil, errors.New("could not marshal union type UploadingMethod: all fields are null")
}

// DestinationRedshiftSchemasTunnelMethodTunnelMethod - Connect through a jump server tunnel host using username and password authentication
type DestinationRedshiftSchemasTunnelMethodTunnelMethod string

const (
	DestinationRedshiftSchemasTunnelMethodTunnelMethodSSHPasswordAuth DestinationRedshiftSchemasTunnelMethodTunnelMethod = "SSH_PASSWORD_AUTH"
)

func (e DestinationRedshiftSchemasTunnelMethodTunnelMethod) ToPointer() *DestinationRedshiftSchemasTunnelMethodTunnelMethod {
	return &e
}
func (e *DestinationRedshiftSchemasTunnelMethodTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_PASSWORD_AUTH":
		*e = DestinationRedshiftSchemasTunnelMethodTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationRedshiftSchemasTunnelMethodTunnelMethod: %v", v)
	}
}

type DestinationRedshiftPasswordAuthentication struct {
	// Connect through a jump server tunnel host using username and password authentication
	tunnelMethod DestinationRedshiftSchemasTunnelMethodTunnelMethod `const:"SSH_PASSWORD_AUTH" json:"tunnel_method"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser string `json:"tunnel_user"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword string `json:"tunnel_user_password"`
}

func (d DestinationRedshiftPasswordAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationRedshiftPasswordAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationRedshiftPasswordAuthentication) GetTunnelMethod() DestinationRedshiftSchemasTunnelMethodTunnelMethod {
	return DestinationRedshiftSchemasTunnelMethodTunnelMethodSSHPasswordAuth
}

func (o *DestinationRedshiftPasswordAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *DestinationRedshiftPasswordAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *DestinationRedshiftPasswordAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

func (o *DestinationRedshiftPasswordAuthentication) GetTunnelUserPassword() string {
	if o == nil {
		return ""
	}
	return o.TunnelUserPassword
}

// DestinationRedshiftSchemasTunnelMethod - Connect through a jump server tunnel host using username and ssh key
type DestinationRedshiftSchemasTunnelMethod string

const (
	DestinationRedshiftSchemasTunnelMethodSSHKeyAuth DestinationRedshiftSchemasTunnelMethod = "SSH_KEY_AUTH"
)

func (e DestinationRedshiftSchemasTunnelMethod) ToPointer() *DestinationRedshiftSchemasTunnelMethod {
	return &e
}
func (e *DestinationRedshiftSchemasTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_KEY_AUTH":
		*e = DestinationRedshiftSchemasTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationRedshiftSchemasTunnelMethod: %v", v)
	}
}

type DestinationRedshiftSSHKeyAuthentication struct {
	// Connect through a jump server tunnel host using username and ssh key
	tunnelMethod DestinationRedshiftSchemasTunnelMethod `const:"SSH_KEY_AUTH" json:"tunnel_method"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host.
	TunnelUser string `json:"tunnel_user"`
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey string `json:"ssh_key"`
}

func (d DestinationRedshiftSSHKeyAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationRedshiftSSHKeyAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationRedshiftSSHKeyAuthentication) GetTunnelMethod() DestinationRedshiftSchemasTunnelMethod {
	return DestinationRedshiftSchemasTunnelMethodSSHKeyAuth
}

func (o *DestinationRedshiftSSHKeyAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *DestinationRedshiftSSHKeyAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *DestinationRedshiftSSHKeyAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

func (o *DestinationRedshiftSSHKeyAuthentication) GetSSHKey() string {
	if o == nil {
		return ""
	}
	return o.SSHKey
}

// DestinationRedshiftTunnelMethod - No ssh tunnel needed to connect to database
type DestinationRedshiftTunnelMethod string

const (
	DestinationRedshiftTunnelMethodNoTunnel DestinationRedshiftTunnelMethod = "NO_TUNNEL"
)

func (e DestinationRedshiftTunnelMethod) ToPointer() *DestinationRedshiftTunnelMethod {
	return &e
}
func (e *DestinationRedshiftTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NO_TUNNEL":
		*e = DestinationRedshiftTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationRedshiftTunnelMethod: %v", v)
	}
}

type DestinationRedshiftNoTunnel struct {
	// No ssh tunnel needed to connect to database
	tunnelMethod DestinationRedshiftTunnelMethod `const:"NO_TUNNEL" json:"tunnel_method"`
}

func (d DestinationRedshiftNoTunnel) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationRedshiftNoTunnel) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationRedshiftNoTunnel) GetTunnelMethod() DestinationRedshiftTunnelMethod {
	return DestinationRedshiftTunnelMethodNoTunnel
}

type DestinationRedshiftSSHTunnelMethodType string

const (
	DestinationRedshiftSSHTunnelMethodTypeDestinationRedshiftNoTunnel               DestinationRedshiftSSHTunnelMethodType = "destination-redshift_No Tunnel"
	DestinationRedshiftSSHTunnelMethodTypeDestinationRedshiftSSHKeyAuthentication   DestinationRedshiftSSHTunnelMethodType = "destination-redshift_SSH Key Authentication"
	DestinationRedshiftSSHTunnelMethodTypeDestinationRedshiftPasswordAuthentication DestinationRedshiftSSHTunnelMethodType = "destination-redshift_Password Authentication"
)

// DestinationRedshiftSSHTunnelMethod - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type DestinationRedshiftSSHTunnelMethod struct {
	DestinationRedshiftNoTunnel               *DestinationRedshiftNoTunnel               `queryParam:"inline"`
	DestinationRedshiftSSHKeyAuthentication   *DestinationRedshiftSSHKeyAuthentication   `queryParam:"inline"`
	DestinationRedshiftPasswordAuthentication *DestinationRedshiftPasswordAuthentication `queryParam:"inline"`

	Type DestinationRedshiftSSHTunnelMethodType
}

func CreateDestinationRedshiftSSHTunnelMethodDestinationRedshiftNoTunnel(destinationRedshiftNoTunnel DestinationRedshiftNoTunnel) DestinationRedshiftSSHTunnelMethod {
	typ := DestinationRedshiftSSHTunnelMethodTypeDestinationRedshiftNoTunnel

	return DestinationRedshiftSSHTunnelMethod{
		DestinationRedshiftNoTunnel: &destinationRedshiftNoTunnel,
		Type:                        typ,
	}
}

func CreateDestinationRedshiftSSHTunnelMethodDestinationRedshiftSSHKeyAuthentication(destinationRedshiftSSHKeyAuthentication DestinationRedshiftSSHKeyAuthentication) DestinationRedshiftSSHTunnelMethod {
	typ := DestinationRedshiftSSHTunnelMethodTypeDestinationRedshiftSSHKeyAuthentication

	return DestinationRedshiftSSHTunnelMethod{
		DestinationRedshiftSSHKeyAuthentication: &destinationRedshiftSSHKeyAuthentication,
		Type:                                    typ,
	}
}

func CreateDestinationRedshiftSSHTunnelMethodDestinationRedshiftPasswordAuthentication(destinationRedshiftPasswordAuthentication DestinationRedshiftPasswordAuthentication) DestinationRedshiftSSHTunnelMethod {
	typ := DestinationRedshiftSSHTunnelMethodTypeDestinationRedshiftPasswordAuthentication

	return DestinationRedshiftSSHTunnelMethod{
		DestinationRedshiftPasswordAuthentication: &destinationRedshiftPasswordAuthentication,
		Type: typ,
	}
}

func (u *DestinationRedshiftSSHTunnelMethod) UnmarshalJSON(data []byte) error {

	var destinationRedshiftNoTunnel DestinationRedshiftNoTunnel = DestinationRedshiftNoTunnel{}
	if err := utils.UnmarshalJSON(data, &destinationRedshiftNoTunnel, "", true, true); err == nil {
		u.DestinationRedshiftNoTunnel = &destinationRedshiftNoTunnel
		u.Type = DestinationRedshiftSSHTunnelMethodTypeDestinationRedshiftNoTunnel
		return nil
	}

	var destinationRedshiftSSHKeyAuthentication DestinationRedshiftSSHKeyAuthentication = DestinationRedshiftSSHKeyAuthentication{}
	if err := utils.UnmarshalJSON(data, &destinationRedshiftSSHKeyAuthentication, "", true, true); err == nil {
		u.DestinationRedshiftSSHKeyAuthentication = &destinationRedshiftSSHKeyAuthentication
		u.Type = DestinationRedshiftSSHTunnelMethodTypeDestinationRedshiftSSHKeyAuthentication
		return nil
	}

	var destinationRedshiftPasswordAuthentication DestinationRedshiftPasswordAuthentication = DestinationRedshiftPasswordAuthentication{}
	if err := utils.UnmarshalJSON(data, &destinationRedshiftPasswordAuthentication, "", true, true); err == nil {
		u.DestinationRedshiftPasswordAuthentication = &destinationRedshiftPasswordAuthentication
		u.Type = DestinationRedshiftSSHTunnelMethodTypeDestinationRedshiftPasswordAuthentication
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationRedshiftSSHTunnelMethod", string(data))
}

func (u DestinationRedshiftSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.DestinationRedshiftNoTunnel != nil {
		return utils.MarshalJSON(u.DestinationRedshiftNoTunnel, "", true)
	}

	if u.DestinationRedshiftSSHKeyAuthentication != nil {
		return utils.MarshalJSON(u.DestinationRedshiftSSHKeyAuthentication, "", true)
	}

	if u.DestinationRedshiftPasswordAuthentication != nil {
		return utils.MarshalJSON(u.DestinationRedshiftPasswordAuthentication, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationRedshiftSSHTunnelMethod: all fields are null")
}

type DestinationRedshiftRedshift string

const (
	DestinationRedshiftRedshiftRedshift DestinationRedshiftRedshift = "redshift"
)

func (e DestinationRedshiftRedshift) ToPointer() *DestinationRedshiftRedshift {
	return &e
}
func (e *DestinationRedshiftRedshift) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "redshift":
		*e = DestinationRedshiftRedshift(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationRedshiftRedshift: %v", v)
	}
}

type DestinationRedshift struct {
	// Host Endpoint of the Redshift Cluster (must include the cluster-id, region and end with .redshift.amazonaws.com)
	Host string `json:"host"`
	// Port of the database.
	Port *int64 `default:"5439" json:"port"`
	// Username to use to access the database.
	Username string `json:"username"`
	// Password associated with the username.
	Password string `json:"password"`
	// Name of the database.
	Database string `json:"database"`
	// The default schema tables are written to if the source does not specify a namespace. Unless specifically configured, the usual value for this field is "public".
	Schema *string `default:"public" json:"schema"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// The way data will be uploaded to Redshift.
	UploadingMethod *UploadingMethod `json:"uploading_method,omitempty"`
	// The schema to write raw tables into (default: airbyte_internal).
	RawDataSchema *string `json:"raw_data_schema,omitempty"`
	// Disable Writing Final Tables. WARNING! The data format in _airbyte_data is likely stable but there are no guarantees that other metadata columns will remain the same in future versions
	DisableTypeDedupe *bool `default:"false" json:"disable_type_dedupe"`
	// Drop tables with CASCADE. WARNING! This will delete all data in all dependent objects (views, etc.). Use with caution. This option is intended for usecases which can easily rebuild the dependent objects.
	DropCascade *bool `default:"false" json:"drop_cascade"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod    *DestinationRedshiftSSHTunnelMethod `json:"tunnel_method,omitempty"`
	destinationType DestinationRedshiftRedshift         `const:"redshift" json:"destinationType"`
}

func (d DestinationRedshift) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationRedshift) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *DestinationRedshift) GetHost() string {
	if o == nil {
		return ""
	}
	return o.Host
}

func (o *DestinationRedshift) GetPort() *int64 {
	if o == nil {
		return nil
	}
	return o.Port
}

func (o *DestinationRedshift) GetUsername() string {
	if o == nil {
		return ""
	}
	return o.Username
}

func (o *DestinationRedshift) GetPassword() string {
	if o == nil {
		return ""
	}
	return o.Password
}

func (o *DestinationRedshift) GetDatabase() string {
	if o == nil {
		return ""
	}
	return o.Database
}

func (o *DestinationRedshift) GetSchema() *string {
	if o == nil {
		return nil
	}
	return o.Schema
}

func (o *DestinationRedshift) GetJdbcURLParams() *string {
	if o == nil {
		return nil
	}
	return o.JdbcURLParams
}

func (o *DestinationRedshift) GetUploadingMethod() *UploadingMethod {
	if o == nil {
		return nil
	}
	return o.UploadingMethod
}

func (o *DestinationRedshift) GetRawDataSchema() *string {
	if o == nil {
		return nil
	}
	return o.RawDataSchema
}

func (o *DestinationRedshift) GetDisableTypeDedupe() *bool {
	if o == nil {
		return nil
	}
	return o.DisableTypeDedupe
}

func (o *DestinationRedshift) GetDropCascade() *bool {
	if o == nil {
		return nil
	}
	return o.DropCascade
}

func (o *DestinationRedshift) GetTunnelMethod() *DestinationRedshiftSSHTunnelMethod {
	if o == nil {
		return nil
	}
	return o.TunnelMethod
}

func (o *DestinationRedshift) GetDestinationType() DestinationRedshiftRedshift {
	return DestinationRedshiftRedshiftRedshift
}
