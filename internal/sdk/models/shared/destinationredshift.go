// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

type Redshift string

const (
	RedshiftRedshift Redshift = "redshift"
)

func (e Redshift) ToPointer() *Redshift {
	return &e
}
func (e *Redshift) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "redshift":
		*e = Redshift(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Redshift: %v", v)
	}
}

// DestinationRedshiftSchemasTunnelMethodTunnelMethod - Connect through a jump server tunnel host using username and password authentication
type DestinationRedshiftSchemasTunnelMethodTunnelMethod string

const (
	DestinationRedshiftSchemasTunnelMethodTunnelMethodSSHPasswordAuth DestinationRedshiftSchemasTunnelMethodTunnelMethod = "SSH_PASSWORD_AUTH"
)

func (e DestinationRedshiftSchemasTunnelMethodTunnelMethod) ToPointer() *DestinationRedshiftSchemasTunnelMethodTunnelMethod {
	return &e
}
func (e *DestinationRedshiftSchemasTunnelMethodTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_PASSWORD_AUTH":
		*e = DestinationRedshiftSchemasTunnelMethodTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationRedshiftSchemasTunnelMethodTunnelMethod: %v", v)
	}
}

type DestinationRedshiftPasswordAuthentication struct {
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and password authentication
	tunnelMethod DestinationRedshiftSchemasTunnelMethodTunnelMethod `const:"SSH_PASSWORD_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser string `json:"tunnel_user"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword string `json:"tunnel_user_password"`
}

func (d DestinationRedshiftPasswordAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationRedshiftPasswordAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationRedshiftPasswordAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *DestinationRedshiftPasswordAuthentication) GetTunnelMethod() DestinationRedshiftSchemasTunnelMethodTunnelMethod {
	return DestinationRedshiftSchemasTunnelMethodTunnelMethodSSHPasswordAuth
}

func (o *DestinationRedshiftPasswordAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *DestinationRedshiftPasswordAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

func (o *DestinationRedshiftPasswordAuthentication) GetTunnelUserPassword() string {
	if o == nil {
		return ""
	}
	return o.TunnelUserPassword
}

// DestinationRedshiftSchemasTunnelMethod - Connect through a jump server tunnel host using username and ssh key
type DestinationRedshiftSchemasTunnelMethod string

const (
	DestinationRedshiftSchemasTunnelMethodSSHKeyAuth DestinationRedshiftSchemasTunnelMethod = "SSH_KEY_AUTH"
)

func (e DestinationRedshiftSchemasTunnelMethod) ToPointer() *DestinationRedshiftSchemasTunnelMethod {
	return &e
}
func (e *DestinationRedshiftSchemasTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_KEY_AUTH":
		*e = DestinationRedshiftSchemasTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationRedshiftSchemasTunnelMethod: %v", v)
	}
}

type DestinationRedshiftSSHKeyAuthentication struct {
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey string `json:"ssh_key"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and ssh key
	tunnelMethod DestinationRedshiftSchemasTunnelMethod `const:"SSH_KEY_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host.
	TunnelUser string `json:"tunnel_user"`
}

func (d DestinationRedshiftSSHKeyAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationRedshiftSSHKeyAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationRedshiftSSHKeyAuthentication) GetSSHKey() string {
	if o == nil {
		return ""
	}
	return o.SSHKey
}

func (o *DestinationRedshiftSSHKeyAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *DestinationRedshiftSSHKeyAuthentication) GetTunnelMethod() DestinationRedshiftSchemasTunnelMethod {
	return DestinationRedshiftSchemasTunnelMethodSSHKeyAuth
}

func (o *DestinationRedshiftSSHKeyAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *DestinationRedshiftSSHKeyAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

// DestinationRedshiftTunnelMethod - No ssh tunnel needed to connect to database
type DestinationRedshiftTunnelMethod string

const (
	DestinationRedshiftTunnelMethodNoTunnel DestinationRedshiftTunnelMethod = "NO_TUNNEL"
)

func (e DestinationRedshiftTunnelMethod) ToPointer() *DestinationRedshiftTunnelMethod {
	return &e
}
func (e *DestinationRedshiftTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NO_TUNNEL":
		*e = DestinationRedshiftTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationRedshiftTunnelMethod: %v", v)
	}
}

type DestinationRedshiftNoTunnel struct {
	// No ssh tunnel needed to connect to database
	tunnelMethod DestinationRedshiftTunnelMethod `const:"NO_TUNNEL" json:"tunnel_method"`
}

func (d DestinationRedshiftNoTunnel) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationRedshiftNoTunnel) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationRedshiftNoTunnel) GetTunnelMethod() DestinationRedshiftTunnelMethod {
	return DestinationRedshiftTunnelMethodNoTunnel
}

type DestinationRedshiftSSHTunnelMethodType string

const (
	DestinationRedshiftSSHTunnelMethodTypeDestinationRedshiftNoTunnel               DestinationRedshiftSSHTunnelMethodType = "destination-redshift_No Tunnel"
	DestinationRedshiftSSHTunnelMethodTypeDestinationRedshiftSSHKeyAuthentication   DestinationRedshiftSSHTunnelMethodType = "destination-redshift_SSH Key Authentication"
	DestinationRedshiftSSHTunnelMethodTypeDestinationRedshiftPasswordAuthentication DestinationRedshiftSSHTunnelMethodType = "destination-redshift_Password Authentication"
)

// DestinationRedshiftSSHTunnelMethod - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type DestinationRedshiftSSHTunnelMethod struct {
	DestinationRedshiftNoTunnel               *DestinationRedshiftNoTunnel
	DestinationRedshiftSSHKeyAuthentication   *DestinationRedshiftSSHKeyAuthentication
	DestinationRedshiftPasswordAuthentication *DestinationRedshiftPasswordAuthentication

	Type DestinationRedshiftSSHTunnelMethodType
}

func CreateDestinationRedshiftSSHTunnelMethodDestinationRedshiftNoTunnel(destinationRedshiftNoTunnel DestinationRedshiftNoTunnel) DestinationRedshiftSSHTunnelMethod {
	typ := DestinationRedshiftSSHTunnelMethodTypeDestinationRedshiftNoTunnel

	return DestinationRedshiftSSHTunnelMethod{
		DestinationRedshiftNoTunnel: &destinationRedshiftNoTunnel,
		Type:                        typ,
	}
}

func CreateDestinationRedshiftSSHTunnelMethodDestinationRedshiftSSHKeyAuthentication(destinationRedshiftSSHKeyAuthentication DestinationRedshiftSSHKeyAuthentication) DestinationRedshiftSSHTunnelMethod {
	typ := DestinationRedshiftSSHTunnelMethodTypeDestinationRedshiftSSHKeyAuthentication

	return DestinationRedshiftSSHTunnelMethod{
		DestinationRedshiftSSHKeyAuthentication: &destinationRedshiftSSHKeyAuthentication,
		Type:                                    typ,
	}
}

func CreateDestinationRedshiftSSHTunnelMethodDestinationRedshiftPasswordAuthentication(destinationRedshiftPasswordAuthentication DestinationRedshiftPasswordAuthentication) DestinationRedshiftSSHTunnelMethod {
	typ := DestinationRedshiftSSHTunnelMethodTypeDestinationRedshiftPasswordAuthentication

	return DestinationRedshiftSSHTunnelMethod{
		DestinationRedshiftPasswordAuthentication: &destinationRedshiftPasswordAuthentication,
		Type: typ,
	}
}

func (u *DestinationRedshiftSSHTunnelMethod) UnmarshalJSON(data []byte) error {

	var destinationRedshiftNoTunnel DestinationRedshiftNoTunnel = DestinationRedshiftNoTunnel{}
	if err := utils.UnmarshalJSON(data, &destinationRedshiftNoTunnel, "", true, true); err == nil {
		u.DestinationRedshiftNoTunnel = &destinationRedshiftNoTunnel
		u.Type = DestinationRedshiftSSHTunnelMethodTypeDestinationRedshiftNoTunnel
		return nil
	}

	var destinationRedshiftSSHKeyAuthentication DestinationRedshiftSSHKeyAuthentication = DestinationRedshiftSSHKeyAuthentication{}
	if err := utils.UnmarshalJSON(data, &destinationRedshiftSSHKeyAuthentication, "", true, true); err == nil {
		u.DestinationRedshiftSSHKeyAuthentication = &destinationRedshiftSSHKeyAuthentication
		u.Type = DestinationRedshiftSSHTunnelMethodTypeDestinationRedshiftSSHKeyAuthentication
		return nil
	}

	var destinationRedshiftPasswordAuthentication DestinationRedshiftPasswordAuthentication = DestinationRedshiftPasswordAuthentication{}
	if err := utils.UnmarshalJSON(data, &destinationRedshiftPasswordAuthentication, "", true, true); err == nil {
		u.DestinationRedshiftPasswordAuthentication = &destinationRedshiftPasswordAuthentication
		u.Type = DestinationRedshiftSSHTunnelMethodTypeDestinationRedshiftPasswordAuthentication
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationRedshiftSSHTunnelMethod", string(data))
}

func (u DestinationRedshiftSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.DestinationRedshiftNoTunnel != nil {
		return utils.MarshalJSON(u.DestinationRedshiftNoTunnel, "", true)
	}

	if u.DestinationRedshiftSSHKeyAuthentication != nil {
		return utils.MarshalJSON(u.DestinationRedshiftSSHKeyAuthentication, "", true)
	}

	if u.DestinationRedshiftPasswordAuthentication != nil {
		return utils.MarshalJSON(u.DestinationRedshiftPasswordAuthentication, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationRedshiftSSHTunnelMethod: all fields are null")
}

type DestinationRedshiftMethod string

const (
	DestinationRedshiftMethodS3Staging DestinationRedshiftMethod = "S3 Staging"
)

func (e DestinationRedshiftMethod) ToPointer() *DestinationRedshiftMethod {
	return &e
}
func (e *DestinationRedshiftMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "S3 Staging":
		*e = DestinationRedshiftMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationRedshiftMethod: %v", v)
	}
}

// DestinationRedshiftS3BucketRegion - The region of the S3 staging bucket.
type DestinationRedshiftS3BucketRegion string

const (
	DestinationRedshiftS3BucketRegionUnknown      DestinationRedshiftS3BucketRegion = ""
	DestinationRedshiftS3BucketRegionAfSouth1     DestinationRedshiftS3BucketRegion = "af-south-1"
	DestinationRedshiftS3BucketRegionApEast1      DestinationRedshiftS3BucketRegion = "ap-east-1"
	DestinationRedshiftS3BucketRegionApNortheast1 DestinationRedshiftS3BucketRegion = "ap-northeast-1"
	DestinationRedshiftS3BucketRegionApNortheast2 DestinationRedshiftS3BucketRegion = "ap-northeast-2"
	DestinationRedshiftS3BucketRegionApNortheast3 DestinationRedshiftS3BucketRegion = "ap-northeast-3"
	DestinationRedshiftS3BucketRegionApSouth1     DestinationRedshiftS3BucketRegion = "ap-south-1"
	DestinationRedshiftS3BucketRegionApSouth2     DestinationRedshiftS3BucketRegion = "ap-south-2"
	DestinationRedshiftS3BucketRegionApSoutheast1 DestinationRedshiftS3BucketRegion = "ap-southeast-1"
	DestinationRedshiftS3BucketRegionApSoutheast2 DestinationRedshiftS3BucketRegion = "ap-southeast-2"
	DestinationRedshiftS3BucketRegionApSoutheast3 DestinationRedshiftS3BucketRegion = "ap-southeast-3"
	DestinationRedshiftS3BucketRegionApSoutheast4 DestinationRedshiftS3BucketRegion = "ap-southeast-4"
	DestinationRedshiftS3BucketRegionCaCentral1   DestinationRedshiftS3BucketRegion = "ca-central-1"
	DestinationRedshiftS3BucketRegionCaWest1      DestinationRedshiftS3BucketRegion = "ca-west-1"
	DestinationRedshiftS3BucketRegionCnNorth1     DestinationRedshiftS3BucketRegion = "cn-north-1"
	DestinationRedshiftS3BucketRegionCnNorthwest1 DestinationRedshiftS3BucketRegion = "cn-northwest-1"
	DestinationRedshiftS3BucketRegionEuCentral1   DestinationRedshiftS3BucketRegion = "eu-central-1"
	DestinationRedshiftS3BucketRegionEuCentral2   DestinationRedshiftS3BucketRegion = "eu-central-2"
	DestinationRedshiftS3BucketRegionEuNorth1     DestinationRedshiftS3BucketRegion = "eu-north-1"
	DestinationRedshiftS3BucketRegionEuSouth1     DestinationRedshiftS3BucketRegion = "eu-south-1"
	DestinationRedshiftS3BucketRegionEuSouth2     DestinationRedshiftS3BucketRegion = "eu-south-2"
	DestinationRedshiftS3BucketRegionEuWest1      DestinationRedshiftS3BucketRegion = "eu-west-1"
	DestinationRedshiftS3BucketRegionEuWest2      DestinationRedshiftS3BucketRegion = "eu-west-2"
	DestinationRedshiftS3BucketRegionEuWest3      DestinationRedshiftS3BucketRegion = "eu-west-3"
	DestinationRedshiftS3BucketRegionIlCentral1   DestinationRedshiftS3BucketRegion = "il-central-1"
	DestinationRedshiftS3BucketRegionMeCentral1   DestinationRedshiftS3BucketRegion = "me-central-1"
	DestinationRedshiftS3BucketRegionMeSouth1     DestinationRedshiftS3BucketRegion = "me-south-1"
	DestinationRedshiftS3BucketRegionSaEast1      DestinationRedshiftS3BucketRegion = "sa-east-1"
	DestinationRedshiftS3BucketRegionUsEast1      DestinationRedshiftS3BucketRegion = "us-east-1"
	DestinationRedshiftS3BucketRegionUsEast2      DestinationRedshiftS3BucketRegion = "us-east-2"
	DestinationRedshiftS3BucketRegionUsGovEast1   DestinationRedshiftS3BucketRegion = "us-gov-east-1"
	DestinationRedshiftS3BucketRegionUsGovWest1   DestinationRedshiftS3BucketRegion = "us-gov-west-1"
	DestinationRedshiftS3BucketRegionUsWest1      DestinationRedshiftS3BucketRegion = "us-west-1"
	DestinationRedshiftS3BucketRegionUsWest2      DestinationRedshiftS3BucketRegion = "us-west-2"
)

func (e DestinationRedshiftS3BucketRegion) ToPointer() *DestinationRedshiftS3BucketRegion {
	return &e
}
func (e *DestinationRedshiftS3BucketRegion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "":
		fallthrough
	case "af-south-1":
		fallthrough
	case "ap-east-1":
		fallthrough
	case "ap-northeast-1":
		fallthrough
	case "ap-northeast-2":
		fallthrough
	case "ap-northeast-3":
		fallthrough
	case "ap-south-1":
		fallthrough
	case "ap-south-2":
		fallthrough
	case "ap-southeast-1":
		fallthrough
	case "ap-southeast-2":
		fallthrough
	case "ap-southeast-3":
		fallthrough
	case "ap-southeast-4":
		fallthrough
	case "ca-central-1":
		fallthrough
	case "ca-west-1":
		fallthrough
	case "cn-north-1":
		fallthrough
	case "cn-northwest-1":
		fallthrough
	case "eu-central-1":
		fallthrough
	case "eu-central-2":
		fallthrough
	case "eu-north-1":
		fallthrough
	case "eu-south-1":
		fallthrough
	case "eu-south-2":
		fallthrough
	case "eu-west-1":
		fallthrough
	case "eu-west-2":
		fallthrough
	case "eu-west-3":
		fallthrough
	case "il-central-1":
		fallthrough
	case "me-central-1":
		fallthrough
	case "me-south-1":
		fallthrough
	case "sa-east-1":
		fallthrough
	case "us-east-1":
		fallthrough
	case "us-east-2":
		fallthrough
	case "us-gov-east-1":
		fallthrough
	case "us-gov-west-1":
		fallthrough
	case "us-west-1":
		fallthrough
	case "us-west-2":
		*e = DestinationRedshiftS3BucketRegion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationRedshiftS3BucketRegion: %v", v)
	}
}

// DestinationRedshiftAWSS3Staging - <i>(recommended)</i> Uploads data to S3 and then uses a COPY to insert the data into Redshift. COPY is recommended for production workloads for better speed and scalability. See <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/creating-bucket.html">AWS docs</a> for more details.
type DestinationRedshiftAWSS3Staging struct {
	// This ID grants access to the above S3 staging bucket. Airbyte requires Read and Write permissions to the given bucket. See <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">AWS docs</a> on how to generate an access key ID and secret access key.
	AccessKeyID string `json:"access_key_id"`
	// The pattern allows you to set the file-name format for the S3 staging file(s)
	FileNamePattern *string                   `json:"file_name_pattern,omitempty"`
	method          DestinationRedshiftMethod `const:"S3 Staging" json:"method"`
	// Whether to delete the staging files from S3 after completing the sync. See <a href="https://docs.airbyte.com/integrations/destinations/redshift/#:~:text=the%20root%20directory.-,Purge%20Staging%20Data,-Whether%20to%20delete"> docs</a> for details.
	PurgeStagingData *bool `default:"true" json:"purge_staging_data"`
	// The name of the staging S3 bucket.
	S3BucketName string `json:"s3_bucket_name"`
	// The directory under the S3 bucket where data will be written. If not provided, then defaults to the root directory. See <a href="https://docs.aws.amazon.com/prescriptive-guidance/latest/defining-bucket-names-data-lakes/faq.html#:~:text=be%20globally%20unique.-,For%20S3%20bucket%20paths,-%2C%20you%20can%20use">path's name recommendations</a> for more details.
	S3BucketPath *string `json:"s3_bucket_path,omitempty"`
	// The region of the S3 staging bucket.
	S3BucketRegion *DestinationRedshiftS3BucketRegion `default:"" json:"s3_bucket_region"`
	// The corresponding secret to the above access key id. See <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">AWS docs</a> on how to generate an access key ID and secret access key.
	SecretAccessKey string `json:"secret_access_key"`
}

func (d DestinationRedshiftAWSS3Staging) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationRedshiftAWSS3Staging) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationRedshiftAWSS3Staging) GetAccessKeyID() string {
	if o == nil {
		return ""
	}
	return o.AccessKeyID
}

func (o *DestinationRedshiftAWSS3Staging) GetFileNamePattern() *string {
	if o == nil {
		return nil
	}
	return o.FileNamePattern
}

func (o *DestinationRedshiftAWSS3Staging) GetMethod() DestinationRedshiftMethod {
	return DestinationRedshiftMethodS3Staging
}

func (o *DestinationRedshiftAWSS3Staging) GetPurgeStagingData() *bool {
	if o == nil {
		return nil
	}
	return o.PurgeStagingData
}

func (o *DestinationRedshiftAWSS3Staging) GetS3BucketName() string {
	if o == nil {
		return ""
	}
	return o.S3BucketName
}

func (o *DestinationRedshiftAWSS3Staging) GetS3BucketPath() *string {
	if o == nil {
		return nil
	}
	return o.S3BucketPath
}

func (o *DestinationRedshiftAWSS3Staging) GetS3BucketRegion() *DestinationRedshiftS3BucketRegion {
	if o == nil {
		return nil
	}
	return o.S3BucketRegion
}

func (o *DestinationRedshiftAWSS3Staging) GetSecretAccessKey() string {
	if o == nil {
		return ""
	}
	return o.SecretAccessKey
}

type DestinationRedshiftUploadingMethodType string

const (
	DestinationRedshiftUploadingMethodTypeDestinationRedshiftAWSS3Staging DestinationRedshiftUploadingMethodType = "destination-redshift_AWS S3 Staging"
)

// DestinationRedshiftUploadingMethod - The way data will be uploaded to Redshift.
type DestinationRedshiftUploadingMethod struct {
	DestinationRedshiftAWSS3Staging *DestinationRedshiftAWSS3Staging

	Type DestinationRedshiftUploadingMethodType
}

func CreateDestinationRedshiftUploadingMethodDestinationRedshiftAWSS3Staging(destinationRedshiftAWSS3Staging DestinationRedshiftAWSS3Staging) DestinationRedshiftUploadingMethod {
	typ := DestinationRedshiftUploadingMethodTypeDestinationRedshiftAWSS3Staging

	return DestinationRedshiftUploadingMethod{
		DestinationRedshiftAWSS3Staging: &destinationRedshiftAWSS3Staging,
		Type:                            typ,
	}
}

func (u *DestinationRedshiftUploadingMethod) UnmarshalJSON(data []byte) error {

	var destinationRedshiftAWSS3Staging DestinationRedshiftAWSS3Staging = DestinationRedshiftAWSS3Staging{}
	if err := utils.UnmarshalJSON(data, &destinationRedshiftAWSS3Staging, "", true, true); err == nil {
		u.DestinationRedshiftAWSS3Staging = &destinationRedshiftAWSS3Staging
		u.Type = DestinationRedshiftUploadingMethodTypeDestinationRedshiftAWSS3Staging
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationRedshiftUploadingMethod", string(data))
}

func (u DestinationRedshiftUploadingMethod) MarshalJSON() ([]byte, error) {
	if u.DestinationRedshiftAWSS3Staging != nil {
		return utils.MarshalJSON(u.DestinationRedshiftAWSS3Staging, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationRedshiftUploadingMethod: all fields are null")
}

type DestinationRedshift struct {
	// Name of the database.
	Database        string   `json:"database"`
	destinationType Redshift `const:"redshift" json:"destinationType"`
	// Disable Writing Final Tables. WARNING! The data format in _airbyte_data is likely stable but there are no guarantees that other metadata columns will remain the same in future versions
	DisableTypeDedupe *bool `default:"false" json:"disable_type_dedupe"`
	// Drop tables with CASCADE. WARNING! This will delete all data in all dependent objects (views, etc.). Use with caution. This option is intended for usecases which can easily rebuild the dependent objects.
	DropCascade *bool `default:"false" json:"drop_cascade"`
	// Host Endpoint of the Redshift Cluster (must include the cluster-id, region and end with .redshift.amazonaws.com)
	Host string `json:"host"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// Password associated with the username.
	Password string `json:"password"`
	// Port of the database.
	Port *int64 `default:"5439" json:"port"`
	// The schema to write raw tables into (default: airbyte_internal).
	RawDataSchema *string `json:"raw_data_schema,omitempty"`
	// The default schema tables are written to if the source does not specify a namespace. Unless specifically configured, the usual value for this field is "public".
	Schema *string `default:"public" json:"schema"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod *DestinationRedshiftSSHTunnelMethod `json:"tunnel_method,omitempty"`
	// The way data will be uploaded to Redshift.
	UploadingMethod *DestinationRedshiftUploadingMethod `json:"uploading_method,omitempty"`
	// Username to use to access the database.
	Username string `json:"username"`
}

func (d DestinationRedshift) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationRedshift) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *DestinationRedshift) GetDatabase() string {
	if o == nil {
		return ""
	}
	return o.Database
}

func (o *DestinationRedshift) GetDestinationType() Redshift {
	return RedshiftRedshift
}

func (o *DestinationRedshift) GetDisableTypeDedupe() *bool {
	if o == nil {
		return nil
	}
	return o.DisableTypeDedupe
}

func (o *DestinationRedshift) GetDropCascade() *bool {
	if o == nil {
		return nil
	}
	return o.DropCascade
}

func (o *DestinationRedshift) GetHost() string {
	if o == nil {
		return ""
	}
	return o.Host
}

func (o *DestinationRedshift) GetJdbcURLParams() *string {
	if o == nil {
		return nil
	}
	return o.JdbcURLParams
}

func (o *DestinationRedshift) GetPassword() string {
	if o == nil {
		return ""
	}
	return o.Password
}

func (o *DestinationRedshift) GetPort() *int64 {
	if o == nil {
		return nil
	}
	return o.Port
}

func (o *DestinationRedshift) GetRawDataSchema() *string {
	if o == nil {
		return nil
	}
	return o.RawDataSchema
}

func (o *DestinationRedshift) GetSchema() *string {
	if o == nil {
		return nil
	}
	return o.Schema
}

func (o *DestinationRedshift) GetTunnelMethod() *DestinationRedshiftSSHTunnelMethod {
	if o == nil {
		return nil
	}
	return o.TunnelMethod
}

func (o *DestinationRedshift) GetUploadingMethod() *DestinationRedshiftUploadingMethod {
	if o == nil {
		return nil
	}
	return o.UploadingMethod
}

func (o *DestinationRedshift) GetUsername() string {
	if o == nil {
		return ""
	}
	return o.Username
}
