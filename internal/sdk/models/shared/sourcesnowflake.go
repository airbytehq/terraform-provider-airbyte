// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

type SourceSnowflakeSchemasAuthType string

const (
	SourceSnowflakeSchemasAuthTypeUsernamePassword SourceSnowflakeSchemasAuthType = "username/password"
)

func (e SourceSnowflakeSchemasAuthType) ToPointer() *SourceSnowflakeSchemasAuthType {
	return &e
}
func (e *SourceSnowflakeSchemasAuthType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "username/password":
		*e = SourceSnowflakeSchemasAuthType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceSnowflakeSchemasAuthType: %v", v)
	}
}

type UsernameAndPassword struct {
	AuthType *SourceSnowflakeSchemasAuthType `default:"username/password" json:"auth_type"`
	// The password associated with the username.
	Password string `json:"password"`
	// The username you created to allow Airbyte to access the database.
	Username             string `json:"username"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (u UsernameAndPassword) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(u, "", false)
}

func (u *UsernameAndPassword) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &u, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (u *UsernameAndPassword) GetAuthType() *SourceSnowflakeSchemasAuthType {
	if u == nil {
		return nil
	}
	return u.AuthType
}

func (u *UsernameAndPassword) GetPassword() string {
	if u == nil {
		return ""
	}
	return u.Password
}

func (u *UsernameAndPassword) GetUsername() string {
	if u == nil {
		return ""
	}
	return u.Username
}

func (u *UsernameAndPassword) GetAdditionalProperties() any {
	if u == nil {
		return nil
	}
	return u.AdditionalProperties
}

type SourceSnowflakeAuthType string

const (
	SourceSnowflakeAuthTypeKeyPairAuthentication SourceSnowflakeAuthType = "Key Pair Authentication"
)

func (e SourceSnowflakeAuthType) ToPointer() *SourceSnowflakeAuthType {
	return &e
}
func (e *SourceSnowflakeAuthType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Key Pair Authentication":
		*e = SourceSnowflakeAuthType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceSnowflakeAuthType: %v", v)
	}
}

type KeyPairAuthentication struct {
	AuthType *SourceSnowflakeAuthType `default:"Key Pair Authentication" json:"auth_type"`
	// RSA Private key to use for Snowflake connection. See the <a href="https://docs.airbyte.com/integrations/sources/snowflake#key-pair-authentication">docs</a> for more information on how to obtain this key.
	PrivateKey string `json:"private_key"`
	// Passphrase for private key
	PrivateKeyPassword *string `json:"private_key_password,omitempty"`
	// The username you created to allow Airbyte to access the database.
	Username             string `json:"username"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (k KeyPairAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(k, "", false)
}

func (k *KeyPairAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &k, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (k *KeyPairAuthentication) GetAuthType() *SourceSnowflakeAuthType {
	if k == nil {
		return nil
	}
	return k.AuthType
}

func (k *KeyPairAuthentication) GetPrivateKey() string {
	if k == nil {
		return ""
	}
	return k.PrivateKey
}

func (k *KeyPairAuthentication) GetPrivateKeyPassword() *string {
	if k == nil {
		return nil
	}
	return k.PrivateKeyPassword
}

func (k *KeyPairAuthentication) GetUsername() string {
	if k == nil {
		return ""
	}
	return k.Username
}

func (k *KeyPairAuthentication) GetAdditionalProperties() any {
	if k == nil {
		return nil
	}
	return k.AdditionalProperties
}

type SourceSnowflakeAuthorizationMethodType string

const (
	SourceSnowflakeAuthorizationMethodTypeKeyPairAuthentication SourceSnowflakeAuthorizationMethodType = "Key Pair Authentication"
	SourceSnowflakeAuthorizationMethodTypeUsernameAndPassword   SourceSnowflakeAuthorizationMethodType = "Username and Password"
)

type SourceSnowflakeAuthorizationMethod struct {
	KeyPairAuthentication *KeyPairAuthentication `queryParam:"inline" union:"member"`
	UsernameAndPassword   *UsernameAndPassword   `queryParam:"inline" union:"member"`

	Type SourceSnowflakeAuthorizationMethodType
}

func CreateSourceSnowflakeAuthorizationMethodKeyPairAuthentication(keyPairAuthentication KeyPairAuthentication) SourceSnowflakeAuthorizationMethod {
	typ := SourceSnowflakeAuthorizationMethodTypeKeyPairAuthentication

	return SourceSnowflakeAuthorizationMethod{
		KeyPairAuthentication: &keyPairAuthentication,
		Type:                  typ,
	}
}

func CreateSourceSnowflakeAuthorizationMethodUsernameAndPassword(usernameAndPassword UsernameAndPassword) SourceSnowflakeAuthorizationMethod {
	typ := SourceSnowflakeAuthorizationMethodTypeUsernameAndPassword

	return SourceSnowflakeAuthorizationMethod{
		UsernameAndPassword: &usernameAndPassword,
		Type:                typ,
	}
}

func (u *SourceSnowflakeAuthorizationMethod) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var keyPairAuthentication KeyPairAuthentication = KeyPairAuthentication{}
	if err := utils.UnmarshalJSON(data, &keyPairAuthentication, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceSnowflakeAuthorizationMethodTypeKeyPairAuthentication,
			Value: &keyPairAuthentication,
		})
	}

	var usernameAndPassword UsernameAndPassword = UsernameAndPassword{}
	if err := utils.UnmarshalJSON(data, &usernameAndPassword, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceSnowflakeAuthorizationMethodTypeUsernameAndPassword,
			Value: &usernameAndPassword,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceSnowflakeAuthorizationMethod", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceSnowflakeAuthorizationMethod", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceSnowflakeAuthorizationMethodType)
	switch best.Type {
	case SourceSnowflakeAuthorizationMethodTypeKeyPairAuthentication:
		u.KeyPairAuthentication = best.Value.(*KeyPairAuthentication)
		return nil
	case SourceSnowflakeAuthorizationMethodTypeUsernameAndPassword:
		u.UsernameAndPassword = best.Value.(*UsernameAndPassword)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceSnowflakeAuthorizationMethod", string(data))
}

func (u SourceSnowflakeAuthorizationMethod) MarshalJSON() ([]byte, error) {
	if u.KeyPairAuthentication != nil {
		return utils.MarshalJSON(u.KeyPairAuthentication, "", true)
	}

	if u.UsernameAndPassword != nil {
		return utils.MarshalJSON(u.UsernameAndPassword, "", true)
	}

	return nil, errors.New("could not marshal union type SourceSnowflakeAuthorizationMethod: all fields are null")
}

type SourceSnowflakeCursorMethod string

const (
	SourceSnowflakeCursorMethodUserDefined SourceSnowflakeCursorMethod = "user_defined"
)

func (e SourceSnowflakeCursorMethod) ToPointer() *SourceSnowflakeCursorMethod {
	return &e
}
func (e *SourceSnowflakeCursorMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "user_defined":
		*e = SourceSnowflakeCursorMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceSnowflakeCursorMethod: %v", v)
	}
}

// SourceSnowflakeScanChangesWithUserDefinedCursor - Incrementally detects new inserts and updates using the <a href="https://docs.airbyte.com/understanding-airbyte/connections/incremental-append/#user-defined-cursor">cursor column</a> chosen when configuring a connection (e.g. created_at, updated_at).
type SourceSnowflakeScanChangesWithUserDefinedCursor struct {
	CursorMethod         *SourceSnowflakeCursorMethod `default:"user_defined" json:"cursor_method"`
	AdditionalProperties any                          `additionalProperties:"true" json:"-"`
}

func (s SourceSnowflakeScanChangesWithUserDefinedCursor) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceSnowflakeScanChangesWithUserDefinedCursor) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceSnowflakeScanChangesWithUserDefinedCursor) GetCursorMethod() *SourceSnowflakeCursorMethod {
	if s == nil {
		return nil
	}
	return s.CursorMethod
}

func (s *SourceSnowflakeScanChangesWithUserDefinedCursor) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceSnowflakeUpdateMethodType string

const (
	SourceSnowflakeUpdateMethodTypeSourceSnowflakeScanChangesWithUserDefinedCursor SourceSnowflakeUpdateMethodType = "source-snowflake_Scan Changes with User Defined Cursor"
)

// SourceSnowflakeUpdateMethod - Configures how data is extracted from the database.
type SourceSnowflakeUpdateMethod struct {
	SourceSnowflakeScanChangesWithUserDefinedCursor *SourceSnowflakeScanChangesWithUserDefinedCursor `queryParam:"inline" union:"member"`

	Type SourceSnowflakeUpdateMethodType
}

func CreateSourceSnowflakeUpdateMethodSourceSnowflakeScanChangesWithUserDefinedCursor(sourceSnowflakeScanChangesWithUserDefinedCursor SourceSnowflakeScanChangesWithUserDefinedCursor) SourceSnowflakeUpdateMethod {
	typ := SourceSnowflakeUpdateMethodTypeSourceSnowflakeScanChangesWithUserDefinedCursor

	return SourceSnowflakeUpdateMethod{
		SourceSnowflakeScanChangesWithUserDefinedCursor: &sourceSnowflakeScanChangesWithUserDefinedCursor,
		Type: typ,
	}
}

func (u *SourceSnowflakeUpdateMethod) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var sourceSnowflakeScanChangesWithUserDefinedCursor SourceSnowflakeScanChangesWithUserDefinedCursor = SourceSnowflakeScanChangesWithUserDefinedCursor{}
	if err := utils.UnmarshalJSON(data, &sourceSnowflakeScanChangesWithUserDefinedCursor, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceSnowflakeUpdateMethodTypeSourceSnowflakeScanChangesWithUserDefinedCursor,
			Value: &sourceSnowflakeScanChangesWithUserDefinedCursor,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceSnowflakeUpdateMethod", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceSnowflakeUpdateMethod", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceSnowflakeUpdateMethodType)
	switch best.Type {
	case SourceSnowflakeUpdateMethodTypeSourceSnowflakeScanChangesWithUserDefinedCursor:
		u.SourceSnowflakeScanChangesWithUserDefinedCursor = best.Value.(*SourceSnowflakeScanChangesWithUserDefinedCursor)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceSnowflakeUpdateMethod", string(data))
}

func (u SourceSnowflakeUpdateMethod) MarshalJSON() ([]byte, error) {
	if u.SourceSnowflakeScanChangesWithUserDefinedCursor != nil {
		return utils.MarshalJSON(u.SourceSnowflakeScanChangesWithUserDefinedCursor, "", true)
	}

	return nil, errors.New("could not marshal union type SourceSnowflakeUpdateMethod: all fields are null")
}

type SourceSnowflakeSourceType string

const (
	SourceSnowflakeSourceTypeSnowflake SourceSnowflakeSourceType = "snowflake"
)

func (e SourceSnowflakeSourceType) ToPointer() *SourceSnowflakeSourceType {
	return &e
}
func (e *SourceSnowflakeSourceType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "snowflake":
		*e = SourceSnowflakeSourceType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceSnowflakeSourceType: %v", v)
	}
}

type SourceSnowflake struct {
	// When this feature is enabled, during schema discovery the connector will query each table or view individually to check access privileges and inaccessible tables, views, or columns therein will be removed. In large schemas, this might cause schema discovery to take too long, in which case it might be advisable to disable this feature.
	CheckPrivileges *bool `default:"true" json:"check_privileges"`
	// How often (in seconds) a stream should checkpoint, when possible.
	CheckpointTargetIntervalSeconds *int64 `default:"300" json:"checkpoint_target_interval_seconds"`
	// Maximum number of concurrent queries to the database.
	Concurrency *int64                              `default:"1" json:"concurrency"`
	Credentials *SourceSnowflakeAuthorizationMethod `json:"credentials,omitempty"`
	// Configures how data is extracted from the database.
	Cursor *SourceSnowflakeUpdateMethod `json:"cursor,omitempty"`
	// The database you created for Airbyte to access data.
	Database string `json:"database"`
	// The host domain of the snowflake instance (must include the account, region, cloud environment, and end with snowflakecomputing.com).
	Host string `json:"host"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// The role you created for Airbyte to access Snowflake.
	Role string `json:"role"`
	// The source Snowflake schema tables. Leave empty to access tables from multiple schemas.
	Schema *string `json:"schema,omitempty"`
	// The warehouse you created for Airbyte to access data.
	Warehouse            string                     `json:"warehouse"`
	sourceType           *SourceSnowflakeSourceType `const:"snowflake" json:"sourceType"`
	AdditionalProperties any                        `additionalProperties:"true" json:"-"`
}

func (s SourceSnowflake) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceSnowflake) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceSnowflake) GetCheckPrivileges() *bool {
	if s == nil {
		return nil
	}
	return s.CheckPrivileges
}

func (s *SourceSnowflake) GetCheckpointTargetIntervalSeconds() *int64 {
	if s == nil {
		return nil
	}
	return s.CheckpointTargetIntervalSeconds
}

func (s *SourceSnowflake) GetConcurrency() *int64 {
	if s == nil {
		return nil
	}
	return s.Concurrency
}

func (s *SourceSnowflake) GetCredentials() *SourceSnowflakeAuthorizationMethod {
	if s == nil {
		return nil
	}
	return s.Credentials
}

func (s *SourceSnowflake) GetCursor() *SourceSnowflakeUpdateMethod {
	if s == nil {
		return nil
	}
	return s.Cursor
}

func (s *SourceSnowflake) GetDatabase() string {
	if s == nil {
		return ""
	}
	return s.Database
}

func (s *SourceSnowflake) GetHost() string {
	if s == nil {
		return ""
	}
	return s.Host
}

func (s *SourceSnowflake) GetJdbcURLParams() *string {
	if s == nil {
		return nil
	}
	return s.JdbcURLParams
}

func (s *SourceSnowflake) GetRole() string {
	if s == nil {
		return ""
	}
	return s.Role
}

func (s *SourceSnowflake) GetSchema() *string {
	if s == nil {
		return nil
	}
	return s.Schema
}

func (s *SourceSnowflake) GetWarehouse() string {
	if s == nil {
		return ""
	}
	return s.Warehouse
}

func (s *SourceSnowflake) GetSourceType() *SourceSnowflakeSourceType {
	return SourceSnowflakeSourceTypeSnowflake.ToPointer()
}

func (s *SourceSnowflake) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}
