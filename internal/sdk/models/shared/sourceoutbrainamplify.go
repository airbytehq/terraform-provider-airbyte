// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

// DefinitionOfConversionCountInReports - The definition of conversion count in reports. See <a href="https://amplifyv01.docs.apiary.io/#reference/performance-reporting/periodic/retrieve-performance-statistics-for-all-marketer-campaigns-by-periodic-breakdown">the docs</a>.
type DefinitionOfConversionCountInReports string

const (
	DefinitionOfConversionCountInReportsClickViewTime  DefinitionOfConversionCountInReports = "click/view_time"
	DefinitionOfConversionCountInReportsConversionTime DefinitionOfConversionCountInReports = "conversion_time"
)

func (e DefinitionOfConversionCountInReports) ToPointer() *DefinitionOfConversionCountInReports {
	return &e
}
func (e *DefinitionOfConversionCountInReports) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "click/view_time":
		fallthrough
	case "conversion_time":
		*e = DefinitionOfConversionCountInReports(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DefinitionOfConversionCountInReports: %v", v)
	}
}

type SourceOutbrainAmplifyUsernamePassword struct {
	// Add Password for authentication.
	Password string `json:"password"`
	type_    string `const:"username_password" json:"type"`
	// Add Username for authentication.
	Username string `json:"username"`
}

func (s SourceOutbrainAmplifyUsernamePassword) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceOutbrainAmplifyUsernamePassword) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceOutbrainAmplifyUsernamePassword) GetPassword() string {
	if s == nil {
		return ""
	}
	return s.Password
}

func (s *SourceOutbrainAmplifyUsernamePassword) GetType() string {
	return "username_password"
}

func (s *SourceOutbrainAmplifyUsernamePassword) GetUsername() string {
	if s == nil {
		return ""
	}
	return s.Username
}

type SourceOutbrainAmplifyAccessToken struct {
	// Access Token for making authenticated requests.
	AccessToken string `json:"access_token"`
	type_       string `const:"access_token" json:"type"`
}

func (s SourceOutbrainAmplifyAccessToken) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceOutbrainAmplifyAccessToken) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceOutbrainAmplifyAccessToken) GetAccessToken() string {
	if s == nil {
		return ""
	}
	return s.AccessToken
}

func (s *SourceOutbrainAmplifyAccessToken) GetType() string {
	return "access_token"
}

type SourceOutbrainAmplifyAuthenticationMethodType string

const (
	SourceOutbrainAmplifyAuthenticationMethodTypeSourceOutbrainAmplifyAccessToken      SourceOutbrainAmplifyAuthenticationMethodType = "source-outbrain-amplify_Access token"
	SourceOutbrainAmplifyAuthenticationMethodTypeSourceOutbrainAmplifyUsernamePassword SourceOutbrainAmplifyAuthenticationMethodType = "source-outbrain-amplify_Username Password"
)

// SourceOutbrainAmplifyAuthenticationMethod - Credentials for making authenticated requests requires either username/password or access_token.
type SourceOutbrainAmplifyAuthenticationMethod struct {
	SourceOutbrainAmplifyAccessToken      *SourceOutbrainAmplifyAccessToken      `queryParam:"inline" union:"member"`
	SourceOutbrainAmplifyUsernamePassword *SourceOutbrainAmplifyUsernamePassword `queryParam:"inline" union:"member"`

	Type SourceOutbrainAmplifyAuthenticationMethodType
}

func CreateSourceOutbrainAmplifyAuthenticationMethodSourceOutbrainAmplifyAccessToken(sourceOutbrainAmplifyAccessToken SourceOutbrainAmplifyAccessToken) SourceOutbrainAmplifyAuthenticationMethod {
	typ := SourceOutbrainAmplifyAuthenticationMethodTypeSourceOutbrainAmplifyAccessToken

	return SourceOutbrainAmplifyAuthenticationMethod{
		SourceOutbrainAmplifyAccessToken: &sourceOutbrainAmplifyAccessToken,
		Type:                             typ,
	}
}

func CreateSourceOutbrainAmplifyAuthenticationMethodSourceOutbrainAmplifyUsernamePassword(sourceOutbrainAmplifyUsernamePassword SourceOutbrainAmplifyUsernamePassword) SourceOutbrainAmplifyAuthenticationMethod {
	typ := SourceOutbrainAmplifyAuthenticationMethodTypeSourceOutbrainAmplifyUsernamePassword

	return SourceOutbrainAmplifyAuthenticationMethod{
		SourceOutbrainAmplifyUsernamePassword: &sourceOutbrainAmplifyUsernamePassword,
		Type:                                  typ,
	}
}

func (u *SourceOutbrainAmplifyAuthenticationMethod) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var sourceOutbrainAmplifyAccessToken SourceOutbrainAmplifyAccessToken = SourceOutbrainAmplifyAccessToken{}
	if err := utils.UnmarshalJSON(data, &sourceOutbrainAmplifyAccessToken, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceOutbrainAmplifyAuthenticationMethodTypeSourceOutbrainAmplifyAccessToken,
			Value: &sourceOutbrainAmplifyAccessToken,
		})
	}

	var sourceOutbrainAmplifyUsernamePassword SourceOutbrainAmplifyUsernamePassword = SourceOutbrainAmplifyUsernamePassword{}
	if err := utils.UnmarshalJSON(data, &sourceOutbrainAmplifyUsernamePassword, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceOutbrainAmplifyAuthenticationMethodTypeSourceOutbrainAmplifyUsernamePassword,
			Value: &sourceOutbrainAmplifyUsernamePassword,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceOutbrainAmplifyAuthenticationMethod", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceOutbrainAmplifyAuthenticationMethod", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceOutbrainAmplifyAuthenticationMethodType)
	switch best.Type {
	case SourceOutbrainAmplifyAuthenticationMethodTypeSourceOutbrainAmplifyAccessToken:
		u.SourceOutbrainAmplifyAccessToken = best.Value.(*SourceOutbrainAmplifyAccessToken)
		return nil
	case SourceOutbrainAmplifyAuthenticationMethodTypeSourceOutbrainAmplifyUsernamePassword:
		u.SourceOutbrainAmplifyUsernamePassword = best.Value.(*SourceOutbrainAmplifyUsernamePassword)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceOutbrainAmplifyAuthenticationMethod", string(data))
}

func (u SourceOutbrainAmplifyAuthenticationMethod) MarshalJSON() ([]byte, error) {
	if u.SourceOutbrainAmplifyAccessToken != nil {
		return utils.MarshalJSON(u.SourceOutbrainAmplifyAccessToken, "", true)
	}

	if u.SourceOutbrainAmplifyUsernamePassword != nil {
		return utils.MarshalJSON(u.SourceOutbrainAmplifyUsernamePassword, "", true)
	}

	return nil, errors.New("could not marshal union type SourceOutbrainAmplifyAuthenticationMethod: all fields are null")
}

// GranularityForGeoLocationRegion - The granularity used for geo location data in reports.
type GranularityForGeoLocationRegion string

const (
	GranularityForGeoLocationRegionCountry   GranularityForGeoLocationRegion = "country"
	GranularityForGeoLocationRegionRegion    GranularityForGeoLocationRegion = "region"
	GranularityForGeoLocationRegionSubregion GranularityForGeoLocationRegion = "subregion"
)

func (e GranularityForGeoLocationRegion) ToPointer() *GranularityForGeoLocationRegion {
	return &e
}
func (e *GranularityForGeoLocationRegion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "country":
		fallthrough
	case "region":
		fallthrough
	case "subregion":
		*e = GranularityForGeoLocationRegion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GranularityForGeoLocationRegion: %v", v)
	}
}

// GranularityForPeriodicReports - The granularity used for periodic data in reports. See <a href="https://amplifyv01.docs.apiary.io/#reference/performance-reporting/periodic/retrieve-performance-statistics-for-all-marketer-campaigns-by-periodic-breakdown">the docs</a>.
type GranularityForPeriodicReports string

const (
	GranularityForPeriodicReportsDaily   GranularityForPeriodicReports = "daily"
	GranularityForPeriodicReportsWeekly  GranularityForPeriodicReports = "weekly"
	GranularityForPeriodicReportsMonthly GranularityForPeriodicReports = "monthly"
)

func (e GranularityForPeriodicReports) ToPointer() *GranularityForPeriodicReports {
	return &e
}
func (e *GranularityForPeriodicReports) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "daily":
		fallthrough
	case "weekly":
		fallthrough
	case "monthly":
		*e = GranularityForPeriodicReports(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GranularityForPeriodicReports: %v", v)
	}
}

type SourceOutbrainAmplifySourceType string

const (
	SourceOutbrainAmplifySourceTypeOutbrainAmplify SourceOutbrainAmplifySourceType = "outbrain-amplify"
)

func (e SourceOutbrainAmplifySourceType) ToPointer() *SourceOutbrainAmplifySourceType {
	return &e
}
func (e *SourceOutbrainAmplifySourceType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "outbrain-amplify":
		*e = SourceOutbrainAmplifySourceType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceOutbrainAmplifySourceType: %v", v)
	}
}

type SourceOutbrainAmplify struct {
	// The definition of conversion count in reports. See <a href="https://amplifyv01.docs.apiary.io/#reference/performance-reporting/periodic/retrieve-performance-statistics-for-all-marketer-campaigns-by-periodic-breakdown">the docs</a>.
	ConversionCount *DefinitionOfConversionCountInReports `json:"conversion_count,omitempty"`
	// Credentials for making authenticated requests requires either username/password or access_token.
	Credentials SourceOutbrainAmplifyAuthenticationMethod `json:"credentials"`
	// Date in the format YYYY-MM-DD.
	EndDate *string `json:"end_date,omitempty"`
	// The granularity used for geo location data in reports.
	GeoLocationBreakdown *GranularityForGeoLocationRegion `json:"geo_location_breakdown,omitempty"`
	// The granularity used for periodic data in reports. See <a href="https://amplifyv01.docs.apiary.io/#reference/performance-reporting/periodic/retrieve-performance-statistics-for-all-marketer-campaigns-by-periodic-breakdown">the docs</a>.
	ReportGranularity *GranularityForPeriodicReports `json:"report_granularity,omitempty"`
	// Date in the format YYYY-MM-DD eg. 2017-01-25. Any data before this date will not be replicated.
	StartDate  string                           `json:"start_date"`
	sourceType *SourceOutbrainAmplifySourceType `const:"outbrain-amplify" json:"sourceType"`
}

func (s SourceOutbrainAmplify) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceOutbrainAmplify) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceOutbrainAmplify) GetConversionCount() *DefinitionOfConversionCountInReports {
	if s == nil {
		return nil
	}
	return s.ConversionCount
}

func (s *SourceOutbrainAmplify) GetCredentials() SourceOutbrainAmplifyAuthenticationMethod {
	if s == nil {
		return SourceOutbrainAmplifyAuthenticationMethod{}
	}
	return s.Credentials
}

func (s *SourceOutbrainAmplify) GetEndDate() *string {
	if s == nil {
		return nil
	}
	return s.EndDate
}

func (s *SourceOutbrainAmplify) GetGeoLocationBreakdown() *GranularityForGeoLocationRegion {
	if s == nil {
		return nil
	}
	return s.GeoLocationBreakdown
}

func (s *SourceOutbrainAmplify) GetReportGranularity() *GranularityForPeriodicReports {
	if s == nil {
		return nil
	}
	return s.ReportGranularity
}

func (s *SourceOutbrainAmplify) GetStartDate() string {
	if s == nil {
		return ""
	}
	return s.StartDate
}

func (s *SourceOutbrainAmplify) GetSourceType() *SourceOutbrainAmplifySourceType {
	return SourceOutbrainAmplifySourceTypeOutbrainAmplify.ToPointer()
}
