// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

type SourceNetsuiteEnterpriseUpdateSchemasAuthenticationMethodAuthenticationMethod string

const (
	SourceNetsuiteEnterpriseUpdateSchemasAuthenticationMethodAuthenticationMethodOauth2Authentication SourceNetsuiteEnterpriseUpdateSchemasAuthenticationMethodAuthenticationMethod = "oauth2_authentication"
)

func (e SourceNetsuiteEnterpriseUpdateSchemasAuthenticationMethodAuthenticationMethod) ToPointer() *SourceNetsuiteEnterpriseUpdateSchemasAuthenticationMethodAuthenticationMethod {
	return &e
}
func (e *SourceNetsuiteEnterpriseUpdateSchemasAuthenticationMethodAuthenticationMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "oauth2_authentication":
		*e = SourceNetsuiteEnterpriseUpdateSchemasAuthenticationMethodAuthenticationMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceNetsuiteEnterpriseUpdateSchemasAuthenticationMethodAuthenticationMethod: %v", v)
	}
}

// SourceNetsuiteEnterpriseUpdateOAuth2Authentication - Authenticate using OAuth2. This requires a consumer key, the private part of the certificate with which netsuite OAuth2 Client Credentials was setup and the certificate ID for the OAuth2 setup entry.
type SourceNetsuiteEnterpriseUpdateOAuth2Authentication struct {
	AuthenticationMethod *SourceNetsuiteEnterpriseUpdateSchemasAuthenticationMethodAuthenticationMethod `default:"oauth2_authentication" json:"authentication_method"`
	// The consumer key used for OAuth2 authentication. This is generated in NetSuite when creating an integration record.
	ClientID *string `json:"client_id,omitempty"`
	// The certificate ID for the OAuth 2.0 Client Credentials Setup entry.
	KeyID *string `json:"key_id,omitempty"`
	// The private portion of the certificate with which OAuth2 was setup. ( created with openssl req -new -x509 -newkey rsa:4096 -keyout private.pem -sigopt rsa_padding_mode:pss -sha256 -sigopt rsa_pss_saltlen:64 -out public.pem -nodes -days 365 )
	Oauth2PrivateKey     *string `json:"oauth2_private_key,omitempty"`
	AdditionalProperties any     `additionalProperties:"true" json:"-"`
}

func (s SourceNetsuiteEnterpriseUpdateOAuth2Authentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceNetsuiteEnterpriseUpdateOAuth2Authentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceNetsuiteEnterpriseUpdateOAuth2Authentication) GetAuthenticationMethod() *SourceNetsuiteEnterpriseUpdateSchemasAuthenticationMethodAuthenticationMethod {
	if s == nil {
		return nil
	}
	return s.AuthenticationMethod
}

func (s *SourceNetsuiteEnterpriseUpdateOAuth2Authentication) GetClientID() *string {
	if s == nil {
		return nil
	}
	return s.ClientID
}

func (s *SourceNetsuiteEnterpriseUpdateOAuth2Authentication) GetKeyID() *string {
	if s == nil {
		return nil
	}
	return s.KeyID
}

func (s *SourceNetsuiteEnterpriseUpdateOAuth2Authentication) GetOauth2PrivateKey() *string {
	if s == nil {
		return nil
	}
	return s.Oauth2PrivateKey
}

func (s *SourceNetsuiteEnterpriseUpdateOAuth2Authentication) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceNetsuiteEnterpriseUpdateSchemasAuthenticationMethod string

const (
	SourceNetsuiteEnterpriseUpdateSchemasAuthenticationMethodTokenBasedAuthentication SourceNetsuiteEnterpriseUpdateSchemasAuthenticationMethod = "token_based_authentication"
)

func (e SourceNetsuiteEnterpriseUpdateSchemasAuthenticationMethod) ToPointer() *SourceNetsuiteEnterpriseUpdateSchemasAuthenticationMethod {
	return &e
}
func (e *SourceNetsuiteEnterpriseUpdateSchemasAuthenticationMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "token_based_authentication":
		*e = SourceNetsuiteEnterpriseUpdateSchemasAuthenticationMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceNetsuiteEnterpriseUpdateSchemasAuthenticationMethod: %v", v)
	}
}

// SourceNetsuiteEnterpriseUpdateTokenBasedAuthentication - Authenticate using a token-based authentication method. This requires a consumer key and secret, as well as a token ID and secret.
type SourceNetsuiteEnterpriseUpdateTokenBasedAuthentication struct {
	AuthenticationMethod *SourceNetsuiteEnterpriseUpdateSchemasAuthenticationMethod `default:"token_based_authentication" json:"authentication_method"`
	// The consumer key used for token-based authentication. This is generated in NetSuite when creating an integration record.
	ClientID *string `json:"client_id,omitempty"`
	// The consumer secret used for token-based authentication. This is generated in NetSuite when creating an integration record.
	ClientSecret *string `json:"client_secret,omitempty"`
	// The token ID used for token-based authentication. This is generated in NetSuite when creating a token-based role.
	TokenID *string `json:"token_id,omitempty"`
	// The token secret used for token-based authentication. This is generated in NetSuite when creating a token-based role.Ensure to keep this value secure.
	TokenSecret          *string `json:"token_secret,omitempty"`
	AdditionalProperties any     `additionalProperties:"true" json:"-"`
}

func (s SourceNetsuiteEnterpriseUpdateTokenBasedAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceNetsuiteEnterpriseUpdateTokenBasedAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceNetsuiteEnterpriseUpdateTokenBasedAuthentication) GetAuthenticationMethod() *SourceNetsuiteEnterpriseUpdateSchemasAuthenticationMethod {
	if s == nil {
		return nil
	}
	return s.AuthenticationMethod
}

func (s *SourceNetsuiteEnterpriseUpdateTokenBasedAuthentication) GetClientID() *string {
	if s == nil {
		return nil
	}
	return s.ClientID
}

func (s *SourceNetsuiteEnterpriseUpdateTokenBasedAuthentication) GetClientSecret() *string {
	if s == nil {
		return nil
	}
	return s.ClientSecret
}

func (s *SourceNetsuiteEnterpriseUpdateTokenBasedAuthentication) GetTokenID() *string {
	if s == nil {
		return nil
	}
	return s.TokenID
}

func (s *SourceNetsuiteEnterpriseUpdateTokenBasedAuthentication) GetTokenSecret() *string {
	if s == nil {
		return nil
	}
	return s.TokenSecret
}

func (s *SourceNetsuiteEnterpriseUpdateTokenBasedAuthentication) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceNetsuiteEnterpriseUpdateSchemasAuthenticationMethodAuthenticationMethodAuthenticationMethod string

const (
	SourceNetsuiteEnterpriseUpdateSchemasAuthenticationMethodAuthenticationMethodAuthenticationMethodPasswordAuthentication SourceNetsuiteEnterpriseUpdateSchemasAuthenticationMethodAuthenticationMethodAuthenticationMethod = "password_authentication"
)

func (e SourceNetsuiteEnterpriseUpdateSchemasAuthenticationMethodAuthenticationMethodAuthenticationMethod) ToPointer() *SourceNetsuiteEnterpriseUpdateSchemasAuthenticationMethodAuthenticationMethodAuthenticationMethod {
	return &e
}
func (e *SourceNetsuiteEnterpriseUpdateSchemasAuthenticationMethodAuthenticationMethodAuthenticationMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "password_authentication":
		*e = SourceNetsuiteEnterpriseUpdateSchemasAuthenticationMethodAuthenticationMethodAuthenticationMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceNetsuiteEnterpriseUpdateSchemasAuthenticationMethodAuthenticationMethodAuthenticationMethod: %v", v)
	}
}

// SourceNetsuiteEnterpriseUpdatePasswordAuthentication - Authenticate using a password.
type SourceNetsuiteEnterpriseUpdatePasswordAuthentication struct {
	AuthenticationMethod *SourceNetsuiteEnterpriseUpdateSchemasAuthenticationMethodAuthenticationMethodAuthenticationMethod `default:"password_authentication" json:"authentication_method"`
	// The password associated with the username.
	Password             *string `json:"password,omitempty"`
	AdditionalProperties any     `additionalProperties:"true" json:"-"`
}

func (s SourceNetsuiteEnterpriseUpdatePasswordAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceNetsuiteEnterpriseUpdatePasswordAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceNetsuiteEnterpriseUpdatePasswordAuthentication) GetAuthenticationMethod() *SourceNetsuiteEnterpriseUpdateSchemasAuthenticationMethodAuthenticationMethodAuthenticationMethod {
	if s == nil {
		return nil
	}
	return s.AuthenticationMethod
}

func (s *SourceNetsuiteEnterpriseUpdatePasswordAuthentication) GetPassword() *string {
	if s == nil {
		return nil
	}
	return s.Password
}

func (s *SourceNetsuiteEnterpriseUpdatePasswordAuthentication) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceNetsuiteEnterpriseUpdateAuthenticationMethodType string

const (
	SourceNetsuiteEnterpriseUpdateAuthenticationMethodTypeSourceNetsuiteEnterpriseUpdatePasswordAuthentication   SourceNetsuiteEnterpriseUpdateAuthenticationMethodType = "source-netsuite-enterprise-update_Password Authentication"
	SourceNetsuiteEnterpriseUpdateAuthenticationMethodTypeSourceNetsuiteEnterpriseUpdateTokenBasedAuthentication SourceNetsuiteEnterpriseUpdateAuthenticationMethodType = "source-netsuite-enterprise-update_Token Based Authentication"
	SourceNetsuiteEnterpriseUpdateAuthenticationMethodTypeSourceNetsuiteEnterpriseUpdateOAuth2Authentication     SourceNetsuiteEnterpriseUpdateAuthenticationMethodType = "source-netsuite-enterprise-update_OAuth2 Authentication"
)

// SourceNetsuiteEnterpriseUpdateAuthenticationMethod - Configure how to authenticate to Netsuite. Options include username/password or token-based authentication.
type SourceNetsuiteEnterpriseUpdateAuthenticationMethod struct {
	SourceNetsuiteEnterpriseUpdatePasswordAuthentication   *SourceNetsuiteEnterpriseUpdatePasswordAuthentication   `queryParam:"inline" union:"member"`
	SourceNetsuiteEnterpriseUpdateTokenBasedAuthentication *SourceNetsuiteEnterpriseUpdateTokenBasedAuthentication `queryParam:"inline" union:"member"`
	SourceNetsuiteEnterpriseUpdateOAuth2Authentication     *SourceNetsuiteEnterpriseUpdateOAuth2Authentication     `queryParam:"inline" union:"member"`

	Type SourceNetsuiteEnterpriseUpdateAuthenticationMethodType
}

func CreateSourceNetsuiteEnterpriseUpdateAuthenticationMethodSourceNetsuiteEnterpriseUpdatePasswordAuthentication(sourceNetsuiteEnterpriseUpdatePasswordAuthentication SourceNetsuiteEnterpriseUpdatePasswordAuthentication) SourceNetsuiteEnterpriseUpdateAuthenticationMethod {
	typ := SourceNetsuiteEnterpriseUpdateAuthenticationMethodTypeSourceNetsuiteEnterpriseUpdatePasswordAuthentication

	return SourceNetsuiteEnterpriseUpdateAuthenticationMethod{
		SourceNetsuiteEnterpriseUpdatePasswordAuthentication: &sourceNetsuiteEnterpriseUpdatePasswordAuthentication,
		Type: typ,
	}
}

func CreateSourceNetsuiteEnterpriseUpdateAuthenticationMethodSourceNetsuiteEnterpriseUpdateTokenBasedAuthentication(sourceNetsuiteEnterpriseUpdateTokenBasedAuthentication SourceNetsuiteEnterpriseUpdateTokenBasedAuthentication) SourceNetsuiteEnterpriseUpdateAuthenticationMethod {
	typ := SourceNetsuiteEnterpriseUpdateAuthenticationMethodTypeSourceNetsuiteEnterpriseUpdateTokenBasedAuthentication

	return SourceNetsuiteEnterpriseUpdateAuthenticationMethod{
		SourceNetsuiteEnterpriseUpdateTokenBasedAuthentication: &sourceNetsuiteEnterpriseUpdateTokenBasedAuthentication,
		Type: typ,
	}
}

func CreateSourceNetsuiteEnterpriseUpdateAuthenticationMethodSourceNetsuiteEnterpriseUpdateOAuth2Authentication(sourceNetsuiteEnterpriseUpdateOAuth2Authentication SourceNetsuiteEnterpriseUpdateOAuth2Authentication) SourceNetsuiteEnterpriseUpdateAuthenticationMethod {
	typ := SourceNetsuiteEnterpriseUpdateAuthenticationMethodTypeSourceNetsuiteEnterpriseUpdateOAuth2Authentication

	return SourceNetsuiteEnterpriseUpdateAuthenticationMethod{
		SourceNetsuiteEnterpriseUpdateOAuth2Authentication: &sourceNetsuiteEnterpriseUpdateOAuth2Authentication,
		Type: typ,
	}
}

func (u *SourceNetsuiteEnterpriseUpdateAuthenticationMethod) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var sourceNetsuiteEnterpriseUpdatePasswordAuthentication SourceNetsuiteEnterpriseUpdatePasswordAuthentication = SourceNetsuiteEnterpriseUpdatePasswordAuthentication{}
	if err := utils.UnmarshalJSON(data, &sourceNetsuiteEnterpriseUpdatePasswordAuthentication, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceNetsuiteEnterpriseUpdateAuthenticationMethodTypeSourceNetsuiteEnterpriseUpdatePasswordAuthentication,
			Value: &sourceNetsuiteEnterpriseUpdatePasswordAuthentication,
		})
	}

	var sourceNetsuiteEnterpriseUpdateTokenBasedAuthentication SourceNetsuiteEnterpriseUpdateTokenBasedAuthentication = SourceNetsuiteEnterpriseUpdateTokenBasedAuthentication{}
	if err := utils.UnmarshalJSON(data, &sourceNetsuiteEnterpriseUpdateTokenBasedAuthentication, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceNetsuiteEnterpriseUpdateAuthenticationMethodTypeSourceNetsuiteEnterpriseUpdateTokenBasedAuthentication,
			Value: &sourceNetsuiteEnterpriseUpdateTokenBasedAuthentication,
		})
	}

	var sourceNetsuiteEnterpriseUpdateOAuth2Authentication SourceNetsuiteEnterpriseUpdateOAuth2Authentication = SourceNetsuiteEnterpriseUpdateOAuth2Authentication{}
	if err := utils.UnmarshalJSON(data, &sourceNetsuiteEnterpriseUpdateOAuth2Authentication, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceNetsuiteEnterpriseUpdateAuthenticationMethodTypeSourceNetsuiteEnterpriseUpdateOAuth2Authentication,
			Value: &sourceNetsuiteEnterpriseUpdateOAuth2Authentication,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceNetsuiteEnterpriseUpdateAuthenticationMethod", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceNetsuiteEnterpriseUpdateAuthenticationMethod", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceNetsuiteEnterpriseUpdateAuthenticationMethodType)
	switch best.Type {
	case SourceNetsuiteEnterpriseUpdateAuthenticationMethodTypeSourceNetsuiteEnterpriseUpdatePasswordAuthentication:
		u.SourceNetsuiteEnterpriseUpdatePasswordAuthentication = best.Value.(*SourceNetsuiteEnterpriseUpdatePasswordAuthentication)
		return nil
	case SourceNetsuiteEnterpriseUpdateAuthenticationMethodTypeSourceNetsuiteEnterpriseUpdateTokenBasedAuthentication:
		u.SourceNetsuiteEnterpriseUpdateTokenBasedAuthentication = best.Value.(*SourceNetsuiteEnterpriseUpdateTokenBasedAuthentication)
		return nil
	case SourceNetsuiteEnterpriseUpdateAuthenticationMethodTypeSourceNetsuiteEnterpriseUpdateOAuth2Authentication:
		u.SourceNetsuiteEnterpriseUpdateOAuth2Authentication = best.Value.(*SourceNetsuiteEnterpriseUpdateOAuth2Authentication)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceNetsuiteEnterpriseUpdateAuthenticationMethod", string(data))
}

func (u SourceNetsuiteEnterpriseUpdateAuthenticationMethod) MarshalJSON() ([]byte, error) {
	if u.SourceNetsuiteEnterpriseUpdatePasswordAuthentication != nil {
		return utils.MarshalJSON(u.SourceNetsuiteEnterpriseUpdatePasswordAuthentication, "", true)
	}

	if u.SourceNetsuiteEnterpriseUpdateTokenBasedAuthentication != nil {
		return utils.MarshalJSON(u.SourceNetsuiteEnterpriseUpdateTokenBasedAuthentication, "", true)
	}

	if u.SourceNetsuiteEnterpriseUpdateOAuth2Authentication != nil {
		return utils.MarshalJSON(u.SourceNetsuiteEnterpriseUpdateOAuth2Authentication, "", true)
	}

	return nil, errors.New("could not marshal union type SourceNetsuiteEnterpriseUpdateAuthenticationMethod: all fields are null")
}

type SourceNetsuiteEnterpriseUpdateCursorMethod string

const (
	SourceNetsuiteEnterpriseUpdateCursorMethodUserDefined SourceNetsuiteEnterpriseUpdateCursorMethod = "user_defined"
)

func (e SourceNetsuiteEnterpriseUpdateCursorMethod) ToPointer() *SourceNetsuiteEnterpriseUpdateCursorMethod {
	return &e
}
func (e *SourceNetsuiteEnterpriseUpdateCursorMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "user_defined":
		*e = SourceNetsuiteEnterpriseUpdateCursorMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceNetsuiteEnterpriseUpdateCursorMethod: %v", v)
	}
}

// SourceNetsuiteEnterpriseUpdateScanChangesWithUserDefinedCursor - Incrementally detects new inserts and updates using the <a href="https://docs.airbyte.com/understanding-airbyte/connections/incremental-append/#user-defined-cursor">cursor column</a> chosen when configuring a connection (e.g. created_at, updated_at).
type SourceNetsuiteEnterpriseUpdateScanChangesWithUserDefinedCursor struct {
	CursorMethod         *SourceNetsuiteEnterpriseUpdateCursorMethod `default:"user_defined" json:"cursor_method"`
	AdditionalProperties any                                         `additionalProperties:"true" json:"-"`
}

func (s SourceNetsuiteEnterpriseUpdateScanChangesWithUserDefinedCursor) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceNetsuiteEnterpriseUpdateScanChangesWithUserDefinedCursor) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceNetsuiteEnterpriseUpdateScanChangesWithUserDefinedCursor) GetCursorMethod() *SourceNetsuiteEnterpriseUpdateCursorMethod {
	if s == nil {
		return nil
	}
	return s.CursorMethod
}

func (s *SourceNetsuiteEnterpriseUpdateScanChangesWithUserDefinedCursor) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceNetsuiteEnterpriseUpdateUpdateMethodType string

const (
	SourceNetsuiteEnterpriseUpdateUpdateMethodTypeSourceNetsuiteEnterpriseUpdateScanChangesWithUserDefinedCursor SourceNetsuiteEnterpriseUpdateUpdateMethodType = "source-netsuite-enterprise-update_Scan Changes with User Defined Cursor"
)

// SourceNetsuiteEnterpriseUpdateUpdateMethod - Configures how data is extracted from the database.
type SourceNetsuiteEnterpriseUpdateUpdateMethod struct {
	SourceNetsuiteEnterpriseUpdateScanChangesWithUserDefinedCursor *SourceNetsuiteEnterpriseUpdateScanChangesWithUserDefinedCursor `queryParam:"inline" union:"member"`

	Type SourceNetsuiteEnterpriseUpdateUpdateMethodType
}

func CreateSourceNetsuiteEnterpriseUpdateUpdateMethodSourceNetsuiteEnterpriseUpdateScanChangesWithUserDefinedCursor(sourceNetsuiteEnterpriseUpdateScanChangesWithUserDefinedCursor SourceNetsuiteEnterpriseUpdateScanChangesWithUserDefinedCursor) SourceNetsuiteEnterpriseUpdateUpdateMethod {
	typ := SourceNetsuiteEnterpriseUpdateUpdateMethodTypeSourceNetsuiteEnterpriseUpdateScanChangesWithUserDefinedCursor

	return SourceNetsuiteEnterpriseUpdateUpdateMethod{
		SourceNetsuiteEnterpriseUpdateScanChangesWithUserDefinedCursor: &sourceNetsuiteEnterpriseUpdateScanChangesWithUserDefinedCursor,
		Type: typ,
	}
}

func (u *SourceNetsuiteEnterpriseUpdateUpdateMethod) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var sourceNetsuiteEnterpriseUpdateScanChangesWithUserDefinedCursor SourceNetsuiteEnterpriseUpdateScanChangesWithUserDefinedCursor = SourceNetsuiteEnterpriseUpdateScanChangesWithUserDefinedCursor{}
	if err := utils.UnmarshalJSON(data, &sourceNetsuiteEnterpriseUpdateScanChangesWithUserDefinedCursor, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceNetsuiteEnterpriseUpdateUpdateMethodTypeSourceNetsuiteEnterpriseUpdateScanChangesWithUserDefinedCursor,
			Value: &sourceNetsuiteEnterpriseUpdateScanChangesWithUserDefinedCursor,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceNetsuiteEnterpriseUpdateUpdateMethod", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceNetsuiteEnterpriseUpdateUpdateMethod", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceNetsuiteEnterpriseUpdateUpdateMethodType)
	switch best.Type {
	case SourceNetsuiteEnterpriseUpdateUpdateMethodTypeSourceNetsuiteEnterpriseUpdateScanChangesWithUserDefinedCursor:
		u.SourceNetsuiteEnterpriseUpdateScanChangesWithUserDefinedCursor = best.Value.(*SourceNetsuiteEnterpriseUpdateScanChangesWithUserDefinedCursor)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceNetsuiteEnterpriseUpdateUpdateMethod", string(data))
}

func (u SourceNetsuiteEnterpriseUpdateUpdateMethod) MarshalJSON() ([]byte, error) {
	if u.SourceNetsuiteEnterpriseUpdateScanChangesWithUserDefinedCursor != nil {
		return utils.MarshalJSON(u.SourceNetsuiteEnterpriseUpdateScanChangesWithUserDefinedCursor, "", true)
	}

	return nil, errors.New("could not marshal union type SourceNetsuiteEnterpriseUpdateUpdateMethod: all fields are null")
}

type SourceNetsuiteEnterpriseUpdateSchemasTunnelMethodTunnelMethod string

const (
	SourceNetsuiteEnterpriseUpdateSchemasTunnelMethodTunnelMethodSSHPasswordAuth SourceNetsuiteEnterpriseUpdateSchemasTunnelMethodTunnelMethod = "SSH_PASSWORD_AUTH"
)

func (e SourceNetsuiteEnterpriseUpdateSchemasTunnelMethodTunnelMethod) ToPointer() *SourceNetsuiteEnterpriseUpdateSchemasTunnelMethodTunnelMethod {
	return &e
}
func (e *SourceNetsuiteEnterpriseUpdateSchemasTunnelMethodTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_PASSWORD_AUTH":
		*e = SourceNetsuiteEnterpriseUpdateSchemasTunnelMethodTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceNetsuiteEnterpriseUpdateSchemasTunnelMethodTunnelMethod: %v", v)
	}
}

// SourceNetsuiteEnterpriseUpdateSchemasPasswordAuthentication - Connect through a jump server tunnel host using username and password authentication
type SourceNetsuiteEnterpriseUpdateSchemasPasswordAuthentication struct {
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost   *string                                                        `json:"tunnel_host,omitempty"`
	TunnelMethod *SourceNetsuiteEnterpriseUpdateSchemasTunnelMethodTunnelMethod `default:"SSH_PASSWORD_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser *string `json:"tunnel_user,omitempty"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword   *string `json:"tunnel_user_password,omitempty"`
	AdditionalProperties any     `additionalProperties:"true" json:"-"`
}

func (s SourceNetsuiteEnterpriseUpdateSchemasPasswordAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceNetsuiteEnterpriseUpdateSchemasPasswordAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceNetsuiteEnterpriseUpdateSchemasPasswordAuthentication) GetTunnelHost() *string {
	if s == nil {
		return nil
	}
	return s.TunnelHost
}

func (s *SourceNetsuiteEnterpriseUpdateSchemasPasswordAuthentication) GetTunnelMethod() *SourceNetsuiteEnterpriseUpdateSchemasTunnelMethodTunnelMethod {
	if s == nil {
		return nil
	}
	return s.TunnelMethod
}

func (s *SourceNetsuiteEnterpriseUpdateSchemasPasswordAuthentication) GetTunnelPort() *int64 {
	if s == nil {
		return nil
	}
	return s.TunnelPort
}

func (s *SourceNetsuiteEnterpriseUpdateSchemasPasswordAuthentication) GetTunnelUser() *string {
	if s == nil {
		return nil
	}
	return s.TunnelUser
}

func (s *SourceNetsuiteEnterpriseUpdateSchemasPasswordAuthentication) GetTunnelUserPassword() *string {
	if s == nil {
		return nil
	}
	return s.TunnelUserPassword
}

func (s *SourceNetsuiteEnterpriseUpdateSchemasPasswordAuthentication) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceNetsuiteEnterpriseUpdateSchemasTunnelMethod string

const (
	SourceNetsuiteEnterpriseUpdateSchemasTunnelMethodSSHKeyAuth SourceNetsuiteEnterpriseUpdateSchemasTunnelMethod = "SSH_KEY_AUTH"
)

func (e SourceNetsuiteEnterpriseUpdateSchemasTunnelMethod) ToPointer() *SourceNetsuiteEnterpriseUpdateSchemasTunnelMethod {
	return &e
}
func (e *SourceNetsuiteEnterpriseUpdateSchemasTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_KEY_AUTH":
		*e = SourceNetsuiteEnterpriseUpdateSchemasTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceNetsuiteEnterpriseUpdateSchemasTunnelMethod: %v", v)
	}
}

// SourceNetsuiteEnterpriseUpdateSSHKeyAuthentication - Connect through a jump server tunnel host using username and ssh key
type SourceNetsuiteEnterpriseUpdateSSHKeyAuthentication struct {
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey *string `json:"ssh_key,omitempty"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost   *string                                            `json:"tunnel_host,omitempty"`
	TunnelMethod *SourceNetsuiteEnterpriseUpdateSchemasTunnelMethod `default:"SSH_KEY_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser           *string `json:"tunnel_user,omitempty"`
	AdditionalProperties any     `additionalProperties:"true" json:"-"`
}

func (s SourceNetsuiteEnterpriseUpdateSSHKeyAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceNetsuiteEnterpriseUpdateSSHKeyAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceNetsuiteEnterpriseUpdateSSHKeyAuthentication) GetSSHKey() *string {
	if s == nil {
		return nil
	}
	return s.SSHKey
}

func (s *SourceNetsuiteEnterpriseUpdateSSHKeyAuthentication) GetTunnelHost() *string {
	if s == nil {
		return nil
	}
	return s.TunnelHost
}

func (s *SourceNetsuiteEnterpriseUpdateSSHKeyAuthentication) GetTunnelMethod() *SourceNetsuiteEnterpriseUpdateSchemasTunnelMethod {
	if s == nil {
		return nil
	}
	return s.TunnelMethod
}

func (s *SourceNetsuiteEnterpriseUpdateSSHKeyAuthentication) GetTunnelPort() *int64 {
	if s == nil {
		return nil
	}
	return s.TunnelPort
}

func (s *SourceNetsuiteEnterpriseUpdateSSHKeyAuthentication) GetTunnelUser() *string {
	if s == nil {
		return nil
	}
	return s.TunnelUser
}

func (s *SourceNetsuiteEnterpriseUpdateSSHKeyAuthentication) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceNetsuiteEnterpriseUpdateTunnelMethod string

const (
	SourceNetsuiteEnterpriseUpdateTunnelMethodNoTunnel SourceNetsuiteEnterpriseUpdateTunnelMethod = "NO_TUNNEL"
)

func (e SourceNetsuiteEnterpriseUpdateTunnelMethod) ToPointer() *SourceNetsuiteEnterpriseUpdateTunnelMethod {
	return &e
}
func (e *SourceNetsuiteEnterpriseUpdateTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NO_TUNNEL":
		*e = SourceNetsuiteEnterpriseUpdateTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceNetsuiteEnterpriseUpdateTunnelMethod: %v", v)
	}
}

// SourceNetsuiteEnterpriseUpdateNoTunnel - No ssh tunnel needed to connect to database
type SourceNetsuiteEnterpriseUpdateNoTunnel struct {
	TunnelMethod         *SourceNetsuiteEnterpriseUpdateTunnelMethod `default:"NO_TUNNEL" json:"tunnel_method"`
	AdditionalProperties any                                         `additionalProperties:"true" json:"-"`
}

func (s SourceNetsuiteEnterpriseUpdateNoTunnel) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceNetsuiteEnterpriseUpdateNoTunnel) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceNetsuiteEnterpriseUpdateNoTunnel) GetTunnelMethod() *SourceNetsuiteEnterpriseUpdateTunnelMethod {
	if s == nil {
		return nil
	}
	return s.TunnelMethod
}

func (s *SourceNetsuiteEnterpriseUpdateNoTunnel) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceNetsuiteEnterpriseUpdateSSHTunnelMethodType string

const (
	SourceNetsuiteEnterpriseUpdateSSHTunnelMethodTypeSourceNetsuiteEnterpriseUpdateNoTunnel                      SourceNetsuiteEnterpriseUpdateSSHTunnelMethodType = "source-netsuite-enterprise-update_No Tunnel"
	SourceNetsuiteEnterpriseUpdateSSHTunnelMethodTypeSourceNetsuiteEnterpriseUpdateSSHKeyAuthentication          SourceNetsuiteEnterpriseUpdateSSHTunnelMethodType = "source-netsuite-enterprise-update_SSH Key Authentication"
	SourceNetsuiteEnterpriseUpdateSSHTunnelMethodTypeSourceNetsuiteEnterpriseUpdateSchemasPasswordAuthentication SourceNetsuiteEnterpriseUpdateSSHTunnelMethodType = "source-netsuite-enterprise-update_Schemas_Password Authentication"
)

// SourceNetsuiteEnterpriseUpdateSSHTunnelMethod - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceNetsuiteEnterpriseUpdateSSHTunnelMethod struct {
	SourceNetsuiteEnterpriseUpdateNoTunnel                      *SourceNetsuiteEnterpriseUpdateNoTunnel                      `queryParam:"inline" union:"member"`
	SourceNetsuiteEnterpriseUpdateSSHKeyAuthentication          *SourceNetsuiteEnterpriseUpdateSSHKeyAuthentication          `queryParam:"inline" union:"member"`
	SourceNetsuiteEnterpriseUpdateSchemasPasswordAuthentication *SourceNetsuiteEnterpriseUpdateSchemasPasswordAuthentication `queryParam:"inline" union:"member"`

	Type SourceNetsuiteEnterpriseUpdateSSHTunnelMethodType
}

func CreateSourceNetsuiteEnterpriseUpdateSSHTunnelMethodSourceNetsuiteEnterpriseUpdateNoTunnel(sourceNetsuiteEnterpriseUpdateNoTunnel SourceNetsuiteEnterpriseUpdateNoTunnel) SourceNetsuiteEnterpriseUpdateSSHTunnelMethod {
	typ := SourceNetsuiteEnterpriseUpdateSSHTunnelMethodTypeSourceNetsuiteEnterpriseUpdateNoTunnel

	return SourceNetsuiteEnterpriseUpdateSSHTunnelMethod{
		SourceNetsuiteEnterpriseUpdateNoTunnel: &sourceNetsuiteEnterpriseUpdateNoTunnel,
		Type:                                   typ,
	}
}

func CreateSourceNetsuiteEnterpriseUpdateSSHTunnelMethodSourceNetsuiteEnterpriseUpdateSSHKeyAuthentication(sourceNetsuiteEnterpriseUpdateSSHKeyAuthentication SourceNetsuiteEnterpriseUpdateSSHKeyAuthentication) SourceNetsuiteEnterpriseUpdateSSHTunnelMethod {
	typ := SourceNetsuiteEnterpriseUpdateSSHTunnelMethodTypeSourceNetsuiteEnterpriseUpdateSSHKeyAuthentication

	return SourceNetsuiteEnterpriseUpdateSSHTunnelMethod{
		SourceNetsuiteEnterpriseUpdateSSHKeyAuthentication: &sourceNetsuiteEnterpriseUpdateSSHKeyAuthentication,
		Type: typ,
	}
}

func CreateSourceNetsuiteEnterpriseUpdateSSHTunnelMethodSourceNetsuiteEnterpriseUpdateSchemasPasswordAuthentication(sourceNetsuiteEnterpriseUpdateSchemasPasswordAuthentication SourceNetsuiteEnterpriseUpdateSchemasPasswordAuthentication) SourceNetsuiteEnterpriseUpdateSSHTunnelMethod {
	typ := SourceNetsuiteEnterpriseUpdateSSHTunnelMethodTypeSourceNetsuiteEnterpriseUpdateSchemasPasswordAuthentication

	return SourceNetsuiteEnterpriseUpdateSSHTunnelMethod{
		SourceNetsuiteEnterpriseUpdateSchemasPasswordAuthentication: &sourceNetsuiteEnterpriseUpdateSchemasPasswordAuthentication,
		Type: typ,
	}
}

func (u *SourceNetsuiteEnterpriseUpdateSSHTunnelMethod) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var sourceNetsuiteEnterpriseUpdateNoTunnel SourceNetsuiteEnterpriseUpdateNoTunnel = SourceNetsuiteEnterpriseUpdateNoTunnel{}
	if err := utils.UnmarshalJSON(data, &sourceNetsuiteEnterpriseUpdateNoTunnel, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceNetsuiteEnterpriseUpdateSSHTunnelMethodTypeSourceNetsuiteEnterpriseUpdateNoTunnel,
			Value: &sourceNetsuiteEnterpriseUpdateNoTunnel,
		})
	}

	var sourceNetsuiteEnterpriseUpdateSSHKeyAuthentication SourceNetsuiteEnterpriseUpdateSSHKeyAuthentication = SourceNetsuiteEnterpriseUpdateSSHKeyAuthentication{}
	if err := utils.UnmarshalJSON(data, &sourceNetsuiteEnterpriseUpdateSSHKeyAuthentication, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceNetsuiteEnterpriseUpdateSSHTunnelMethodTypeSourceNetsuiteEnterpriseUpdateSSHKeyAuthentication,
			Value: &sourceNetsuiteEnterpriseUpdateSSHKeyAuthentication,
		})
	}

	var sourceNetsuiteEnterpriseUpdateSchemasPasswordAuthentication SourceNetsuiteEnterpriseUpdateSchemasPasswordAuthentication = SourceNetsuiteEnterpriseUpdateSchemasPasswordAuthentication{}
	if err := utils.UnmarshalJSON(data, &sourceNetsuiteEnterpriseUpdateSchemasPasswordAuthentication, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceNetsuiteEnterpriseUpdateSSHTunnelMethodTypeSourceNetsuiteEnterpriseUpdateSchemasPasswordAuthentication,
			Value: &sourceNetsuiteEnterpriseUpdateSchemasPasswordAuthentication,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceNetsuiteEnterpriseUpdateSSHTunnelMethod", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceNetsuiteEnterpriseUpdateSSHTunnelMethod", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceNetsuiteEnterpriseUpdateSSHTunnelMethodType)
	switch best.Type {
	case SourceNetsuiteEnterpriseUpdateSSHTunnelMethodTypeSourceNetsuiteEnterpriseUpdateNoTunnel:
		u.SourceNetsuiteEnterpriseUpdateNoTunnel = best.Value.(*SourceNetsuiteEnterpriseUpdateNoTunnel)
		return nil
	case SourceNetsuiteEnterpriseUpdateSSHTunnelMethodTypeSourceNetsuiteEnterpriseUpdateSSHKeyAuthentication:
		u.SourceNetsuiteEnterpriseUpdateSSHKeyAuthentication = best.Value.(*SourceNetsuiteEnterpriseUpdateSSHKeyAuthentication)
		return nil
	case SourceNetsuiteEnterpriseUpdateSSHTunnelMethodTypeSourceNetsuiteEnterpriseUpdateSchemasPasswordAuthentication:
		u.SourceNetsuiteEnterpriseUpdateSchemasPasswordAuthentication = best.Value.(*SourceNetsuiteEnterpriseUpdateSchemasPasswordAuthentication)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceNetsuiteEnterpriseUpdateSSHTunnelMethod", string(data))
}

func (u SourceNetsuiteEnterpriseUpdateSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.SourceNetsuiteEnterpriseUpdateNoTunnel != nil {
		return utils.MarshalJSON(u.SourceNetsuiteEnterpriseUpdateNoTunnel, "", true)
	}

	if u.SourceNetsuiteEnterpriseUpdateSSHKeyAuthentication != nil {
		return utils.MarshalJSON(u.SourceNetsuiteEnterpriseUpdateSSHKeyAuthentication, "", true)
	}

	if u.SourceNetsuiteEnterpriseUpdateSchemasPasswordAuthentication != nil {
		return utils.MarshalJSON(u.SourceNetsuiteEnterpriseUpdateSchemasPasswordAuthentication, "", true)
	}

	return nil, errors.New("could not marshal union type SourceNetsuiteEnterpriseUpdateSSHTunnelMethod: all fields are null")
}

type SourceNetsuiteEnterpriseUpdateSourceType string

const (
	SourceNetsuiteEnterpriseUpdateSourceTypeNetsuiteEnterprise SourceNetsuiteEnterpriseUpdateSourceType = "netsuite-enterprise"
)

func (e SourceNetsuiteEnterpriseUpdateSourceType) ToPointer() *SourceNetsuiteEnterpriseUpdateSourceType {
	return &e
}
func (e *SourceNetsuiteEnterpriseUpdateSourceType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "netsuite-enterprise":
		*e = SourceNetsuiteEnterpriseUpdateSourceType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceNetsuiteEnterpriseUpdateSourceType: %v", v)
	}
}

type SourceNetsuiteEnterpriseUpdate struct {
	// The username which is used to access the database.
	AccountID *string `json:"account_id,omitempty"`
	// Configure how to authenticate to Netsuite. Options include username/password or token-based authentication.
	AuthenticationMethod *SourceNetsuiteEnterpriseUpdateAuthenticationMethod `json:"authentication_method,omitempty"`
	// When this feature is enabled, during schema discovery the connector will query each table or view individually to check access privileges and inaccessible tables, views, or columns therein will be removed. In large schemas, this might cause schema discovery to take too long, in which case it might be advisable to disable this feature.
	CheckPrivileges *bool `default:"true" json:"check_privileges"`
	// How often (in seconds) a stream should checkpoint, when possible.
	CheckpointTargetIntervalSeconds *int64 `default:"300" json:"checkpoint_target_interval_seconds"`
	// Maximum number of concurrent queries to the database.
	Concurrency *int64 `default:"1" json:"concurrency"`
	// Configures how data is extracted from the database.
	Cursor *SourceNetsuiteEnterpriseUpdateUpdateMethod `json:"cursor,omitempty"`
	// Hostname of the database.
	Host *string `json:"host,omitempty"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// Port of the database.
	Port *int64 `default:"1708" json:"port"`
	// The username which is used to access the database.
	RoleID *string `json:"role_id,omitempty"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod *SourceNetsuiteEnterpriseUpdateSSHTunnelMethod `json:"tunnel_method,omitempty"`
	// The username which is used to access the database.
	Username             *string                                   `json:"username,omitempty"`
	sourceType           *SourceNetsuiteEnterpriseUpdateSourceType `const:"netsuite-enterprise" json:"sourceType"`
	AdditionalProperties any                                       `additionalProperties:"true" json:"-"`
}

func (s SourceNetsuiteEnterpriseUpdate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceNetsuiteEnterpriseUpdate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceNetsuiteEnterpriseUpdate) GetAccountID() *string {
	if s == nil {
		return nil
	}
	return s.AccountID
}

func (s *SourceNetsuiteEnterpriseUpdate) GetAuthenticationMethod() *SourceNetsuiteEnterpriseUpdateAuthenticationMethod {
	if s == nil {
		return nil
	}
	return s.AuthenticationMethod
}

func (s *SourceNetsuiteEnterpriseUpdate) GetCheckPrivileges() *bool {
	if s == nil {
		return nil
	}
	return s.CheckPrivileges
}

func (s *SourceNetsuiteEnterpriseUpdate) GetCheckpointTargetIntervalSeconds() *int64 {
	if s == nil {
		return nil
	}
	return s.CheckpointTargetIntervalSeconds
}

func (s *SourceNetsuiteEnterpriseUpdate) GetConcurrency() *int64 {
	if s == nil {
		return nil
	}
	return s.Concurrency
}

func (s *SourceNetsuiteEnterpriseUpdate) GetCursor() *SourceNetsuiteEnterpriseUpdateUpdateMethod {
	if s == nil {
		return nil
	}
	return s.Cursor
}

func (s *SourceNetsuiteEnterpriseUpdate) GetHost() *string {
	if s == nil {
		return nil
	}
	return s.Host
}

func (s *SourceNetsuiteEnterpriseUpdate) GetJdbcURLParams() *string {
	if s == nil {
		return nil
	}
	return s.JdbcURLParams
}

func (s *SourceNetsuiteEnterpriseUpdate) GetPort() *int64 {
	if s == nil {
		return nil
	}
	return s.Port
}

func (s *SourceNetsuiteEnterpriseUpdate) GetRoleID() *string {
	if s == nil {
		return nil
	}
	return s.RoleID
}

func (s *SourceNetsuiteEnterpriseUpdate) GetTunnelMethod() *SourceNetsuiteEnterpriseUpdateSSHTunnelMethod {
	if s == nil {
		return nil
	}
	return s.TunnelMethod
}

func (s *SourceNetsuiteEnterpriseUpdate) GetUsername() *string {
	if s == nil {
		return nil
	}
	return s.Username
}

func (s *SourceNetsuiteEnterpriseUpdate) GetSourceType() *SourceNetsuiteEnterpriseUpdateSourceType {
	return SourceNetsuiteEnterpriseUpdateSourceTypeNetsuiteEnterprise.ToPointer()
}

func (s *SourceNetsuiteEnterpriseUpdate) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}
