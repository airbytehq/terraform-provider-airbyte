// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

type SourceNetsuiteEnterpriseUpdateSchemasAuthenticationMethod string

const (
	SourceNetsuiteEnterpriseUpdateSchemasAuthenticationMethodTokenBasedAuthentication SourceNetsuiteEnterpriseUpdateSchemasAuthenticationMethod = "token_based_authentication"
)

func (e SourceNetsuiteEnterpriseUpdateSchemasAuthenticationMethod) ToPointer() *SourceNetsuiteEnterpriseUpdateSchemasAuthenticationMethod {
	return &e
}
func (e *SourceNetsuiteEnterpriseUpdateSchemasAuthenticationMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "token_based_authentication":
		*e = SourceNetsuiteEnterpriseUpdateSchemasAuthenticationMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceNetsuiteEnterpriseUpdateSchemasAuthenticationMethod: %v", v)
	}
}

// SourceNetsuiteEnterpriseUpdateTokenBasedAuthentication - Authenticate using a token-based authentication method. This requires a consumer key and secret, as well as a token ID and secret.
type SourceNetsuiteEnterpriseUpdateTokenBasedAuthentication struct {
	AuthenticationMethod *SourceNetsuiteEnterpriseUpdateSchemasAuthenticationMethod `default:"token_based_authentication" json:"authentication_method"`
	// The consumer key used for token-based authentication. This is generated in NetSuite when creating an integration record.
	ClientID string `json:"client_id"`
	// The consumer secret used for token-based authentication. This is generated in NetSuite when creating an integration record.
	ClientSecret string `json:"client_secret"`
	// The token ID used for token-based authentication. This is generated in NetSuite when creating a token-based role.
	TokenID string `json:"token_id"`
	// The token secret used for token-based authentication. This is generated in NetSuite when creating a token-based role.Ensure to keep this value secure.
	TokenSecret          string `json:"token_secret"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (s SourceNetsuiteEnterpriseUpdateTokenBasedAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceNetsuiteEnterpriseUpdateTokenBasedAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceNetsuiteEnterpriseUpdateTokenBasedAuthentication) GetAuthenticationMethod() *SourceNetsuiteEnterpriseUpdateSchemasAuthenticationMethod {
	if o == nil {
		return nil
	}
	return o.AuthenticationMethod
}

func (o *SourceNetsuiteEnterpriseUpdateTokenBasedAuthentication) GetClientID() string {
	if o == nil {
		return ""
	}
	return o.ClientID
}

func (o *SourceNetsuiteEnterpriseUpdateTokenBasedAuthentication) GetClientSecret() string {
	if o == nil {
		return ""
	}
	return o.ClientSecret
}

func (o *SourceNetsuiteEnterpriseUpdateTokenBasedAuthentication) GetTokenID() string {
	if o == nil {
		return ""
	}
	return o.TokenID
}

func (o *SourceNetsuiteEnterpriseUpdateTokenBasedAuthentication) GetTokenSecret() string {
	if o == nil {
		return ""
	}
	return o.TokenSecret
}

func (o *SourceNetsuiteEnterpriseUpdateTokenBasedAuthentication) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

type SourceNetsuiteEnterpriseUpdateSchemasAuthenticationMethodAuthenticationMethod string

const (
	SourceNetsuiteEnterpriseUpdateSchemasAuthenticationMethodAuthenticationMethodPasswordAuthentication SourceNetsuiteEnterpriseUpdateSchemasAuthenticationMethodAuthenticationMethod = "password_authentication"
)

func (e SourceNetsuiteEnterpriseUpdateSchemasAuthenticationMethodAuthenticationMethod) ToPointer() *SourceNetsuiteEnterpriseUpdateSchemasAuthenticationMethodAuthenticationMethod {
	return &e
}
func (e *SourceNetsuiteEnterpriseUpdateSchemasAuthenticationMethodAuthenticationMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "password_authentication":
		*e = SourceNetsuiteEnterpriseUpdateSchemasAuthenticationMethodAuthenticationMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceNetsuiteEnterpriseUpdateSchemasAuthenticationMethodAuthenticationMethod: %v", v)
	}
}

// SourceNetsuiteEnterpriseUpdatePasswordAuthentication - Authenticate using a password.
type SourceNetsuiteEnterpriseUpdatePasswordAuthentication struct {
	AuthenticationMethod *SourceNetsuiteEnterpriseUpdateSchemasAuthenticationMethodAuthenticationMethod `default:"password_authentication" json:"authentication_method"`
	// The password associated with the username.
	Password             string `json:"password"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (s SourceNetsuiteEnterpriseUpdatePasswordAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceNetsuiteEnterpriseUpdatePasswordAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceNetsuiteEnterpriseUpdatePasswordAuthentication) GetAuthenticationMethod() *SourceNetsuiteEnterpriseUpdateSchemasAuthenticationMethodAuthenticationMethod {
	if o == nil {
		return nil
	}
	return o.AuthenticationMethod
}

func (o *SourceNetsuiteEnterpriseUpdatePasswordAuthentication) GetPassword() string {
	if o == nil {
		return ""
	}
	return o.Password
}

func (o *SourceNetsuiteEnterpriseUpdatePasswordAuthentication) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

type SourceNetsuiteEnterpriseUpdateAuthenticationMethodType string

const (
	SourceNetsuiteEnterpriseUpdateAuthenticationMethodTypeSourceNetsuiteEnterpriseUpdatePasswordAuthentication   SourceNetsuiteEnterpriseUpdateAuthenticationMethodType = "source-netsuite-enterprise-update_Password Authentication"
	SourceNetsuiteEnterpriseUpdateAuthenticationMethodTypeSourceNetsuiteEnterpriseUpdateTokenBasedAuthentication SourceNetsuiteEnterpriseUpdateAuthenticationMethodType = "source-netsuite-enterprise-update_Token Based Authentication"
)

// SourceNetsuiteEnterpriseUpdateAuthenticationMethod - Configure how to authenticate to Netsuite. Options include username/password or token-based authentication.
type SourceNetsuiteEnterpriseUpdateAuthenticationMethod struct {
	SourceNetsuiteEnterpriseUpdatePasswordAuthentication   *SourceNetsuiteEnterpriseUpdatePasswordAuthentication   `queryParam:"inline"`
	SourceNetsuiteEnterpriseUpdateTokenBasedAuthentication *SourceNetsuiteEnterpriseUpdateTokenBasedAuthentication `queryParam:"inline"`

	Type SourceNetsuiteEnterpriseUpdateAuthenticationMethodType
}

func CreateSourceNetsuiteEnterpriseUpdateAuthenticationMethodSourceNetsuiteEnterpriseUpdatePasswordAuthentication(sourceNetsuiteEnterpriseUpdatePasswordAuthentication SourceNetsuiteEnterpriseUpdatePasswordAuthentication) SourceNetsuiteEnterpriseUpdateAuthenticationMethod {
	typ := SourceNetsuiteEnterpriseUpdateAuthenticationMethodTypeSourceNetsuiteEnterpriseUpdatePasswordAuthentication

	return SourceNetsuiteEnterpriseUpdateAuthenticationMethod{
		SourceNetsuiteEnterpriseUpdatePasswordAuthentication: &sourceNetsuiteEnterpriseUpdatePasswordAuthentication,
		Type: typ,
	}
}

func CreateSourceNetsuiteEnterpriseUpdateAuthenticationMethodSourceNetsuiteEnterpriseUpdateTokenBasedAuthentication(sourceNetsuiteEnterpriseUpdateTokenBasedAuthentication SourceNetsuiteEnterpriseUpdateTokenBasedAuthentication) SourceNetsuiteEnterpriseUpdateAuthenticationMethod {
	typ := SourceNetsuiteEnterpriseUpdateAuthenticationMethodTypeSourceNetsuiteEnterpriseUpdateTokenBasedAuthentication

	return SourceNetsuiteEnterpriseUpdateAuthenticationMethod{
		SourceNetsuiteEnterpriseUpdateTokenBasedAuthentication: &sourceNetsuiteEnterpriseUpdateTokenBasedAuthentication,
		Type: typ,
	}
}

func (u *SourceNetsuiteEnterpriseUpdateAuthenticationMethod) UnmarshalJSON(data []byte) error {

	var sourceNetsuiteEnterpriseUpdatePasswordAuthentication SourceNetsuiteEnterpriseUpdatePasswordAuthentication = SourceNetsuiteEnterpriseUpdatePasswordAuthentication{}
	if err := utils.UnmarshalJSON(data, &sourceNetsuiteEnterpriseUpdatePasswordAuthentication, "", true, true); err == nil {
		u.SourceNetsuiteEnterpriseUpdatePasswordAuthentication = &sourceNetsuiteEnterpriseUpdatePasswordAuthentication
		u.Type = SourceNetsuiteEnterpriseUpdateAuthenticationMethodTypeSourceNetsuiteEnterpriseUpdatePasswordAuthentication
		return nil
	}

	var sourceNetsuiteEnterpriseUpdateTokenBasedAuthentication SourceNetsuiteEnterpriseUpdateTokenBasedAuthentication = SourceNetsuiteEnterpriseUpdateTokenBasedAuthentication{}
	if err := utils.UnmarshalJSON(data, &sourceNetsuiteEnterpriseUpdateTokenBasedAuthentication, "", true, true); err == nil {
		u.SourceNetsuiteEnterpriseUpdateTokenBasedAuthentication = &sourceNetsuiteEnterpriseUpdateTokenBasedAuthentication
		u.Type = SourceNetsuiteEnterpriseUpdateAuthenticationMethodTypeSourceNetsuiteEnterpriseUpdateTokenBasedAuthentication
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceNetsuiteEnterpriseUpdateAuthenticationMethod", string(data))
}

func (u SourceNetsuiteEnterpriseUpdateAuthenticationMethod) MarshalJSON() ([]byte, error) {
	if u.SourceNetsuiteEnterpriseUpdatePasswordAuthentication != nil {
		return utils.MarshalJSON(u.SourceNetsuiteEnterpriseUpdatePasswordAuthentication, "", true)
	}

	if u.SourceNetsuiteEnterpriseUpdateTokenBasedAuthentication != nil {
		return utils.MarshalJSON(u.SourceNetsuiteEnterpriseUpdateTokenBasedAuthentication, "", true)
	}

	return nil, errors.New("could not marshal union type SourceNetsuiteEnterpriseUpdateAuthenticationMethod: all fields are null")
}

type SourceNetsuiteEnterpriseUpdateSchemasTunnelMethodTunnelMethod string

const (
	SourceNetsuiteEnterpriseUpdateSchemasTunnelMethodTunnelMethodSSHPasswordAuth SourceNetsuiteEnterpriseUpdateSchemasTunnelMethodTunnelMethod = "SSH_PASSWORD_AUTH"
)

func (e SourceNetsuiteEnterpriseUpdateSchemasTunnelMethodTunnelMethod) ToPointer() *SourceNetsuiteEnterpriseUpdateSchemasTunnelMethodTunnelMethod {
	return &e
}
func (e *SourceNetsuiteEnterpriseUpdateSchemasTunnelMethodTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_PASSWORD_AUTH":
		*e = SourceNetsuiteEnterpriseUpdateSchemasTunnelMethodTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceNetsuiteEnterpriseUpdateSchemasTunnelMethodTunnelMethod: %v", v)
	}
}

// SourceNetsuiteEnterpriseUpdateSchemasPasswordAuthentication - Connect through a jump server tunnel host using username and password authentication
type SourceNetsuiteEnterpriseUpdateSchemasPasswordAuthentication struct {
	TunnelMethod *SourceNetsuiteEnterpriseUpdateSchemasTunnelMethodTunnelMethod `default:"SSH_PASSWORD_AUTH" json:"tunnel_method"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser string `json:"tunnel_user"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword   string `json:"tunnel_user_password"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (s SourceNetsuiteEnterpriseUpdateSchemasPasswordAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceNetsuiteEnterpriseUpdateSchemasPasswordAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceNetsuiteEnterpriseUpdateSchemasPasswordAuthentication) GetTunnelMethod() *SourceNetsuiteEnterpriseUpdateSchemasTunnelMethodTunnelMethod {
	if o == nil {
		return nil
	}
	return o.TunnelMethod
}

func (o *SourceNetsuiteEnterpriseUpdateSchemasPasswordAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *SourceNetsuiteEnterpriseUpdateSchemasPasswordAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *SourceNetsuiteEnterpriseUpdateSchemasPasswordAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

func (o *SourceNetsuiteEnterpriseUpdateSchemasPasswordAuthentication) GetTunnelUserPassword() string {
	if o == nil {
		return ""
	}
	return o.TunnelUserPassword
}

func (o *SourceNetsuiteEnterpriseUpdateSchemasPasswordAuthentication) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

type SourceNetsuiteEnterpriseUpdateSchemasTunnelMethod string

const (
	SourceNetsuiteEnterpriseUpdateSchemasTunnelMethodSSHKeyAuth SourceNetsuiteEnterpriseUpdateSchemasTunnelMethod = "SSH_KEY_AUTH"
)

func (e SourceNetsuiteEnterpriseUpdateSchemasTunnelMethod) ToPointer() *SourceNetsuiteEnterpriseUpdateSchemasTunnelMethod {
	return &e
}
func (e *SourceNetsuiteEnterpriseUpdateSchemasTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_KEY_AUTH":
		*e = SourceNetsuiteEnterpriseUpdateSchemasTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceNetsuiteEnterpriseUpdateSchemasTunnelMethod: %v", v)
	}
}

// SourceNetsuiteEnterpriseUpdateSSHKeyAuthentication - Connect through a jump server tunnel host using username and ssh key
type SourceNetsuiteEnterpriseUpdateSSHKeyAuthentication struct {
	TunnelMethod *SourceNetsuiteEnterpriseUpdateSchemasTunnelMethod `default:"SSH_KEY_AUTH" json:"tunnel_method"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser string `json:"tunnel_user"`
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey               string `json:"ssh_key"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (s SourceNetsuiteEnterpriseUpdateSSHKeyAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceNetsuiteEnterpriseUpdateSSHKeyAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceNetsuiteEnterpriseUpdateSSHKeyAuthentication) GetTunnelMethod() *SourceNetsuiteEnterpriseUpdateSchemasTunnelMethod {
	if o == nil {
		return nil
	}
	return o.TunnelMethod
}

func (o *SourceNetsuiteEnterpriseUpdateSSHKeyAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *SourceNetsuiteEnterpriseUpdateSSHKeyAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *SourceNetsuiteEnterpriseUpdateSSHKeyAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

func (o *SourceNetsuiteEnterpriseUpdateSSHKeyAuthentication) GetSSHKey() string {
	if o == nil {
		return ""
	}
	return o.SSHKey
}

func (o *SourceNetsuiteEnterpriseUpdateSSHKeyAuthentication) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

type SourceNetsuiteEnterpriseUpdateTunnelMethod string

const (
	SourceNetsuiteEnterpriseUpdateTunnelMethodNoTunnel SourceNetsuiteEnterpriseUpdateTunnelMethod = "NO_TUNNEL"
)

func (e SourceNetsuiteEnterpriseUpdateTunnelMethod) ToPointer() *SourceNetsuiteEnterpriseUpdateTunnelMethod {
	return &e
}
func (e *SourceNetsuiteEnterpriseUpdateTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NO_TUNNEL":
		*e = SourceNetsuiteEnterpriseUpdateTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceNetsuiteEnterpriseUpdateTunnelMethod: %v", v)
	}
}

// SourceNetsuiteEnterpriseUpdateNoTunnel - No ssh tunnel needed to connect to database
type SourceNetsuiteEnterpriseUpdateNoTunnel struct {
	TunnelMethod         *SourceNetsuiteEnterpriseUpdateTunnelMethod `default:"NO_TUNNEL" json:"tunnel_method"`
	AdditionalProperties any                                         `additionalProperties:"true" json:"-"`
}

func (s SourceNetsuiteEnterpriseUpdateNoTunnel) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceNetsuiteEnterpriseUpdateNoTunnel) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceNetsuiteEnterpriseUpdateNoTunnel) GetTunnelMethod() *SourceNetsuiteEnterpriseUpdateTunnelMethod {
	if o == nil {
		return nil
	}
	return o.TunnelMethod
}

func (o *SourceNetsuiteEnterpriseUpdateNoTunnel) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

type SourceNetsuiteEnterpriseUpdateSSHTunnelMethodType string

const (
	SourceNetsuiteEnterpriseUpdateSSHTunnelMethodTypeSourceNetsuiteEnterpriseUpdateNoTunnel                      SourceNetsuiteEnterpriseUpdateSSHTunnelMethodType = "source-netsuite-enterprise-update_No Tunnel"
	SourceNetsuiteEnterpriseUpdateSSHTunnelMethodTypeSourceNetsuiteEnterpriseUpdateSSHKeyAuthentication          SourceNetsuiteEnterpriseUpdateSSHTunnelMethodType = "source-netsuite-enterprise-update_SSH Key Authentication"
	SourceNetsuiteEnterpriseUpdateSSHTunnelMethodTypeSourceNetsuiteEnterpriseUpdateSchemasPasswordAuthentication SourceNetsuiteEnterpriseUpdateSSHTunnelMethodType = "source-netsuite-enterprise-update_Schemas_Password Authentication"
)

// SourceNetsuiteEnterpriseUpdateSSHTunnelMethod - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceNetsuiteEnterpriseUpdateSSHTunnelMethod struct {
	SourceNetsuiteEnterpriseUpdateNoTunnel                      *SourceNetsuiteEnterpriseUpdateNoTunnel                      `queryParam:"inline"`
	SourceNetsuiteEnterpriseUpdateSSHKeyAuthentication          *SourceNetsuiteEnterpriseUpdateSSHKeyAuthentication          `queryParam:"inline"`
	SourceNetsuiteEnterpriseUpdateSchemasPasswordAuthentication *SourceNetsuiteEnterpriseUpdateSchemasPasswordAuthentication `queryParam:"inline"`

	Type SourceNetsuiteEnterpriseUpdateSSHTunnelMethodType
}

func CreateSourceNetsuiteEnterpriseUpdateSSHTunnelMethodSourceNetsuiteEnterpriseUpdateNoTunnel(sourceNetsuiteEnterpriseUpdateNoTunnel SourceNetsuiteEnterpriseUpdateNoTunnel) SourceNetsuiteEnterpriseUpdateSSHTunnelMethod {
	typ := SourceNetsuiteEnterpriseUpdateSSHTunnelMethodTypeSourceNetsuiteEnterpriseUpdateNoTunnel

	return SourceNetsuiteEnterpriseUpdateSSHTunnelMethod{
		SourceNetsuiteEnterpriseUpdateNoTunnel: &sourceNetsuiteEnterpriseUpdateNoTunnel,
		Type:                                   typ,
	}
}

func CreateSourceNetsuiteEnterpriseUpdateSSHTunnelMethodSourceNetsuiteEnterpriseUpdateSSHKeyAuthentication(sourceNetsuiteEnterpriseUpdateSSHKeyAuthentication SourceNetsuiteEnterpriseUpdateSSHKeyAuthentication) SourceNetsuiteEnterpriseUpdateSSHTunnelMethod {
	typ := SourceNetsuiteEnterpriseUpdateSSHTunnelMethodTypeSourceNetsuiteEnterpriseUpdateSSHKeyAuthentication

	return SourceNetsuiteEnterpriseUpdateSSHTunnelMethod{
		SourceNetsuiteEnterpriseUpdateSSHKeyAuthentication: &sourceNetsuiteEnterpriseUpdateSSHKeyAuthentication,
		Type: typ,
	}
}

func CreateSourceNetsuiteEnterpriseUpdateSSHTunnelMethodSourceNetsuiteEnterpriseUpdateSchemasPasswordAuthentication(sourceNetsuiteEnterpriseUpdateSchemasPasswordAuthentication SourceNetsuiteEnterpriseUpdateSchemasPasswordAuthentication) SourceNetsuiteEnterpriseUpdateSSHTunnelMethod {
	typ := SourceNetsuiteEnterpriseUpdateSSHTunnelMethodTypeSourceNetsuiteEnterpriseUpdateSchemasPasswordAuthentication

	return SourceNetsuiteEnterpriseUpdateSSHTunnelMethod{
		SourceNetsuiteEnterpriseUpdateSchemasPasswordAuthentication: &sourceNetsuiteEnterpriseUpdateSchemasPasswordAuthentication,
		Type: typ,
	}
}

func (u *SourceNetsuiteEnterpriseUpdateSSHTunnelMethod) UnmarshalJSON(data []byte) error {

	var sourceNetsuiteEnterpriseUpdateNoTunnel SourceNetsuiteEnterpriseUpdateNoTunnel = SourceNetsuiteEnterpriseUpdateNoTunnel{}
	if err := utils.UnmarshalJSON(data, &sourceNetsuiteEnterpriseUpdateNoTunnel, "", true, true); err == nil {
		u.SourceNetsuiteEnterpriseUpdateNoTunnel = &sourceNetsuiteEnterpriseUpdateNoTunnel
		u.Type = SourceNetsuiteEnterpriseUpdateSSHTunnelMethodTypeSourceNetsuiteEnterpriseUpdateNoTunnel
		return nil
	}

	var sourceNetsuiteEnterpriseUpdateSSHKeyAuthentication SourceNetsuiteEnterpriseUpdateSSHKeyAuthentication = SourceNetsuiteEnterpriseUpdateSSHKeyAuthentication{}
	if err := utils.UnmarshalJSON(data, &sourceNetsuiteEnterpriseUpdateSSHKeyAuthentication, "", true, true); err == nil {
		u.SourceNetsuiteEnterpriseUpdateSSHKeyAuthentication = &sourceNetsuiteEnterpriseUpdateSSHKeyAuthentication
		u.Type = SourceNetsuiteEnterpriseUpdateSSHTunnelMethodTypeSourceNetsuiteEnterpriseUpdateSSHKeyAuthentication
		return nil
	}

	var sourceNetsuiteEnterpriseUpdateSchemasPasswordAuthentication SourceNetsuiteEnterpriseUpdateSchemasPasswordAuthentication = SourceNetsuiteEnterpriseUpdateSchemasPasswordAuthentication{}
	if err := utils.UnmarshalJSON(data, &sourceNetsuiteEnterpriseUpdateSchemasPasswordAuthentication, "", true, true); err == nil {
		u.SourceNetsuiteEnterpriseUpdateSchemasPasswordAuthentication = &sourceNetsuiteEnterpriseUpdateSchemasPasswordAuthentication
		u.Type = SourceNetsuiteEnterpriseUpdateSSHTunnelMethodTypeSourceNetsuiteEnterpriseUpdateSchemasPasswordAuthentication
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceNetsuiteEnterpriseUpdateSSHTunnelMethod", string(data))
}

func (u SourceNetsuiteEnterpriseUpdateSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.SourceNetsuiteEnterpriseUpdateNoTunnel != nil {
		return utils.MarshalJSON(u.SourceNetsuiteEnterpriseUpdateNoTunnel, "", true)
	}

	if u.SourceNetsuiteEnterpriseUpdateSSHKeyAuthentication != nil {
		return utils.MarshalJSON(u.SourceNetsuiteEnterpriseUpdateSSHKeyAuthentication, "", true)
	}

	if u.SourceNetsuiteEnterpriseUpdateSchemasPasswordAuthentication != nil {
		return utils.MarshalJSON(u.SourceNetsuiteEnterpriseUpdateSchemasPasswordAuthentication, "", true)
	}

	return nil, errors.New("could not marshal union type SourceNetsuiteEnterpriseUpdateSSHTunnelMethod: all fields are null")
}

type SourceNetsuiteEnterpriseUpdateCursorMethod string

const (
	SourceNetsuiteEnterpriseUpdateCursorMethodUserDefined SourceNetsuiteEnterpriseUpdateCursorMethod = "user_defined"
)

func (e SourceNetsuiteEnterpriseUpdateCursorMethod) ToPointer() *SourceNetsuiteEnterpriseUpdateCursorMethod {
	return &e
}
func (e *SourceNetsuiteEnterpriseUpdateCursorMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "user_defined":
		*e = SourceNetsuiteEnterpriseUpdateCursorMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceNetsuiteEnterpriseUpdateCursorMethod: %v", v)
	}
}

// SourceNetsuiteEnterpriseUpdateScanChangesWithUserDefinedCursor - Incrementally detects new inserts and updates using the <a href="https://docs.airbyte.com/understanding-airbyte/connections/incremental-append/#user-defined-cursor">cursor column</a> chosen when configuring a connection (e.g. created_at, updated_at).
type SourceNetsuiteEnterpriseUpdateScanChangesWithUserDefinedCursor struct {
	CursorMethod         *SourceNetsuiteEnterpriseUpdateCursorMethod `default:"user_defined" json:"cursor_method"`
	AdditionalProperties any                                         `additionalProperties:"true" json:"-"`
}

func (s SourceNetsuiteEnterpriseUpdateScanChangesWithUserDefinedCursor) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceNetsuiteEnterpriseUpdateScanChangesWithUserDefinedCursor) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceNetsuiteEnterpriseUpdateScanChangesWithUserDefinedCursor) GetCursorMethod() *SourceNetsuiteEnterpriseUpdateCursorMethod {
	if o == nil {
		return nil
	}
	return o.CursorMethod
}

func (o *SourceNetsuiteEnterpriseUpdateScanChangesWithUserDefinedCursor) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

type SourceNetsuiteEnterpriseUpdateUpdateMethodType string

const (
	SourceNetsuiteEnterpriseUpdateUpdateMethodTypeSourceNetsuiteEnterpriseUpdateScanChangesWithUserDefinedCursor SourceNetsuiteEnterpriseUpdateUpdateMethodType = "source-netsuite-enterprise-update_Scan Changes with User Defined Cursor"
)

// SourceNetsuiteEnterpriseUpdateUpdateMethod - Configures how data is extracted from the database.
type SourceNetsuiteEnterpriseUpdateUpdateMethod struct {
	SourceNetsuiteEnterpriseUpdateScanChangesWithUserDefinedCursor *SourceNetsuiteEnterpriseUpdateScanChangesWithUserDefinedCursor `queryParam:"inline"`

	Type SourceNetsuiteEnterpriseUpdateUpdateMethodType
}

func CreateSourceNetsuiteEnterpriseUpdateUpdateMethodSourceNetsuiteEnterpriseUpdateScanChangesWithUserDefinedCursor(sourceNetsuiteEnterpriseUpdateScanChangesWithUserDefinedCursor SourceNetsuiteEnterpriseUpdateScanChangesWithUserDefinedCursor) SourceNetsuiteEnterpriseUpdateUpdateMethod {
	typ := SourceNetsuiteEnterpriseUpdateUpdateMethodTypeSourceNetsuiteEnterpriseUpdateScanChangesWithUserDefinedCursor

	return SourceNetsuiteEnterpriseUpdateUpdateMethod{
		SourceNetsuiteEnterpriseUpdateScanChangesWithUserDefinedCursor: &sourceNetsuiteEnterpriseUpdateScanChangesWithUserDefinedCursor,
		Type: typ,
	}
}

func (u *SourceNetsuiteEnterpriseUpdateUpdateMethod) UnmarshalJSON(data []byte) error {

	var sourceNetsuiteEnterpriseUpdateScanChangesWithUserDefinedCursor SourceNetsuiteEnterpriseUpdateScanChangesWithUserDefinedCursor = SourceNetsuiteEnterpriseUpdateScanChangesWithUserDefinedCursor{}
	if err := utils.UnmarshalJSON(data, &sourceNetsuiteEnterpriseUpdateScanChangesWithUserDefinedCursor, "", true, true); err == nil {
		u.SourceNetsuiteEnterpriseUpdateScanChangesWithUserDefinedCursor = &sourceNetsuiteEnterpriseUpdateScanChangesWithUserDefinedCursor
		u.Type = SourceNetsuiteEnterpriseUpdateUpdateMethodTypeSourceNetsuiteEnterpriseUpdateScanChangesWithUserDefinedCursor
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceNetsuiteEnterpriseUpdateUpdateMethod", string(data))
}

func (u SourceNetsuiteEnterpriseUpdateUpdateMethod) MarshalJSON() ([]byte, error) {
	if u.SourceNetsuiteEnterpriseUpdateScanChangesWithUserDefinedCursor != nil {
		return utils.MarshalJSON(u.SourceNetsuiteEnterpriseUpdateScanChangesWithUserDefinedCursor, "", true)
	}

	return nil, errors.New("could not marshal union type SourceNetsuiteEnterpriseUpdateUpdateMethod: all fields are null")
}

type SourceNetsuiteEnterpriseUpdate struct {
	// Hostname of the database.
	Host string `json:"host"`
	// Port of the database.
	Port *int64 `default:"1708" json:"port"`
	// The username which is used to access the database.
	Username string `json:"username"`
	// Configure how to authenticate to Netsuite. Options include username/password or token-based authentication.
	AuthenticationMethod SourceNetsuiteEnterpriseUpdateAuthenticationMethod `json:"authentication_method"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod SourceNetsuiteEnterpriseUpdateSSHTunnelMethod `json:"tunnel_method"`
	// Configures how data is extracted from the database.
	Cursor SourceNetsuiteEnterpriseUpdateUpdateMethod `json:"cursor"`
	// The username which is used to access the database.
	AccountID string `json:"account_id"`
	// The username which is used to access the database.
	RoleID string `json:"role_id"`
	// How often (in seconds) a stream should checkpoint, when possible.
	CheckpointTargetIntervalSeconds *int64 `default:"300" json:"checkpoint_target_interval_seconds"`
	// Maximum number of concurrent queries to the database.
	Concurrency *int64 `default:"1" json:"concurrency"`
	// When this feature is enabled, during schema discovery the connector will query each table or view individually to check access privileges and inaccessible tables, views, or columns therein will be removed. In large schemas, this might cause schema discovery to take too long, in which case it might be advisable to disable this feature.
	CheckPrivileges *bool `default:"true" json:"check_privileges"`
}

func (s SourceNetsuiteEnterpriseUpdate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceNetsuiteEnterpriseUpdate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *SourceNetsuiteEnterpriseUpdate) GetHost() string {
	if o == nil {
		return ""
	}
	return o.Host
}

func (o *SourceNetsuiteEnterpriseUpdate) GetPort() *int64 {
	if o == nil {
		return nil
	}
	return o.Port
}

func (o *SourceNetsuiteEnterpriseUpdate) GetUsername() string {
	if o == nil {
		return ""
	}
	return o.Username
}

func (o *SourceNetsuiteEnterpriseUpdate) GetAuthenticationMethod() SourceNetsuiteEnterpriseUpdateAuthenticationMethod {
	if o == nil {
		return SourceNetsuiteEnterpriseUpdateAuthenticationMethod{}
	}
	return o.AuthenticationMethod
}

func (o *SourceNetsuiteEnterpriseUpdate) GetJdbcURLParams() *string {
	if o == nil {
		return nil
	}
	return o.JdbcURLParams
}

func (o *SourceNetsuiteEnterpriseUpdate) GetTunnelMethod() SourceNetsuiteEnterpriseUpdateSSHTunnelMethod {
	if o == nil {
		return SourceNetsuiteEnterpriseUpdateSSHTunnelMethod{}
	}
	return o.TunnelMethod
}

func (o *SourceNetsuiteEnterpriseUpdate) GetCursor() SourceNetsuiteEnterpriseUpdateUpdateMethod {
	if o == nil {
		return SourceNetsuiteEnterpriseUpdateUpdateMethod{}
	}
	return o.Cursor
}

func (o *SourceNetsuiteEnterpriseUpdate) GetAccountID() string {
	if o == nil {
		return ""
	}
	return o.AccountID
}

func (o *SourceNetsuiteEnterpriseUpdate) GetRoleID() string {
	if o == nil {
		return ""
	}
	return o.RoleID
}

func (o *SourceNetsuiteEnterpriseUpdate) GetCheckpointTargetIntervalSeconds() *int64 {
	if o == nil {
		return nil
	}
	return o.CheckpointTargetIntervalSeconds
}

func (o *SourceNetsuiteEnterpriseUpdate) GetConcurrency() *int64 {
	if o == nil {
		return nil
	}
	return o.Concurrency
}

func (o *SourceNetsuiteEnterpriseUpdate) GetCheckPrivileges() *bool {
	if o == nil {
		return nil
	}
	return o.CheckPrivileges
}
