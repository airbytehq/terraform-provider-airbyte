// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/types"
	"time"
)

type SourceSlackUpdateAPIToken struct {
	// A Slack bot token. See the <a href="https://docs.airbyte.com/integrations/sources/slack">docs</a> for instructions on how to generate it.
	APIToken    *string `json:"api_token,omitempty"`
	optionTitle *string `const:"API Token Credentials" json:"option_title,omitempty"`
}

func (s SourceSlackUpdateAPIToken) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceSlackUpdateAPIToken) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceSlackUpdateAPIToken) GetAPIToken() *string {
	if s == nil {
		return nil
	}
	return s.APIToken
}

func (s *SourceSlackUpdateAPIToken) GetOptionTitle() *string {
	return types.Pointer("API Token Credentials")
}

type SourceSlackUpdateSignInViaSlackOAuth struct {
	// Slack access_token. See our <a href="https://docs.airbyte.com/integrations/sources/slack">docs</a> if you need help generating the token.
	AccessToken *string `json:"access_token,omitempty"`
	// Slack client_id. See our <a href="https://docs.airbyte.com/integrations/sources/slack">docs</a> if you need help finding this id.
	ClientID *string `json:"client_id,omitempty"`
	// Slack client_secret. See our <a href="https://docs.airbyte.com/integrations/sources/slack">docs</a> if you need help finding this secret.
	ClientSecret *string `json:"client_secret,omitempty"`
	optionTitle  *string `const:"Default OAuth2.0 authorization" json:"option_title,omitempty"`
}

func (s SourceSlackUpdateSignInViaSlackOAuth) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceSlackUpdateSignInViaSlackOAuth) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceSlackUpdateSignInViaSlackOAuth) GetAccessToken() *string {
	if s == nil {
		return nil
	}
	return s.AccessToken
}

func (s *SourceSlackUpdateSignInViaSlackOAuth) GetClientID() *string {
	if s == nil {
		return nil
	}
	return s.ClientID
}

func (s *SourceSlackUpdateSignInViaSlackOAuth) GetClientSecret() *string {
	if s == nil {
		return nil
	}
	return s.ClientSecret
}

func (s *SourceSlackUpdateSignInViaSlackOAuth) GetOptionTitle() *string {
	return types.Pointer("Default OAuth2.0 authorization")
}

type SourceSlackUpdateAuthenticationMechanismType string

const (
	SourceSlackUpdateAuthenticationMechanismTypeSourceSlackUpdateSignInViaSlackOAuth SourceSlackUpdateAuthenticationMechanismType = "source-slack-update_Sign in via Slack (OAuth)"
	SourceSlackUpdateAuthenticationMechanismTypeSourceSlackUpdateAPIToken            SourceSlackUpdateAuthenticationMechanismType = "source-slack-update_API Token"
)

// SourceSlackUpdateAuthenticationMechanism - Choose how to authenticate into Slack
type SourceSlackUpdateAuthenticationMechanism struct {
	SourceSlackUpdateSignInViaSlackOAuth *SourceSlackUpdateSignInViaSlackOAuth `queryParam:"inline" union:"member"`
	SourceSlackUpdateAPIToken            *SourceSlackUpdateAPIToken            `queryParam:"inline" union:"member"`

	Type SourceSlackUpdateAuthenticationMechanismType
}

func CreateSourceSlackUpdateAuthenticationMechanismSourceSlackUpdateSignInViaSlackOAuth(sourceSlackUpdateSignInViaSlackOAuth SourceSlackUpdateSignInViaSlackOAuth) SourceSlackUpdateAuthenticationMechanism {
	typ := SourceSlackUpdateAuthenticationMechanismTypeSourceSlackUpdateSignInViaSlackOAuth

	return SourceSlackUpdateAuthenticationMechanism{
		SourceSlackUpdateSignInViaSlackOAuth: &sourceSlackUpdateSignInViaSlackOAuth,
		Type:                                 typ,
	}
}

func CreateSourceSlackUpdateAuthenticationMechanismSourceSlackUpdateAPIToken(sourceSlackUpdateAPIToken SourceSlackUpdateAPIToken) SourceSlackUpdateAuthenticationMechanism {
	typ := SourceSlackUpdateAuthenticationMechanismTypeSourceSlackUpdateAPIToken

	return SourceSlackUpdateAuthenticationMechanism{
		SourceSlackUpdateAPIToken: &sourceSlackUpdateAPIToken,
		Type:                      typ,
	}
}

func (u *SourceSlackUpdateAuthenticationMechanism) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var sourceSlackUpdateSignInViaSlackOAuth SourceSlackUpdateSignInViaSlackOAuth = SourceSlackUpdateSignInViaSlackOAuth{}
	if err := utils.UnmarshalJSON(data, &sourceSlackUpdateSignInViaSlackOAuth, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceSlackUpdateAuthenticationMechanismTypeSourceSlackUpdateSignInViaSlackOAuth,
			Value: &sourceSlackUpdateSignInViaSlackOAuth,
		})
	}

	var sourceSlackUpdateAPIToken SourceSlackUpdateAPIToken = SourceSlackUpdateAPIToken{}
	if err := utils.UnmarshalJSON(data, &sourceSlackUpdateAPIToken, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceSlackUpdateAuthenticationMechanismTypeSourceSlackUpdateAPIToken,
			Value: &sourceSlackUpdateAPIToken,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceSlackUpdateAuthenticationMechanism", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceSlackUpdateAuthenticationMechanism", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceSlackUpdateAuthenticationMechanismType)
	switch best.Type {
	case SourceSlackUpdateAuthenticationMechanismTypeSourceSlackUpdateSignInViaSlackOAuth:
		u.SourceSlackUpdateSignInViaSlackOAuth = best.Value.(*SourceSlackUpdateSignInViaSlackOAuth)
		return nil
	case SourceSlackUpdateAuthenticationMechanismTypeSourceSlackUpdateAPIToken:
		u.SourceSlackUpdateAPIToken = best.Value.(*SourceSlackUpdateAPIToken)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceSlackUpdateAuthenticationMechanism", string(data))
}

func (u SourceSlackUpdateAuthenticationMechanism) MarshalJSON() ([]byte, error) {
	if u.SourceSlackUpdateSignInViaSlackOAuth != nil {
		return utils.MarshalJSON(u.SourceSlackUpdateSignInViaSlackOAuth, "", true)
	}

	if u.SourceSlackUpdateAPIToken != nil {
		return utils.MarshalJSON(u.SourceSlackUpdateAPIToken, "", true)
	}

	return nil, errors.New("could not marshal union type SourceSlackUpdateAuthenticationMechanism: all fields are null")
}

type SourceSlackUpdateSourceType string

const (
	SourceSlackUpdateSourceTypeSlack SourceSlackUpdateSourceType = "slack"
)

func (e SourceSlackUpdateSourceType) ToPointer() *SourceSlackUpdateSourceType {
	return &e
}
func (e *SourceSlackUpdateSourceType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "slack":
		*e = SourceSlackUpdateSourceType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceSlackUpdateSourceType: %v", v)
	}
}

type SourceSlackUpdate struct {
	// A channel name list (without leading '#' char) which limit the channels from which you'd like to sync. Empty list means no filter.
	ChannelFilter []string `json:"channel_filter,omitempty"`
	// The size (in days) of the date window that will be used while syncing data from the channel messages stream. A smaller window will allow for greater parallelization when syncing records, but can lead to rate limiting errors.
	ChannelMessagesWindowSize *int64 `default:"100" json:"channel_messages_window_size"`
	// Choose how to authenticate into Slack
	Credentials *SourceSlackUpdateAuthenticationMechanism `json:"credentials,omitempty"`
	// Whether to read information from private channels that the bot is already in.  If false, only public channels will be read.  If true, the bot must be manually added to private channels.
	IncludePrivateChannels *bool `default:"false" json:"include_private_channels"`
	// Whether to join all channels or to sync data only from channels the bot is already in.  If false, you''ll need to manually add the bot to all the channels from which you''d like to sync messages.
	JoinChannels *bool `default:"true" json:"join_channels"`
	// How far into the past to look for messages in threads, default is 0 days
	LookbackWindow *int64 `default:"0" json:"lookback_window"`
	// The number of worker threads to use for the sync.
	NumWorkers *int64 `default:"2" json:"num_workers"`
	// UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
	StartDate            *time.Time                   `json:"start_date,omitempty"`
	sourceType           *SourceSlackUpdateSourceType `const:"slack" json:"sourceType"`
	AdditionalProperties any                          `additionalProperties:"true" json:"-"`
}

func (s SourceSlackUpdate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceSlackUpdate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceSlackUpdate) GetChannelFilter() []string {
	if s == nil {
		return nil
	}
	return s.ChannelFilter
}

func (s *SourceSlackUpdate) GetChannelMessagesWindowSize() *int64 {
	if s == nil {
		return nil
	}
	return s.ChannelMessagesWindowSize
}

func (s *SourceSlackUpdate) GetCredentials() *SourceSlackUpdateAuthenticationMechanism {
	if s == nil {
		return nil
	}
	return s.Credentials
}

func (s *SourceSlackUpdate) GetIncludePrivateChannels() *bool {
	if s == nil {
		return nil
	}
	return s.IncludePrivateChannels
}

func (s *SourceSlackUpdate) GetJoinChannels() *bool {
	if s == nil {
		return nil
	}
	return s.JoinChannels
}

func (s *SourceSlackUpdate) GetLookbackWindow() *int64 {
	if s == nil {
		return nil
	}
	return s.LookbackWindow
}

func (s *SourceSlackUpdate) GetNumWorkers() *int64 {
	if s == nil {
		return nil
	}
	return s.NumWorkers
}

func (s *SourceSlackUpdate) GetStartDate() *time.Time {
	if s == nil {
		return nil
	}
	return s.StartDate
}

func (s *SourceSlackUpdate) GetSourceType() *SourceSlackUpdateSourceType {
	return SourceSlackUpdateSourceTypeSlack.ToPointer()
}

func (s *SourceSlackUpdate) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}
