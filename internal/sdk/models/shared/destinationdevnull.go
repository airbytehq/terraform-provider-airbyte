// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

type DevNull string

const (
	DevNullDevNull DevNull = "dev-null"
)

func (e DevNull) ToPointer() *DevNull {
	return &e
}
func (e *DevNull) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "dev-null":
		*e = DevNull(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DevNull: %v", v)
	}
}

type DestinationDevNullSchemasTestDestinationTestDestinationTestDestinationType string

const (
	DestinationDevNullSchemasTestDestinationTestDestinationTestDestinationTypeFailing DestinationDevNullSchemasTestDestinationTestDestinationTestDestinationType = "FAILING"
)

func (e DestinationDevNullSchemasTestDestinationTestDestinationTestDestinationType) ToPointer() *DestinationDevNullSchemasTestDestinationTestDestinationTestDestinationType {
	return &e
}
func (e *DestinationDevNullSchemasTestDestinationTestDestinationTestDestinationType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "FAILING":
		*e = DestinationDevNullSchemasTestDestinationTestDestinationTestDestinationType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationDevNullSchemasTestDestinationTestDestinationTestDestinationType: %v", v)
	}
}

type DestinationDevNullFailing struct {
	// Number of messages after which to fail.
	NumMessages         int64                                                                       `json:"num_messages"`
	testDestinationType *DestinationDevNullSchemasTestDestinationTestDestinationTestDestinationType `const:"FAILING" json:"test_destination_type"`
}

func (d DestinationDevNullFailing) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationDevNullFailing) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationDevNullFailing) GetNumMessages() int64 {
	if o == nil {
		return 0
	}
	return o.NumMessages
}

func (o *DestinationDevNullFailing) GetTestDestinationType() *DestinationDevNullSchemasTestDestinationTestDestinationTestDestinationType {
	return DestinationDevNullSchemasTestDestinationTestDestinationTestDestinationTypeFailing.ToPointer()
}

type DestinationDevNullSchemasTestDestinationTestDestinationType string

const (
	DestinationDevNullSchemasTestDestinationTestDestinationTypeThrottled DestinationDevNullSchemasTestDestinationTestDestinationType = "THROTTLED"
)

func (e DestinationDevNullSchemasTestDestinationTestDestinationType) ToPointer() *DestinationDevNullSchemasTestDestinationTestDestinationType {
	return &e
}
func (e *DestinationDevNullSchemasTestDestinationTestDestinationType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "THROTTLED":
		*e = DestinationDevNullSchemasTestDestinationTestDestinationType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationDevNullSchemasTestDestinationTestDestinationType: %v", v)
	}
}

type DestinationDevNullThrottled struct {
	// Number of milli-second to pause in between records.
	MillisPerRecord     int64                                                        `json:"millis_per_record"`
	testDestinationType *DestinationDevNullSchemasTestDestinationTestDestinationType `const:"THROTTLED" json:"test_destination_type"`
}

func (d DestinationDevNullThrottled) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationDevNullThrottled) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationDevNullThrottled) GetMillisPerRecord() int64 {
	if o == nil {
		return 0
	}
	return o.MillisPerRecord
}

func (o *DestinationDevNullThrottled) GetTestDestinationType() *DestinationDevNullSchemasTestDestinationTestDestinationType {
	return DestinationDevNullSchemasTestDestinationTestDestinationTypeThrottled.ToPointer()
}

type DestinationDevNullSchemasTestDestinationType string

const (
	DestinationDevNullSchemasTestDestinationTypeSilent DestinationDevNullSchemasTestDestinationType = "SILENT"
)

func (e DestinationDevNullSchemasTestDestinationType) ToPointer() *DestinationDevNullSchemasTestDestinationType {
	return &e
}
func (e *DestinationDevNullSchemasTestDestinationType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SILENT":
		*e = DestinationDevNullSchemasTestDestinationType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationDevNullSchemasTestDestinationType: %v", v)
	}
}

type DestinationDevNullSilent struct {
	testDestinationType *DestinationDevNullSchemasTestDestinationType `const:"SILENT" json:"test_destination_type"`
}

func (d DestinationDevNullSilent) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationDevNullSilent) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationDevNullSilent) GetTestDestinationType() *DestinationDevNullSchemasTestDestinationType {
	return DestinationDevNullSchemasTestDestinationTypeSilent.ToPointer()
}

type DestinationDevNullSchemasTestDestinationLoggingType string

const (
	DestinationDevNullSchemasTestDestinationLoggingTypeRandomSampling DestinationDevNullSchemasTestDestinationLoggingType = "RandomSampling"
)

func (e DestinationDevNullSchemasTestDestinationLoggingType) ToPointer() *DestinationDevNullSchemasTestDestinationLoggingType {
	return &e
}
func (e *DestinationDevNullSchemasTestDestinationLoggingType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "RandomSampling":
		*e = DestinationDevNullSchemasTestDestinationLoggingType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationDevNullSchemasTestDestinationLoggingType: %v", v)
	}
}

// DestinationDevNullRandomSampling - For each stream, randomly log a percentage of the entries with a maximum cap.
type DestinationDevNullRandomSampling struct {
	LoggingType *DestinationDevNullSchemasTestDestinationLoggingType `default:"RandomSampling" json:"logging_type"`
	// Max number of entries to log. This destination is for testing only. So it won't make sense to log infinitely. The maximum is 1,000 entries.
	MaxEntryCount *float64 `default:"100" json:"max_entry_count"`
	// A positive floating number smaller than 1.
	SamplingRatio *float64 `default:"0.001" json:"sampling_ratio"`
	// When the seed is unspecified, the current time millis will be used as the seed.
	Seed *float64 `json:"seed,omitempty"`
}

func (d DestinationDevNullRandomSampling) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationDevNullRandomSampling) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationDevNullRandomSampling) GetLoggingType() *DestinationDevNullSchemasTestDestinationLoggingType {
	if o == nil {
		return nil
	}
	return o.LoggingType
}

func (o *DestinationDevNullRandomSampling) GetMaxEntryCount() *float64 {
	if o == nil {
		return nil
	}
	return o.MaxEntryCount
}

func (o *DestinationDevNullRandomSampling) GetSamplingRatio() *float64 {
	if o == nil {
		return nil
	}
	return o.SamplingRatio
}

func (o *DestinationDevNullRandomSampling) GetSeed() *float64 {
	if o == nil {
		return nil
	}
	return o.Seed
}

type DestinationDevNullSchemasLoggingType string

const (
	DestinationDevNullSchemasLoggingTypeEveryNth DestinationDevNullSchemasLoggingType = "EveryNth"
)

func (e DestinationDevNullSchemasLoggingType) ToPointer() *DestinationDevNullSchemasLoggingType {
	return &e
}
func (e *DestinationDevNullSchemasLoggingType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "EveryNth":
		*e = DestinationDevNullSchemasLoggingType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationDevNullSchemasLoggingType: %v", v)
	}
}

// DestinationDevNullEveryNThEntry - For each stream, log every N-th entry with a maximum cap.
type DestinationDevNullEveryNThEntry struct {
	LoggingType *DestinationDevNullSchemasLoggingType `default:"EveryNth" json:"logging_type"`
	// Max number of entries to log. This destination is for testing only. So it won't make sense to log infinitely. The maximum is 1,000 entries.
	MaxEntryCount *float64 `default:"100" json:"max_entry_count"`
	// The N-th entry to log for each stream. N starts from 1. For example, when N = 1, every entry is logged; when N = 2, every other entry is logged; when N = 3, one out of three entries is logged.
	NthEntryToLog float64 `json:"nth_entry_to_log"`
}

func (d DestinationDevNullEveryNThEntry) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationDevNullEveryNThEntry) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationDevNullEveryNThEntry) GetLoggingType() *DestinationDevNullSchemasLoggingType {
	if o == nil {
		return nil
	}
	return o.LoggingType
}

func (o *DestinationDevNullEveryNThEntry) GetMaxEntryCount() *float64 {
	if o == nil {
		return nil
	}
	return o.MaxEntryCount
}

func (o *DestinationDevNullEveryNThEntry) GetNthEntryToLog() float64 {
	if o == nil {
		return 0.0
	}
	return o.NthEntryToLog
}

type DestinationDevNullLoggingType string

const (
	DestinationDevNullLoggingTypeFirstN DestinationDevNullLoggingType = "FirstN"
)

func (e DestinationDevNullLoggingType) ToPointer() *DestinationDevNullLoggingType {
	return &e
}
func (e *DestinationDevNullLoggingType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "FirstN":
		*e = DestinationDevNullLoggingType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationDevNullLoggingType: %v", v)
	}
}

// DestinationDevNullFirstNEntries - Log first N entries per stream.
type DestinationDevNullFirstNEntries struct {
	LoggingType *DestinationDevNullLoggingType `default:"FirstN" json:"logging_type"`
	// Number of entries to log. This destination is for testing only. So it won't make sense to log infinitely. The maximum is 1,000 entries.
	MaxEntryCount *float64 `default:"100" json:"max_entry_count"`
}

func (d DestinationDevNullFirstNEntries) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationDevNullFirstNEntries) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationDevNullFirstNEntries) GetLoggingType() *DestinationDevNullLoggingType {
	if o == nil {
		return nil
	}
	return o.LoggingType
}

func (o *DestinationDevNullFirstNEntries) GetMaxEntryCount() *float64 {
	if o == nil {
		return nil
	}
	return o.MaxEntryCount
}

type DestinationDevNullLoggingConfigurationType string

const (
	DestinationDevNullLoggingConfigurationTypeDestinationDevNullFirstNEntries  DestinationDevNullLoggingConfigurationType = "destination-dev-null_First N Entries"
	DestinationDevNullLoggingConfigurationTypeDestinationDevNullEveryNThEntry  DestinationDevNullLoggingConfigurationType = "destination-dev-null_Every N-th Entry"
	DestinationDevNullLoggingConfigurationTypeDestinationDevNullRandomSampling DestinationDevNullLoggingConfigurationType = "destination-dev-null_Random Sampling"
)

// DestinationDevNullLoggingConfiguration - Configurate how the messages are logged.
type DestinationDevNullLoggingConfiguration struct {
	DestinationDevNullFirstNEntries  *DestinationDevNullFirstNEntries
	DestinationDevNullEveryNThEntry  *DestinationDevNullEveryNThEntry
	DestinationDevNullRandomSampling *DestinationDevNullRandomSampling

	Type DestinationDevNullLoggingConfigurationType
}

func CreateDestinationDevNullLoggingConfigurationDestinationDevNullFirstNEntries(destinationDevNullFirstNEntries DestinationDevNullFirstNEntries) DestinationDevNullLoggingConfiguration {
	typ := DestinationDevNullLoggingConfigurationTypeDestinationDevNullFirstNEntries

	return DestinationDevNullLoggingConfiguration{
		DestinationDevNullFirstNEntries: &destinationDevNullFirstNEntries,
		Type:                            typ,
	}
}

func CreateDestinationDevNullLoggingConfigurationDestinationDevNullEveryNThEntry(destinationDevNullEveryNThEntry DestinationDevNullEveryNThEntry) DestinationDevNullLoggingConfiguration {
	typ := DestinationDevNullLoggingConfigurationTypeDestinationDevNullEveryNThEntry

	return DestinationDevNullLoggingConfiguration{
		DestinationDevNullEveryNThEntry: &destinationDevNullEveryNThEntry,
		Type:                            typ,
	}
}

func CreateDestinationDevNullLoggingConfigurationDestinationDevNullRandomSampling(destinationDevNullRandomSampling DestinationDevNullRandomSampling) DestinationDevNullLoggingConfiguration {
	typ := DestinationDevNullLoggingConfigurationTypeDestinationDevNullRandomSampling

	return DestinationDevNullLoggingConfiguration{
		DestinationDevNullRandomSampling: &destinationDevNullRandomSampling,
		Type:                             typ,
	}
}

func (u *DestinationDevNullLoggingConfiguration) UnmarshalJSON(data []byte) error {

	var destinationDevNullFirstNEntries DestinationDevNullFirstNEntries = DestinationDevNullFirstNEntries{}
	if err := utils.UnmarshalJSON(data, &destinationDevNullFirstNEntries, "", true, true); err == nil {
		u.DestinationDevNullFirstNEntries = &destinationDevNullFirstNEntries
		u.Type = DestinationDevNullLoggingConfigurationTypeDestinationDevNullFirstNEntries
		return nil
	}

	var destinationDevNullEveryNThEntry DestinationDevNullEveryNThEntry = DestinationDevNullEveryNThEntry{}
	if err := utils.UnmarshalJSON(data, &destinationDevNullEveryNThEntry, "", true, true); err == nil {
		u.DestinationDevNullEveryNThEntry = &destinationDevNullEveryNThEntry
		u.Type = DestinationDevNullLoggingConfigurationTypeDestinationDevNullEveryNThEntry
		return nil
	}

	var destinationDevNullRandomSampling DestinationDevNullRandomSampling = DestinationDevNullRandomSampling{}
	if err := utils.UnmarshalJSON(data, &destinationDevNullRandomSampling, "", true, true); err == nil {
		u.DestinationDevNullRandomSampling = &destinationDevNullRandomSampling
		u.Type = DestinationDevNullLoggingConfigurationTypeDestinationDevNullRandomSampling
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationDevNullLoggingConfiguration", string(data))
}

func (u DestinationDevNullLoggingConfiguration) MarshalJSON() ([]byte, error) {
	if u.DestinationDevNullFirstNEntries != nil {
		return utils.MarshalJSON(u.DestinationDevNullFirstNEntries, "", true)
	}

	if u.DestinationDevNullEveryNThEntry != nil {
		return utils.MarshalJSON(u.DestinationDevNullEveryNThEntry, "", true)
	}

	if u.DestinationDevNullRandomSampling != nil {
		return utils.MarshalJSON(u.DestinationDevNullRandomSampling, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationDevNullLoggingConfiguration: all fields are null")
}

type DestinationDevNullTestDestinationType string

const (
	DestinationDevNullTestDestinationTypeLogging DestinationDevNullTestDestinationType = "LOGGING"
)

func (e DestinationDevNullTestDestinationType) ToPointer() *DestinationDevNullTestDestinationType {
	return &e
}
func (e *DestinationDevNullTestDestinationType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "LOGGING":
		*e = DestinationDevNullTestDestinationType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationDevNullTestDestinationType: %v", v)
	}
}

type DestinationDevNullLogging struct {
	// Configurate how the messages are logged.
	LoggingConfig       DestinationDevNullLoggingConfiguration `json:"logging_config"`
	testDestinationType *DestinationDevNullTestDestinationType `const:"LOGGING" json:"test_destination_type"`
}

func (d DestinationDevNullLogging) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationDevNullLogging) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationDevNullLogging) GetLoggingConfig() DestinationDevNullLoggingConfiguration {
	if o == nil {
		return DestinationDevNullLoggingConfiguration{}
	}
	return o.LoggingConfig
}

func (o *DestinationDevNullLogging) GetTestDestinationType() *DestinationDevNullTestDestinationType {
	return DestinationDevNullTestDestinationTypeLogging.ToPointer()
}

type DestinationDevNullTestDestinationUnionType string

const (
	DestinationDevNullTestDestinationUnionTypeDestinationDevNullLogging   DestinationDevNullTestDestinationUnionType = "destination-dev-null_Logging"
	DestinationDevNullTestDestinationUnionTypeDestinationDevNullSilent    DestinationDevNullTestDestinationUnionType = "destination-dev-null_Silent"
	DestinationDevNullTestDestinationUnionTypeDestinationDevNullThrottled DestinationDevNullTestDestinationUnionType = "destination-dev-null_Throttled"
	DestinationDevNullTestDestinationUnionTypeDestinationDevNullFailing   DestinationDevNullTestDestinationUnionType = "destination-dev-null_Failing"
)

// DestinationDevNullTestDestination - The type of destination to be used
type DestinationDevNullTestDestination struct {
	DestinationDevNullLogging   *DestinationDevNullLogging
	DestinationDevNullSilent    *DestinationDevNullSilent
	DestinationDevNullThrottled *DestinationDevNullThrottled
	DestinationDevNullFailing   *DestinationDevNullFailing

	Type DestinationDevNullTestDestinationUnionType
}

func CreateDestinationDevNullTestDestinationDestinationDevNullLogging(destinationDevNullLogging DestinationDevNullLogging) DestinationDevNullTestDestination {
	typ := DestinationDevNullTestDestinationUnionTypeDestinationDevNullLogging

	return DestinationDevNullTestDestination{
		DestinationDevNullLogging: &destinationDevNullLogging,
		Type:                      typ,
	}
}

func CreateDestinationDevNullTestDestinationDestinationDevNullSilent(destinationDevNullSilent DestinationDevNullSilent) DestinationDevNullTestDestination {
	typ := DestinationDevNullTestDestinationUnionTypeDestinationDevNullSilent

	return DestinationDevNullTestDestination{
		DestinationDevNullSilent: &destinationDevNullSilent,
		Type:                     typ,
	}
}

func CreateDestinationDevNullTestDestinationDestinationDevNullThrottled(destinationDevNullThrottled DestinationDevNullThrottled) DestinationDevNullTestDestination {
	typ := DestinationDevNullTestDestinationUnionTypeDestinationDevNullThrottled

	return DestinationDevNullTestDestination{
		DestinationDevNullThrottled: &destinationDevNullThrottled,
		Type:                        typ,
	}
}

func CreateDestinationDevNullTestDestinationDestinationDevNullFailing(destinationDevNullFailing DestinationDevNullFailing) DestinationDevNullTestDestination {
	typ := DestinationDevNullTestDestinationUnionTypeDestinationDevNullFailing

	return DestinationDevNullTestDestination{
		DestinationDevNullFailing: &destinationDevNullFailing,
		Type:                      typ,
	}
}

func (u *DestinationDevNullTestDestination) UnmarshalJSON(data []byte) error {

	var destinationDevNullSilent DestinationDevNullSilent = DestinationDevNullSilent{}
	if err := utils.UnmarshalJSON(data, &destinationDevNullSilent, "", true, true); err == nil {
		u.DestinationDevNullSilent = &destinationDevNullSilent
		u.Type = DestinationDevNullTestDestinationUnionTypeDestinationDevNullSilent
		return nil
	}

	var destinationDevNullLogging DestinationDevNullLogging = DestinationDevNullLogging{}
	if err := utils.UnmarshalJSON(data, &destinationDevNullLogging, "", true, true); err == nil {
		u.DestinationDevNullLogging = &destinationDevNullLogging
		u.Type = DestinationDevNullTestDestinationUnionTypeDestinationDevNullLogging
		return nil
	}

	var destinationDevNullThrottled DestinationDevNullThrottled = DestinationDevNullThrottled{}
	if err := utils.UnmarshalJSON(data, &destinationDevNullThrottled, "", true, true); err == nil {
		u.DestinationDevNullThrottled = &destinationDevNullThrottled
		u.Type = DestinationDevNullTestDestinationUnionTypeDestinationDevNullThrottled
		return nil
	}

	var destinationDevNullFailing DestinationDevNullFailing = DestinationDevNullFailing{}
	if err := utils.UnmarshalJSON(data, &destinationDevNullFailing, "", true, true); err == nil {
		u.DestinationDevNullFailing = &destinationDevNullFailing
		u.Type = DestinationDevNullTestDestinationUnionTypeDestinationDevNullFailing
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationDevNullTestDestination", string(data))
}

func (u DestinationDevNullTestDestination) MarshalJSON() ([]byte, error) {
	if u.DestinationDevNullLogging != nil {
		return utils.MarshalJSON(u.DestinationDevNullLogging, "", true)
	}

	if u.DestinationDevNullSilent != nil {
		return utils.MarshalJSON(u.DestinationDevNullSilent, "", true)
	}

	if u.DestinationDevNullThrottled != nil {
		return utils.MarshalJSON(u.DestinationDevNullThrottled, "", true)
	}

	if u.DestinationDevNullFailing != nil {
		return utils.MarshalJSON(u.DestinationDevNullFailing, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationDevNullTestDestination: all fields are null")
}

type DestinationDevNull struct {
	destinationType DevNull `const:"dev-null" json:"destinationType"`
	// The type of destination to be used
	TestDestination DestinationDevNullTestDestination `json:"test_destination"`
}

func (d DestinationDevNull) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationDevNull) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *DestinationDevNull) GetDestinationType() DevNull {
	return DevNullDevNull
}

func (o *DestinationDevNull) GetTestDestination() DestinationDevNullTestDestination {
	if o == nil {
		return DestinationDevNullTestDestination{}
	}
	return o.TestDestination
}
