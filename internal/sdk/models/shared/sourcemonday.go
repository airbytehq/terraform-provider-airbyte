// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

type APIToken struct {
	// API Token for making authenticated requests.
	APIToken string `json:"api_token"`
	authType string `const:"api_token" json:"auth_type"`
}

func (a APIToken) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *APIToken) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (a *APIToken) GetAPIToken() string {
	if a == nil {
		return ""
	}
	return a.APIToken
}

func (a *APIToken) GetAuthType() string {
	return "api_token"
}

type SourceMondayOAuth20 struct {
	// Access Token for making authenticated requests.
	AccessToken string `json:"access_token"`
	authType    string `const:"oauth2.0" json:"auth_type"`
	// The Client ID of your OAuth application.
	ClientID string `json:"client_id"`
	// The Client Secret of your OAuth application.
	ClientSecret string `json:"client_secret"`
	// Slug/subdomain of the account, or the first part of the URL that comes before .monday.com
	Subdomain *string `default:"" json:"subdomain"`
}

func (s SourceMondayOAuth20) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMondayOAuth20) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceMondayOAuth20) GetAccessToken() string {
	if s == nil {
		return ""
	}
	return s.AccessToken
}

func (s *SourceMondayOAuth20) GetAuthType() string {
	return "oauth2.0"
}

func (s *SourceMondayOAuth20) GetClientID() string {
	if s == nil {
		return ""
	}
	return s.ClientID
}

func (s *SourceMondayOAuth20) GetClientSecret() string {
	if s == nil {
		return ""
	}
	return s.ClientSecret
}

func (s *SourceMondayOAuth20) GetSubdomain() *string {
	if s == nil {
		return nil
	}
	return s.Subdomain
}

type SourceMondayAuthorizationMethodType string

const (
	SourceMondayAuthorizationMethodTypeSourceMondayOAuth20 SourceMondayAuthorizationMethodType = "source-monday_OAuth2.0"
	SourceMondayAuthorizationMethodTypeAPIToken            SourceMondayAuthorizationMethodType = "API Token"
)

type SourceMondayAuthorizationMethod struct {
	SourceMondayOAuth20 *SourceMondayOAuth20 `queryParam:"inline" union:"member"`
	APIToken            *APIToken            `queryParam:"inline" union:"member"`

	Type SourceMondayAuthorizationMethodType
}

func CreateSourceMondayAuthorizationMethodSourceMondayOAuth20(sourceMondayOAuth20 SourceMondayOAuth20) SourceMondayAuthorizationMethod {
	typ := SourceMondayAuthorizationMethodTypeSourceMondayOAuth20

	return SourceMondayAuthorizationMethod{
		SourceMondayOAuth20: &sourceMondayOAuth20,
		Type:                typ,
	}
}

func CreateSourceMondayAuthorizationMethodAPIToken(apiToken APIToken) SourceMondayAuthorizationMethod {
	typ := SourceMondayAuthorizationMethodTypeAPIToken

	return SourceMondayAuthorizationMethod{
		APIToken: &apiToken,
		Type:     typ,
	}
}

func (u *SourceMondayAuthorizationMethod) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var sourceMondayOAuth20 SourceMondayOAuth20 = SourceMondayOAuth20{}
	if err := utils.UnmarshalJSON(data, &sourceMondayOAuth20, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceMondayAuthorizationMethodTypeSourceMondayOAuth20,
			Value: &sourceMondayOAuth20,
		})
	}

	var apiToken APIToken = APIToken{}
	if err := utils.UnmarshalJSON(data, &apiToken, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceMondayAuthorizationMethodTypeAPIToken,
			Value: &apiToken,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMondayAuthorizationMethod", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMondayAuthorizationMethod", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceMondayAuthorizationMethodType)
	switch best.Type {
	case SourceMondayAuthorizationMethodTypeSourceMondayOAuth20:
		u.SourceMondayOAuth20 = best.Value.(*SourceMondayOAuth20)
		return nil
	case SourceMondayAuthorizationMethodTypeAPIToken:
		u.APIToken = best.Value.(*APIToken)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMondayAuthorizationMethod", string(data))
}

func (u SourceMondayAuthorizationMethod) MarshalJSON() ([]byte, error) {
	if u.SourceMondayOAuth20 != nil {
		return utils.MarshalJSON(u.SourceMondayOAuth20, "", true)
	}

	if u.APIToken != nil {
		return utils.MarshalJSON(u.APIToken, "", true)
	}

	return nil, errors.New("could not marshal union type SourceMondayAuthorizationMethod: all fields are null")
}

type SourceMondaySourceType string

const (
	SourceMondaySourceTypeMonday SourceMondaySourceType = "monday"
)

func (e SourceMondaySourceType) ToPointer() *SourceMondaySourceType {
	return &e
}
func (e *SourceMondaySourceType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "monday":
		*e = SourceMondaySourceType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMondaySourceType: %v", v)
	}
}

type SourceMonday struct {
	// The IDs of the boards that the Items and Boards streams will extract records from. When left empty, streams will extract records from all boards that exist within the account.
	BoardIds    []int64                          `json:"board_ids,omitempty"`
	Credentials *SourceMondayAuthorizationMethod `json:"credentials,omitempty"`
	// The number of worker threads to use for the sync.
	NumWorkers           *int64                  `default:"4" json:"num_workers"`
	sourceType           *SourceMondaySourceType `const:"monday" json:"sourceType"`
	AdditionalProperties any                     `additionalProperties:"true" json:"-"`
}

func (s SourceMonday) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMonday) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceMonday) GetBoardIds() []int64 {
	if s == nil {
		return nil
	}
	return s.BoardIds
}

func (s *SourceMonday) GetCredentials() *SourceMondayAuthorizationMethod {
	if s == nil {
		return nil
	}
	return s.Credentials
}

func (s *SourceMonday) GetNumWorkers() *int64 {
	if s == nil {
		return nil
	}
	return s.NumWorkers
}

func (s *SourceMonday) GetSourceType() *SourceMondaySourceType {
	return SourceMondaySourceTypeMonday.ToPointer()
}

func (s *SourceMonday) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}
