// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

type DestinationSalesforceSchemasCompressionType string

const (
	DestinationSalesforceSchemasCompressionTypeGzip DestinationSalesforceSchemasCompressionType = "GZIP"
)

func (e DestinationSalesforceSchemasCompressionType) ToPointer() *DestinationSalesforceSchemasCompressionType {
	return &e
}
func (e *DestinationSalesforceSchemasCompressionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "GZIP":
		*e = DestinationSalesforceSchemasCompressionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationSalesforceSchemasCompressionType: %v", v)
	}
}

type DestinationSalesforceGZIP struct {
	CompressionType      *DestinationSalesforceSchemasCompressionType `default:"GZIP" json:"compression_type"`
	AdditionalProperties any                                          `additionalProperties:"true" json:"-"`
}

func (d DestinationSalesforceGZIP) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationSalesforceGZIP) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationSalesforceGZIP) GetCompressionType() *DestinationSalesforceSchemasCompressionType {
	if d == nil {
		return nil
	}
	return d.CompressionType
}

func (d *DestinationSalesforceGZIP) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationSalesforceCompressionType string

const (
	DestinationSalesforceCompressionTypeNoCompression DestinationSalesforceCompressionType = "No Compression"
)

func (e DestinationSalesforceCompressionType) ToPointer() *DestinationSalesforceCompressionType {
	return &e
}
func (e *DestinationSalesforceCompressionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "No Compression":
		*e = DestinationSalesforceCompressionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationSalesforceCompressionType: %v", v)
	}
}

type DestinationSalesforceNoCompression struct {
	CompressionType      *DestinationSalesforceCompressionType `default:"No Compression" json:"compression_type"`
	AdditionalProperties any                                   `additionalProperties:"true" json:"-"`
}

func (d DestinationSalesforceNoCompression) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationSalesforceNoCompression) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationSalesforceNoCompression) GetCompressionType() *DestinationSalesforceCompressionType {
	if d == nil {
		return nil
	}
	return d.CompressionType
}

func (d *DestinationSalesforceNoCompression) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationSalesforceCompressionUnionType string

const (
	DestinationSalesforceCompressionUnionTypeDestinationSalesforceNoCompression DestinationSalesforceCompressionUnionType = "destination-salesforce_No Compression"
	DestinationSalesforceCompressionUnionTypeDestinationSalesforceGZIP          DestinationSalesforceCompressionUnionType = "destination-salesforce_GZIP"
)

// DestinationSalesforceCompression - Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").
type DestinationSalesforceCompression struct {
	DestinationSalesforceNoCompression *DestinationSalesforceNoCompression `queryParam:"inline" union:"member"`
	DestinationSalesforceGZIP          *DestinationSalesforceGZIP          `queryParam:"inline" union:"member"`

	Type DestinationSalesforceCompressionUnionType
}

func CreateDestinationSalesforceCompressionDestinationSalesforceNoCompression(destinationSalesforceNoCompression DestinationSalesforceNoCompression) DestinationSalesforceCompression {
	typ := DestinationSalesforceCompressionUnionTypeDestinationSalesforceNoCompression

	return DestinationSalesforceCompression{
		DestinationSalesforceNoCompression: &destinationSalesforceNoCompression,
		Type:                               typ,
	}
}

func CreateDestinationSalesforceCompressionDestinationSalesforceGZIP(destinationSalesforceGZIP DestinationSalesforceGZIP) DestinationSalesforceCompression {
	typ := DestinationSalesforceCompressionUnionTypeDestinationSalesforceGZIP

	return DestinationSalesforceCompression{
		DestinationSalesforceGZIP: &destinationSalesforceGZIP,
		Type:                      typ,
	}
}

func (u *DestinationSalesforceCompression) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var destinationSalesforceNoCompression DestinationSalesforceNoCompression = DestinationSalesforceNoCompression{}
	if err := utils.UnmarshalJSON(data, &destinationSalesforceNoCompression, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationSalesforceCompressionUnionTypeDestinationSalesforceNoCompression,
			Value: &destinationSalesforceNoCompression,
		})
	}

	var destinationSalesforceGZIP DestinationSalesforceGZIP = DestinationSalesforceGZIP{}
	if err := utils.UnmarshalJSON(data, &destinationSalesforceGZIP, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationSalesforceCompressionUnionTypeDestinationSalesforceGZIP,
			Value: &destinationSalesforceGZIP,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationSalesforceCompression", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationSalesforceCompression", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(DestinationSalesforceCompressionUnionType)
	switch best.Type {
	case DestinationSalesforceCompressionUnionTypeDestinationSalesforceNoCompression:
		u.DestinationSalesforceNoCompression = best.Value.(*DestinationSalesforceNoCompression)
		return nil
	case DestinationSalesforceCompressionUnionTypeDestinationSalesforceGZIP:
		u.DestinationSalesforceGZIP = best.Value.(*DestinationSalesforceGZIP)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationSalesforceCompression", string(data))
}

func (u DestinationSalesforceCompression) MarshalJSON() ([]byte, error) {
	if u.DestinationSalesforceNoCompression != nil {
		return utils.MarshalJSON(u.DestinationSalesforceNoCompression, "", true)
	}

	if u.DestinationSalesforceGZIP != nil {
		return utils.MarshalJSON(u.DestinationSalesforceGZIP, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationSalesforceCompression: all fields are null")
}

type DestinationSalesforceSchemasFlattening string

const (
	DestinationSalesforceSchemasFlatteningNoFlattening        DestinationSalesforceSchemasFlattening = "No flattening"
	DestinationSalesforceSchemasFlatteningRootLevelFlattening DestinationSalesforceSchemasFlattening = "Root level flattening"
)

func (e DestinationSalesforceSchemasFlattening) ToPointer() *DestinationSalesforceSchemasFlattening {
	return &e
}
func (e *DestinationSalesforceSchemasFlattening) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "No flattening":
		fallthrough
	case "Root level flattening":
		*e = DestinationSalesforceSchemasFlattening(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationSalesforceSchemasFlattening: %v", v)
	}
}

type DestinationSalesforceSchemasFormatType string

const (
	DestinationSalesforceSchemasFormatTypeJsonl DestinationSalesforceSchemasFormatType = "JSONL"
)

func (e DestinationSalesforceSchemasFormatType) ToPointer() *DestinationSalesforceSchemasFormatType {
	return &e
}
func (e *DestinationSalesforceSchemasFormatType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "JSONL":
		*e = DestinationSalesforceSchemasFormatType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationSalesforceSchemasFormatType: %v", v)
	}
}

type DestinationSalesforceJSONLinesNewlineDelimitedJSON struct {
	Flattening           *DestinationSalesforceSchemasFlattening `default:"No flattening" json:"flattening"`
	FormatType           *DestinationSalesforceSchemasFormatType `default:"JSONL" json:"format_type"`
	AdditionalProperties any                                     `additionalProperties:"true" json:"-"`
}

func (d DestinationSalesforceJSONLinesNewlineDelimitedJSON) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationSalesforceJSONLinesNewlineDelimitedJSON) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationSalesforceJSONLinesNewlineDelimitedJSON) GetFlattening() *DestinationSalesforceSchemasFlattening {
	if d == nil {
		return nil
	}
	return d.Flattening
}

func (d *DestinationSalesforceJSONLinesNewlineDelimitedJSON) GetFormatType() *DestinationSalesforceSchemasFormatType {
	if d == nil {
		return nil
	}
	return d.FormatType
}

func (d *DestinationSalesforceJSONLinesNewlineDelimitedJSON) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationSalesforceFlattening string

const (
	DestinationSalesforceFlatteningNoFlattening        DestinationSalesforceFlattening = "No flattening"
	DestinationSalesforceFlatteningRootLevelFlattening DestinationSalesforceFlattening = "Root level flattening"
)

func (e DestinationSalesforceFlattening) ToPointer() *DestinationSalesforceFlattening {
	return &e
}
func (e *DestinationSalesforceFlattening) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "No flattening":
		fallthrough
	case "Root level flattening":
		*e = DestinationSalesforceFlattening(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationSalesforceFlattening: %v", v)
	}
}

type DestinationSalesforceFormatType string

const (
	DestinationSalesforceFormatTypeCsv DestinationSalesforceFormatType = "CSV"
)

func (e DestinationSalesforceFormatType) ToPointer() *DestinationSalesforceFormatType {
	return &e
}
func (e *DestinationSalesforceFormatType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CSV":
		*e = DestinationSalesforceFormatType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationSalesforceFormatType: %v", v)
	}
}

type DestinationSalesforceCSVCommaSeparatedValues struct {
	Flattening           *DestinationSalesforceFlattening `default:"No flattening" json:"flattening"`
	FormatType           *DestinationSalesforceFormatType `default:"CSV" json:"format_type"`
	AdditionalProperties any                              `additionalProperties:"true" json:"-"`
}

func (d DestinationSalesforceCSVCommaSeparatedValues) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationSalesforceCSVCommaSeparatedValues) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationSalesforceCSVCommaSeparatedValues) GetFlattening() *DestinationSalesforceFlattening {
	if d == nil {
		return nil
	}
	return d.Flattening
}

func (d *DestinationSalesforceCSVCommaSeparatedValues) GetFormatType() *DestinationSalesforceFormatType {
	if d == nil {
		return nil
	}
	return d.FormatType
}

func (d *DestinationSalesforceCSVCommaSeparatedValues) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationSalesforceOutputFormatType string

const (
	DestinationSalesforceOutputFormatTypeDestinationSalesforceCSVCommaSeparatedValues       DestinationSalesforceOutputFormatType = "destination-salesforce_CSV: Comma-Separated Values"
	DestinationSalesforceOutputFormatTypeDestinationSalesforceJSONLinesNewlineDelimitedJSON DestinationSalesforceOutputFormatType = "destination-salesforce_JSON Lines: Newline-delimited JSON"
)

// DestinationSalesforceOutputFormat - Format of the data output.
type DestinationSalesforceOutputFormat struct {
	DestinationSalesforceCSVCommaSeparatedValues       *DestinationSalesforceCSVCommaSeparatedValues       `queryParam:"inline" union:"member"`
	DestinationSalesforceJSONLinesNewlineDelimitedJSON *DestinationSalesforceJSONLinesNewlineDelimitedJSON `queryParam:"inline" union:"member"`

	Type DestinationSalesforceOutputFormatType
}

func CreateDestinationSalesforceOutputFormatDestinationSalesforceCSVCommaSeparatedValues(destinationSalesforceCSVCommaSeparatedValues DestinationSalesforceCSVCommaSeparatedValues) DestinationSalesforceOutputFormat {
	typ := DestinationSalesforceOutputFormatTypeDestinationSalesforceCSVCommaSeparatedValues

	return DestinationSalesforceOutputFormat{
		DestinationSalesforceCSVCommaSeparatedValues: &destinationSalesforceCSVCommaSeparatedValues,
		Type: typ,
	}
}

func CreateDestinationSalesforceOutputFormatDestinationSalesforceJSONLinesNewlineDelimitedJSON(destinationSalesforceJSONLinesNewlineDelimitedJSON DestinationSalesforceJSONLinesNewlineDelimitedJSON) DestinationSalesforceOutputFormat {
	typ := DestinationSalesforceOutputFormatTypeDestinationSalesforceJSONLinesNewlineDelimitedJSON

	return DestinationSalesforceOutputFormat{
		DestinationSalesforceJSONLinesNewlineDelimitedJSON: &destinationSalesforceJSONLinesNewlineDelimitedJSON,
		Type: typ,
	}
}

func (u *DestinationSalesforceOutputFormat) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var destinationSalesforceCSVCommaSeparatedValues DestinationSalesforceCSVCommaSeparatedValues = DestinationSalesforceCSVCommaSeparatedValues{}
	if err := utils.UnmarshalJSON(data, &destinationSalesforceCSVCommaSeparatedValues, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationSalesforceOutputFormatTypeDestinationSalesforceCSVCommaSeparatedValues,
			Value: &destinationSalesforceCSVCommaSeparatedValues,
		})
	}

	var destinationSalesforceJSONLinesNewlineDelimitedJSON DestinationSalesforceJSONLinesNewlineDelimitedJSON = DestinationSalesforceJSONLinesNewlineDelimitedJSON{}
	if err := utils.UnmarshalJSON(data, &destinationSalesforceJSONLinesNewlineDelimitedJSON, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationSalesforceOutputFormatTypeDestinationSalesforceJSONLinesNewlineDelimitedJSON,
			Value: &destinationSalesforceJSONLinesNewlineDelimitedJSON,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationSalesforceOutputFormat", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationSalesforceOutputFormat", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(DestinationSalesforceOutputFormatType)
	switch best.Type {
	case DestinationSalesforceOutputFormatTypeDestinationSalesforceCSVCommaSeparatedValues:
		u.DestinationSalesforceCSVCommaSeparatedValues = best.Value.(*DestinationSalesforceCSVCommaSeparatedValues)
		return nil
	case DestinationSalesforceOutputFormatTypeDestinationSalesforceJSONLinesNewlineDelimitedJSON:
		u.DestinationSalesforceJSONLinesNewlineDelimitedJSON = best.Value.(*DestinationSalesforceJSONLinesNewlineDelimitedJSON)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationSalesforceOutputFormat", string(data))
}

func (u DestinationSalesforceOutputFormat) MarshalJSON() ([]byte, error) {
	if u.DestinationSalesforceCSVCommaSeparatedValues != nil {
		return utils.MarshalJSON(u.DestinationSalesforceCSVCommaSeparatedValues, "", true)
	}

	if u.DestinationSalesforceJSONLinesNewlineDelimitedJSON != nil {
		return utils.MarshalJSON(u.DestinationSalesforceJSONLinesNewlineDelimitedJSON, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationSalesforceOutputFormat: all fields are null")
}

// DestinationSalesforceS3BucketRegion - The region of the S3 bucket. See <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-available-regions">here</a> for all region codes.
type DestinationSalesforceS3BucketRegion string

const (
	DestinationSalesforceS3BucketRegionUnknown      DestinationSalesforceS3BucketRegion = ""
	DestinationSalesforceS3BucketRegionAfSouth1     DestinationSalesforceS3BucketRegion = "af-south-1"
	DestinationSalesforceS3BucketRegionApEast1      DestinationSalesforceS3BucketRegion = "ap-east-1"
	DestinationSalesforceS3BucketRegionApNortheast1 DestinationSalesforceS3BucketRegion = "ap-northeast-1"
	DestinationSalesforceS3BucketRegionApNortheast2 DestinationSalesforceS3BucketRegion = "ap-northeast-2"
	DestinationSalesforceS3BucketRegionApNortheast3 DestinationSalesforceS3BucketRegion = "ap-northeast-3"
	DestinationSalesforceS3BucketRegionApSouth1     DestinationSalesforceS3BucketRegion = "ap-south-1"
	DestinationSalesforceS3BucketRegionApSouth2     DestinationSalesforceS3BucketRegion = "ap-south-2"
	DestinationSalesforceS3BucketRegionApSoutheast1 DestinationSalesforceS3BucketRegion = "ap-southeast-1"
	DestinationSalesforceS3BucketRegionApSoutheast2 DestinationSalesforceS3BucketRegion = "ap-southeast-2"
	DestinationSalesforceS3BucketRegionApSoutheast3 DestinationSalesforceS3BucketRegion = "ap-southeast-3"
	DestinationSalesforceS3BucketRegionApSoutheast4 DestinationSalesforceS3BucketRegion = "ap-southeast-4"
	DestinationSalesforceS3BucketRegionCaCentral1   DestinationSalesforceS3BucketRegion = "ca-central-1"
	DestinationSalesforceS3BucketRegionCaWest1      DestinationSalesforceS3BucketRegion = "ca-west-1"
	DestinationSalesforceS3BucketRegionCnNorth1     DestinationSalesforceS3BucketRegion = "cn-north-1"
	DestinationSalesforceS3BucketRegionCnNorthwest1 DestinationSalesforceS3BucketRegion = "cn-northwest-1"
	DestinationSalesforceS3BucketRegionEuCentral1   DestinationSalesforceS3BucketRegion = "eu-central-1"
	DestinationSalesforceS3BucketRegionEuCentral2   DestinationSalesforceS3BucketRegion = "eu-central-2"
	DestinationSalesforceS3BucketRegionEuNorth1     DestinationSalesforceS3BucketRegion = "eu-north-1"
	DestinationSalesforceS3BucketRegionEuSouth1     DestinationSalesforceS3BucketRegion = "eu-south-1"
	DestinationSalesforceS3BucketRegionEuSouth2     DestinationSalesforceS3BucketRegion = "eu-south-2"
	DestinationSalesforceS3BucketRegionEuWest1      DestinationSalesforceS3BucketRegion = "eu-west-1"
	DestinationSalesforceS3BucketRegionEuWest2      DestinationSalesforceS3BucketRegion = "eu-west-2"
	DestinationSalesforceS3BucketRegionEuWest3      DestinationSalesforceS3BucketRegion = "eu-west-3"
	DestinationSalesforceS3BucketRegionIlCentral1   DestinationSalesforceS3BucketRegion = "il-central-1"
	DestinationSalesforceS3BucketRegionMeCentral1   DestinationSalesforceS3BucketRegion = "me-central-1"
	DestinationSalesforceS3BucketRegionMeSouth1     DestinationSalesforceS3BucketRegion = "me-south-1"
	DestinationSalesforceS3BucketRegionSaEast1      DestinationSalesforceS3BucketRegion = "sa-east-1"
	DestinationSalesforceS3BucketRegionUsEast1      DestinationSalesforceS3BucketRegion = "us-east-1"
	DestinationSalesforceS3BucketRegionUsEast2      DestinationSalesforceS3BucketRegion = "us-east-2"
	DestinationSalesforceS3BucketRegionUsGovEast1   DestinationSalesforceS3BucketRegion = "us-gov-east-1"
	DestinationSalesforceS3BucketRegionUsGovWest1   DestinationSalesforceS3BucketRegion = "us-gov-west-1"
	DestinationSalesforceS3BucketRegionUsWest1      DestinationSalesforceS3BucketRegion = "us-west-1"
	DestinationSalesforceS3BucketRegionUsWest2      DestinationSalesforceS3BucketRegion = "us-west-2"
)

func (e DestinationSalesforceS3BucketRegion) ToPointer() *DestinationSalesforceS3BucketRegion {
	return &e
}
func (e *DestinationSalesforceS3BucketRegion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "":
		fallthrough
	case "af-south-1":
		fallthrough
	case "ap-east-1":
		fallthrough
	case "ap-northeast-1":
		fallthrough
	case "ap-northeast-2":
		fallthrough
	case "ap-northeast-3":
		fallthrough
	case "ap-south-1":
		fallthrough
	case "ap-south-2":
		fallthrough
	case "ap-southeast-1":
		fallthrough
	case "ap-southeast-2":
		fallthrough
	case "ap-southeast-3":
		fallthrough
	case "ap-southeast-4":
		fallthrough
	case "ca-central-1":
		fallthrough
	case "ca-west-1":
		fallthrough
	case "cn-north-1":
		fallthrough
	case "cn-northwest-1":
		fallthrough
	case "eu-central-1":
		fallthrough
	case "eu-central-2":
		fallthrough
	case "eu-north-1":
		fallthrough
	case "eu-south-1":
		fallthrough
	case "eu-south-2":
		fallthrough
	case "eu-west-1":
		fallthrough
	case "eu-west-2":
		fallthrough
	case "eu-west-3":
		fallthrough
	case "il-central-1":
		fallthrough
	case "me-central-1":
		fallthrough
	case "me-south-1":
		fallthrough
	case "sa-east-1":
		fallthrough
	case "us-east-1":
		fallthrough
	case "us-east-2":
		fallthrough
	case "us-gov-east-1":
		fallthrough
	case "us-gov-west-1":
		fallthrough
	case "us-west-1":
		fallthrough
	case "us-west-2":
		*e = DestinationSalesforceS3BucketRegion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationSalesforceS3BucketRegion: %v", v)
	}
}

type DestinationSalesforceSchemasStorageType string

const (
	DestinationSalesforceSchemasStorageTypeS3 DestinationSalesforceSchemasStorageType = "S3"
)

func (e DestinationSalesforceSchemasStorageType) ToPointer() *DestinationSalesforceSchemasStorageType {
	return &e
}
func (e *DestinationSalesforceSchemasStorageType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "S3":
		*e = DestinationSalesforceSchemasStorageType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationSalesforceSchemasStorageType: %v", v)
	}
}

type DestinationSalesforceS3 struct {
	// The access key ID to access the S3 bucket. Airbyte requires Read and Write permissions to the given bucket. Read more <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">here</a>.
	AccessKeyID *string `json:"access_key_id,omitempty"`
	// All files in the bucket will be prefixed by this.
	BucketPath string `json:"bucket_path"`
	// Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").
	Compression    *DestinationSalesforceCompression `json:"compression,omitempty"`
	FileNameFormat *string                           `default:"{date}_{timestamp}_{part_number}{format_extension}" json:"file_name_format"`
	// Format of the data output.
	Format     DestinationSalesforceOutputFormat `json:"format"`
	PathFormat *string                           `default:"{sync_id}/{namespace}/{stream_name}/" json:"path_format"`
	// The ARN of the AWS role to assume. Only usable in Airbyte Cloud.
	RoleArn *string `json:"role_arn,omitempty"`
	// The name of the S3 bucket. Read more <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/create-bucket-overview.html">here</a>.
	S3BucketName string `json:"s3_bucket_name"`
	// The region of the S3 bucket. See <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-available-regions">here</a> for all region codes.
	S3BucketRegion *DestinationSalesforceS3BucketRegion `default:"" json:"s3_bucket_region"`
	// Your S3 endpoint url. Read more <a href="https://docs.aws.amazon.com/general/latest/gr/s3.html#:~:text=Service%20endpoints-,Amazon%20S3%20endpoints,-When%20you%20use">here</a>
	S3Endpoint *string `json:"s3_endpoint,omitempty"`
	// The corresponding secret to the access key ID. Read more <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">here</a>
	SecretAccessKey      *string                                  `json:"secret_access_key,omitempty"`
	StorageType          *DestinationSalesforceSchemasStorageType `default:"S3" json:"storage_type"`
	AdditionalProperties any                                      `additionalProperties:"true" json:"-"`
}

func (d DestinationSalesforceS3) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationSalesforceS3) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationSalesforceS3) GetAccessKeyID() *string {
	if d == nil {
		return nil
	}
	return d.AccessKeyID
}

func (d *DestinationSalesforceS3) GetBucketPath() string {
	if d == nil {
		return ""
	}
	return d.BucketPath
}

func (d *DestinationSalesforceS3) GetCompression() *DestinationSalesforceCompression {
	if d == nil {
		return nil
	}
	return d.Compression
}

func (d *DestinationSalesforceS3) GetFileNameFormat() *string {
	if d == nil {
		return nil
	}
	return d.FileNameFormat
}

func (d *DestinationSalesforceS3) GetFormat() DestinationSalesforceOutputFormat {
	if d == nil {
		return DestinationSalesforceOutputFormat{}
	}
	return d.Format
}

func (d *DestinationSalesforceS3) GetPathFormat() *string {
	if d == nil {
		return nil
	}
	return d.PathFormat
}

func (d *DestinationSalesforceS3) GetRoleArn() *string {
	if d == nil {
		return nil
	}
	return d.RoleArn
}

func (d *DestinationSalesforceS3) GetS3BucketName() string {
	if d == nil {
		return ""
	}
	return d.S3BucketName
}

func (d *DestinationSalesforceS3) GetS3BucketRegion() *DestinationSalesforceS3BucketRegion {
	if d == nil {
		return nil
	}
	return d.S3BucketRegion
}

func (d *DestinationSalesforceS3) GetS3Endpoint() *string {
	if d == nil {
		return nil
	}
	return d.S3Endpoint
}

func (d *DestinationSalesforceS3) GetSecretAccessKey() *string {
	if d == nil {
		return nil
	}
	return d.SecretAccessKey
}

func (d *DestinationSalesforceS3) GetStorageType() *DestinationSalesforceSchemasStorageType {
	if d == nil {
		return nil
	}
	return d.StorageType
}

func (d *DestinationSalesforceS3) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationSalesforceStorageType string

const (
	DestinationSalesforceStorageTypeNone DestinationSalesforceStorageType = "None"
)

func (e DestinationSalesforceStorageType) ToPointer() *DestinationSalesforceStorageType {
	return &e
}
func (e *DestinationSalesforceStorageType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "None":
		*e = DestinationSalesforceStorageType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationSalesforceStorageType: %v", v)
	}
}

type DestinationSalesforceNone struct {
	StorageType          *DestinationSalesforceStorageType `default:"None" json:"storage_type"`
	AdditionalProperties any                               `additionalProperties:"true" json:"-"`
}

func (d DestinationSalesforceNone) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationSalesforceNone) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationSalesforceNone) GetStorageType() *DestinationSalesforceStorageType {
	if d == nil {
		return nil
	}
	return d.StorageType
}

func (d *DestinationSalesforceNone) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationSalesforceObjectStorageSpecType string

const (
	DestinationSalesforceObjectStorageSpecTypeDestinationSalesforceNone DestinationSalesforceObjectStorageSpecType = "destination-salesforce_None"
	DestinationSalesforceObjectStorageSpecTypeDestinationSalesforceS3   DestinationSalesforceObjectStorageSpecType = "destination-salesforce_S3"
)

type DestinationSalesforceObjectStorageSpec struct {
	DestinationSalesforceNone *DestinationSalesforceNone `queryParam:"inline" union:"member"`
	DestinationSalesforceS3   *DestinationSalesforceS3   `queryParam:"inline" union:"member"`

	Type DestinationSalesforceObjectStorageSpecType
}

func CreateDestinationSalesforceObjectStorageSpecDestinationSalesforceNone(destinationSalesforceNone DestinationSalesforceNone) DestinationSalesforceObjectStorageSpec {
	typ := DestinationSalesforceObjectStorageSpecTypeDestinationSalesforceNone

	return DestinationSalesforceObjectStorageSpec{
		DestinationSalesforceNone: &destinationSalesforceNone,
		Type:                      typ,
	}
}

func CreateDestinationSalesforceObjectStorageSpecDestinationSalesforceS3(destinationSalesforceS3 DestinationSalesforceS3) DestinationSalesforceObjectStorageSpec {
	typ := DestinationSalesforceObjectStorageSpecTypeDestinationSalesforceS3

	return DestinationSalesforceObjectStorageSpec{
		DestinationSalesforceS3: &destinationSalesforceS3,
		Type:                    typ,
	}
}

func (u *DestinationSalesforceObjectStorageSpec) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var destinationSalesforceNone DestinationSalesforceNone = DestinationSalesforceNone{}
	if err := utils.UnmarshalJSON(data, &destinationSalesforceNone, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationSalesforceObjectStorageSpecTypeDestinationSalesforceNone,
			Value: &destinationSalesforceNone,
		})
	}

	var destinationSalesforceS3 DestinationSalesforceS3 = DestinationSalesforceS3{}
	if err := utils.UnmarshalJSON(data, &destinationSalesforceS3, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationSalesforceObjectStorageSpecTypeDestinationSalesforceS3,
			Value: &destinationSalesforceS3,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationSalesforceObjectStorageSpec", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationSalesforceObjectStorageSpec", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(DestinationSalesforceObjectStorageSpecType)
	switch best.Type {
	case DestinationSalesforceObjectStorageSpecTypeDestinationSalesforceNone:
		u.DestinationSalesforceNone = best.Value.(*DestinationSalesforceNone)
		return nil
	case DestinationSalesforceObjectStorageSpecTypeDestinationSalesforceS3:
		u.DestinationSalesforceS3 = best.Value.(*DestinationSalesforceS3)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationSalesforceObjectStorageSpec", string(data))
}

func (u DestinationSalesforceObjectStorageSpec) MarshalJSON() ([]byte, error) {
	if u.DestinationSalesforceNone != nil {
		return utils.MarshalJSON(u.DestinationSalesforceNone, "", true)
	}

	if u.DestinationSalesforceS3 != nil {
		return utils.MarshalJSON(u.DestinationSalesforceS3, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationSalesforceObjectStorageSpec: all fields are null")
}

type DestinationSalesforceDestinationType string

const (
	DestinationSalesforceDestinationTypeSalesforce DestinationSalesforceDestinationType = "salesforce"
)

func (e DestinationSalesforceDestinationType) ToPointer() *DestinationSalesforceDestinationType {
	return &e
}
func (e *DestinationSalesforceDestinationType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "salesforce":
		*e = DestinationSalesforceDestinationType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationSalesforceDestinationType: %v", v)
	}
}

type DestinationSalesforce struct {
	authType string `const:"Client" json:"auth_type"`
	// Enter your Salesforce developer application's <a href="https://developer.salesforce.com/forums/?id=9062I000000DLgbQAG">Client ID</a>.
	ClientID string `json:"client_id"`
	// Enter your Salesforce developer application's <a href="https://developer.salesforce.com/forums/?id=9062I000000DLgbQAG">Client secret</a>.
	ClientSecret string `json:"client_secret"`
	// Toggle if you're using a <a href="https://help.salesforce.com/s/articleView?id=sf.deploy_sandboxes_parent.htm&type=5">Salesforce Sandbox</a>.
	IsSandbox           *bool                                   `default:"false" json:"is_sandbox"`
	ObjectStorageConfig *DestinationSalesforceObjectStorageSpec `json:"object_storage_config,omitempty"`
	// Enter your application's <a href="https://developer.salesforce.com/docs/atlas.en-us.mobile_sdk.meta/mobile_sdk/oauth_refresh_token_flow.htm">Salesforce Refresh Token</a> used for Airbyte to access your Salesforce account.
	RefreshToken         string                                `json:"refresh_token"`
	destinationType      *DestinationSalesforceDestinationType `const:"salesforce" json:"destinationType"`
	AdditionalProperties any                                   `additionalProperties:"true" json:"-"`
}

func (d DestinationSalesforce) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationSalesforce) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationSalesforce) GetAuthType() string {
	return "Client"
}

func (d *DestinationSalesforce) GetClientID() string {
	if d == nil {
		return ""
	}
	return d.ClientID
}

func (d *DestinationSalesforce) GetClientSecret() string {
	if d == nil {
		return ""
	}
	return d.ClientSecret
}

func (d *DestinationSalesforce) GetIsSandbox() *bool {
	if d == nil {
		return nil
	}
	return d.IsSandbox
}

func (d *DestinationSalesforce) GetObjectStorageConfig() *DestinationSalesforceObjectStorageSpec {
	if d == nil {
		return nil
	}
	return d.ObjectStorageConfig
}

func (d *DestinationSalesforce) GetRefreshToken() string {
	if d == nil {
		return ""
	}
	return d.RefreshToken
}

func (d *DestinationSalesforce) GetDestinationType() *DestinationSalesforceDestinationType {
	return DestinationSalesforceDestinationTypeSalesforce.ToPointer()
}

func (d *DestinationSalesforce) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}
