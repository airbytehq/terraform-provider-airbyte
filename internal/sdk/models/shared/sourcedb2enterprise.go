// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

type SourceDb2EnterpriseCursorMethod string

const (
	SourceDb2EnterpriseCursorMethodCdc SourceDb2EnterpriseCursorMethod = "cdc"
)

func (e SourceDb2EnterpriseCursorMethod) ToPointer() *SourceDb2EnterpriseCursorMethod {
	return &e
}
func (e *SourceDb2EnterpriseCursorMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "cdc":
		*e = SourceDb2EnterpriseCursorMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceDb2EnterpriseCursorMethod: %v", v)
	}
}

// ReadChangesUsingChangeDataCaptureCDC - <i>Recommended</i> - Incrementally reads new inserts, updates, and deletes using change data capture feature. This must be enabled on your database.
type ReadChangesUsingChangeDataCaptureCDC struct {
	CursorMethod *SourceDb2EnterpriseCursorMethod `default:"cdc" json:"cursor_method"`
	// The amount of time an initial load is allowed to continue for before catching up on CDC events.
	InitialLoadTimeoutHours *int64 `default:"8" json:"initial_load_timeout_hours"`
	AdditionalProperties    any    `additionalProperties:"true" json:"-"`
}

func (r ReadChangesUsingChangeDataCaptureCDC) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(r, "", false)
}

func (r *ReadChangesUsingChangeDataCaptureCDC) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &r, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (r *ReadChangesUsingChangeDataCaptureCDC) GetCursorMethod() *SourceDb2EnterpriseCursorMethod {
	if r == nil {
		return nil
	}
	return r.CursorMethod
}

func (r *ReadChangesUsingChangeDataCaptureCDC) GetInitialLoadTimeoutHours() *int64 {
	if r == nil {
		return nil
	}
	return r.InitialLoadTimeoutHours
}

func (r *ReadChangesUsingChangeDataCaptureCDC) GetAdditionalProperties() any {
	if r == nil {
		return nil
	}
	return r.AdditionalProperties
}

type CursorMethod string

const (
	CursorMethodUserDefined CursorMethod = "user_defined"
)

func (e CursorMethod) ToPointer() *CursorMethod {
	return &e
}
func (e *CursorMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "user_defined":
		*e = CursorMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CursorMethod: %v", v)
	}
}

// ScanChangesWithUserDefinedCursor - Incrementally detects new inserts and updates using the <a href="https://docs.airbyte.com/understanding-airbyte/connections/incremental-append/#user-defined-cursor">cursor column</a> chosen when configuring a connection (e.g. created_at, updated_at).
type ScanChangesWithUserDefinedCursor struct {
	CursorMethod         *CursorMethod `default:"user_defined" json:"cursor_method"`
	AdditionalProperties any           `additionalProperties:"true" json:"-"`
}

func (s ScanChangesWithUserDefinedCursor) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *ScanChangesWithUserDefinedCursor) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *ScanChangesWithUserDefinedCursor) GetCursorMethod() *CursorMethod {
	if s == nil {
		return nil
	}
	return s.CursorMethod
}

func (s *ScanChangesWithUserDefinedCursor) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type UpdateMethodType string

const (
	UpdateMethodTypeScanChangesWithUserDefinedCursor     UpdateMethodType = "Scan Changes with User Defined Cursor"
	UpdateMethodTypeReadChangesUsingChangeDataCaptureCDC UpdateMethodType = "Read Changes using Change Data Capture (CDC)"
)

// UpdateMethod - Configures how data is extracted from the database.
type UpdateMethod struct {
	ScanChangesWithUserDefinedCursor     *ScanChangesWithUserDefinedCursor     `queryParam:"inline" union:"member"`
	ReadChangesUsingChangeDataCaptureCDC *ReadChangesUsingChangeDataCaptureCDC `queryParam:"inline" union:"member"`

	Type UpdateMethodType
}

func CreateUpdateMethodScanChangesWithUserDefinedCursor(scanChangesWithUserDefinedCursor ScanChangesWithUserDefinedCursor) UpdateMethod {
	typ := UpdateMethodTypeScanChangesWithUserDefinedCursor

	return UpdateMethod{
		ScanChangesWithUserDefinedCursor: &scanChangesWithUserDefinedCursor,
		Type:                             typ,
	}
}

func CreateUpdateMethodReadChangesUsingChangeDataCaptureCDC(readChangesUsingChangeDataCaptureCDC ReadChangesUsingChangeDataCaptureCDC) UpdateMethod {
	typ := UpdateMethodTypeReadChangesUsingChangeDataCaptureCDC

	return UpdateMethod{
		ReadChangesUsingChangeDataCaptureCDC: &readChangesUsingChangeDataCaptureCDC,
		Type:                                 typ,
	}
}

func (u *UpdateMethod) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var scanChangesWithUserDefinedCursor ScanChangesWithUserDefinedCursor = ScanChangesWithUserDefinedCursor{}
	if err := utils.UnmarshalJSON(data, &scanChangesWithUserDefinedCursor, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  UpdateMethodTypeScanChangesWithUserDefinedCursor,
			Value: &scanChangesWithUserDefinedCursor,
		})
	}

	var readChangesUsingChangeDataCaptureCDC ReadChangesUsingChangeDataCaptureCDC = ReadChangesUsingChangeDataCaptureCDC{}
	if err := utils.UnmarshalJSON(data, &readChangesUsingChangeDataCaptureCDC, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  UpdateMethodTypeReadChangesUsingChangeDataCaptureCDC,
			Value: &readChangesUsingChangeDataCaptureCDC,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for UpdateMethod", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for UpdateMethod", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(UpdateMethodType)
	switch best.Type {
	case UpdateMethodTypeScanChangesWithUserDefinedCursor:
		u.ScanChangesWithUserDefinedCursor = best.Value.(*ScanChangesWithUserDefinedCursor)
		return nil
	case UpdateMethodTypeReadChangesUsingChangeDataCaptureCDC:
		u.ReadChangesUsingChangeDataCaptureCDC = best.Value.(*ReadChangesUsingChangeDataCaptureCDC)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for UpdateMethod", string(data))
}

func (u UpdateMethod) MarshalJSON() ([]byte, error) {
	if u.ScanChangesWithUserDefinedCursor != nil {
		return utils.MarshalJSON(u.ScanChangesWithUserDefinedCursor, "", true)
	}

	if u.ReadChangesUsingChangeDataCaptureCDC != nil {
		return utils.MarshalJSON(u.ReadChangesUsingChangeDataCaptureCDC, "", true)
	}

	return nil, errors.New("could not marshal union type UpdateMethod: all fields are null")
}

type SourceDb2EnterpriseEncryptionMethod string

const (
	SourceDb2EnterpriseEncryptionMethodEncryptedVerifyCertificate SourceDb2EnterpriseEncryptionMethod = "encrypted_verify_certificate"
)

func (e SourceDb2EnterpriseEncryptionMethod) ToPointer() *SourceDb2EnterpriseEncryptionMethod {
	return &e
}
func (e *SourceDb2EnterpriseEncryptionMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "encrypted_verify_certificate":
		*e = SourceDb2EnterpriseEncryptionMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceDb2EnterpriseEncryptionMethod: %v", v)
	}
}

// TLSEncryptedVerifyCertificate - Verify and use the certificate provided by the server.
type TLSEncryptedVerifyCertificate struct {
	EncryptionMethod *SourceDb2EnterpriseEncryptionMethod `default:"encrypted_verify_certificate" json:"encryption_method"`
	// Privacy Enhanced Mail (PEM) files are concatenated certificate containers frequently used in certificate installations.
	SslCertificate       string `json:"ssl_certificate"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (t TLSEncryptedVerifyCertificate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(t, "", false)
}

func (t *TLSEncryptedVerifyCertificate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &t, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (t *TLSEncryptedVerifyCertificate) GetEncryptionMethod() *SourceDb2EnterpriseEncryptionMethod {
	if t == nil {
		return nil
	}
	return t.EncryptionMethod
}

func (t *TLSEncryptedVerifyCertificate) GetSslCertificate() string {
	if t == nil {
		return ""
	}
	return t.SslCertificate
}

func (t *TLSEncryptedVerifyCertificate) GetAdditionalProperties() any {
	if t == nil {
		return nil
	}
	return t.AdditionalProperties
}

type EncryptionMethod string

const (
	EncryptionMethodUnencrypted EncryptionMethod = "unencrypted"
)

func (e EncryptionMethod) ToPointer() *EncryptionMethod {
	return &e
}
func (e *EncryptionMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "unencrypted":
		*e = EncryptionMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for EncryptionMethod: %v", v)
	}
}

// Unencrypted - Data transfer will not be encrypted.
type Unencrypted struct {
	EncryptionMethod     *EncryptionMethod `default:"unencrypted" json:"encryption_method"`
	AdditionalProperties any               `additionalProperties:"true" json:"-"`
}

func (u Unencrypted) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(u, "", false)
}

func (u *Unencrypted) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &u, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (u *Unencrypted) GetEncryptionMethod() *EncryptionMethod {
	if u == nil {
		return nil
	}
	return u.EncryptionMethod
}

func (u *Unencrypted) GetAdditionalProperties() any {
	if u == nil {
		return nil
	}
	return u.AdditionalProperties
}

type SourceDb2EnterpriseEncryptionType string

const (
	SourceDb2EnterpriseEncryptionTypeUnencrypted                   SourceDb2EnterpriseEncryptionType = "Unencrypted"
	SourceDb2EnterpriseEncryptionTypeTLSEncryptedVerifyCertificate SourceDb2EnterpriseEncryptionType = "TLS Encrypted (verify certificate)"
)

// SourceDb2EnterpriseEncryption - The encryption method with is used when communicating with the database.
type SourceDb2EnterpriseEncryption struct {
	Unencrypted                   *Unencrypted                   `queryParam:"inline" union:"member"`
	TLSEncryptedVerifyCertificate *TLSEncryptedVerifyCertificate `queryParam:"inline" union:"member"`

	Type SourceDb2EnterpriseEncryptionType
}

func CreateSourceDb2EnterpriseEncryptionUnencrypted(unencrypted Unencrypted) SourceDb2EnterpriseEncryption {
	typ := SourceDb2EnterpriseEncryptionTypeUnencrypted

	return SourceDb2EnterpriseEncryption{
		Unencrypted: &unencrypted,
		Type:        typ,
	}
}

func CreateSourceDb2EnterpriseEncryptionTLSEncryptedVerifyCertificate(tlsEncryptedVerifyCertificate TLSEncryptedVerifyCertificate) SourceDb2EnterpriseEncryption {
	typ := SourceDb2EnterpriseEncryptionTypeTLSEncryptedVerifyCertificate

	return SourceDb2EnterpriseEncryption{
		TLSEncryptedVerifyCertificate: &tlsEncryptedVerifyCertificate,
		Type:                          typ,
	}
}

func (u *SourceDb2EnterpriseEncryption) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var unencrypted Unencrypted = Unencrypted{}
	if err := utils.UnmarshalJSON(data, &unencrypted, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceDb2EnterpriseEncryptionTypeUnencrypted,
			Value: &unencrypted,
		})
	}

	var tlsEncryptedVerifyCertificate TLSEncryptedVerifyCertificate = TLSEncryptedVerifyCertificate{}
	if err := utils.UnmarshalJSON(data, &tlsEncryptedVerifyCertificate, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceDb2EnterpriseEncryptionTypeTLSEncryptedVerifyCertificate,
			Value: &tlsEncryptedVerifyCertificate,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceDb2EnterpriseEncryption", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceDb2EnterpriseEncryption", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceDb2EnterpriseEncryptionType)
	switch best.Type {
	case SourceDb2EnterpriseEncryptionTypeUnencrypted:
		u.Unencrypted = best.Value.(*Unencrypted)
		return nil
	case SourceDb2EnterpriseEncryptionTypeTLSEncryptedVerifyCertificate:
		u.TLSEncryptedVerifyCertificate = best.Value.(*TLSEncryptedVerifyCertificate)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceDb2EnterpriseEncryption", string(data))
}

func (u SourceDb2EnterpriseEncryption) MarshalJSON() ([]byte, error) {
	if u.Unencrypted != nil {
		return utils.MarshalJSON(u.Unencrypted, "", true)
	}

	if u.TLSEncryptedVerifyCertificate != nil {
		return utils.MarshalJSON(u.TLSEncryptedVerifyCertificate, "", true)
	}

	return nil, errors.New("could not marshal union type SourceDb2EnterpriseEncryption: all fields are null")
}

type SourceDb2EnterpriseSchemasTunnelMethod string

const (
	SourceDb2EnterpriseSchemasTunnelMethodSSHPasswordAuth SourceDb2EnterpriseSchemasTunnelMethod = "SSH_PASSWORD_AUTH"
)

func (e SourceDb2EnterpriseSchemasTunnelMethod) ToPointer() *SourceDb2EnterpriseSchemasTunnelMethod {
	return &e
}
func (e *SourceDb2EnterpriseSchemasTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_PASSWORD_AUTH":
		*e = SourceDb2EnterpriseSchemasTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceDb2EnterpriseSchemasTunnelMethod: %v", v)
	}
}

// SourceDb2EnterprisePasswordAuthentication - Connect through a jump server tunnel host using username and password authentication
type SourceDb2EnterprisePasswordAuthentication struct {
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost   string                                  `json:"tunnel_host"`
	TunnelMethod *SourceDb2EnterpriseSchemasTunnelMethod `default:"SSH_PASSWORD_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser string `json:"tunnel_user"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword   string `json:"tunnel_user_password"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (s SourceDb2EnterprisePasswordAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceDb2EnterprisePasswordAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceDb2EnterprisePasswordAuthentication) GetTunnelHost() string {
	if s == nil {
		return ""
	}
	return s.TunnelHost
}

func (s *SourceDb2EnterprisePasswordAuthentication) GetTunnelMethod() *SourceDb2EnterpriseSchemasTunnelMethod {
	if s == nil {
		return nil
	}
	return s.TunnelMethod
}

func (s *SourceDb2EnterprisePasswordAuthentication) GetTunnelPort() *int64 {
	if s == nil {
		return nil
	}
	return s.TunnelPort
}

func (s *SourceDb2EnterprisePasswordAuthentication) GetTunnelUser() string {
	if s == nil {
		return ""
	}
	return s.TunnelUser
}

func (s *SourceDb2EnterprisePasswordAuthentication) GetTunnelUserPassword() string {
	if s == nil {
		return ""
	}
	return s.TunnelUserPassword
}

func (s *SourceDb2EnterprisePasswordAuthentication) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceDb2EnterpriseTunnelMethod string

const (
	SourceDb2EnterpriseTunnelMethodSSHKeyAuth SourceDb2EnterpriseTunnelMethod = "SSH_KEY_AUTH"
)

func (e SourceDb2EnterpriseTunnelMethod) ToPointer() *SourceDb2EnterpriseTunnelMethod {
	return &e
}
func (e *SourceDb2EnterpriseTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_KEY_AUTH":
		*e = SourceDb2EnterpriseTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceDb2EnterpriseTunnelMethod: %v", v)
	}
}

// SourceDb2EnterpriseSSHKeyAuthentication - Connect through a jump server tunnel host using username and ssh key
type SourceDb2EnterpriseSSHKeyAuthentication struct {
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey string `json:"ssh_key"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost   string                           `json:"tunnel_host"`
	TunnelMethod *SourceDb2EnterpriseTunnelMethod `default:"SSH_KEY_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser           string `json:"tunnel_user"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (s SourceDb2EnterpriseSSHKeyAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceDb2EnterpriseSSHKeyAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceDb2EnterpriseSSHKeyAuthentication) GetSSHKey() string {
	if s == nil {
		return ""
	}
	return s.SSHKey
}

func (s *SourceDb2EnterpriseSSHKeyAuthentication) GetTunnelHost() string {
	if s == nil {
		return ""
	}
	return s.TunnelHost
}

func (s *SourceDb2EnterpriseSSHKeyAuthentication) GetTunnelMethod() *SourceDb2EnterpriseTunnelMethod {
	if s == nil {
		return nil
	}
	return s.TunnelMethod
}

func (s *SourceDb2EnterpriseSSHKeyAuthentication) GetTunnelPort() *int64 {
	if s == nil {
		return nil
	}
	return s.TunnelPort
}

func (s *SourceDb2EnterpriseSSHKeyAuthentication) GetTunnelUser() string {
	if s == nil {
		return ""
	}
	return s.TunnelUser
}

func (s *SourceDb2EnterpriseSSHKeyAuthentication) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type TunnelMethod string

const (
	TunnelMethodNoTunnel TunnelMethod = "NO_TUNNEL"
)

func (e TunnelMethod) ToPointer() *TunnelMethod {
	return &e
}
func (e *TunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NO_TUNNEL":
		*e = TunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TunnelMethod: %v", v)
	}
}

// SourceDb2EnterpriseNoTunnel - No ssh tunnel needed to connect to database
type SourceDb2EnterpriseNoTunnel struct {
	TunnelMethod         *TunnelMethod `default:"NO_TUNNEL" json:"tunnel_method"`
	AdditionalProperties any           `additionalProperties:"true" json:"-"`
}

func (s SourceDb2EnterpriseNoTunnel) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceDb2EnterpriseNoTunnel) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceDb2EnterpriseNoTunnel) GetTunnelMethod() *TunnelMethod {
	if s == nil {
		return nil
	}
	return s.TunnelMethod
}

func (s *SourceDb2EnterpriseNoTunnel) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceDb2EnterpriseSSHTunnelMethodType string

const (
	SourceDb2EnterpriseSSHTunnelMethodTypeSourceDb2EnterpriseNoTunnel               SourceDb2EnterpriseSSHTunnelMethodType = "source-db2-enterprise_No Tunnel"
	SourceDb2EnterpriseSSHTunnelMethodTypeSourceDb2EnterpriseSSHKeyAuthentication   SourceDb2EnterpriseSSHTunnelMethodType = "source-db2-enterprise_SSH Key Authentication"
	SourceDb2EnterpriseSSHTunnelMethodTypeSourceDb2EnterprisePasswordAuthentication SourceDb2EnterpriseSSHTunnelMethodType = "source-db2-enterprise_Password Authentication"
)

// SourceDb2EnterpriseSSHTunnelMethod - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceDb2EnterpriseSSHTunnelMethod struct {
	SourceDb2EnterpriseNoTunnel               *SourceDb2EnterpriseNoTunnel               `queryParam:"inline" union:"member"`
	SourceDb2EnterpriseSSHKeyAuthentication   *SourceDb2EnterpriseSSHKeyAuthentication   `queryParam:"inline" union:"member"`
	SourceDb2EnterprisePasswordAuthentication *SourceDb2EnterprisePasswordAuthentication `queryParam:"inline" union:"member"`

	Type SourceDb2EnterpriseSSHTunnelMethodType
}

func CreateSourceDb2EnterpriseSSHTunnelMethodSourceDb2EnterpriseNoTunnel(sourceDb2EnterpriseNoTunnel SourceDb2EnterpriseNoTunnel) SourceDb2EnterpriseSSHTunnelMethod {
	typ := SourceDb2EnterpriseSSHTunnelMethodTypeSourceDb2EnterpriseNoTunnel

	return SourceDb2EnterpriseSSHTunnelMethod{
		SourceDb2EnterpriseNoTunnel: &sourceDb2EnterpriseNoTunnel,
		Type:                        typ,
	}
}

func CreateSourceDb2EnterpriseSSHTunnelMethodSourceDb2EnterpriseSSHKeyAuthentication(sourceDb2EnterpriseSSHKeyAuthentication SourceDb2EnterpriseSSHKeyAuthentication) SourceDb2EnterpriseSSHTunnelMethod {
	typ := SourceDb2EnterpriseSSHTunnelMethodTypeSourceDb2EnterpriseSSHKeyAuthentication

	return SourceDb2EnterpriseSSHTunnelMethod{
		SourceDb2EnterpriseSSHKeyAuthentication: &sourceDb2EnterpriseSSHKeyAuthentication,
		Type:                                    typ,
	}
}

func CreateSourceDb2EnterpriseSSHTunnelMethodSourceDb2EnterprisePasswordAuthentication(sourceDb2EnterprisePasswordAuthentication SourceDb2EnterprisePasswordAuthentication) SourceDb2EnterpriseSSHTunnelMethod {
	typ := SourceDb2EnterpriseSSHTunnelMethodTypeSourceDb2EnterprisePasswordAuthentication

	return SourceDb2EnterpriseSSHTunnelMethod{
		SourceDb2EnterprisePasswordAuthentication: &sourceDb2EnterprisePasswordAuthentication,
		Type: typ,
	}
}

func (u *SourceDb2EnterpriseSSHTunnelMethod) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var sourceDb2EnterpriseNoTunnel SourceDb2EnterpriseNoTunnel = SourceDb2EnterpriseNoTunnel{}
	if err := utils.UnmarshalJSON(data, &sourceDb2EnterpriseNoTunnel, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceDb2EnterpriseSSHTunnelMethodTypeSourceDb2EnterpriseNoTunnel,
			Value: &sourceDb2EnterpriseNoTunnel,
		})
	}

	var sourceDb2EnterpriseSSHKeyAuthentication SourceDb2EnterpriseSSHKeyAuthentication = SourceDb2EnterpriseSSHKeyAuthentication{}
	if err := utils.UnmarshalJSON(data, &sourceDb2EnterpriseSSHKeyAuthentication, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceDb2EnterpriseSSHTunnelMethodTypeSourceDb2EnterpriseSSHKeyAuthentication,
			Value: &sourceDb2EnterpriseSSHKeyAuthentication,
		})
	}

	var sourceDb2EnterprisePasswordAuthentication SourceDb2EnterprisePasswordAuthentication = SourceDb2EnterprisePasswordAuthentication{}
	if err := utils.UnmarshalJSON(data, &sourceDb2EnterprisePasswordAuthentication, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceDb2EnterpriseSSHTunnelMethodTypeSourceDb2EnterprisePasswordAuthentication,
			Value: &sourceDb2EnterprisePasswordAuthentication,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceDb2EnterpriseSSHTunnelMethod", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceDb2EnterpriseSSHTunnelMethod", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceDb2EnterpriseSSHTunnelMethodType)
	switch best.Type {
	case SourceDb2EnterpriseSSHTunnelMethodTypeSourceDb2EnterpriseNoTunnel:
		u.SourceDb2EnterpriseNoTunnel = best.Value.(*SourceDb2EnterpriseNoTunnel)
		return nil
	case SourceDb2EnterpriseSSHTunnelMethodTypeSourceDb2EnterpriseSSHKeyAuthentication:
		u.SourceDb2EnterpriseSSHKeyAuthentication = best.Value.(*SourceDb2EnterpriseSSHKeyAuthentication)
		return nil
	case SourceDb2EnterpriseSSHTunnelMethodTypeSourceDb2EnterprisePasswordAuthentication:
		u.SourceDb2EnterprisePasswordAuthentication = best.Value.(*SourceDb2EnterprisePasswordAuthentication)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceDb2EnterpriseSSHTunnelMethod", string(data))
}

func (u SourceDb2EnterpriseSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.SourceDb2EnterpriseNoTunnel != nil {
		return utils.MarshalJSON(u.SourceDb2EnterpriseNoTunnel, "", true)
	}

	if u.SourceDb2EnterpriseSSHKeyAuthentication != nil {
		return utils.MarshalJSON(u.SourceDb2EnterpriseSSHKeyAuthentication, "", true)
	}

	if u.SourceDb2EnterprisePasswordAuthentication != nil {
		return utils.MarshalJSON(u.SourceDb2EnterprisePasswordAuthentication, "", true)
	}

	return nil, errors.New("could not marshal union type SourceDb2EnterpriseSSHTunnelMethod: all fields are null")
}

type SourceDb2EnterpriseSourceType string

const (
	SourceDb2EnterpriseSourceTypeDb2Enterprise SourceDb2EnterpriseSourceType = "db2-enterprise"
)

func (e SourceDb2EnterpriseSourceType) ToPointer() *SourceDb2EnterpriseSourceType {
	return &e
}
func (e *SourceDb2EnterpriseSourceType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "db2-enterprise":
		*e = SourceDb2EnterpriseSourceType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceDb2EnterpriseSourceType: %v", v)
	}
}

type SourceDb2Enterprise struct {
	// When this feature is enabled, during schema discovery the connector will query each table or view individually to check access privileges and inaccessible tables, views, or columns therein will be removed. In large schemas, this might cause schema discovery to take too long, in which case it might be advisable to disable this feature.
	CheckPrivileges *bool `default:"true" json:"check_privileges"`
	// How often (in seconds) a stream should checkpoint, when possible.
	CheckpointTargetIntervalSeconds *int64 `default:"300" json:"checkpoint_target_interval_seconds"`
	// Maximum number of concurrent queries to the database.
	Concurrency *int64 `default:"1" json:"concurrency"`
	// Configures how data is extracted from the database.
	Cursor UpdateMethod `json:"cursor"`
	// The database name.
	Database string `json:"database"`
	// The encryption method with is used when communicating with the database.
	Encryption SourceDb2EnterpriseEncryption `json:"encryption"`
	// Hostname of the database.
	Host string `json:"host"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// The password associated with the username.
	Password *string `json:"password,omitempty"`
	// Port of the database.
	Port *int64 `default:"50000" json:"port"`
	// The list of schemas to sync from.
	Schemas []string `json:"schemas"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod SourceDb2EnterpriseSSHTunnelMethod `json:"tunnel_method"`
	// The username which is used to access the database.
	Username             string                         `json:"username"`
	sourceType           *SourceDb2EnterpriseSourceType `const:"db2-enterprise" json:"sourceType"`
	AdditionalProperties any                            `additionalProperties:"true" json:"-"`
}

func (s SourceDb2Enterprise) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceDb2Enterprise) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceDb2Enterprise) GetCheckPrivileges() *bool {
	if s == nil {
		return nil
	}
	return s.CheckPrivileges
}

func (s *SourceDb2Enterprise) GetCheckpointTargetIntervalSeconds() *int64 {
	if s == nil {
		return nil
	}
	return s.CheckpointTargetIntervalSeconds
}

func (s *SourceDb2Enterprise) GetConcurrency() *int64 {
	if s == nil {
		return nil
	}
	return s.Concurrency
}

func (s *SourceDb2Enterprise) GetCursor() UpdateMethod {
	if s == nil {
		return UpdateMethod{}
	}
	return s.Cursor
}

func (s *SourceDb2Enterprise) GetDatabase() string {
	if s == nil {
		return ""
	}
	return s.Database
}

func (s *SourceDb2Enterprise) GetEncryption() SourceDb2EnterpriseEncryption {
	if s == nil {
		return SourceDb2EnterpriseEncryption{}
	}
	return s.Encryption
}

func (s *SourceDb2Enterprise) GetHost() string {
	if s == nil {
		return ""
	}
	return s.Host
}

func (s *SourceDb2Enterprise) GetJdbcURLParams() *string {
	if s == nil {
		return nil
	}
	return s.JdbcURLParams
}

func (s *SourceDb2Enterprise) GetPassword() *string {
	if s == nil {
		return nil
	}
	return s.Password
}

func (s *SourceDb2Enterprise) GetPort() *int64 {
	if s == nil {
		return nil
	}
	return s.Port
}

func (s *SourceDb2Enterprise) GetSchemas() []string {
	if s == nil {
		return []string{}
	}
	return s.Schemas
}

func (s *SourceDb2Enterprise) GetTunnelMethod() SourceDb2EnterpriseSSHTunnelMethod {
	if s == nil {
		return SourceDb2EnterpriseSSHTunnelMethod{}
	}
	return s.TunnelMethod
}

func (s *SourceDb2Enterprise) GetUsername() string {
	if s == nil {
		return ""
	}
	return s.Username
}

func (s *SourceDb2Enterprise) GetSourceType() *SourceDb2EnterpriseSourceType {
	return SourceDb2EnterpriseSourceTypeDb2Enterprise.ToPointer()
}

func (s *SourceDb2Enterprise) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}
