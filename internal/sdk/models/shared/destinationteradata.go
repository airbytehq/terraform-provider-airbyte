// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

type Teradata string

const (
	TeradataTeradata Teradata = "teradata"
)

func (e Teradata) ToPointer() *Teradata {
	return &e
}
func (e *Teradata) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "teradata":
		*e = Teradata(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Teradata: %v", v)
	}
}

type DestinationTeradataSchemasSSLModeSSLModes6Mode string

const (
	DestinationTeradataSchemasSSLModeSSLModes6ModeVerifyFull DestinationTeradataSchemasSSLModeSSLModes6Mode = "verify-full"
)

func (e DestinationTeradataSchemasSSLModeSSLModes6Mode) ToPointer() *DestinationTeradataSchemasSSLModeSSLModes6Mode {
	return &e
}
func (e *DestinationTeradataSchemasSSLModeSSLModes6Mode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "verify-full":
		*e = DestinationTeradataSchemasSSLModeSSLModes6Mode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationTeradataSchemasSSLModeSSLModes6Mode: %v", v)
	}
}

// DestinationTeradataVerifyFull - Verify-full SSL mode.
type DestinationTeradataVerifyFull struct {
	mode *DestinationTeradataSchemasSSLModeSSLModes6Mode `const:"verify-full" json:"mode"`
	// Specifies the file name of a PEM file that contains Certificate Authority (CA) certificates for use with SSLMODE=verify-full.
	//  See more information - <a href="https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/jdbcug_chapter_2.html#URL_SSLCA"> in the docs</a>.
	SslCaCertificate string `json:"ssl_ca_certificate"`
}

func (d DestinationTeradataVerifyFull) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationTeradataVerifyFull) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationTeradataVerifyFull) GetMode() *DestinationTeradataSchemasSSLModeSSLModes6Mode {
	return DestinationTeradataSchemasSSLModeSSLModes6ModeVerifyFull.ToPointer()
}

func (o *DestinationTeradataVerifyFull) GetSslCaCertificate() string {
	if o == nil {
		return ""
	}
	return o.SslCaCertificate
}

type DestinationTeradataSchemasSSLModeSSLModes5Mode string

const (
	DestinationTeradataSchemasSSLModeSSLModes5ModeVerifyCa DestinationTeradataSchemasSSLModeSSLModes5Mode = "verify-ca"
)

func (e DestinationTeradataSchemasSSLModeSSLModes5Mode) ToPointer() *DestinationTeradataSchemasSSLModeSSLModes5Mode {
	return &e
}
func (e *DestinationTeradataSchemasSSLModeSSLModes5Mode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "verify-ca":
		*e = DestinationTeradataSchemasSSLModeSSLModes5Mode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationTeradataSchemasSSLModeSSLModes5Mode: %v", v)
	}
}

// DestinationTeradataVerifyCa - Verify-ca SSL mode.
type DestinationTeradataVerifyCa struct {
	mode *DestinationTeradataSchemasSSLModeSSLModes5Mode `const:"verify-ca" json:"mode"`
	// Specifies the file name of a PEM file that contains Certificate Authority (CA) certificates for use with SSLMODE=verify-ca.
	//  See more information - <a href="https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/jdbcug_chapter_2.html#URL_SSLCA"> in the docs</a>.
	SslCaCertificate string `json:"ssl_ca_certificate"`
}

func (d DestinationTeradataVerifyCa) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationTeradataVerifyCa) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationTeradataVerifyCa) GetMode() *DestinationTeradataSchemasSSLModeSSLModes5Mode {
	return DestinationTeradataSchemasSSLModeSSLModes5ModeVerifyCa.ToPointer()
}

func (o *DestinationTeradataVerifyCa) GetSslCaCertificate() string {
	if o == nil {
		return ""
	}
	return o.SslCaCertificate
}

type DestinationTeradataSchemasSSLModeSSLModesMode string

const (
	DestinationTeradataSchemasSSLModeSSLModesModeRequire DestinationTeradataSchemasSSLModeSSLModesMode = "require"
)

func (e DestinationTeradataSchemasSSLModeSSLModesMode) ToPointer() *DestinationTeradataSchemasSSLModeSSLModesMode {
	return &e
}
func (e *DestinationTeradataSchemasSSLModeSSLModesMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "require":
		*e = DestinationTeradataSchemasSSLModeSSLModesMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationTeradataSchemasSSLModeSSLModesMode: %v", v)
	}
}

// DestinationTeradataRequire - Require SSL mode.
type DestinationTeradataRequire struct {
	mode *DestinationTeradataSchemasSSLModeSSLModesMode `const:"require" json:"mode"`
}

func (d DestinationTeradataRequire) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationTeradataRequire) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationTeradataRequire) GetMode() *DestinationTeradataSchemasSSLModeSSLModesMode {
	return DestinationTeradataSchemasSSLModeSSLModesModeRequire.ToPointer()
}

type DestinationTeradataSchemasSslModeMode string

const (
	DestinationTeradataSchemasSslModeModePrefer DestinationTeradataSchemasSslModeMode = "prefer"
)

func (e DestinationTeradataSchemasSslModeMode) ToPointer() *DestinationTeradataSchemasSslModeMode {
	return &e
}
func (e *DestinationTeradataSchemasSslModeMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "prefer":
		*e = DestinationTeradataSchemasSslModeMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationTeradataSchemasSslModeMode: %v", v)
	}
}

// DestinationTeradataPrefer - Prefer SSL mode.
type DestinationTeradataPrefer struct {
	mode *DestinationTeradataSchemasSslModeMode `const:"prefer" json:"mode"`
}

func (d DestinationTeradataPrefer) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationTeradataPrefer) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationTeradataPrefer) GetMode() *DestinationTeradataSchemasSslModeMode {
	return DestinationTeradataSchemasSslModeModePrefer.ToPointer()
}

type DestinationTeradataSchemasMode string

const (
	DestinationTeradataSchemasModeAllow DestinationTeradataSchemasMode = "allow"
)

func (e DestinationTeradataSchemasMode) ToPointer() *DestinationTeradataSchemasMode {
	return &e
}
func (e *DestinationTeradataSchemasMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "allow":
		*e = DestinationTeradataSchemasMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationTeradataSchemasMode: %v", v)
	}
}

// DestinationTeradataAllow - Allow SSL mode.
type DestinationTeradataAllow struct {
	mode *DestinationTeradataSchemasMode `const:"allow" json:"mode"`
}

func (d DestinationTeradataAllow) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationTeradataAllow) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationTeradataAllow) GetMode() *DestinationTeradataSchemasMode {
	return DestinationTeradataSchemasModeAllow.ToPointer()
}

type DestinationTeradataMode string

const (
	DestinationTeradataModeDisable DestinationTeradataMode = "disable"
)

func (e DestinationTeradataMode) ToPointer() *DestinationTeradataMode {
	return &e
}
func (e *DestinationTeradataMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "disable":
		*e = DestinationTeradataMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationTeradataMode: %v", v)
	}
}

// DestinationTeradataDisable - Disable SSL.
type DestinationTeradataDisable struct {
	mode *DestinationTeradataMode `const:"disable" json:"mode"`
}

func (d DestinationTeradataDisable) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationTeradataDisable) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationTeradataDisable) GetMode() *DestinationTeradataMode {
	return DestinationTeradataModeDisable.ToPointer()
}

type DestinationTeradataSSLModesType string

const (
	DestinationTeradataSSLModesTypeDestinationTeradataDisable    DestinationTeradataSSLModesType = "destination-teradata_disable"
	DestinationTeradataSSLModesTypeDestinationTeradataAllow      DestinationTeradataSSLModesType = "destination-teradata_allow"
	DestinationTeradataSSLModesTypeDestinationTeradataPrefer     DestinationTeradataSSLModesType = "destination-teradata_prefer"
	DestinationTeradataSSLModesTypeDestinationTeradataRequire    DestinationTeradataSSLModesType = "destination-teradata_require"
	DestinationTeradataSSLModesTypeDestinationTeradataVerifyCa   DestinationTeradataSSLModesType = "destination-teradata_verify-ca"
	DestinationTeradataSSLModesTypeDestinationTeradataVerifyFull DestinationTeradataSSLModesType = "destination-teradata_verify-full"
)

// DestinationTeradataSSLModes - SSL connection modes.
//
//	<b>disable</b> - Chose this mode to disable encryption of communication between Airbyte and destination database
//	<b>allow</b> - Chose this mode to enable encryption only when required by the destination database
//	<b>prefer</b> - Chose this mode to allow unencrypted connection only if the destination database does not support encryption
//	<b>require</b> - Chose this mode to always require encryption. If the destination database server does not support encryption, connection will fail
//	 <b>verify-ca</b> - Chose this mode to always require encryption and to verify that the destination database server has a valid SSL certificate
//	 <b>verify-full</b> - This is the most secure mode. Chose this mode to always require encryption and to verify the identity of the destination database server
//	See more information - <a href="https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/jdbcug_chapter_2.html#URL_SSLMODE"> in the docs</a>.
type DestinationTeradataSSLModes struct {
	DestinationTeradataDisable    *DestinationTeradataDisable
	DestinationTeradataAllow      *DestinationTeradataAllow
	DestinationTeradataPrefer     *DestinationTeradataPrefer
	DestinationTeradataRequire    *DestinationTeradataRequire
	DestinationTeradataVerifyCa   *DestinationTeradataVerifyCa
	DestinationTeradataVerifyFull *DestinationTeradataVerifyFull

	Type DestinationTeradataSSLModesType
}

func CreateDestinationTeradataSSLModesDestinationTeradataDisable(destinationTeradataDisable DestinationTeradataDisable) DestinationTeradataSSLModes {
	typ := DestinationTeradataSSLModesTypeDestinationTeradataDisable

	return DestinationTeradataSSLModes{
		DestinationTeradataDisable: &destinationTeradataDisable,
		Type:                       typ,
	}
}

func CreateDestinationTeradataSSLModesDestinationTeradataAllow(destinationTeradataAllow DestinationTeradataAllow) DestinationTeradataSSLModes {
	typ := DestinationTeradataSSLModesTypeDestinationTeradataAllow

	return DestinationTeradataSSLModes{
		DestinationTeradataAllow: &destinationTeradataAllow,
		Type:                     typ,
	}
}

func CreateDestinationTeradataSSLModesDestinationTeradataPrefer(destinationTeradataPrefer DestinationTeradataPrefer) DestinationTeradataSSLModes {
	typ := DestinationTeradataSSLModesTypeDestinationTeradataPrefer

	return DestinationTeradataSSLModes{
		DestinationTeradataPrefer: &destinationTeradataPrefer,
		Type:                      typ,
	}
}

func CreateDestinationTeradataSSLModesDestinationTeradataRequire(destinationTeradataRequire DestinationTeradataRequire) DestinationTeradataSSLModes {
	typ := DestinationTeradataSSLModesTypeDestinationTeradataRequire

	return DestinationTeradataSSLModes{
		DestinationTeradataRequire: &destinationTeradataRequire,
		Type:                       typ,
	}
}

func CreateDestinationTeradataSSLModesDestinationTeradataVerifyCa(destinationTeradataVerifyCa DestinationTeradataVerifyCa) DestinationTeradataSSLModes {
	typ := DestinationTeradataSSLModesTypeDestinationTeradataVerifyCa

	return DestinationTeradataSSLModes{
		DestinationTeradataVerifyCa: &destinationTeradataVerifyCa,
		Type:                        typ,
	}
}

func CreateDestinationTeradataSSLModesDestinationTeradataVerifyFull(destinationTeradataVerifyFull DestinationTeradataVerifyFull) DestinationTeradataSSLModes {
	typ := DestinationTeradataSSLModesTypeDestinationTeradataVerifyFull

	return DestinationTeradataSSLModes{
		DestinationTeradataVerifyFull: &destinationTeradataVerifyFull,
		Type:                          typ,
	}
}

func (u *DestinationTeradataSSLModes) UnmarshalJSON(data []byte) error {

	var destinationTeradataDisable DestinationTeradataDisable = DestinationTeradataDisable{}
	if err := utils.UnmarshalJSON(data, &destinationTeradataDisable, "", true, true); err == nil {
		u.DestinationTeradataDisable = &destinationTeradataDisable
		u.Type = DestinationTeradataSSLModesTypeDestinationTeradataDisable
		return nil
	}

	var destinationTeradataAllow DestinationTeradataAllow = DestinationTeradataAllow{}
	if err := utils.UnmarshalJSON(data, &destinationTeradataAllow, "", true, true); err == nil {
		u.DestinationTeradataAllow = &destinationTeradataAllow
		u.Type = DestinationTeradataSSLModesTypeDestinationTeradataAllow
		return nil
	}

	var destinationTeradataPrefer DestinationTeradataPrefer = DestinationTeradataPrefer{}
	if err := utils.UnmarshalJSON(data, &destinationTeradataPrefer, "", true, true); err == nil {
		u.DestinationTeradataPrefer = &destinationTeradataPrefer
		u.Type = DestinationTeradataSSLModesTypeDestinationTeradataPrefer
		return nil
	}

	var destinationTeradataRequire DestinationTeradataRequire = DestinationTeradataRequire{}
	if err := utils.UnmarshalJSON(data, &destinationTeradataRequire, "", true, true); err == nil {
		u.DestinationTeradataRequire = &destinationTeradataRequire
		u.Type = DestinationTeradataSSLModesTypeDestinationTeradataRequire
		return nil
	}

	var destinationTeradataVerifyCa DestinationTeradataVerifyCa = DestinationTeradataVerifyCa{}
	if err := utils.UnmarshalJSON(data, &destinationTeradataVerifyCa, "", true, true); err == nil {
		u.DestinationTeradataVerifyCa = &destinationTeradataVerifyCa
		u.Type = DestinationTeradataSSLModesTypeDestinationTeradataVerifyCa
		return nil
	}

	var destinationTeradataVerifyFull DestinationTeradataVerifyFull = DestinationTeradataVerifyFull{}
	if err := utils.UnmarshalJSON(data, &destinationTeradataVerifyFull, "", true, true); err == nil {
		u.DestinationTeradataVerifyFull = &destinationTeradataVerifyFull
		u.Type = DestinationTeradataSSLModesTypeDestinationTeradataVerifyFull
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationTeradataSSLModes", string(data))
}

func (u DestinationTeradataSSLModes) MarshalJSON() ([]byte, error) {
	if u.DestinationTeradataDisable != nil {
		return utils.MarshalJSON(u.DestinationTeradataDisable, "", true)
	}

	if u.DestinationTeradataAllow != nil {
		return utils.MarshalJSON(u.DestinationTeradataAllow, "", true)
	}

	if u.DestinationTeradataPrefer != nil {
		return utils.MarshalJSON(u.DestinationTeradataPrefer, "", true)
	}

	if u.DestinationTeradataRequire != nil {
		return utils.MarshalJSON(u.DestinationTeradataRequire, "", true)
	}

	if u.DestinationTeradataVerifyCa != nil {
		return utils.MarshalJSON(u.DestinationTeradataVerifyCa, "", true)
	}

	if u.DestinationTeradataVerifyFull != nil {
		return utils.MarshalJSON(u.DestinationTeradataVerifyFull, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationTeradataSSLModes: all fields are null")
}

type DestinationTeradata struct {
	destinationType Teradata `const:"teradata" json:"destinationType"`
	// Hostname of the database.
	Host string `json:"host"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// Password associated with the username.
	Password *string `json:"password,omitempty"`
	// The default schema tables are written to if the source does not specify a namespace. The usual value for this field is "public".
	Schema *string `default:"airbyte_td" json:"schema"`
	// Encrypt data using SSL. When activating SSL, please select one of the connection modes.
	Ssl *bool `default:"false" json:"ssl"`
	// SSL connection modes.
	//  <b>disable</b> - Chose this mode to disable encryption of communication between Airbyte and destination database
	//  <b>allow</b> - Chose this mode to enable encryption only when required by the destination database
	//  <b>prefer</b> - Chose this mode to allow unencrypted connection only if the destination database does not support encryption
	//  <b>require</b> - Chose this mode to always require encryption. If the destination database server does not support encryption, connection will fail
	//   <b>verify-ca</b> - Chose this mode to always require encryption and to verify that the destination database server has a valid SSL certificate
	//   <b>verify-full</b> - This is the most secure mode. Chose this mode to always require encryption and to verify the identity of the destination database server
	//  See more information - <a href="https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/jdbcug_chapter_2.html#URL_SSLMODE"> in the docs</a>.
	SslMode *DestinationTeradataSSLModes `json:"ssl_mode,omitempty"`
	// Username to use to access the database.
	Username string `json:"username"`
}

func (d DestinationTeradata) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationTeradata) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *DestinationTeradata) GetDestinationType() Teradata {
	return TeradataTeradata
}

func (o *DestinationTeradata) GetHost() string {
	if o == nil {
		return ""
	}
	return o.Host
}

func (o *DestinationTeradata) GetJdbcURLParams() *string {
	if o == nil {
		return nil
	}
	return o.JdbcURLParams
}

func (o *DestinationTeradata) GetPassword() *string {
	if o == nil {
		return nil
	}
	return o.Password
}

func (o *DestinationTeradata) GetSchema() *string {
	if o == nil {
		return nil
	}
	return o.Schema
}

func (o *DestinationTeradata) GetSsl() *bool {
	if o == nil {
		return nil
	}
	return o.Ssl
}

func (o *DestinationTeradata) GetSslMode() *DestinationTeradataSSLModes {
	if o == nil {
		return nil
	}
	return o.SslMode
}

func (o *DestinationTeradata) GetUsername() string {
	if o == nil {
		return ""
	}
	return o.Username
}
