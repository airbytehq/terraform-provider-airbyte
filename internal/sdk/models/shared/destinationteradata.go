// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

type DestinationTeradataSchemasAuthType string

const (
	DestinationTeradataSchemasAuthTypeLdap DestinationTeradataSchemasAuthType = "LDAP"
)

func (e DestinationTeradataSchemasAuthType) ToPointer() *DestinationTeradataSchemasAuthType {
	return &e
}
func (e *DestinationTeradataSchemasAuthType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "LDAP":
		*e = DestinationTeradataSchemasAuthType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationTeradataSchemasAuthType: %v", v)
	}
}

type Ldap struct {
	authType *DestinationTeradataSchemasAuthType `const:"LDAP" json:"auth_type"`
	// Enter the password associated with the username.
	Password string `json:"password"`
	// Username to use to access the database.
	Username string `json:"username"`
}

func (l Ldap) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *Ldap) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (l *Ldap) GetAuthType() *DestinationTeradataSchemasAuthType {
	return DestinationTeradataSchemasAuthTypeLdap.ToPointer()
}

func (l *Ldap) GetPassword() string {
	if l == nil {
		return ""
	}
	return l.Password
}

func (l *Ldap) GetUsername() string {
	if l == nil {
		return ""
	}
	return l.Username
}

type DestinationTeradataAuthType string

const (
	DestinationTeradataAuthTypeTd2 DestinationTeradataAuthType = "TD2"
)

func (e DestinationTeradataAuthType) ToPointer() *DestinationTeradataAuthType {
	return &e
}
func (e *DestinationTeradataAuthType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "TD2":
		*e = DestinationTeradataAuthType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationTeradataAuthType: %v", v)
	}
}

type Td2 struct {
	authType *DestinationTeradataAuthType `const:"TD2" json:"auth_type"`
	// Enter the password associated with the username.
	Password string `json:"password"`
	// Username to use to access the database.
	Username string `json:"username"`
}

func (t Td2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(t, "", false)
}

func (t *Td2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &t, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (t *Td2) GetAuthType() *DestinationTeradataAuthType {
	return DestinationTeradataAuthTypeTd2.ToPointer()
}

func (t *Td2) GetPassword() string {
	if t == nil {
		return ""
	}
	return t.Password
}

func (t *Td2) GetUsername() string {
	if t == nil {
		return ""
	}
	return t.Username
}

type AuthorizationMechanismType string

const (
	AuthorizationMechanismTypeTd2  AuthorizationMechanismType = "TD2"
	AuthorizationMechanismTypeLdap AuthorizationMechanismType = "LDAP"
)

type AuthorizationMechanism struct {
	Td2  *Td2  `queryParam:"inline" union:"member"`
	Ldap *Ldap `queryParam:"inline" union:"member"`

	Type AuthorizationMechanismType
}

func CreateAuthorizationMechanismTd2(td2 Td2) AuthorizationMechanism {
	typ := AuthorizationMechanismTypeTd2

	return AuthorizationMechanism{
		Td2:  &td2,
		Type: typ,
	}
}

func CreateAuthorizationMechanismLdap(ldap Ldap) AuthorizationMechanism {
	typ := AuthorizationMechanismTypeLdap

	return AuthorizationMechanism{
		Ldap: &ldap,
		Type: typ,
	}
}

func (u *AuthorizationMechanism) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var td2 Td2 = Td2{}
	if err := utils.UnmarshalJSON(data, &td2, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  AuthorizationMechanismTypeTd2,
			Value: &td2,
		})
	}

	var ldap Ldap = Ldap{}
	if err := utils.UnmarshalJSON(data, &ldap, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  AuthorizationMechanismTypeLdap,
			Value: &ldap,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for AuthorizationMechanism", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for AuthorizationMechanism", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(AuthorizationMechanismType)
	switch best.Type {
	case AuthorizationMechanismTypeTd2:
		u.Td2 = best.Value.(*Td2)
		return nil
	case AuthorizationMechanismTypeLdap:
		u.Ldap = best.Value.(*Ldap)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for AuthorizationMechanism", string(data))
}

func (u AuthorizationMechanism) MarshalJSON() ([]byte, error) {
	if u.Td2 != nil {
		return utils.MarshalJSON(u.Td2, "", true)
	}

	if u.Ldap != nil {
		return utils.MarshalJSON(u.Ldap, "", true)
	}

	return nil, errors.New("could not marshal union type AuthorizationMechanism: all fields are null")
}

type DestinationTeradataSchemasSSLModeSSLModes6Mode string

const (
	DestinationTeradataSchemasSSLModeSSLModes6ModeVerifyFull DestinationTeradataSchemasSSLModeSSLModes6Mode = "verify-full"
)

func (e DestinationTeradataSchemasSSLModeSSLModes6Mode) ToPointer() *DestinationTeradataSchemasSSLModeSSLModes6Mode {
	return &e
}
func (e *DestinationTeradataSchemasSSLModeSSLModes6Mode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "verify-full":
		*e = DestinationTeradataSchemasSSLModeSSLModes6Mode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationTeradataSchemasSSLModeSSLModes6Mode: %v", v)
	}
}

// DestinationTeradataVerifyFull - Verify-full SSL mode.
type DestinationTeradataVerifyFull struct {
	mode *DestinationTeradataSchemasSSLModeSSLModes6Mode `const:"verify-full" json:"mode"`
	// Specifies the file name of a PEM file that contains Certificate Authority (CA) certificates for use with SSLMODE=verify-full.
	//  See more information - <a href="https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/jdbcug_chapter_2.html#URL_SSLCA"> in the docs</a>.
	SslCaCertificate string `json:"ssl_ca_certificate"`
}

func (d DestinationTeradataVerifyFull) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationTeradataVerifyFull) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationTeradataVerifyFull) GetMode() *DestinationTeradataSchemasSSLModeSSLModes6Mode {
	return DestinationTeradataSchemasSSLModeSSLModes6ModeVerifyFull.ToPointer()
}

func (d *DestinationTeradataVerifyFull) GetSslCaCertificate() string {
	if d == nil {
		return ""
	}
	return d.SslCaCertificate
}

type DestinationTeradataSchemasSSLModeSSLModes5Mode string

const (
	DestinationTeradataSchemasSSLModeSSLModes5ModeVerifyCa DestinationTeradataSchemasSSLModeSSLModes5Mode = "verify-ca"
)

func (e DestinationTeradataSchemasSSLModeSSLModes5Mode) ToPointer() *DestinationTeradataSchemasSSLModeSSLModes5Mode {
	return &e
}
func (e *DestinationTeradataSchemasSSLModeSSLModes5Mode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "verify-ca":
		*e = DestinationTeradataSchemasSSLModeSSLModes5Mode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationTeradataSchemasSSLModeSSLModes5Mode: %v", v)
	}
}

// DestinationTeradataVerifyCa - Verify-ca SSL mode.
type DestinationTeradataVerifyCa struct {
	mode *DestinationTeradataSchemasSSLModeSSLModes5Mode `const:"verify-ca" json:"mode"`
	// Specifies the file name of a PEM file that contains Certificate Authority (CA) certificates for use with SSLMODE=verify-ca.
	//  See more information - <a href="https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/jdbcug_chapter_2.html#URL_SSLCA"> in the docs</a>.
	SslCaCertificate string `json:"ssl_ca_certificate"`
}

func (d DestinationTeradataVerifyCa) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationTeradataVerifyCa) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationTeradataVerifyCa) GetMode() *DestinationTeradataSchemasSSLModeSSLModes5Mode {
	return DestinationTeradataSchemasSSLModeSSLModes5ModeVerifyCa.ToPointer()
}

func (d *DestinationTeradataVerifyCa) GetSslCaCertificate() string {
	if d == nil {
		return ""
	}
	return d.SslCaCertificate
}

type DestinationTeradataSchemasSSLModeSSLModesMode string

const (
	DestinationTeradataSchemasSSLModeSSLModesModeRequire DestinationTeradataSchemasSSLModeSSLModesMode = "require"
)

func (e DestinationTeradataSchemasSSLModeSSLModesMode) ToPointer() *DestinationTeradataSchemasSSLModeSSLModesMode {
	return &e
}
func (e *DestinationTeradataSchemasSSLModeSSLModesMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "require":
		*e = DestinationTeradataSchemasSSLModeSSLModesMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationTeradataSchemasSSLModeSSLModesMode: %v", v)
	}
}

// DestinationTeradataRequire - Require SSL mode.
type DestinationTeradataRequire struct {
	mode *DestinationTeradataSchemasSSLModeSSLModesMode `const:"require" json:"mode"`
}

func (d DestinationTeradataRequire) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationTeradataRequire) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationTeradataRequire) GetMode() *DestinationTeradataSchemasSSLModeSSLModesMode {
	return DestinationTeradataSchemasSSLModeSSLModesModeRequire.ToPointer()
}

type DestinationTeradataSchemasSslModeMode string

const (
	DestinationTeradataSchemasSslModeModePrefer DestinationTeradataSchemasSslModeMode = "prefer"
)

func (e DestinationTeradataSchemasSslModeMode) ToPointer() *DestinationTeradataSchemasSslModeMode {
	return &e
}
func (e *DestinationTeradataSchemasSslModeMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "prefer":
		*e = DestinationTeradataSchemasSslModeMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationTeradataSchemasSslModeMode: %v", v)
	}
}

// DestinationTeradataPrefer - Prefer SSL mode.
type DestinationTeradataPrefer struct {
	mode *DestinationTeradataSchemasSslModeMode `const:"prefer" json:"mode"`
}

func (d DestinationTeradataPrefer) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationTeradataPrefer) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationTeradataPrefer) GetMode() *DestinationTeradataSchemasSslModeMode {
	return DestinationTeradataSchemasSslModeModePrefer.ToPointer()
}

type DestinationTeradataSchemasMode string

const (
	DestinationTeradataSchemasModeAllow DestinationTeradataSchemasMode = "allow"
)

func (e DestinationTeradataSchemasMode) ToPointer() *DestinationTeradataSchemasMode {
	return &e
}
func (e *DestinationTeradataSchemasMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "allow":
		*e = DestinationTeradataSchemasMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationTeradataSchemasMode: %v", v)
	}
}

// DestinationTeradataAllow - Allow SSL mode.
type DestinationTeradataAllow struct {
	mode *DestinationTeradataSchemasMode `const:"allow" json:"mode"`
}

func (d DestinationTeradataAllow) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationTeradataAllow) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationTeradataAllow) GetMode() *DestinationTeradataSchemasMode {
	return DestinationTeradataSchemasModeAllow.ToPointer()
}

type DestinationTeradataMode string

const (
	DestinationTeradataModeDisable DestinationTeradataMode = "disable"
)

func (e DestinationTeradataMode) ToPointer() *DestinationTeradataMode {
	return &e
}
func (e *DestinationTeradataMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "disable":
		*e = DestinationTeradataMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationTeradataMode: %v", v)
	}
}

// DestinationTeradataDisable - Disable SSL.
type DestinationTeradataDisable struct {
	mode *DestinationTeradataMode `const:"disable" json:"mode"`
}

func (d DestinationTeradataDisable) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationTeradataDisable) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationTeradataDisable) GetMode() *DestinationTeradataMode {
	return DestinationTeradataModeDisable.ToPointer()
}

type DestinationTeradataSSLModesType string

const (
	DestinationTeradataSSLModesTypeDestinationTeradataDisable    DestinationTeradataSSLModesType = "destination-teradata_disable"
	DestinationTeradataSSLModesTypeDestinationTeradataAllow      DestinationTeradataSSLModesType = "destination-teradata_allow"
	DestinationTeradataSSLModesTypeDestinationTeradataPrefer     DestinationTeradataSSLModesType = "destination-teradata_prefer"
	DestinationTeradataSSLModesTypeDestinationTeradataRequire    DestinationTeradataSSLModesType = "destination-teradata_require"
	DestinationTeradataSSLModesTypeDestinationTeradataVerifyCa   DestinationTeradataSSLModesType = "destination-teradata_verify-ca"
	DestinationTeradataSSLModesTypeDestinationTeradataVerifyFull DestinationTeradataSSLModesType = "destination-teradata_verify-full"
)

// DestinationTeradataSSLModes - SSL connection modes.
//
//	<b>disable</b> - Chose this mode to disable encryption of communication between Airbyte and destination database
//	<b>allow</b> - Chose this mode to enable encryption only when required by the destination database
//	<b>prefer</b> - Chose this mode to allow unencrypted connection only if the destination database does not support encryption
//	<b>require</b> - Chose this mode to always require encryption. If the destination database server does not support encryption, connection will fail
//	 <b>verify-ca</b> - Chose this mode to always require encryption and to verify that the destination database server has a valid SSL certificate
//	 <b>verify-full</b> - This is the most secure mode. Chose this mode to always require encryption and to verify the identity of the destination database server
//	See more information - <a href="https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/jdbcug_chapter_2.html#URL_SSLMODE"> in the docs</a>.
type DestinationTeradataSSLModes struct {
	DestinationTeradataDisable    *DestinationTeradataDisable    `queryParam:"inline" union:"member"`
	DestinationTeradataAllow      *DestinationTeradataAllow      `queryParam:"inline" union:"member"`
	DestinationTeradataPrefer     *DestinationTeradataPrefer     `queryParam:"inline" union:"member"`
	DestinationTeradataRequire    *DestinationTeradataRequire    `queryParam:"inline" union:"member"`
	DestinationTeradataVerifyCa   *DestinationTeradataVerifyCa   `queryParam:"inline" union:"member"`
	DestinationTeradataVerifyFull *DestinationTeradataVerifyFull `queryParam:"inline" union:"member"`

	Type DestinationTeradataSSLModesType
}

func CreateDestinationTeradataSSLModesDestinationTeradataDisable(destinationTeradataDisable DestinationTeradataDisable) DestinationTeradataSSLModes {
	typ := DestinationTeradataSSLModesTypeDestinationTeradataDisable

	return DestinationTeradataSSLModes{
		DestinationTeradataDisable: &destinationTeradataDisable,
		Type:                       typ,
	}
}

func CreateDestinationTeradataSSLModesDestinationTeradataAllow(destinationTeradataAllow DestinationTeradataAllow) DestinationTeradataSSLModes {
	typ := DestinationTeradataSSLModesTypeDestinationTeradataAllow

	return DestinationTeradataSSLModes{
		DestinationTeradataAllow: &destinationTeradataAllow,
		Type:                     typ,
	}
}

func CreateDestinationTeradataSSLModesDestinationTeradataPrefer(destinationTeradataPrefer DestinationTeradataPrefer) DestinationTeradataSSLModes {
	typ := DestinationTeradataSSLModesTypeDestinationTeradataPrefer

	return DestinationTeradataSSLModes{
		DestinationTeradataPrefer: &destinationTeradataPrefer,
		Type:                      typ,
	}
}

func CreateDestinationTeradataSSLModesDestinationTeradataRequire(destinationTeradataRequire DestinationTeradataRequire) DestinationTeradataSSLModes {
	typ := DestinationTeradataSSLModesTypeDestinationTeradataRequire

	return DestinationTeradataSSLModes{
		DestinationTeradataRequire: &destinationTeradataRequire,
		Type:                       typ,
	}
}

func CreateDestinationTeradataSSLModesDestinationTeradataVerifyCa(destinationTeradataVerifyCa DestinationTeradataVerifyCa) DestinationTeradataSSLModes {
	typ := DestinationTeradataSSLModesTypeDestinationTeradataVerifyCa

	return DestinationTeradataSSLModes{
		DestinationTeradataVerifyCa: &destinationTeradataVerifyCa,
		Type:                        typ,
	}
}

func CreateDestinationTeradataSSLModesDestinationTeradataVerifyFull(destinationTeradataVerifyFull DestinationTeradataVerifyFull) DestinationTeradataSSLModes {
	typ := DestinationTeradataSSLModesTypeDestinationTeradataVerifyFull

	return DestinationTeradataSSLModes{
		DestinationTeradataVerifyFull: &destinationTeradataVerifyFull,
		Type:                          typ,
	}
}

func (u *DestinationTeradataSSLModes) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var destinationTeradataDisable DestinationTeradataDisable = DestinationTeradataDisable{}
	if err := utils.UnmarshalJSON(data, &destinationTeradataDisable, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationTeradataSSLModesTypeDestinationTeradataDisable,
			Value: &destinationTeradataDisable,
		})
	}

	var destinationTeradataAllow DestinationTeradataAllow = DestinationTeradataAllow{}
	if err := utils.UnmarshalJSON(data, &destinationTeradataAllow, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationTeradataSSLModesTypeDestinationTeradataAllow,
			Value: &destinationTeradataAllow,
		})
	}

	var destinationTeradataPrefer DestinationTeradataPrefer = DestinationTeradataPrefer{}
	if err := utils.UnmarshalJSON(data, &destinationTeradataPrefer, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationTeradataSSLModesTypeDestinationTeradataPrefer,
			Value: &destinationTeradataPrefer,
		})
	}

	var destinationTeradataRequire DestinationTeradataRequire = DestinationTeradataRequire{}
	if err := utils.UnmarshalJSON(data, &destinationTeradataRequire, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationTeradataSSLModesTypeDestinationTeradataRequire,
			Value: &destinationTeradataRequire,
		})
	}

	var destinationTeradataVerifyCa DestinationTeradataVerifyCa = DestinationTeradataVerifyCa{}
	if err := utils.UnmarshalJSON(data, &destinationTeradataVerifyCa, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationTeradataSSLModesTypeDestinationTeradataVerifyCa,
			Value: &destinationTeradataVerifyCa,
		})
	}

	var destinationTeradataVerifyFull DestinationTeradataVerifyFull = DestinationTeradataVerifyFull{}
	if err := utils.UnmarshalJSON(data, &destinationTeradataVerifyFull, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationTeradataSSLModesTypeDestinationTeradataVerifyFull,
			Value: &destinationTeradataVerifyFull,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationTeradataSSLModes", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationTeradataSSLModes", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(DestinationTeradataSSLModesType)
	switch best.Type {
	case DestinationTeradataSSLModesTypeDestinationTeradataDisable:
		u.DestinationTeradataDisable = best.Value.(*DestinationTeradataDisable)
		return nil
	case DestinationTeradataSSLModesTypeDestinationTeradataAllow:
		u.DestinationTeradataAllow = best.Value.(*DestinationTeradataAllow)
		return nil
	case DestinationTeradataSSLModesTypeDestinationTeradataPrefer:
		u.DestinationTeradataPrefer = best.Value.(*DestinationTeradataPrefer)
		return nil
	case DestinationTeradataSSLModesTypeDestinationTeradataRequire:
		u.DestinationTeradataRequire = best.Value.(*DestinationTeradataRequire)
		return nil
	case DestinationTeradataSSLModesTypeDestinationTeradataVerifyCa:
		u.DestinationTeradataVerifyCa = best.Value.(*DestinationTeradataVerifyCa)
		return nil
	case DestinationTeradataSSLModesTypeDestinationTeradataVerifyFull:
		u.DestinationTeradataVerifyFull = best.Value.(*DestinationTeradataVerifyFull)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationTeradataSSLModes", string(data))
}

func (u DestinationTeradataSSLModes) MarshalJSON() ([]byte, error) {
	if u.DestinationTeradataDisable != nil {
		return utils.MarshalJSON(u.DestinationTeradataDisable, "", true)
	}

	if u.DestinationTeradataAllow != nil {
		return utils.MarshalJSON(u.DestinationTeradataAllow, "", true)
	}

	if u.DestinationTeradataPrefer != nil {
		return utils.MarshalJSON(u.DestinationTeradataPrefer, "", true)
	}

	if u.DestinationTeradataRequire != nil {
		return utils.MarshalJSON(u.DestinationTeradataRequire, "", true)
	}

	if u.DestinationTeradataVerifyCa != nil {
		return utils.MarshalJSON(u.DestinationTeradataVerifyCa, "", true)
	}

	if u.DestinationTeradataVerifyFull != nil {
		return utils.MarshalJSON(u.DestinationTeradataVerifyFull, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationTeradataSSLModes: all fields are null")
}

type DestinationTeradataDestinationType string

const (
	DestinationTeradataDestinationTypeTeradata DestinationTeradataDestinationType = "teradata"
)

func (e DestinationTeradataDestinationType) ToPointer() *DestinationTeradataDestinationType {
	return &e
}
func (e *DestinationTeradataDestinationType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "teradata":
		*e = DestinationTeradataDestinationType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationTeradataDestinationType: %v", v)
	}
}

type DestinationTeradata struct {
	// Disable Writing Final Tables. WARNING! The data format in _airbyte_data is likely stable but there are no guarantees that other metadata columns will remain the same in future versions
	DisableTypeDedupe *bool `default:"false" json:"disable_type_dedupe"`
	// Drop tables with CASCADE. WARNING! This will delete all data in all dependent objects (views, etc.). Use with caution. This option is intended for usecases which can easily rebuild the dependent objects.
	DropCascade *bool `default:"false" json:"drop_cascade"`
	// Hostname of the database.
	Host string `json:"host"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
	JdbcURLParams *string                 `json:"jdbc_url_params,omitempty"`
	Logmech       *AuthorizationMechanism `json:"logmech,omitempty"`
	// Defines the custom session query band using name-value pairs. For example, 'org=Finance;report=Fin123;'
	QueryBand *string `json:"query_band,omitempty"`
	// The database to write raw tables into
	RawDataSchema *string `json:"raw_data_schema,omitempty"`
	// The default schema tables are written to if the source does not specify a namespace. The usual value for this field is "public".
	Schema *string `default:"airbyte_td" json:"schema"`
	// Encrypt data using SSL. When activating SSL, please select one of the SSL modes.
	Ssl *bool `default:"false" json:"ssl"`
	// SSL connection modes.
	//  <b>disable</b> - Chose this mode to disable encryption of communication between Airbyte and destination database
	//  <b>allow</b> - Chose this mode to enable encryption only when required by the destination database
	//  <b>prefer</b> - Chose this mode to allow unencrypted connection only if the destination database does not support encryption
	//  <b>require</b> - Chose this mode to always require encryption. If the destination database server does not support encryption, connection will fail
	//   <b>verify-ca</b> - Chose this mode to always require encryption and to verify that the destination database server has a valid SSL certificate
	//   <b>verify-full</b> - This is the most secure mode. Chose this mode to always require encryption and to verify the identity of the destination database server
	//  See more information - <a href="https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/jdbcug_chapter_2.html#URL_SSLMODE"> in the docs</a>.
	SslMode              *DestinationTeradataSSLModes        `json:"ssl_mode,omitempty"`
	destinationType      *DestinationTeradataDestinationType `const:"teradata" json:"destinationType"`
	AdditionalProperties any                                 `additionalProperties:"true" json:"-"`
}

func (d DestinationTeradata) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationTeradata) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationTeradata) GetDisableTypeDedupe() *bool {
	if d == nil {
		return nil
	}
	return d.DisableTypeDedupe
}

func (d *DestinationTeradata) GetDropCascade() *bool {
	if d == nil {
		return nil
	}
	return d.DropCascade
}

func (d *DestinationTeradata) GetHost() string {
	if d == nil {
		return ""
	}
	return d.Host
}

func (d *DestinationTeradata) GetJdbcURLParams() *string {
	if d == nil {
		return nil
	}
	return d.JdbcURLParams
}

func (d *DestinationTeradata) GetLogmech() *AuthorizationMechanism {
	if d == nil {
		return nil
	}
	return d.Logmech
}

func (d *DestinationTeradata) GetQueryBand() *string {
	if d == nil {
		return nil
	}
	return d.QueryBand
}

func (d *DestinationTeradata) GetRawDataSchema() *string {
	if d == nil {
		return nil
	}
	return d.RawDataSchema
}

func (d *DestinationTeradata) GetSchema() *string {
	if d == nil {
		return nil
	}
	return d.Schema
}

func (d *DestinationTeradata) GetSsl() *bool {
	if d == nil {
		return nil
	}
	return d.Ssl
}

func (d *DestinationTeradata) GetSslMode() *DestinationTeradataSSLModes {
	if d == nil {
		return nil
	}
	return d.SslMode
}

func (d *DestinationTeradata) GetDestinationType() *DestinationTeradataDestinationType {
	return DestinationTeradataDestinationTypeTeradata.ToPointer()
}

func (d *DestinationTeradata) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}
