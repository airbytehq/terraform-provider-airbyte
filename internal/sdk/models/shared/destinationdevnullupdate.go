// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

type DestinationDevNullUpdateSchemasTestDestinationTestDestinationTestDestinationType string

const (
	DestinationDevNullUpdateSchemasTestDestinationTestDestinationTestDestinationTypeFailing DestinationDevNullUpdateSchemasTestDestinationTestDestinationTestDestinationType = "FAILING"
)

func (e DestinationDevNullUpdateSchemasTestDestinationTestDestinationTestDestinationType) ToPointer() *DestinationDevNullUpdateSchemasTestDestinationTestDestinationTestDestinationType {
	return &e
}
func (e *DestinationDevNullUpdateSchemasTestDestinationTestDestinationTestDestinationType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "FAILING":
		*e = DestinationDevNullUpdateSchemasTestDestinationTestDestinationTestDestinationType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationDevNullUpdateSchemasTestDestinationTestDestinationTestDestinationType: %v", v)
	}
}

type DestinationDevNullUpdateFailing struct {
	TestDestinationType *DestinationDevNullUpdateSchemasTestDestinationTestDestinationTestDestinationType `default:"FAILING" json:"test_destination_type"`
	// Number of messages after which to fail.
	NumMessages          int64 `json:"num_messages"`
	AdditionalProperties any   `additionalProperties:"true" json:"-"`
}

func (d DestinationDevNullUpdateFailing) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationDevNullUpdateFailing) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationDevNullUpdateFailing) GetTestDestinationType() *DestinationDevNullUpdateSchemasTestDestinationTestDestinationTestDestinationType {
	if o == nil {
		return nil
	}
	return o.TestDestinationType
}

func (o *DestinationDevNullUpdateFailing) GetNumMessages() int64 {
	if o == nil {
		return 0
	}
	return o.NumMessages
}

func (o *DestinationDevNullUpdateFailing) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

type DestinationDevNullUpdateSchemasTestDestinationTestDestinationType string

const (
	DestinationDevNullUpdateSchemasTestDestinationTestDestinationTypeThrottled DestinationDevNullUpdateSchemasTestDestinationTestDestinationType = "THROTTLED"
)

func (e DestinationDevNullUpdateSchemasTestDestinationTestDestinationType) ToPointer() *DestinationDevNullUpdateSchemasTestDestinationTestDestinationType {
	return &e
}
func (e *DestinationDevNullUpdateSchemasTestDestinationTestDestinationType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "THROTTLED":
		*e = DestinationDevNullUpdateSchemasTestDestinationTestDestinationType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationDevNullUpdateSchemasTestDestinationTestDestinationType: %v", v)
	}
}

type DestinationDevNullUpdateThrottled struct {
	TestDestinationType *DestinationDevNullUpdateSchemasTestDestinationTestDestinationType `default:"THROTTLED" json:"test_destination_type"`
	// The number of milliseconds to wait between each record.
	MillisPerRecord      int64 `json:"millis_per_record"`
	AdditionalProperties any   `additionalProperties:"true" json:"-"`
}

func (d DestinationDevNullUpdateThrottled) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationDevNullUpdateThrottled) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationDevNullUpdateThrottled) GetTestDestinationType() *DestinationDevNullUpdateSchemasTestDestinationTestDestinationType {
	if o == nil {
		return nil
	}
	return o.TestDestinationType
}

func (o *DestinationDevNullUpdateThrottled) GetMillisPerRecord() int64 {
	if o == nil {
		return 0
	}
	return o.MillisPerRecord
}

func (o *DestinationDevNullUpdateThrottled) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

type DestinationDevNullUpdateSchemasTestDestinationType string

const (
	DestinationDevNullUpdateSchemasTestDestinationTypeSilent DestinationDevNullUpdateSchemasTestDestinationType = "SILENT"
)

func (e DestinationDevNullUpdateSchemasTestDestinationType) ToPointer() *DestinationDevNullUpdateSchemasTestDestinationType {
	return &e
}
func (e *DestinationDevNullUpdateSchemasTestDestinationType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SILENT":
		*e = DestinationDevNullUpdateSchemasTestDestinationType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationDevNullUpdateSchemasTestDestinationType: %v", v)
	}
}

type DestinationDevNullUpdateSilent struct {
	TestDestinationType  *DestinationDevNullUpdateSchemasTestDestinationType `default:"SILENT" json:"test_destination_type"`
	AdditionalProperties any                                                 `additionalProperties:"true" json:"-"`
}

func (d DestinationDevNullUpdateSilent) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationDevNullUpdateSilent) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationDevNullUpdateSilent) GetTestDestinationType() *DestinationDevNullUpdateSchemasTestDestinationType {
	if o == nil {
		return nil
	}
	return o.TestDestinationType
}

func (o *DestinationDevNullUpdateSilent) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

type DestinationDevNullUpdateTestDestinationType string

const (
	DestinationDevNullUpdateTestDestinationTypeLogging DestinationDevNullUpdateTestDestinationType = "LOGGING"
)

func (e DestinationDevNullUpdateTestDestinationType) ToPointer() *DestinationDevNullUpdateTestDestinationType {
	return &e
}
func (e *DestinationDevNullUpdateTestDestinationType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "LOGGING":
		*e = DestinationDevNullUpdateTestDestinationType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationDevNullUpdateTestDestinationType: %v", v)
	}
}

type DestinationDevNullUpdateSchemasTestDestinationLoggingType string

const (
	DestinationDevNullUpdateSchemasTestDestinationLoggingTypeRandomSampling DestinationDevNullUpdateSchemasTestDestinationLoggingType = "RandomSampling"
)

func (e DestinationDevNullUpdateSchemasTestDestinationLoggingType) ToPointer() *DestinationDevNullUpdateSchemasTestDestinationLoggingType {
	return &e
}
func (e *DestinationDevNullUpdateSchemasTestDestinationLoggingType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "RandomSampling":
		*e = DestinationDevNullUpdateSchemasTestDestinationLoggingType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationDevNullUpdateSchemasTestDestinationLoggingType: %v", v)
	}
}

// DestinationDevNullUpdateRandomSampling - For each stream, randomly log a percentage of the entries with a maximum cap.
type DestinationDevNullUpdateRandomSampling struct {
	LoggingType *DestinationDevNullUpdateSchemasTestDestinationLoggingType `default:"RandomSampling" json:"logging_type"`
	// A positive floating number smaller than 1.
	SamplingRatio *float64 `default:"0.001" json:"sampling_ratio"`
	// When the seed is unspecified, the current time millis will be used as the seed.
	Seed *float64 `json:"seed,omitempty"`
	// Number of entries to log. This destination is for testing only. So it won't make sense to log infinitely. The maximum is 1,000 entries.
	MaxEntryCount        *float64 `default:"100" json:"max_entry_count"`
	AdditionalProperties any      `additionalProperties:"true" json:"-"`
}

func (d DestinationDevNullUpdateRandomSampling) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationDevNullUpdateRandomSampling) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationDevNullUpdateRandomSampling) GetLoggingType() *DestinationDevNullUpdateSchemasTestDestinationLoggingType {
	if o == nil {
		return nil
	}
	return o.LoggingType
}

func (o *DestinationDevNullUpdateRandomSampling) GetSamplingRatio() *float64 {
	if o == nil {
		return nil
	}
	return o.SamplingRatio
}

func (o *DestinationDevNullUpdateRandomSampling) GetSeed() *float64 {
	if o == nil {
		return nil
	}
	return o.Seed
}

func (o *DestinationDevNullUpdateRandomSampling) GetMaxEntryCount() *float64 {
	if o == nil {
		return nil
	}
	return o.MaxEntryCount
}

func (o *DestinationDevNullUpdateRandomSampling) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

type DestinationDevNullUpdateSchemasLoggingType string

const (
	DestinationDevNullUpdateSchemasLoggingTypeEveryNth DestinationDevNullUpdateSchemasLoggingType = "EveryNth"
)

func (e DestinationDevNullUpdateSchemasLoggingType) ToPointer() *DestinationDevNullUpdateSchemasLoggingType {
	return &e
}
func (e *DestinationDevNullUpdateSchemasLoggingType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "EveryNth":
		*e = DestinationDevNullUpdateSchemasLoggingType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationDevNullUpdateSchemasLoggingType: %v", v)
	}
}

// DestinationDevNullUpdateEveryNThEntry - For each stream, log every N-th entry with a maximum cap.
type DestinationDevNullUpdateEveryNThEntry struct {
	LoggingType *DestinationDevNullUpdateSchemasLoggingType `default:"EveryNth" json:"logging_type"`
	// The N-th entry to log for each stream. N starts from 1. For example, when N = 1, every entry is logged; when N = 2, every other entry is logged; when N = 3, one out of three entries is logged.
	NthEntryToLog int64 `json:"nth_entry_to_log"`
	// Number of entries to log. This destination is for testing only. So it won't make sense to log infinitely. The maximum is 1,000 entries.
	MaxEntryCount        *float64 `default:"100" json:"max_entry_count"`
	AdditionalProperties any      `additionalProperties:"true" json:"-"`
}

func (d DestinationDevNullUpdateEveryNThEntry) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationDevNullUpdateEveryNThEntry) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationDevNullUpdateEveryNThEntry) GetLoggingType() *DestinationDevNullUpdateSchemasLoggingType {
	if o == nil {
		return nil
	}
	return o.LoggingType
}

func (o *DestinationDevNullUpdateEveryNThEntry) GetNthEntryToLog() int64 {
	if o == nil {
		return 0
	}
	return o.NthEntryToLog
}

func (o *DestinationDevNullUpdateEveryNThEntry) GetMaxEntryCount() *float64 {
	if o == nil {
		return nil
	}
	return o.MaxEntryCount
}

func (o *DestinationDevNullUpdateEveryNThEntry) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

type DestinationDevNullUpdateLoggingType string

const (
	DestinationDevNullUpdateLoggingTypeFirstN DestinationDevNullUpdateLoggingType = "FirstN"
)

func (e DestinationDevNullUpdateLoggingType) ToPointer() *DestinationDevNullUpdateLoggingType {
	return &e
}
func (e *DestinationDevNullUpdateLoggingType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "FirstN":
		*e = DestinationDevNullUpdateLoggingType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationDevNullUpdateLoggingType: %v", v)
	}
}

// DestinationDevNullUpdateFirstNEntries - Log first N entries per stream.
type DestinationDevNullUpdateFirstNEntries struct {
	LoggingType *DestinationDevNullUpdateLoggingType `default:"FirstN" json:"logging_type"`
	// Number of entries to log. This destination is for testing only. So it won't make sense to log infinitely. The maximum is 1,000 entries.
	MaxEntryCount        *float64 `default:"100" json:"max_entry_count"`
	AdditionalProperties any      `additionalProperties:"true" json:"-"`
}

func (d DestinationDevNullUpdateFirstNEntries) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationDevNullUpdateFirstNEntries) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationDevNullUpdateFirstNEntries) GetLoggingType() *DestinationDevNullUpdateLoggingType {
	if o == nil {
		return nil
	}
	return o.LoggingType
}

func (o *DestinationDevNullUpdateFirstNEntries) GetMaxEntryCount() *float64 {
	if o == nil {
		return nil
	}
	return o.MaxEntryCount
}

func (o *DestinationDevNullUpdateFirstNEntries) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

type DestinationDevNullUpdateLoggingConfigurationType string

const (
	DestinationDevNullUpdateLoggingConfigurationTypeDestinationDevNullUpdateFirstNEntries  DestinationDevNullUpdateLoggingConfigurationType = "destination-dev-null-update_First N Entries"
	DestinationDevNullUpdateLoggingConfigurationTypeDestinationDevNullUpdateEveryNThEntry  DestinationDevNullUpdateLoggingConfigurationType = "destination-dev-null-update_Every N-th Entry"
	DestinationDevNullUpdateLoggingConfigurationTypeDestinationDevNullUpdateRandomSampling DestinationDevNullUpdateLoggingConfigurationType = "destination-dev-null-update_Random Sampling"
)

// DestinationDevNullUpdateLoggingConfiguration - Configurate how the messages are logged.
type DestinationDevNullUpdateLoggingConfiguration struct {
	DestinationDevNullUpdateFirstNEntries  *DestinationDevNullUpdateFirstNEntries  `queryParam:"inline"`
	DestinationDevNullUpdateEveryNThEntry  *DestinationDevNullUpdateEveryNThEntry  `queryParam:"inline"`
	DestinationDevNullUpdateRandomSampling *DestinationDevNullUpdateRandomSampling `queryParam:"inline"`

	Type DestinationDevNullUpdateLoggingConfigurationType
}

func CreateDestinationDevNullUpdateLoggingConfigurationDestinationDevNullUpdateFirstNEntries(destinationDevNullUpdateFirstNEntries DestinationDevNullUpdateFirstNEntries) DestinationDevNullUpdateLoggingConfiguration {
	typ := DestinationDevNullUpdateLoggingConfigurationTypeDestinationDevNullUpdateFirstNEntries

	return DestinationDevNullUpdateLoggingConfiguration{
		DestinationDevNullUpdateFirstNEntries: &destinationDevNullUpdateFirstNEntries,
		Type:                                  typ,
	}
}

func CreateDestinationDevNullUpdateLoggingConfigurationDestinationDevNullUpdateEveryNThEntry(destinationDevNullUpdateEveryNThEntry DestinationDevNullUpdateEveryNThEntry) DestinationDevNullUpdateLoggingConfiguration {
	typ := DestinationDevNullUpdateLoggingConfigurationTypeDestinationDevNullUpdateEveryNThEntry

	return DestinationDevNullUpdateLoggingConfiguration{
		DestinationDevNullUpdateEveryNThEntry: &destinationDevNullUpdateEveryNThEntry,
		Type:                                  typ,
	}
}

func CreateDestinationDevNullUpdateLoggingConfigurationDestinationDevNullUpdateRandomSampling(destinationDevNullUpdateRandomSampling DestinationDevNullUpdateRandomSampling) DestinationDevNullUpdateLoggingConfiguration {
	typ := DestinationDevNullUpdateLoggingConfigurationTypeDestinationDevNullUpdateRandomSampling

	return DestinationDevNullUpdateLoggingConfiguration{
		DestinationDevNullUpdateRandomSampling: &destinationDevNullUpdateRandomSampling,
		Type:                                   typ,
	}
}

func (u *DestinationDevNullUpdateLoggingConfiguration) UnmarshalJSON(data []byte) error {

	var destinationDevNullUpdateFirstNEntries DestinationDevNullUpdateFirstNEntries = DestinationDevNullUpdateFirstNEntries{}
	if err := utils.UnmarshalJSON(data, &destinationDevNullUpdateFirstNEntries, "", true, true); err == nil {
		u.DestinationDevNullUpdateFirstNEntries = &destinationDevNullUpdateFirstNEntries
		u.Type = DestinationDevNullUpdateLoggingConfigurationTypeDestinationDevNullUpdateFirstNEntries
		return nil
	}

	var destinationDevNullUpdateEveryNThEntry DestinationDevNullUpdateEveryNThEntry = DestinationDevNullUpdateEveryNThEntry{}
	if err := utils.UnmarshalJSON(data, &destinationDevNullUpdateEveryNThEntry, "", true, true); err == nil {
		u.DestinationDevNullUpdateEveryNThEntry = &destinationDevNullUpdateEveryNThEntry
		u.Type = DestinationDevNullUpdateLoggingConfigurationTypeDestinationDevNullUpdateEveryNThEntry
		return nil
	}

	var destinationDevNullUpdateRandomSampling DestinationDevNullUpdateRandomSampling = DestinationDevNullUpdateRandomSampling{}
	if err := utils.UnmarshalJSON(data, &destinationDevNullUpdateRandomSampling, "", true, true); err == nil {
		u.DestinationDevNullUpdateRandomSampling = &destinationDevNullUpdateRandomSampling
		u.Type = DestinationDevNullUpdateLoggingConfigurationTypeDestinationDevNullUpdateRandomSampling
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationDevNullUpdateLoggingConfiguration", string(data))
}

func (u DestinationDevNullUpdateLoggingConfiguration) MarshalJSON() ([]byte, error) {
	if u.DestinationDevNullUpdateFirstNEntries != nil {
		return utils.MarshalJSON(u.DestinationDevNullUpdateFirstNEntries, "", true)
	}

	if u.DestinationDevNullUpdateEveryNThEntry != nil {
		return utils.MarshalJSON(u.DestinationDevNullUpdateEveryNThEntry, "", true)
	}

	if u.DestinationDevNullUpdateRandomSampling != nil {
		return utils.MarshalJSON(u.DestinationDevNullUpdateRandomSampling, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationDevNullUpdateLoggingConfiguration: all fields are null")
}

type DestinationDevNullUpdateLogging struct {
	TestDestinationType *DestinationDevNullUpdateTestDestinationType `default:"LOGGING" json:"test_destination_type"`
	// Configurate how the messages are logged.
	LoggingConfig        DestinationDevNullUpdateLoggingConfiguration `json:"logging_config"`
	AdditionalProperties any                                          `additionalProperties:"true" json:"-"`
}

func (d DestinationDevNullUpdateLogging) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationDevNullUpdateLogging) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationDevNullUpdateLogging) GetTestDestinationType() *DestinationDevNullUpdateTestDestinationType {
	if o == nil {
		return nil
	}
	return o.TestDestinationType
}

func (o *DestinationDevNullUpdateLogging) GetLoggingConfig() DestinationDevNullUpdateLoggingConfiguration {
	if o == nil {
		return DestinationDevNullUpdateLoggingConfiguration{}
	}
	return o.LoggingConfig
}

func (o *DestinationDevNullUpdateLogging) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

type DestinationDevNullUpdateTestDestinationUnionType string

const (
	DestinationDevNullUpdateTestDestinationUnionTypeDestinationDevNullUpdateLogging   DestinationDevNullUpdateTestDestinationUnionType = "destination-dev-null-update_Logging"
	DestinationDevNullUpdateTestDestinationUnionTypeDestinationDevNullUpdateSilent    DestinationDevNullUpdateTestDestinationUnionType = "destination-dev-null-update_Silent"
	DestinationDevNullUpdateTestDestinationUnionTypeDestinationDevNullUpdateThrottled DestinationDevNullUpdateTestDestinationUnionType = "destination-dev-null-update_Throttled"
	DestinationDevNullUpdateTestDestinationUnionTypeDestinationDevNullUpdateFailing   DestinationDevNullUpdateTestDestinationUnionType = "destination-dev-null-update_Failing"
)

// DestinationDevNullUpdateTestDestination - The type of destination to be used
type DestinationDevNullUpdateTestDestination struct {
	DestinationDevNullUpdateLogging   *DestinationDevNullUpdateLogging   `queryParam:"inline"`
	DestinationDevNullUpdateSilent    *DestinationDevNullUpdateSilent    `queryParam:"inline"`
	DestinationDevNullUpdateThrottled *DestinationDevNullUpdateThrottled `queryParam:"inline"`
	DestinationDevNullUpdateFailing   *DestinationDevNullUpdateFailing   `queryParam:"inline"`

	Type DestinationDevNullUpdateTestDestinationUnionType
}

func CreateDestinationDevNullUpdateTestDestinationDestinationDevNullUpdateLogging(destinationDevNullUpdateLogging DestinationDevNullUpdateLogging) DestinationDevNullUpdateTestDestination {
	typ := DestinationDevNullUpdateTestDestinationUnionTypeDestinationDevNullUpdateLogging

	return DestinationDevNullUpdateTestDestination{
		DestinationDevNullUpdateLogging: &destinationDevNullUpdateLogging,
		Type:                            typ,
	}
}

func CreateDestinationDevNullUpdateTestDestinationDestinationDevNullUpdateSilent(destinationDevNullUpdateSilent DestinationDevNullUpdateSilent) DestinationDevNullUpdateTestDestination {
	typ := DestinationDevNullUpdateTestDestinationUnionTypeDestinationDevNullUpdateSilent

	return DestinationDevNullUpdateTestDestination{
		DestinationDevNullUpdateSilent: &destinationDevNullUpdateSilent,
		Type:                           typ,
	}
}

func CreateDestinationDevNullUpdateTestDestinationDestinationDevNullUpdateThrottled(destinationDevNullUpdateThrottled DestinationDevNullUpdateThrottled) DestinationDevNullUpdateTestDestination {
	typ := DestinationDevNullUpdateTestDestinationUnionTypeDestinationDevNullUpdateThrottled

	return DestinationDevNullUpdateTestDestination{
		DestinationDevNullUpdateThrottled: &destinationDevNullUpdateThrottled,
		Type:                              typ,
	}
}

func CreateDestinationDevNullUpdateTestDestinationDestinationDevNullUpdateFailing(destinationDevNullUpdateFailing DestinationDevNullUpdateFailing) DestinationDevNullUpdateTestDestination {
	typ := DestinationDevNullUpdateTestDestinationUnionTypeDestinationDevNullUpdateFailing

	return DestinationDevNullUpdateTestDestination{
		DestinationDevNullUpdateFailing: &destinationDevNullUpdateFailing,
		Type:                            typ,
	}
}

func (u *DestinationDevNullUpdateTestDestination) UnmarshalJSON(data []byte) error {

	var destinationDevNullUpdateSilent DestinationDevNullUpdateSilent = DestinationDevNullUpdateSilent{}
	if err := utils.UnmarshalJSON(data, &destinationDevNullUpdateSilent, "", true, true); err == nil {
		u.DestinationDevNullUpdateSilent = &destinationDevNullUpdateSilent
		u.Type = DestinationDevNullUpdateTestDestinationUnionTypeDestinationDevNullUpdateSilent
		return nil
	}

	var destinationDevNullUpdateLogging DestinationDevNullUpdateLogging = DestinationDevNullUpdateLogging{}
	if err := utils.UnmarshalJSON(data, &destinationDevNullUpdateLogging, "", true, true); err == nil {
		u.DestinationDevNullUpdateLogging = &destinationDevNullUpdateLogging
		u.Type = DestinationDevNullUpdateTestDestinationUnionTypeDestinationDevNullUpdateLogging
		return nil
	}

	var destinationDevNullUpdateThrottled DestinationDevNullUpdateThrottled = DestinationDevNullUpdateThrottled{}
	if err := utils.UnmarshalJSON(data, &destinationDevNullUpdateThrottled, "", true, true); err == nil {
		u.DestinationDevNullUpdateThrottled = &destinationDevNullUpdateThrottled
		u.Type = DestinationDevNullUpdateTestDestinationUnionTypeDestinationDevNullUpdateThrottled
		return nil
	}

	var destinationDevNullUpdateFailing DestinationDevNullUpdateFailing = DestinationDevNullUpdateFailing{}
	if err := utils.UnmarshalJSON(data, &destinationDevNullUpdateFailing, "", true, true); err == nil {
		u.DestinationDevNullUpdateFailing = &destinationDevNullUpdateFailing
		u.Type = DestinationDevNullUpdateTestDestinationUnionTypeDestinationDevNullUpdateFailing
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationDevNullUpdateTestDestination", string(data))
}

func (u DestinationDevNullUpdateTestDestination) MarshalJSON() ([]byte, error) {
	if u.DestinationDevNullUpdateLogging != nil {
		return utils.MarshalJSON(u.DestinationDevNullUpdateLogging, "", true)
	}

	if u.DestinationDevNullUpdateSilent != nil {
		return utils.MarshalJSON(u.DestinationDevNullUpdateSilent, "", true)
	}

	if u.DestinationDevNullUpdateThrottled != nil {
		return utils.MarshalJSON(u.DestinationDevNullUpdateThrottled, "", true)
	}

	if u.DestinationDevNullUpdateFailing != nil {
		return utils.MarshalJSON(u.DestinationDevNullUpdateFailing, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationDevNullUpdateTestDestination: all fields are null")
}

type DestinationDevNullUpdate struct {
	// The type of destination to be used
	TestDestination DestinationDevNullUpdateTestDestination `json:"test_destination"`
}

func (o *DestinationDevNullUpdate) GetTestDestination() DestinationDevNullUpdateTestDestination {
	if o == nil {
		return DestinationDevNullUpdateTestDestination{}
	}
	return o.TestDestination
}
