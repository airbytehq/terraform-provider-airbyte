// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/types"
)

type DestinationSalesforceUpdateSchemasCompressionType string

const (
	DestinationSalesforceUpdateSchemasCompressionTypeGzip DestinationSalesforceUpdateSchemasCompressionType = "GZIP"
)

func (e DestinationSalesforceUpdateSchemasCompressionType) ToPointer() *DestinationSalesforceUpdateSchemasCompressionType {
	return &e
}
func (e *DestinationSalesforceUpdateSchemasCompressionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "GZIP":
		*e = DestinationSalesforceUpdateSchemasCompressionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationSalesforceUpdateSchemasCompressionType: %v", v)
	}
}

type DestinationSalesforceUpdateGZIP struct {
	CompressionType      *DestinationSalesforceUpdateSchemasCompressionType `default:"GZIP" json:"compression_type"`
	AdditionalProperties any                                                `additionalProperties:"true" json:"-"`
}

func (d DestinationSalesforceUpdateGZIP) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationSalesforceUpdateGZIP) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationSalesforceUpdateGZIP) GetCompressionType() *DestinationSalesforceUpdateSchemasCompressionType {
	if d == nil {
		return nil
	}
	return d.CompressionType
}

func (d *DestinationSalesforceUpdateGZIP) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationSalesforceUpdateCompressionType string

const (
	DestinationSalesforceUpdateCompressionTypeNoCompression DestinationSalesforceUpdateCompressionType = "No Compression"
)

func (e DestinationSalesforceUpdateCompressionType) ToPointer() *DestinationSalesforceUpdateCompressionType {
	return &e
}
func (e *DestinationSalesforceUpdateCompressionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "No Compression":
		*e = DestinationSalesforceUpdateCompressionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationSalesforceUpdateCompressionType: %v", v)
	}
}

type DestinationSalesforceUpdateNoCompression struct {
	CompressionType      *DestinationSalesforceUpdateCompressionType `default:"No Compression" json:"compression_type"`
	AdditionalProperties any                                         `additionalProperties:"true" json:"-"`
}

func (d DestinationSalesforceUpdateNoCompression) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationSalesforceUpdateNoCompression) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationSalesforceUpdateNoCompression) GetCompressionType() *DestinationSalesforceUpdateCompressionType {
	if d == nil {
		return nil
	}
	return d.CompressionType
}

func (d *DestinationSalesforceUpdateNoCompression) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationSalesforceUpdateCompressionUnionType string

const (
	DestinationSalesforceUpdateCompressionUnionTypeDestinationSalesforceUpdateNoCompression DestinationSalesforceUpdateCompressionUnionType = "destination-salesforce-update_No Compression"
	DestinationSalesforceUpdateCompressionUnionTypeDestinationSalesforceUpdateGZIP          DestinationSalesforceUpdateCompressionUnionType = "destination-salesforce-update_GZIP"
)

// DestinationSalesforceUpdateCompression - Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").
type DestinationSalesforceUpdateCompression struct {
	DestinationSalesforceUpdateNoCompression *DestinationSalesforceUpdateNoCompression `queryParam:"inline" union:"member"`
	DestinationSalesforceUpdateGZIP          *DestinationSalesforceUpdateGZIP          `queryParam:"inline" union:"member"`

	Type DestinationSalesforceUpdateCompressionUnionType
}

func CreateDestinationSalesforceUpdateCompressionDestinationSalesforceUpdateNoCompression(destinationSalesforceUpdateNoCompression DestinationSalesforceUpdateNoCompression) DestinationSalesforceUpdateCompression {
	typ := DestinationSalesforceUpdateCompressionUnionTypeDestinationSalesforceUpdateNoCompression

	return DestinationSalesforceUpdateCompression{
		DestinationSalesforceUpdateNoCompression: &destinationSalesforceUpdateNoCompression,
		Type:                                     typ,
	}
}

func CreateDestinationSalesforceUpdateCompressionDestinationSalesforceUpdateGZIP(destinationSalesforceUpdateGZIP DestinationSalesforceUpdateGZIP) DestinationSalesforceUpdateCompression {
	typ := DestinationSalesforceUpdateCompressionUnionTypeDestinationSalesforceUpdateGZIP

	return DestinationSalesforceUpdateCompression{
		DestinationSalesforceUpdateGZIP: &destinationSalesforceUpdateGZIP,
		Type:                            typ,
	}
}

func (u *DestinationSalesforceUpdateCompression) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var destinationSalesforceUpdateNoCompression DestinationSalesforceUpdateNoCompression = DestinationSalesforceUpdateNoCompression{}
	if err := utils.UnmarshalJSON(data, &destinationSalesforceUpdateNoCompression, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationSalesforceUpdateCompressionUnionTypeDestinationSalesforceUpdateNoCompression,
			Value: &destinationSalesforceUpdateNoCompression,
		})
	}

	var destinationSalesforceUpdateGZIP DestinationSalesforceUpdateGZIP = DestinationSalesforceUpdateGZIP{}
	if err := utils.UnmarshalJSON(data, &destinationSalesforceUpdateGZIP, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationSalesforceUpdateCompressionUnionTypeDestinationSalesforceUpdateGZIP,
			Value: &destinationSalesforceUpdateGZIP,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationSalesforceUpdateCompression", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationSalesforceUpdateCompression", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(DestinationSalesforceUpdateCompressionUnionType)
	switch best.Type {
	case DestinationSalesforceUpdateCompressionUnionTypeDestinationSalesforceUpdateNoCompression:
		u.DestinationSalesforceUpdateNoCompression = best.Value.(*DestinationSalesforceUpdateNoCompression)
		return nil
	case DestinationSalesforceUpdateCompressionUnionTypeDestinationSalesforceUpdateGZIP:
		u.DestinationSalesforceUpdateGZIP = best.Value.(*DestinationSalesforceUpdateGZIP)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationSalesforceUpdateCompression", string(data))
}

func (u DestinationSalesforceUpdateCompression) MarshalJSON() ([]byte, error) {
	if u.DestinationSalesforceUpdateNoCompression != nil {
		return utils.MarshalJSON(u.DestinationSalesforceUpdateNoCompression, "", true)
	}

	if u.DestinationSalesforceUpdateGZIP != nil {
		return utils.MarshalJSON(u.DestinationSalesforceUpdateGZIP, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationSalesforceUpdateCompression: all fields are null")
}

type DestinationSalesforceUpdateSchemasFlattening string

const (
	DestinationSalesforceUpdateSchemasFlatteningNoFlattening        DestinationSalesforceUpdateSchemasFlattening = "No flattening"
	DestinationSalesforceUpdateSchemasFlatteningRootLevelFlattening DestinationSalesforceUpdateSchemasFlattening = "Root level flattening"
)

func (e DestinationSalesforceUpdateSchemasFlattening) ToPointer() *DestinationSalesforceUpdateSchemasFlattening {
	return &e
}
func (e *DestinationSalesforceUpdateSchemasFlattening) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "No flattening":
		fallthrough
	case "Root level flattening":
		*e = DestinationSalesforceUpdateSchemasFlattening(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationSalesforceUpdateSchemasFlattening: %v", v)
	}
}

type DestinationSalesforceUpdateSchemasFormatType string

const (
	DestinationSalesforceUpdateSchemasFormatTypeJsonl DestinationSalesforceUpdateSchemasFormatType = "JSONL"
)

func (e DestinationSalesforceUpdateSchemasFormatType) ToPointer() *DestinationSalesforceUpdateSchemasFormatType {
	return &e
}
func (e *DestinationSalesforceUpdateSchemasFormatType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "JSONL":
		*e = DestinationSalesforceUpdateSchemasFormatType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationSalesforceUpdateSchemasFormatType: %v", v)
	}
}

type DestinationSalesforceUpdateJSONLinesNewlineDelimitedJSON struct {
	Flattening           *DestinationSalesforceUpdateSchemasFlattening `default:"No flattening" json:"flattening"`
	FormatType           *DestinationSalesforceUpdateSchemasFormatType `default:"JSONL" json:"format_type"`
	AdditionalProperties any                                           `additionalProperties:"true" json:"-"`
}

func (d DestinationSalesforceUpdateJSONLinesNewlineDelimitedJSON) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationSalesforceUpdateJSONLinesNewlineDelimitedJSON) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationSalesforceUpdateJSONLinesNewlineDelimitedJSON) GetFlattening() *DestinationSalesforceUpdateSchemasFlattening {
	if d == nil {
		return nil
	}
	return d.Flattening
}

func (d *DestinationSalesforceUpdateJSONLinesNewlineDelimitedJSON) GetFormatType() *DestinationSalesforceUpdateSchemasFormatType {
	if d == nil {
		return nil
	}
	return d.FormatType
}

func (d *DestinationSalesforceUpdateJSONLinesNewlineDelimitedJSON) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationSalesforceUpdateFlattening string

const (
	DestinationSalesforceUpdateFlatteningNoFlattening        DestinationSalesforceUpdateFlattening = "No flattening"
	DestinationSalesforceUpdateFlatteningRootLevelFlattening DestinationSalesforceUpdateFlattening = "Root level flattening"
)

func (e DestinationSalesforceUpdateFlattening) ToPointer() *DestinationSalesforceUpdateFlattening {
	return &e
}
func (e *DestinationSalesforceUpdateFlattening) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "No flattening":
		fallthrough
	case "Root level flattening":
		*e = DestinationSalesforceUpdateFlattening(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationSalesforceUpdateFlattening: %v", v)
	}
}

type DestinationSalesforceUpdateFormatType string

const (
	DestinationSalesforceUpdateFormatTypeCsv DestinationSalesforceUpdateFormatType = "CSV"
)

func (e DestinationSalesforceUpdateFormatType) ToPointer() *DestinationSalesforceUpdateFormatType {
	return &e
}
func (e *DestinationSalesforceUpdateFormatType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CSV":
		*e = DestinationSalesforceUpdateFormatType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationSalesforceUpdateFormatType: %v", v)
	}
}

type DestinationSalesforceUpdateCSVCommaSeparatedValues struct {
	Flattening           *DestinationSalesforceUpdateFlattening `default:"No flattening" json:"flattening"`
	FormatType           *DestinationSalesforceUpdateFormatType `default:"CSV" json:"format_type"`
	AdditionalProperties any                                    `additionalProperties:"true" json:"-"`
}

func (d DestinationSalesforceUpdateCSVCommaSeparatedValues) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationSalesforceUpdateCSVCommaSeparatedValues) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationSalesforceUpdateCSVCommaSeparatedValues) GetFlattening() *DestinationSalesforceUpdateFlattening {
	if d == nil {
		return nil
	}
	return d.Flattening
}

func (d *DestinationSalesforceUpdateCSVCommaSeparatedValues) GetFormatType() *DestinationSalesforceUpdateFormatType {
	if d == nil {
		return nil
	}
	return d.FormatType
}

func (d *DestinationSalesforceUpdateCSVCommaSeparatedValues) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationSalesforceUpdateOutputFormatType string

const (
	DestinationSalesforceUpdateOutputFormatTypeDestinationSalesforceUpdateCSVCommaSeparatedValues       DestinationSalesforceUpdateOutputFormatType = "destination-salesforce-update_CSV: Comma-Separated Values"
	DestinationSalesforceUpdateOutputFormatTypeDestinationSalesforceUpdateJSONLinesNewlineDelimitedJSON DestinationSalesforceUpdateOutputFormatType = "destination-salesforce-update_JSON Lines: Newline-delimited JSON"
)

// DestinationSalesforceUpdateOutputFormat - Format of the data output.
type DestinationSalesforceUpdateOutputFormat struct {
	DestinationSalesforceUpdateCSVCommaSeparatedValues       *DestinationSalesforceUpdateCSVCommaSeparatedValues       `queryParam:"inline" union:"member"`
	DestinationSalesforceUpdateJSONLinesNewlineDelimitedJSON *DestinationSalesforceUpdateJSONLinesNewlineDelimitedJSON `queryParam:"inline" union:"member"`

	Type DestinationSalesforceUpdateOutputFormatType
}

func CreateDestinationSalesforceUpdateOutputFormatDestinationSalesforceUpdateCSVCommaSeparatedValues(destinationSalesforceUpdateCSVCommaSeparatedValues DestinationSalesforceUpdateCSVCommaSeparatedValues) DestinationSalesforceUpdateOutputFormat {
	typ := DestinationSalesforceUpdateOutputFormatTypeDestinationSalesforceUpdateCSVCommaSeparatedValues

	return DestinationSalesforceUpdateOutputFormat{
		DestinationSalesforceUpdateCSVCommaSeparatedValues: &destinationSalesforceUpdateCSVCommaSeparatedValues,
		Type: typ,
	}
}

func CreateDestinationSalesforceUpdateOutputFormatDestinationSalesforceUpdateJSONLinesNewlineDelimitedJSON(destinationSalesforceUpdateJSONLinesNewlineDelimitedJSON DestinationSalesforceUpdateJSONLinesNewlineDelimitedJSON) DestinationSalesforceUpdateOutputFormat {
	typ := DestinationSalesforceUpdateOutputFormatTypeDestinationSalesforceUpdateJSONLinesNewlineDelimitedJSON

	return DestinationSalesforceUpdateOutputFormat{
		DestinationSalesforceUpdateJSONLinesNewlineDelimitedJSON: &destinationSalesforceUpdateJSONLinesNewlineDelimitedJSON,
		Type: typ,
	}
}

func (u *DestinationSalesforceUpdateOutputFormat) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var destinationSalesforceUpdateCSVCommaSeparatedValues DestinationSalesforceUpdateCSVCommaSeparatedValues = DestinationSalesforceUpdateCSVCommaSeparatedValues{}
	if err := utils.UnmarshalJSON(data, &destinationSalesforceUpdateCSVCommaSeparatedValues, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationSalesforceUpdateOutputFormatTypeDestinationSalesforceUpdateCSVCommaSeparatedValues,
			Value: &destinationSalesforceUpdateCSVCommaSeparatedValues,
		})
	}

	var destinationSalesforceUpdateJSONLinesNewlineDelimitedJSON DestinationSalesforceUpdateJSONLinesNewlineDelimitedJSON = DestinationSalesforceUpdateJSONLinesNewlineDelimitedJSON{}
	if err := utils.UnmarshalJSON(data, &destinationSalesforceUpdateJSONLinesNewlineDelimitedJSON, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationSalesforceUpdateOutputFormatTypeDestinationSalesforceUpdateJSONLinesNewlineDelimitedJSON,
			Value: &destinationSalesforceUpdateJSONLinesNewlineDelimitedJSON,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationSalesforceUpdateOutputFormat", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationSalesforceUpdateOutputFormat", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(DestinationSalesforceUpdateOutputFormatType)
	switch best.Type {
	case DestinationSalesforceUpdateOutputFormatTypeDestinationSalesforceUpdateCSVCommaSeparatedValues:
		u.DestinationSalesforceUpdateCSVCommaSeparatedValues = best.Value.(*DestinationSalesforceUpdateCSVCommaSeparatedValues)
		return nil
	case DestinationSalesforceUpdateOutputFormatTypeDestinationSalesforceUpdateJSONLinesNewlineDelimitedJSON:
		u.DestinationSalesforceUpdateJSONLinesNewlineDelimitedJSON = best.Value.(*DestinationSalesforceUpdateJSONLinesNewlineDelimitedJSON)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationSalesforceUpdateOutputFormat", string(data))
}

func (u DestinationSalesforceUpdateOutputFormat) MarshalJSON() ([]byte, error) {
	if u.DestinationSalesforceUpdateCSVCommaSeparatedValues != nil {
		return utils.MarshalJSON(u.DestinationSalesforceUpdateCSVCommaSeparatedValues, "", true)
	}

	if u.DestinationSalesforceUpdateJSONLinesNewlineDelimitedJSON != nil {
		return utils.MarshalJSON(u.DestinationSalesforceUpdateJSONLinesNewlineDelimitedJSON, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationSalesforceUpdateOutputFormat: all fields are null")
}

// DestinationSalesforceUpdateS3BucketRegion - The region of the S3 bucket. See <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-available-regions">here</a> for all region codes.
type DestinationSalesforceUpdateS3BucketRegion string

const (
	DestinationSalesforceUpdateS3BucketRegionUnknown      DestinationSalesforceUpdateS3BucketRegion = ""
	DestinationSalesforceUpdateS3BucketRegionAfSouth1     DestinationSalesforceUpdateS3BucketRegion = "af-south-1"
	DestinationSalesforceUpdateS3BucketRegionApEast1      DestinationSalesforceUpdateS3BucketRegion = "ap-east-1"
	DestinationSalesforceUpdateS3BucketRegionApNortheast1 DestinationSalesforceUpdateS3BucketRegion = "ap-northeast-1"
	DestinationSalesforceUpdateS3BucketRegionApNortheast2 DestinationSalesforceUpdateS3BucketRegion = "ap-northeast-2"
	DestinationSalesforceUpdateS3BucketRegionApNortheast3 DestinationSalesforceUpdateS3BucketRegion = "ap-northeast-3"
	DestinationSalesforceUpdateS3BucketRegionApSouth1     DestinationSalesforceUpdateS3BucketRegion = "ap-south-1"
	DestinationSalesforceUpdateS3BucketRegionApSouth2     DestinationSalesforceUpdateS3BucketRegion = "ap-south-2"
	DestinationSalesforceUpdateS3BucketRegionApSoutheast1 DestinationSalesforceUpdateS3BucketRegion = "ap-southeast-1"
	DestinationSalesforceUpdateS3BucketRegionApSoutheast2 DestinationSalesforceUpdateS3BucketRegion = "ap-southeast-2"
	DestinationSalesforceUpdateS3BucketRegionApSoutheast3 DestinationSalesforceUpdateS3BucketRegion = "ap-southeast-3"
	DestinationSalesforceUpdateS3BucketRegionApSoutheast4 DestinationSalesforceUpdateS3BucketRegion = "ap-southeast-4"
	DestinationSalesforceUpdateS3BucketRegionCaCentral1   DestinationSalesforceUpdateS3BucketRegion = "ca-central-1"
	DestinationSalesforceUpdateS3BucketRegionCaWest1      DestinationSalesforceUpdateS3BucketRegion = "ca-west-1"
	DestinationSalesforceUpdateS3BucketRegionCnNorth1     DestinationSalesforceUpdateS3BucketRegion = "cn-north-1"
	DestinationSalesforceUpdateS3BucketRegionCnNorthwest1 DestinationSalesforceUpdateS3BucketRegion = "cn-northwest-1"
	DestinationSalesforceUpdateS3BucketRegionEuCentral1   DestinationSalesforceUpdateS3BucketRegion = "eu-central-1"
	DestinationSalesforceUpdateS3BucketRegionEuCentral2   DestinationSalesforceUpdateS3BucketRegion = "eu-central-2"
	DestinationSalesforceUpdateS3BucketRegionEuNorth1     DestinationSalesforceUpdateS3BucketRegion = "eu-north-1"
	DestinationSalesforceUpdateS3BucketRegionEuSouth1     DestinationSalesforceUpdateS3BucketRegion = "eu-south-1"
	DestinationSalesforceUpdateS3BucketRegionEuSouth2     DestinationSalesforceUpdateS3BucketRegion = "eu-south-2"
	DestinationSalesforceUpdateS3BucketRegionEuWest1      DestinationSalesforceUpdateS3BucketRegion = "eu-west-1"
	DestinationSalesforceUpdateS3BucketRegionEuWest2      DestinationSalesforceUpdateS3BucketRegion = "eu-west-2"
	DestinationSalesforceUpdateS3BucketRegionEuWest3      DestinationSalesforceUpdateS3BucketRegion = "eu-west-3"
	DestinationSalesforceUpdateS3BucketRegionIlCentral1   DestinationSalesforceUpdateS3BucketRegion = "il-central-1"
	DestinationSalesforceUpdateS3BucketRegionMeCentral1   DestinationSalesforceUpdateS3BucketRegion = "me-central-1"
	DestinationSalesforceUpdateS3BucketRegionMeSouth1     DestinationSalesforceUpdateS3BucketRegion = "me-south-1"
	DestinationSalesforceUpdateS3BucketRegionSaEast1      DestinationSalesforceUpdateS3BucketRegion = "sa-east-1"
	DestinationSalesforceUpdateS3BucketRegionUsEast1      DestinationSalesforceUpdateS3BucketRegion = "us-east-1"
	DestinationSalesforceUpdateS3BucketRegionUsEast2      DestinationSalesforceUpdateS3BucketRegion = "us-east-2"
	DestinationSalesforceUpdateS3BucketRegionUsGovEast1   DestinationSalesforceUpdateS3BucketRegion = "us-gov-east-1"
	DestinationSalesforceUpdateS3BucketRegionUsGovWest1   DestinationSalesforceUpdateS3BucketRegion = "us-gov-west-1"
	DestinationSalesforceUpdateS3BucketRegionUsWest1      DestinationSalesforceUpdateS3BucketRegion = "us-west-1"
	DestinationSalesforceUpdateS3BucketRegionUsWest2      DestinationSalesforceUpdateS3BucketRegion = "us-west-2"
)

func (e DestinationSalesforceUpdateS3BucketRegion) ToPointer() *DestinationSalesforceUpdateS3BucketRegion {
	return &e
}
func (e *DestinationSalesforceUpdateS3BucketRegion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "":
		fallthrough
	case "af-south-1":
		fallthrough
	case "ap-east-1":
		fallthrough
	case "ap-northeast-1":
		fallthrough
	case "ap-northeast-2":
		fallthrough
	case "ap-northeast-3":
		fallthrough
	case "ap-south-1":
		fallthrough
	case "ap-south-2":
		fallthrough
	case "ap-southeast-1":
		fallthrough
	case "ap-southeast-2":
		fallthrough
	case "ap-southeast-3":
		fallthrough
	case "ap-southeast-4":
		fallthrough
	case "ca-central-1":
		fallthrough
	case "ca-west-1":
		fallthrough
	case "cn-north-1":
		fallthrough
	case "cn-northwest-1":
		fallthrough
	case "eu-central-1":
		fallthrough
	case "eu-central-2":
		fallthrough
	case "eu-north-1":
		fallthrough
	case "eu-south-1":
		fallthrough
	case "eu-south-2":
		fallthrough
	case "eu-west-1":
		fallthrough
	case "eu-west-2":
		fallthrough
	case "eu-west-3":
		fallthrough
	case "il-central-1":
		fallthrough
	case "me-central-1":
		fallthrough
	case "me-south-1":
		fallthrough
	case "sa-east-1":
		fallthrough
	case "us-east-1":
		fallthrough
	case "us-east-2":
		fallthrough
	case "us-gov-east-1":
		fallthrough
	case "us-gov-west-1":
		fallthrough
	case "us-west-1":
		fallthrough
	case "us-west-2":
		*e = DestinationSalesforceUpdateS3BucketRegion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationSalesforceUpdateS3BucketRegion: %v", v)
	}
}

type DestinationSalesforceUpdateSchemasStorageType string

const (
	DestinationSalesforceUpdateSchemasStorageTypeS3 DestinationSalesforceUpdateSchemasStorageType = "S3"
)

func (e DestinationSalesforceUpdateSchemasStorageType) ToPointer() *DestinationSalesforceUpdateSchemasStorageType {
	return &e
}
func (e *DestinationSalesforceUpdateSchemasStorageType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "S3":
		*e = DestinationSalesforceUpdateSchemasStorageType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationSalesforceUpdateSchemasStorageType: %v", v)
	}
}

type DestinationSalesforceUpdateS3 struct {
	// The access key ID to access the S3 bucket. Airbyte requires Read and Write permissions to the given bucket. Read more <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">here</a>.
	AccessKeyID *string `json:"access_key_id,omitempty"`
	// All files in the bucket will be prefixed by this.
	BucketPath *string `json:"bucket_path,omitempty"`
	// Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").
	Compression    *DestinationSalesforceUpdateCompression `json:"compression,omitempty"`
	FileNameFormat *string                                 `default:"{date}_{timestamp}_{part_number}{format_extension}" json:"file_name_format"`
	// Format of the data output.
	Format     *DestinationSalesforceUpdateOutputFormat `json:"format,omitempty"`
	PathFormat *string                                  `default:"{sync_id}/{namespace}/{stream_name}/" json:"path_format"`
	// The ARN of the AWS role to assume. Only usable in Airbyte Cloud.
	RoleArn *string `json:"role_arn,omitempty"`
	// The name of the S3 bucket. Read more <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/create-bucket-overview.html">here</a>.
	S3BucketName *string `json:"s3_bucket_name,omitempty"`
	// The region of the S3 bucket. See <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-available-regions">here</a> for all region codes.
	S3BucketRegion *DestinationSalesforceUpdateS3BucketRegion `default:"" json:"s3_bucket_region"`
	// Your S3 endpoint url. Read more <a href="https://docs.aws.amazon.com/general/latest/gr/s3.html#:~:text=Service%20endpoints-,Amazon%20S3%20endpoints,-When%20you%20use">here</a>
	S3Endpoint *string `json:"s3_endpoint,omitempty"`
	// The corresponding secret to the access key ID. Read more <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">here</a>
	SecretAccessKey      *string                                        `json:"secret_access_key,omitempty"`
	StorageType          *DestinationSalesforceUpdateSchemasStorageType `default:"S3" json:"storage_type"`
	AdditionalProperties any                                            `additionalProperties:"true" json:"-"`
}

func (d DestinationSalesforceUpdateS3) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationSalesforceUpdateS3) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationSalesforceUpdateS3) GetAccessKeyID() *string {
	if d == nil {
		return nil
	}
	return d.AccessKeyID
}

func (d *DestinationSalesforceUpdateS3) GetBucketPath() *string {
	if d == nil {
		return nil
	}
	return d.BucketPath
}

func (d *DestinationSalesforceUpdateS3) GetCompression() *DestinationSalesforceUpdateCompression {
	if d == nil {
		return nil
	}
	return d.Compression
}

func (d *DestinationSalesforceUpdateS3) GetFileNameFormat() *string {
	if d == nil {
		return nil
	}
	return d.FileNameFormat
}

func (d *DestinationSalesforceUpdateS3) GetFormat() *DestinationSalesforceUpdateOutputFormat {
	if d == nil {
		return nil
	}
	return d.Format
}

func (d *DestinationSalesforceUpdateS3) GetPathFormat() *string {
	if d == nil {
		return nil
	}
	return d.PathFormat
}

func (d *DestinationSalesforceUpdateS3) GetRoleArn() *string {
	if d == nil {
		return nil
	}
	return d.RoleArn
}

func (d *DestinationSalesforceUpdateS3) GetS3BucketName() *string {
	if d == nil {
		return nil
	}
	return d.S3BucketName
}

func (d *DestinationSalesforceUpdateS3) GetS3BucketRegion() *DestinationSalesforceUpdateS3BucketRegion {
	if d == nil {
		return nil
	}
	return d.S3BucketRegion
}

func (d *DestinationSalesforceUpdateS3) GetS3Endpoint() *string {
	if d == nil {
		return nil
	}
	return d.S3Endpoint
}

func (d *DestinationSalesforceUpdateS3) GetSecretAccessKey() *string {
	if d == nil {
		return nil
	}
	return d.SecretAccessKey
}

func (d *DestinationSalesforceUpdateS3) GetStorageType() *DestinationSalesforceUpdateSchemasStorageType {
	if d == nil {
		return nil
	}
	return d.StorageType
}

func (d *DestinationSalesforceUpdateS3) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationSalesforceUpdateStorageType string

const (
	DestinationSalesforceUpdateStorageTypeNone DestinationSalesforceUpdateStorageType = "None"
)

func (e DestinationSalesforceUpdateStorageType) ToPointer() *DestinationSalesforceUpdateStorageType {
	return &e
}
func (e *DestinationSalesforceUpdateStorageType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "None":
		*e = DestinationSalesforceUpdateStorageType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationSalesforceUpdateStorageType: %v", v)
	}
}

type DestinationSalesforceUpdateNone struct {
	StorageType          *DestinationSalesforceUpdateStorageType `default:"None" json:"storage_type"`
	AdditionalProperties any                                     `additionalProperties:"true" json:"-"`
}

func (d DestinationSalesforceUpdateNone) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationSalesforceUpdateNone) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationSalesforceUpdateNone) GetStorageType() *DestinationSalesforceUpdateStorageType {
	if d == nil {
		return nil
	}
	return d.StorageType
}

func (d *DestinationSalesforceUpdateNone) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationSalesforceUpdateObjectStorageSpecType string

const (
	DestinationSalesforceUpdateObjectStorageSpecTypeDestinationSalesforceUpdateNone DestinationSalesforceUpdateObjectStorageSpecType = "destination-salesforce-update_None"
	DestinationSalesforceUpdateObjectStorageSpecTypeDestinationSalesforceUpdateS3   DestinationSalesforceUpdateObjectStorageSpecType = "destination-salesforce-update_S3"
)

type DestinationSalesforceUpdateObjectStorageSpec struct {
	DestinationSalesforceUpdateNone *DestinationSalesforceUpdateNone `queryParam:"inline" union:"member"`
	DestinationSalesforceUpdateS3   *DestinationSalesforceUpdateS3   `queryParam:"inline" union:"member"`

	Type DestinationSalesforceUpdateObjectStorageSpecType
}

func CreateDestinationSalesforceUpdateObjectStorageSpecDestinationSalesforceUpdateNone(destinationSalesforceUpdateNone DestinationSalesforceUpdateNone) DestinationSalesforceUpdateObjectStorageSpec {
	typ := DestinationSalesforceUpdateObjectStorageSpecTypeDestinationSalesforceUpdateNone

	return DestinationSalesforceUpdateObjectStorageSpec{
		DestinationSalesforceUpdateNone: &destinationSalesforceUpdateNone,
		Type:                            typ,
	}
}

func CreateDestinationSalesforceUpdateObjectStorageSpecDestinationSalesforceUpdateS3(destinationSalesforceUpdateS3 DestinationSalesforceUpdateS3) DestinationSalesforceUpdateObjectStorageSpec {
	typ := DestinationSalesforceUpdateObjectStorageSpecTypeDestinationSalesforceUpdateS3

	return DestinationSalesforceUpdateObjectStorageSpec{
		DestinationSalesforceUpdateS3: &destinationSalesforceUpdateS3,
		Type:                          typ,
	}
}

func (u *DestinationSalesforceUpdateObjectStorageSpec) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var destinationSalesforceUpdateNone DestinationSalesforceUpdateNone = DestinationSalesforceUpdateNone{}
	if err := utils.UnmarshalJSON(data, &destinationSalesforceUpdateNone, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationSalesforceUpdateObjectStorageSpecTypeDestinationSalesforceUpdateNone,
			Value: &destinationSalesforceUpdateNone,
		})
	}

	var destinationSalesforceUpdateS3 DestinationSalesforceUpdateS3 = DestinationSalesforceUpdateS3{}
	if err := utils.UnmarshalJSON(data, &destinationSalesforceUpdateS3, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationSalesforceUpdateObjectStorageSpecTypeDestinationSalesforceUpdateS3,
			Value: &destinationSalesforceUpdateS3,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationSalesforceUpdateObjectStorageSpec", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationSalesforceUpdateObjectStorageSpec", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(DestinationSalesforceUpdateObjectStorageSpecType)
	switch best.Type {
	case DestinationSalesforceUpdateObjectStorageSpecTypeDestinationSalesforceUpdateNone:
		u.DestinationSalesforceUpdateNone = best.Value.(*DestinationSalesforceUpdateNone)
		return nil
	case DestinationSalesforceUpdateObjectStorageSpecTypeDestinationSalesforceUpdateS3:
		u.DestinationSalesforceUpdateS3 = best.Value.(*DestinationSalesforceUpdateS3)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationSalesforceUpdateObjectStorageSpec", string(data))
}

func (u DestinationSalesforceUpdateObjectStorageSpec) MarshalJSON() ([]byte, error) {
	if u.DestinationSalesforceUpdateNone != nil {
		return utils.MarshalJSON(u.DestinationSalesforceUpdateNone, "", true)
	}

	if u.DestinationSalesforceUpdateS3 != nil {
		return utils.MarshalJSON(u.DestinationSalesforceUpdateS3, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationSalesforceUpdateObjectStorageSpec: all fields are null")
}

type DestinationSalesforceUpdateDestinationType string

const (
	DestinationSalesforceUpdateDestinationTypeSalesforce DestinationSalesforceUpdateDestinationType = "salesforce"
)

func (e DestinationSalesforceUpdateDestinationType) ToPointer() *DestinationSalesforceUpdateDestinationType {
	return &e
}
func (e *DestinationSalesforceUpdateDestinationType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "salesforce":
		*e = DestinationSalesforceUpdateDestinationType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationSalesforceUpdateDestinationType: %v", v)
	}
}

type DestinationSalesforceUpdate struct {
	authType *string `const:"Client" json:"auth_type,omitempty"`
	// Enter your Salesforce developer application's <a href="https://developer.salesforce.com/forums/?id=9062I000000DLgbQAG">Client ID</a>.
	ClientID *string `json:"client_id,omitempty"`
	// Enter your Salesforce developer application's <a href="https://developer.salesforce.com/forums/?id=9062I000000DLgbQAG">Client secret</a>.
	ClientSecret *string `json:"client_secret,omitempty"`
	// Toggle if you're using a <a href="https://help.salesforce.com/s/articleView?id=sf.deploy_sandboxes_parent.htm&type=5">Salesforce Sandbox</a>.
	IsSandbox           *bool                                         `default:"false" json:"is_sandbox"`
	ObjectStorageConfig *DestinationSalesforceUpdateObjectStorageSpec `json:"object_storage_config,omitempty"`
	// Enter your application's <a href="https://developer.salesforce.com/docs/atlas.en-us.mobile_sdk.meta/mobile_sdk/oauth_refresh_token_flow.htm">Salesforce Refresh Token</a> used for Airbyte to access your Salesforce account.
	RefreshToken         *string                                     `json:"refresh_token,omitempty"`
	destinationType      *DestinationSalesforceUpdateDestinationType `const:"salesforce" json:"destinationType"`
	AdditionalProperties any                                         `additionalProperties:"true" json:"-"`
}

func (d DestinationSalesforceUpdate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationSalesforceUpdate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationSalesforceUpdate) GetAuthType() *string {
	return types.Pointer("Client")
}

func (d *DestinationSalesforceUpdate) GetClientID() *string {
	if d == nil {
		return nil
	}
	return d.ClientID
}

func (d *DestinationSalesforceUpdate) GetClientSecret() *string {
	if d == nil {
		return nil
	}
	return d.ClientSecret
}

func (d *DestinationSalesforceUpdate) GetIsSandbox() *bool {
	if d == nil {
		return nil
	}
	return d.IsSandbox
}

func (d *DestinationSalesforceUpdate) GetObjectStorageConfig() *DestinationSalesforceUpdateObjectStorageSpec {
	if d == nil {
		return nil
	}
	return d.ObjectStorageConfig
}

func (d *DestinationSalesforceUpdate) GetRefreshToken() *string {
	if d == nil {
		return nil
	}
	return d.RefreshToken
}

func (d *DestinationSalesforceUpdate) GetDestinationType() *DestinationSalesforceUpdateDestinationType {
	return DestinationSalesforceUpdateDestinationTypeSalesforce.ToPointer()
}

func (d *DestinationSalesforceUpdate) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}
