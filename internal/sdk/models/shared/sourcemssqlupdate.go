// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

// SourceMssqlUpdateInvalidCDCPositionBehaviorAdvanced - Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value in the mined logs. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss.
type SourceMssqlUpdateInvalidCDCPositionBehaviorAdvanced string

const (
	SourceMssqlUpdateInvalidCDCPositionBehaviorAdvancedFailSync   SourceMssqlUpdateInvalidCDCPositionBehaviorAdvanced = "Fail sync"
	SourceMssqlUpdateInvalidCDCPositionBehaviorAdvancedReSyncData SourceMssqlUpdateInvalidCDCPositionBehaviorAdvanced = "Re-sync data"
)

func (e SourceMssqlUpdateInvalidCDCPositionBehaviorAdvanced) ToPointer() *SourceMssqlUpdateInvalidCDCPositionBehaviorAdvanced {
	return &e
}
func (e *SourceMssqlUpdateInvalidCDCPositionBehaviorAdvanced) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Fail sync":
		fallthrough
	case "Re-sync data":
		*e = SourceMssqlUpdateInvalidCDCPositionBehaviorAdvanced(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMssqlUpdateInvalidCDCPositionBehaviorAdvanced: %v", v)
	}
}

type SourceMssqlUpdateSchemasMethod string

const (
	SourceMssqlUpdateSchemasMethodCdc SourceMssqlUpdateSchemasMethod = "CDC"
)

func (e SourceMssqlUpdateSchemasMethod) ToPointer() *SourceMssqlUpdateSchemasMethod {
	return &e
}
func (e *SourceMssqlUpdateSchemasMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CDC":
		*e = SourceMssqlUpdateSchemasMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMssqlUpdateSchemasMethod: %v", v)
	}
}

// SourceMssqlUpdateReadChangesUsingChangeDataCaptureCDC - <i>Recommended</i> - Incrementally reads new inserts, updates, and deletes using MSSQL's <a href="https://docs.airbyte.com/integrations/sources/mssql/#change-data-capture-cdc"> change data capture feature</a>. This must be enabled on your database.
type SourceMssqlUpdateReadChangesUsingChangeDataCaptureCDC struct {
	// The amount of time an initial load is allowed to continue for before catching up on CDC logs.
	InitialLoadTimeoutHours *int64 `default:"8" json:"initial_load_timeout_hours"`
	// The amount of time the connector will wait when it launches to determine if there is new data to sync or not. Defaults to 300 seconds. Valid range: 120 seconds to 3600 seconds. Read about <a href="https://docs.airbyte.com/integrations/sources/mssql#setting-up-cdc-for-mssql">initial waiting time</a>
	InitialWaitingSeconds *int64 `json:"initial_waiting_seconds,omitempty"`
	// Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value in the mined logs. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss.
	InvalidCdcCursorPositionBehavior *SourceMssqlUpdateInvalidCDCPositionBehaviorAdvanced `default:"Fail sync" json:"invalid_cdc_cursor_position_behavior"`
	Method                           *SourceMssqlUpdateSchemasMethod                      `default:"CDC" json:"method"`
	// How often (in milliseconds) Debezium should poll for new data. Must be smaller than heartbeat interval (15000ms). Lower values provide more responsive data capture but may increase database load.
	PollIntervalMs       *int64 `default:"500" json:"poll_interval_ms"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (s SourceMssqlUpdateReadChangesUsingChangeDataCaptureCDC) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMssqlUpdateReadChangesUsingChangeDataCaptureCDC) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceMssqlUpdateReadChangesUsingChangeDataCaptureCDC) GetInitialLoadTimeoutHours() *int64 {
	if s == nil {
		return nil
	}
	return s.InitialLoadTimeoutHours
}

func (s *SourceMssqlUpdateReadChangesUsingChangeDataCaptureCDC) GetInitialWaitingSeconds() *int64 {
	if s == nil {
		return nil
	}
	return s.InitialWaitingSeconds
}

func (s *SourceMssqlUpdateReadChangesUsingChangeDataCaptureCDC) GetInvalidCdcCursorPositionBehavior() *SourceMssqlUpdateInvalidCDCPositionBehaviorAdvanced {
	if s == nil {
		return nil
	}
	return s.InvalidCdcCursorPositionBehavior
}

func (s *SourceMssqlUpdateReadChangesUsingChangeDataCaptureCDC) GetMethod() *SourceMssqlUpdateSchemasMethod {
	if s == nil {
		return nil
	}
	return s.Method
}

func (s *SourceMssqlUpdateReadChangesUsingChangeDataCaptureCDC) GetPollIntervalMs() *int64 {
	if s == nil {
		return nil
	}
	return s.PollIntervalMs
}

func (s *SourceMssqlUpdateReadChangesUsingChangeDataCaptureCDC) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceMssqlUpdateMethod string

const (
	SourceMssqlUpdateMethodStandard SourceMssqlUpdateMethod = "STANDARD"
)

func (e SourceMssqlUpdateMethod) ToPointer() *SourceMssqlUpdateMethod {
	return &e
}
func (e *SourceMssqlUpdateMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "STANDARD":
		*e = SourceMssqlUpdateMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMssqlUpdateMethod: %v", v)
	}
}

// SourceMssqlUpdateScanChangesWithUserDefinedCursor - Incrementally detects new inserts and updates using the <a href="https://docs.airbyte.com/understanding-airbyte/connections/incremental-append/#user-defined-cursor">cursor column</a> chosen when configuring a connection (e.g. created_at, updated_at).
type SourceMssqlUpdateScanChangesWithUserDefinedCursor struct {
	// When enabled incremental syncs using a cursor of a temporal type (date or datetime) will include cursor values only up until the previous midnight UTC
	ExcludeTodaysData    *bool                    `default:"false" json:"exclude_todays_data"`
	Method               *SourceMssqlUpdateMethod `default:"STANDARD" json:"method"`
	AdditionalProperties any                      `additionalProperties:"true" json:"-"`
}

func (s SourceMssqlUpdateScanChangesWithUserDefinedCursor) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMssqlUpdateScanChangesWithUserDefinedCursor) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceMssqlUpdateScanChangesWithUserDefinedCursor) GetExcludeTodaysData() *bool {
	if s == nil {
		return nil
	}
	return s.ExcludeTodaysData
}

func (s *SourceMssqlUpdateScanChangesWithUserDefinedCursor) GetMethod() *SourceMssqlUpdateMethod {
	if s == nil {
		return nil
	}
	return s.Method
}

func (s *SourceMssqlUpdateScanChangesWithUserDefinedCursor) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceMssqlUpdateUpdateMethodType string

const (
	SourceMssqlUpdateUpdateMethodTypeSourceMssqlUpdateScanChangesWithUserDefinedCursor     SourceMssqlUpdateUpdateMethodType = "source-mssql-update_Scan Changes with User Defined Cursor"
	SourceMssqlUpdateUpdateMethodTypeSourceMssqlUpdateReadChangesUsingChangeDataCaptureCDC SourceMssqlUpdateUpdateMethodType = "source-mssql-update_Read Changes using Change Data Capture (CDC)"
)

// SourceMssqlUpdateUpdateMethod - Configures how data is extracted from the database.
type SourceMssqlUpdateUpdateMethod struct {
	SourceMssqlUpdateScanChangesWithUserDefinedCursor     *SourceMssqlUpdateScanChangesWithUserDefinedCursor     `queryParam:"inline" union:"member"`
	SourceMssqlUpdateReadChangesUsingChangeDataCaptureCDC *SourceMssqlUpdateReadChangesUsingChangeDataCaptureCDC `queryParam:"inline" union:"member"`

	Type SourceMssqlUpdateUpdateMethodType
}

func CreateSourceMssqlUpdateUpdateMethodSourceMssqlUpdateScanChangesWithUserDefinedCursor(sourceMssqlUpdateScanChangesWithUserDefinedCursor SourceMssqlUpdateScanChangesWithUserDefinedCursor) SourceMssqlUpdateUpdateMethod {
	typ := SourceMssqlUpdateUpdateMethodTypeSourceMssqlUpdateScanChangesWithUserDefinedCursor

	return SourceMssqlUpdateUpdateMethod{
		SourceMssqlUpdateScanChangesWithUserDefinedCursor: &sourceMssqlUpdateScanChangesWithUserDefinedCursor,
		Type: typ,
	}
}

func CreateSourceMssqlUpdateUpdateMethodSourceMssqlUpdateReadChangesUsingChangeDataCaptureCDC(sourceMssqlUpdateReadChangesUsingChangeDataCaptureCDC SourceMssqlUpdateReadChangesUsingChangeDataCaptureCDC) SourceMssqlUpdateUpdateMethod {
	typ := SourceMssqlUpdateUpdateMethodTypeSourceMssqlUpdateReadChangesUsingChangeDataCaptureCDC

	return SourceMssqlUpdateUpdateMethod{
		SourceMssqlUpdateReadChangesUsingChangeDataCaptureCDC: &sourceMssqlUpdateReadChangesUsingChangeDataCaptureCDC,
		Type: typ,
	}
}

func (u *SourceMssqlUpdateUpdateMethod) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var sourceMssqlUpdateScanChangesWithUserDefinedCursor SourceMssqlUpdateScanChangesWithUserDefinedCursor = SourceMssqlUpdateScanChangesWithUserDefinedCursor{}
	if err := utils.UnmarshalJSON(data, &sourceMssqlUpdateScanChangesWithUserDefinedCursor, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceMssqlUpdateUpdateMethodTypeSourceMssqlUpdateScanChangesWithUserDefinedCursor,
			Value: &sourceMssqlUpdateScanChangesWithUserDefinedCursor,
		})
	}

	var sourceMssqlUpdateReadChangesUsingChangeDataCaptureCDC SourceMssqlUpdateReadChangesUsingChangeDataCaptureCDC = SourceMssqlUpdateReadChangesUsingChangeDataCaptureCDC{}
	if err := utils.UnmarshalJSON(data, &sourceMssqlUpdateReadChangesUsingChangeDataCaptureCDC, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceMssqlUpdateUpdateMethodTypeSourceMssqlUpdateReadChangesUsingChangeDataCaptureCDC,
			Value: &sourceMssqlUpdateReadChangesUsingChangeDataCaptureCDC,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMssqlUpdateUpdateMethod", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMssqlUpdateUpdateMethod", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceMssqlUpdateUpdateMethodType)
	switch best.Type {
	case SourceMssqlUpdateUpdateMethodTypeSourceMssqlUpdateScanChangesWithUserDefinedCursor:
		u.SourceMssqlUpdateScanChangesWithUserDefinedCursor = best.Value.(*SourceMssqlUpdateScanChangesWithUserDefinedCursor)
		return nil
	case SourceMssqlUpdateUpdateMethodTypeSourceMssqlUpdateReadChangesUsingChangeDataCaptureCDC:
		u.SourceMssqlUpdateReadChangesUsingChangeDataCaptureCDC = best.Value.(*SourceMssqlUpdateReadChangesUsingChangeDataCaptureCDC)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMssqlUpdateUpdateMethod", string(data))
}

func (u SourceMssqlUpdateUpdateMethod) MarshalJSON() ([]byte, error) {
	if u.SourceMssqlUpdateScanChangesWithUserDefinedCursor != nil {
		return utils.MarshalJSON(u.SourceMssqlUpdateScanChangesWithUserDefinedCursor, "", true)
	}

	if u.SourceMssqlUpdateReadChangesUsingChangeDataCaptureCDC != nil {
		return utils.MarshalJSON(u.SourceMssqlUpdateReadChangesUsingChangeDataCaptureCDC, "", true)
	}

	return nil, errors.New("could not marshal union type SourceMssqlUpdateUpdateMethod: all fields are null")
}

type SourceMssqlUpdateSchemasSslModeMode string

const (
	SourceMssqlUpdateSchemasSslModeModeEncryptedVerifyCertificate SourceMssqlUpdateSchemasSslModeMode = "encrypted_verify_certificate"
)

func (e SourceMssqlUpdateSchemasSslModeMode) ToPointer() *SourceMssqlUpdateSchemasSslModeMode {
	return &e
}
func (e *SourceMssqlUpdateSchemasSslModeMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "encrypted_verify_certificate":
		*e = SourceMssqlUpdateSchemasSslModeMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMssqlUpdateSchemasSslModeMode: %v", v)
	}
}

// SourceMssqlUpdateEncryptedVerifyCertificate - Verify and use the certificate provided by the server.
type SourceMssqlUpdateEncryptedVerifyCertificate struct {
	// certificate of the server, or of the CA that signed the server certificate
	Certificate *string `json:"certificate,omitempty"`
	// Specifies the host name of the server. The value of this property must match the subject property of the certificate.
	HostNameInCertificate *string                              `json:"hostNameInCertificate,omitempty"`
	Mode                  *SourceMssqlUpdateSchemasSslModeMode `default:"encrypted_verify_certificate" json:"mode"`
	AdditionalProperties  any                                  `additionalProperties:"true" json:"-"`
}

func (s SourceMssqlUpdateEncryptedVerifyCertificate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMssqlUpdateEncryptedVerifyCertificate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceMssqlUpdateEncryptedVerifyCertificate) GetCertificate() *string {
	if s == nil {
		return nil
	}
	return s.Certificate
}

func (s *SourceMssqlUpdateEncryptedVerifyCertificate) GetHostNameInCertificate() *string {
	if s == nil {
		return nil
	}
	return s.HostNameInCertificate
}

func (s *SourceMssqlUpdateEncryptedVerifyCertificate) GetMode() *SourceMssqlUpdateSchemasSslModeMode {
	if s == nil {
		return nil
	}
	return s.Mode
}

func (s *SourceMssqlUpdateEncryptedVerifyCertificate) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceMssqlUpdateSchemasMode string

const (
	SourceMssqlUpdateSchemasModeEncryptedTrustServerCertificate SourceMssqlUpdateSchemasMode = "encrypted_trust_server_certificate"
)

func (e SourceMssqlUpdateSchemasMode) ToPointer() *SourceMssqlUpdateSchemasMode {
	return &e
}
func (e *SourceMssqlUpdateSchemasMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "encrypted_trust_server_certificate":
		*e = SourceMssqlUpdateSchemasMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMssqlUpdateSchemasMode: %v", v)
	}
}

// SourceMssqlUpdateEncryptedTrustServerCertificate - Use the certificate provided by the server without verification. (For testing purposes only!)
type SourceMssqlUpdateEncryptedTrustServerCertificate struct {
	Mode                 *SourceMssqlUpdateSchemasMode `default:"encrypted_trust_server_certificate" json:"mode"`
	AdditionalProperties any                           `additionalProperties:"true" json:"-"`
}

func (s SourceMssqlUpdateEncryptedTrustServerCertificate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMssqlUpdateEncryptedTrustServerCertificate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceMssqlUpdateEncryptedTrustServerCertificate) GetMode() *SourceMssqlUpdateSchemasMode {
	if s == nil {
		return nil
	}
	return s.Mode
}

func (s *SourceMssqlUpdateEncryptedTrustServerCertificate) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceMssqlUpdateMode string

const (
	SourceMssqlUpdateModeUnencrypted SourceMssqlUpdateMode = "unencrypted"
)

func (e SourceMssqlUpdateMode) ToPointer() *SourceMssqlUpdateMode {
	return &e
}
func (e *SourceMssqlUpdateMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "unencrypted":
		*e = SourceMssqlUpdateMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMssqlUpdateMode: %v", v)
	}
}

// SourceMssqlUpdateUnencrypted - Data transfer will not be encrypted.
type SourceMssqlUpdateUnencrypted struct {
	Mode                 *SourceMssqlUpdateMode `default:"unencrypted" json:"mode"`
	AdditionalProperties any                    `additionalProperties:"true" json:"-"`
}

func (s SourceMssqlUpdateUnencrypted) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMssqlUpdateUnencrypted) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceMssqlUpdateUnencrypted) GetMode() *SourceMssqlUpdateMode {
	if s == nil {
		return nil
	}
	return s.Mode
}

func (s *SourceMssqlUpdateUnencrypted) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceMssqlUpdateEncryptionType string

const (
	SourceMssqlUpdateEncryptionTypeSourceMssqlUpdateUnencrypted                     SourceMssqlUpdateEncryptionType = "source-mssql-update_Unencrypted"
	SourceMssqlUpdateEncryptionTypeSourceMssqlUpdateEncryptedTrustServerCertificate SourceMssqlUpdateEncryptionType = "source-mssql-update_Encrypted (trust server certificate)"
	SourceMssqlUpdateEncryptionTypeSourceMssqlUpdateEncryptedVerifyCertificate      SourceMssqlUpdateEncryptionType = "source-mssql-update_Encrypted (verify certificate)"
)

// SourceMssqlUpdateEncryption - The encryption method which is used when communicating with the database.
type SourceMssqlUpdateEncryption struct {
	SourceMssqlUpdateUnencrypted                     *SourceMssqlUpdateUnencrypted                     `queryParam:"inline" union:"member"`
	SourceMssqlUpdateEncryptedTrustServerCertificate *SourceMssqlUpdateEncryptedTrustServerCertificate `queryParam:"inline" union:"member"`
	SourceMssqlUpdateEncryptedVerifyCertificate      *SourceMssqlUpdateEncryptedVerifyCertificate      `queryParam:"inline" union:"member"`

	Type SourceMssqlUpdateEncryptionType
}

func CreateSourceMssqlUpdateEncryptionSourceMssqlUpdateUnencrypted(sourceMssqlUpdateUnencrypted SourceMssqlUpdateUnencrypted) SourceMssqlUpdateEncryption {
	typ := SourceMssqlUpdateEncryptionTypeSourceMssqlUpdateUnencrypted

	return SourceMssqlUpdateEncryption{
		SourceMssqlUpdateUnencrypted: &sourceMssqlUpdateUnencrypted,
		Type:                         typ,
	}
}

func CreateSourceMssqlUpdateEncryptionSourceMssqlUpdateEncryptedTrustServerCertificate(sourceMssqlUpdateEncryptedTrustServerCertificate SourceMssqlUpdateEncryptedTrustServerCertificate) SourceMssqlUpdateEncryption {
	typ := SourceMssqlUpdateEncryptionTypeSourceMssqlUpdateEncryptedTrustServerCertificate

	return SourceMssqlUpdateEncryption{
		SourceMssqlUpdateEncryptedTrustServerCertificate: &sourceMssqlUpdateEncryptedTrustServerCertificate,
		Type: typ,
	}
}

func CreateSourceMssqlUpdateEncryptionSourceMssqlUpdateEncryptedVerifyCertificate(sourceMssqlUpdateEncryptedVerifyCertificate SourceMssqlUpdateEncryptedVerifyCertificate) SourceMssqlUpdateEncryption {
	typ := SourceMssqlUpdateEncryptionTypeSourceMssqlUpdateEncryptedVerifyCertificate

	return SourceMssqlUpdateEncryption{
		SourceMssqlUpdateEncryptedVerifyCertificate: &sourceMssqlUpdateEncryptedVerifyCertificate,
		Type: typ,
	}
}

func (u *SourceMssqlUpdateEncryption) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var sourceMssqlUpdateUnencrypted SourceMssqlUpdateUnencrypted = SourceMssqlUpdateUnencrypted{}
	if err := utils.UnmarshalJSON(data, &sourceMssqlUpdateUnencrypted, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceMssqlUpdateEncryptionTypeSourceMssqlUpdateUnencrypted,
			Value: &sourceMssqlUpdateUnencrypted,
		})
	}

	var sourceMssqlUpdateEncryptedTrustServerCertificate SourceMssqlUpdateEncryptedTrustServerCertificate = SourceMssqlUpdateEncryptedTrustServerCertificate{}
	if err := utils.UnmarshalJSON(data, &sourceMssqlUpdateEncryptedTrustServerCertificate, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceMssqlUpdateEncryptionTypeSourceMssqlUpdateEncryptedTrustServerCertificate,
			Value: &sourceMssqlUpdateEncryptedTrustServerCertificate,
		})
	}

	var sourceMssqlUpdateEncryptedVerifyCertificate SourceMssqlUpdateEncryptedVerifyCertificate = SourceMssqlUpdateEncryptedVerifyCertificate{}
	if err := utils.UnmarshalJSON(data, &sourceMssqlUpdateEncryptedVerifyCertificate, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceMssqlUpdateEncryptionTypeSourceMssqlUpdateEncryptedVerifyCertificate,
			Value: &sourceMssqlUpdateEncryptedVerifyCertificate,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMssqlUpdateEncryption", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMssqlUpdateEncryption", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceMssqlUpdateEncryptionType)
	switch best.Type {
	case SourceMssqlUpdateEncryptionTypeSourceMssqlUpdateUnencrypted:
		u.SourceMssqlUpdateUnencrypted = best.Value.(*SourceMssqlUpdateUnencrypted)
		return nil
	case SourceMssqlUpdateEncryptionTypeSourceMssqlUpdateEncryptedTrustServerCertificate:
		u.SourceMssqlUpdateEncryptedTrustServerCertificate = best.Value.(*SourceMssqlUpdateEncryptedTrustServerCertificate)
		return nil
	case SourceMssqlUpdateEncryptionTypeSourceMssqlUpdateEncryptedVerifyCertificate:
		u.SourceMssqlUpdateEncryptedVerifyCertificate = best.Value.(*SourceMssqlUpdateEncryptedVerifyCertificate)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMssqlUpdateEncryption", string(data))
}

func (u SourceMssqlUpdateEncryption) MarshalJSON() ([]byte, error) {
	if u.SourceMssqlUpdateUnencrypted != nil {
		return utils.MarshalJSON(u.SourceMssqlUpdateUnencrypted, "", true)
	}

	if u.SourceMssqlUpdateEncryptedTrustServerCertificate != nil {
		return utils.MarshalJSON(u.SourceMssqlUpdateEncryptedTrustServerCertificate, "", true)
	}

	if u.SourceMssqlUpdateEncryptedVerifyCertificate != nil {
		return utils.MarshalJSON(u.SourceMssqlUpdateEncryptedVerifyCertificate, "", true)
	}

	return nil, errors.New("could not marshal union type SourceMssqlUpdateEncryption: all fields are null")
}

type SourceMssqlUpdateSchemasTunnelMethodTunnelMethod string

const (
	SourceMssqlUpdateSchemasTunnelMethodTunnelMethodSSHPasswordAuth SourceMssqlUpdateSchemasTunnelMethodTunnelMethod = "SSH_PASSWORD_AUTH"
)

func (e SourceMssqlUpdateSchemasTunnelMethodTunnelMethod) ToPointer() *SourceMssqlUpdateSchemasTunnelMethodTunnelMethod {
	return &e
}
func (e *SourceMssqlUpdateSchemasTunnelMethodTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_PASSWORD_AUTH":
		*e = SourceMssqlUpdateSchemasTunnelMethodTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMssqlUpdateSchemasTunnelMethodTunnelMethod: %v", v)
	}
}

// SourceMssqlUpdatePasswordAuthentication - Connect through a jump server tunnel host using username and password authentication
type SourceMssqlUpdatePasswordAuthentication struct {
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost   *string                                           `json:"tunnel_host,omitempty"`
	TunnelMethod *SourceMssqlUpdateSchemasTunnelMethodTunnelMethod `default:"SSH_PASSWORD_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser *string `json:"tunnel_user,omitempty"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword   *string `json:"tunnel_user_password,omitempty"`
	AdditionalProperties any     `additionalProperties:"true" json:"-"`
}

func (s SourceMssqlUpdatePasswordAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMssqlUpdatePasswordAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceMssqlUpdatePasswordAuthentication) GetTunnelHost() *string {
	if s == nil {
		return nil
	}
	return s.TunnelHost
}

func (s *SourceMssqlUpdatePasswordAuthentication) GetTunnelMethod() *SourceMssqlUpdateSchemasTunnelMethodTunnelMethod {
	if s == nil {
		return nil
	}
	return s.TunnelMethod
}

func (s *SourceMssqlUpdatePasswordAuthentication) GetTunnelPort() *int64 {
	if s == nil {
		return nil
	}
	return s.TunnelPort
}

func (s *SourceMssqlUpdatePasswordAuthentication) GetTunnelUser() *string {
	if s == nil {
		return nil
	}
	return s.TunnelUser
}

func (s *SourceMssqlUpdatePasswordAuthentication) GetTunnelUserPassword() *string {
	if s == nil {
		return nil
	}
	return s.TunnelUserPassword
}

func (s *SourceMssqlUpdatePasswordAuthentication) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceMssqlUpdateSchemasTunnelMethod string

const (
	SourceMssqlUpdateSchemasTunnelMethodSSHKeyAuth SourceMssqlUpdateSchemasTunnelMethod = "SSH_KEY_AUTH"
)

func (e SourceMssqlUpdateSchemasTunnelMethod) ToPointer() *SourceMssqlUpdateSchemasTunnelMethod {
	return &e
}
func (e *SourceMssqlUpdateSchemasTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_KEY_AUTH":
		*e = SourceMssqlUpdateSchemasTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMssqlUpdateSchemasTunnelMethod: %v", v)
	}
}

// SourceMssqlUpdateSSHKeyAuthentication - Connect through a jump server tunnel host using username and ssh key
type SourceMssqlUpdateSSHKeyAuthentication struct {
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey *string `json:"ssh_key,omitempty"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost   *string                               `json:"tunnel_host,omitempty"`
	TunnelMethod *SourceMssqlUpdateSchemasTunnelMethod `default:"SSH_KEY_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser           *string `json:"tunnel_user,omitempty"`
	AdditionalProperties any     `additionalProperties:"true" json:"-"`
}

func (s SourceMssqlUpdateSSHKeyAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMssqlUpdateSSHKeyAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceMssqlUpdateSSHKeyAuthentication) GetSSHKey() *string {
	if s == nil {
		return nil
	}
	return s.SSHKey
}

func (s *SourceMssqlUpdateSSHKeyAuthentication) GetTunnelHost() *string {
	if s == nil {
		return nil
	}
	return s.TunnelHost
}

func (s *SourceMssqlUpdateSSHKeyAuthentication) GetTunnelMethod() *SourceMssqlUpdateSchemasTunnelMethod {
	if s == nil {
		return nil
	}
	return s.TunnelMethod
}

func (s *SourceMssqlUpdateSSHKeyAuthentication) GetTunnelPort() *int64 {
	if s == nil {
		return nil
	}
	return s.TunnelPort
}

func (s *SourceMssqlUpdateSSHKeyAuthentication) GetTunnelUser() *string {
	if s == nil {
		return nil
	}
	return s.TunnelUser
}

func (s *SourceMssqlUpdateSSHKeyAuthentication) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceMssqlUpdateTunnelMethod string

const (
	SourceMssqlUpdateTunnelMethodNoTunnel SourceMssqlUpdateTunnelMethod = "NO_TUNNEL"
)

func (e SourceMssqlUpdateTunnelMethod) ToPointer() *SourceMssqlUpdateTunnelMethod {
	return &e
}
func (e *SourceMssqlUpdateTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NO_TUNNEL":
		*e = SourceMssqlUpdateTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMssqlUpdateTunnelMethod: %v", v)
	}
}

// SourceMssqlUpdateNoTunnel - No ssh tunnel needed to connect to database
type SourceMssqlUpdateNoTunnel struct {
	TunnelMethod         *SourceMssqlUpdateTunnelMethod `default:"NO_TUNNEL" json:"tunnel_method"`
	AdditionalProperties any                            `additionalProperties:"true" json:"-"`
}

func (s SourceMssqlUpdateNoTunnel) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMssqlUpdateNoTunnel) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceMssqlUpdateNoTunnel) GetTunnelMethod() *SourceMssqlUpdateTunnelMethod {
	if s == nil {
		return nil
	}
	return s.TunnelMethod
}

func (s *SourceMssqlUpdateNoTunnel) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceMssqlUpdateSSHTunnelMethodType string

const (
	SourceMssqlUpdateSSHTunnelMethodTypeSourceMssqlUpdateNoTunnel               SourceMssqlUpdateSSHTunnelMethodType = "source-mssql-update_No Tunnel"
	SourceMssqlUpdateSSHTunnelMethodTypeSourceMssqlUpdateSSHKeyAuthentication   SourceMssqlUpdateSSHTunnelMethodType = "source-mssql-update_SSH Key Authentication"
	SourceMssqlUpdateSSHTunnelMethodTypeSourceMssqlUpdatePasswordAuthentication SourceMssqlUpdateSSHTunnelMethodType = "source-mssql-update_Password Authentication"
)

// SourceMssqlUpdateSSHTunnelMethod - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceMssqlUpdateSSHTunnelMethod struct {
	SourceMssqlUpdateNoTunnel               *SourceMssqlUpdateNoTunnel               `queryParam:"inline" union:"member"`
	SourceMssqlUpdateSSHKeyAuthentication   *SourceMssqlUpdateSSHKeyAuthentication   `queryParam:"inline" union:"member"`
	SourceMssqlUpdatePasswordAuthentication *SourceMssqlUpdatePasswordAuthentication `queryParam:"inline" union:"member"`

	Type SourceMssqlUpdateSSHTunnelMethodType
}

func CreateSourceMssqlUpdateSSHTunnelMethodSourceMssqlUpdateNoTunnel(sourceMssqlUpdateNoTunnel SourceMssqlUpdateNoTunnel) SourceMssqlUpdateSSHTunnelMethod {
	typ := SourceMssqlUpdateSSHTunnelMethodTypeSourceMssqlUpdateNoTunnel

	return SourceMssqlUpdateSSHTunnelMethod{
		SourceMssqlUpdateNoTunnel: &sourceMssqlUpdateNoTunnel,
		Type:                      typ,
	}
}

func CreateSourceMssqlUpdateSSHTunnelMethodSourceMssqlUpdateSSHKeyAuthentication(sourceMssqlUpdateSSHKeyAuthentication SourceMssqlUpdateSSHKeyAuthentication) SourceMssqlUpdateSSHTunnelMethod {
	typ := SourceMssqlUpdateSSHTunnelMethodTypeSourceMssqlUpdateSSHKeyAuthentication

	return SourceMssqlUpdateSSHTunnelMethod{
		SourceMssqlUpdateSSHKeyAuthentication: &sourceMssqlUpdateSSHKeyAuthentication,
		Type:                                  typ,
	}
}

func CreateSourceMssqlUpdateSSHTunnelMethodSourceMssqlUpdatePasswordAuthentication(sourceMssqlUpdatePasswordAuthentication SourceMssqlUpdatePasswordAuthentication) SourceMssqlUpdateSSHTunnelMethod {
	typ := SourceMssqlUpdateSSHTunnelMethodTypeSourceMssqlUpdatePasswordAuthentication

	return SourceMssqlUpdateSSHTunnelMethod{
		SourceMssqlUpdatePasswordAuthentication: &sourceMssqlUpdatePasswordAuthentication,
		Type:                                    typ,
	}
}

func (u *SourceMssqlUpdateSSHTunnelMethod) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var sourceMssqlUpdateNoTunnel SourceMssqlUpdateNoTunnel = SourceMssqlUpdateNoTunnel{}
	if err := utils.UnmarshalJSON(data, &sourceMssqlUpdateNoTunnel, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceMssqlUpdateSSHTunnelMethodTypeSourceMssqlUpdateNoTunnel,
			Value: &sourceMssqlUpdateNoTunnel,
		})
	}

	var sourceMssqlUpdateSSHKeyAuthentication SourceMssqlUpdateSSHKeyAuthentication = SourceMssqlUpdateSSHKeyAuthentication{}
	if err := utils.UnmarshalJSON(data, &sourceMssqlUpdateSSHKeyAuthentication, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceMssqlUpdateSSHTunnelMethodTypeSourceMssqlUpdateSSHKeyAuthentication,
			Value: &sourceMssqlUpdateSSHKeyAuthentication,
		})
	}

	var sourceMssqlUpdatePasswordAuthentication SourceMssqlUpdatePasswordAuthentication = SourceMssqlUpdatePasswordAuthentication{}
	if err := utils.UnmarshalJSON(data, &sourceMssqlUpdatePasswordAuthentication, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceMssqlUpdateSSHTunnelMethodTypeSourceMssqlUpdatePasswordAuthentication,
			Value: &sourceMssqlUpdatePasswordAuthentication,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMssqlUpdateSSHTunnelMethod", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMssqlUpdateSSHTunnelMethod", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceMssqlUpdateSSHTunnelMethodType)
	switch best.Type {
	case SourceMssqlUpdateSSHTunnelMethodTypeSourceMssqlUpdateNoTunnel:
		u.SourceMssqlUpdateNoTunnel = best.Value.(*SourceMssqlUpdateNoTunnel)
		return nil
	case SourceMssqlUpdateSSHTunnelMethodTypeSourceMssqlUpdateSSHKeyAuthentication:
		u.SourceMssqlUpdateSSHKeyAuthentication = best.Value.(*SourceMssqlUpdateSSHKeyAuthentication)
		return nil
	case SourceMssqlUpdateSSHTunnelMethodTypeSourceMssqlUpdatePasswordAuthentication:
		u.SourceMssqlUpdatePasswordAuthentication = best.Value.(*SourceMssqlUpdatePasswordAuthentication)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMssqlUpdateSSHTunnelMethod", string(data))
}

func (u SourceMssqlUpdateSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.SourceMssqlUpdateNoTunnel != nil {
		return utils.MarshalJSON(u.SourceMssqlUpdateNoTunnel, "", true)
	}

	if u.SourceMssqlUpdateSSHKeyAuthentication != nil {
		return utils.MarshalJSON(u.SourceMssqlUpdateSSHKeyAuthentication, "", true)
	}

	if u.SourceMssqlUpdatePasswordAuthentication != nil {
		return utils.MarshalJSON(u.SourceMssqlUpdatePasswordAuthentication, "", true)
	}

	return nil, errors.New("could not marshal union type SourceMssqlUpdateSSHTunnelMethod: all fields are null")
}

type SourceMssqlUpdateSourceType string

const (
	SourceMssqlUpdateSourceTypeMssql SourceMssqlUpdateSourceType = "mssql"
)

func (e SourceMssqlUpdateSourceType) ToPointer() *SourceMssqlUpdateSourceType {
	return &e
}
func (e *SourceMssqlUpdateSourceType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "mssql":
		*e = SourceMssqlUpdateSourceType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMssqlUpdateSourceType: %v", v)
	}
}

type SourceMssqlUpdate struct {
	AdditionalProperties map[string]map[string]any `json:"additionalProperties,omitempty"`
	// When this feature is enabled, during schema discovery the connector will query each table or view individually to check access privileges and inaccessible tables, views, or columns therein will be removed. In large schemas, this might cause schema discovery to take too long, in which case it might be advisable to disable this feature.
	CheckPrivileges *bool `default:"true" json:"check_privileges"`
	// How often (in seconds) a stream should checkpoint, when possible.
	CheckpointTargetIntervalSeconds *int64 `default:"300" json:"checkpoint_target_interval_seconds"`
	// Maximum number of concurrent queries to the database.
	Concurrency *int64 `json:"concurrency,omitempty"`
	// The name of the database.
	Database *string `json:"database,omitempty"`
	// The hostname of the database.
	Host *string `json:"host,omitempty"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// The password associated with the username.
	Password *string `json:"password,omitempty"`
	// The port of the database.
	Port *int64 `default:"1433" json:"port"`
	// Configures how data is extracted from the database.
	ReplicationMethod *SourceMssqlUpdateUpdateMethod `json:"replication_method,omitempty"`
	// The list of schemas to sync from. If not specified, all schemas will be discovered. Case sensitive.
	Schemas []string `json:"schemas,omitempty"`
	// The encryption method which is used when communicating with the database.
	SslMode *SourceMssqlUpdateEncryption `json:"ssl_mode,omitempty"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod *SourceMssqlUpdateSSHTunnelMethod `json:"tunnel_method,omitempty"`
	// The username which is used to access the database.
	Username              *string                      `json:"username,omitempty"`
	sourceType            *SourceMssqlUpdateSourceType `const:"mssql" json:"sourceType"`
	AdditionalProperties1 any                          `additionalProperties:"true" json:"-"`
}

func (s SourceMssqlUpdate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMssqlUpdate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceMssqlUpdate) GetAdditionalProperties() map[string]map[string]any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

func (s *SourceMssqlUpdate) GetCheckPrivileges() *bool {
	if s == nil {
		return nil
	}
	return s.CheckPrivileges
}

func (s *SourceMssqlUpdate) GetCheckpointTargetIntervalSeconds() *int64 {
	if s == nil {
		return nil
	}
	return s.CheckpointTargetIntervalSeconds
}

func (s *SourceMssqlUpdate) GetConcurrency() *int64 {
	if s == nil {
		return nil
	}
	return s.Concurrency
}

func (s *SourceMssqlUpdate) GetDatabase() *string {
	if s == nil {
		return nil
	}
	return s.Database
}

func (s *SourceMssqlUpdate) GetHost() *string {
	if s == nil {
		return nil
	}
	return s.Host
}

func (s *SourceMssqlUpdate) GetJdbcURLParams() *string {
	if s == nil {
		return nil
	}
	return s.JdbcURLParams
}

func (s *SourceMssqlUpdate) GetPassword() *string {
	if s == nil {
		return nil
	}
	return s.Password
}

func (s *SourceMssqlUpdate) GetPort() *int64 {
	if s == nil {
		return nil
	}
	return s.Port
}

func (s *SourceMssqlUpdate) GetReplicationMethod() *SourceMssqlUpdateUpdateMethod {
	if s == nil {
		return nil
	}
	return s.ReplicationMethod
}

func (s *SourceMssqlUpdate) GetSchemas() []string {
	if s == nil {
		return nil
	}
	return s.Schemas
}

func (s *SourceMssqlUpdate) GetSslMode() *SourceMssqlUpdateEncryption {
	if s == nil {
		return nil
	}
	return s.SslMode
}

func (s *SourceMssqlUpdate) GetTunnelMethod() *SourceMssqlUpdateSSHTunnelMethod {
	if s == nil {
		return nil
	}
	return s.TunnelMethod
}

func (s *SourceMssqlUpdate) GetUsername() *string {
	if s == nil {
		return nil
	}
	return s.Username
}

func (s *SourceMssqlUpdate) GetSourceType() *SourceMssqlUpdateSourceType {
	return SourceMssqlUpdateSourceTypeMssql.ToPointer()
}

func (s *SourceMssqlUpdate) GetAdditionalProperties1() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties1
}
