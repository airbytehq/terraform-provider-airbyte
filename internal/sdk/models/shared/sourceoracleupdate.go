// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/types"
)

// SourceOracleUpdateSystemIDSID - Use SID (Oracle System Identifier)
type SourceOracleUpdateSystemIDSID struct {
	connectionType *string `const:"sid" json:"connection_type,omitempty"`
	Sid            *string `json:"sid,omitempty"`
}

func (s SourceOracleUpdateSystemIDSID) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceOracleUpdateSystemIDSID) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceOracleUpdateSystemIDSID) GetConnectionType() *string {
	return types.Pointer("sid")
}

func (s *SourceOracleUpdateSystemIDSID) GetSid() *string {
	if s == nil {
		return nil
	}
	return s.Sid
}

// SourceOracleUpdateServiceName - Use service name
type SourceOracleUpdateServiceName struct {
	connectionType *string `const:"service_name" json:"connection_type,omitempty"`
	ServiceName    *string `json:"service_name,omitempty"`
}

func (s SourceOracleUpdateServiceName) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceOracleUpdateServiceName) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceOracleUpdateServiceName) GetConnectionType() *string {
	return types.Pointer("service_name")
}

func (s *SourceOracleUpdateServiceName) GetServiceName() *string {
	if s == nil {
		return nil
	}
	return s.ServiceName
}

type SourceOracleUpdateConnectByType string

const (
	SourceOracleUpdateConnectByTypeSourceOracleUpdateServiceName SourceOracleUpdateConnectByType = "source-oracle-update_Service name"
	SourceOracleUpdateConnectByTypeSourceOracleUpdateSystemIDSID SourceOracleUpdateConnectByType = "source-oracle-update_System ID (SID)"
)

// SourceOracleUpdateConnectBy - Connect data that will be used for DB connection
type SourceOracleUpdateConnectBy struct {
	SourceOracleUpdateServiceName *SourceOracleUpdateServiceName `queryParam:"inline" union:"member"`
	SourceOracleUpdateSystemIDSID *SourceOracleUpdateSystemIDSID `queryParam:"inline" union:"member"`

	Type SourceOracleUpdateConnectByType
}

func CreateSourceOracleUpdateConnectBySourceOracleUpdateServiceName(sourceOracleUpdateServiceName SourceOracleUpdateServiceName) SourceOracleUpdateConnectBy {
	typ := SourceOracleUpdateConnectByTypeSourceOracleUpdateServiceName

	return SourceOracleUpdateConnectBy{
		SourceOracleUpdateServiceName: &sourceOracleUpdateServiceName,
		Type:                          typ,
	}
}

func CreateSourceOracleUpdateConnectBySourceOracleUpdateSystemIDSID(sourceOracleUpdateSystemIDSID SourceOracleUpdateSystemIDSID) SourceOracleUpdateConnectBy {
	typ := SourceOracleUpdateConnectByTypeSourceOracleUpdateSystemIDSID

	return SourceOracleUpdateConnectBy{
		SourceOracleUpdateSystemIDSID: &sourceOracleUpdateSystemIDSID,
		Type:                          typ,
	}
}

func (u *SourceOracleUpdateConnectBy) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var sourceOracleUpdateServiceName SourceOracleUpdateServiceName = SourceOracleUpdateServiceName{}
	if err := utils.UnmarshalJSON(data, &sourceOracleUpdateServiceName, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceOracleUpdateConnectByTypeSourceOracleUpdateServiceName,
			Value: &sourceOracleUpdateServiceName,
		})
	}

	var sourceOracleUpdateSystemIDSID SourceOracleUpdateSystemIDSID = SourceOracleUpdateSystemIDSID{}
	if err := utils.UnmarshalJSON(data, &sourceOracleUpdateSystemIDSID, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceOracleUpdateConnectByTypeSourceOracleUpdateSystemIDSID,
			Value: &sourceOracleUpdateSystemIDSID,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceOracleUpdateConnectBy", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceOracleUpdateConnectBy", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceOracleUpdateConnectByType)
	switch best.Type {
	case SourceOracleUpdateConnectByTypeSourceOracleUpdateServiceName:
		u.SourceOracleUpdateServiceName = best.Value.(*SourceOracleUpdateServiceName)
		return nil
	case SourceOracleUpdateConnectByTypeSourceOracleUpdateSystemIDSID:
		u.SourceOracleUpdateSystemIDSID = best.Value.(*SourceOracleUpdateSystemIDSID)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceOracleUpdateConnectBy", string(data))
}

func (u SourceOracleUpdateConnectBy) MarshalJSON() ([]byte, error) {
	if u.SourceOracleUpdateServiceName != nil {
		return utils.MarshalJSON(u.SourceOracleUpdateServiceName, "", true)
	}

	if u.SourceOracleUpdateSystemIDSID != nil {
		return utils.MarshalJSON(u.SourceOracleUpdateSystemIDSID, "", true)
	}

	return nil, errors.New("could not marshal union type SourceOracleUpdateConnectBy: all fields are null")
}

// SourceOracleUpdateTLSEncryptedVerifyCertificate - Verify and use the certificate provided by the server.
type SourceOracleUpdateTLSEncryptedVerifyCertificate struct {
	encryptionMethod *string `const:"encrypted_verify_certificate" json:"encryption_method,omitempty"`
	// Privacy Enhanced Mail (PEM) files are concatenated certificate containers frequently used in certificate installations.
	SslCertificate *string `json:"ssl_certificate,omitempty"`
}

func (s SourceOracleUpdateTLSEncryptedVerifyCertificate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceOracleUpdateTLSEncryptedVerifyCertificate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceOracleUpdateTLSEncryptedVerifyCertificate) GetEncryptionMethod() *string {
	return types.Pointer("encrypted_verify_certificate")
}

func (s *SourceOracleUpdateTLSEncryptedVerifyCertificate) GetSslCertificate() *string {
	if s == nil {
		return nil
	}
	return s.SslCertificate
}

// SourceOracleUpdateEncryptionAlgorithm - This parameter defines what encryption algorithm is used.
type SourceOracleUpdateEncryptionAlgorithm string

const (
	SourceOracleUpdateEncryptionAlgorithmAes256      SourceOracleUpdateEncryptionAlgorithm = "AES256"
	SourceOracleUpdateEncryptionAlgorithmRc456       SourceOracleUpdateEncryptionAlgorithm = "RC4_56"
	SourceOracleUpdateEncryptionAlgorithmThreeDes168 SourceOracleUpdateEncryptionAlgorithm = "3DES168"
)

func (e SourceOracleUpdateEncryptionAlgorithm) ToPointer() *SourceOracleUpdateEncryptionAlgorithm {
	return &e
}
func (e *SourceOracleUpdateEncryptionAlgorithm) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "AES256":
		fallthrough
	case "RC4_56":
		fallthrough
	case "3DES168":
		*e = SourceOracleUpdateEncryptionAlgorithm(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceOracleUpdateEncryptionAlgorithm: %v", v)
	}
}

// SourceOracleUpdateNativeNetworkEncryptionNNE - The native network encryption gives you the ability to encrypt database connections, without the configuration overhead of TCP/IP and SSL/TLS and without the need to open and listen on different ports.
type SourceOracleUpdateNativeNetworkEncryptionNNE struct {
	// This parameter defines what encryption algorithm is used.
	EncryptionAlgorithm *SourceOracleUpdateEncryptionAlgorithm `default:"AES256" json:"encryption_algorithm"`
	encryptionMethod    *string                                `const:"client_nne" json:"encryption_method,omitempty"`
}

func (s SourceOracleUpdateNativeNetworkEncryptionNNE) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceOracleUpdateNativeNetworkEncryptionNNE) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceOracleUpdateNativeNetworkEncryptionNNE) GetEncryptionAlgorithm() *SourceOracleUpdateEncryptionAlgorithm {
	if s == nil {
		return nil
	}
	return s.EncryptionAlgorithm
}

func (s *SourceOracleUpdateNativeNetworkEncryptionNNE) GetEncryptionMethod() *string {
	return types.Pointer("client_nne")
}

// SourceOracleUpdateUnencrypted - Data transfer will not be encrypted.
type SourceOracleUpdateUnencrypted struct {
	encryptionMethod *string `const:"unencrypted" json:"encryption_method,omitempty"`
}

func (s SourceOracleUpdateUnencrypted) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceOracleUpdateUnencrypted) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceOracleUpdateUnencrypted) GetEncryptionMethod() *string {
	return types.Pointer("unencrypted")
}

type SourceOracleUpdateEncryptionType string

const (
	SourceOracleUpdateEncryptionTypeSourceOracleUpdateUnencrypted                   SourceOracleUpdateEncryptionType = "source-oracle-update_Unencrypted"
	SourceOracleUpdateEncryptionTypeSourceOracleUpdateNativeNetworkEncryptionNNE    SourceOracleUpdateEncryptionType = "source-oracle-update_Native Network Encryption (NNE)"
	SourceOracleUpdateEncryptionTypeSourceOracleUpdateTLSEncryptedVerifyCertificate SourceOracleUpdateEncryptionType = "source-oracle-update_TLS Encrypted (verify certificate)"
)

// SourceOracleUpdateEncryption - The encryption method with is used when communicating with the database.
type SourceOracleUpdateEncryption struct {
	SourceOracleUpdateUnencrypted                   *SourceOracleUpdateUnencrypted                   `queryParam:"inline" union:"member"`
	SourceOracleUpdateNativeNetworkEncryptionNNE    *SourceOracleUpdateNativeNetworkEncryptionNNE    `queryParam:"inline" union:"member"`
	SourceOracleUpdateTLSEncryptedVerifyCertificate *SourceOracleUpdateTLSEncryptedVerifyCertificate `queryParam:"inline" union:"member"`

	Type SourceOracleUpdateEncryptionType
}

func CreateSourceOracleUpdateEncryptionSourceOracleUpdateUnencrypted(sourceOracleUpdateUnencrypted SourceOracleUpdateUnencrypted) SourceOracleUpdateEncryption {
	typ := SourceOracleUpdateEncryptionTypeSourceOracleUpdateUnencrypted

	return SourceOracleUpdateEncryption{
		SourceOracleUpdateUnencrypted: &sourceOracleUpdateUnencrypted,
		Type:                          typ,
	}
}

func CreateSourceOracleUpdateEncryptionSourceOracleUpdateNativeNetworkEncryptionNNE(sourceOracleUpdateNativeNetworkEncryptionNNE SourceOracleUpdateNativeNetworkEncryptionNNE) SourceOracleUpdateEncryption {
	typ := SourceOracleUpdateEncryptionTypeSourceOracleUpdateNativeNetworkEncryptionNNE

	return SourceOracleUpdateEncryption{
		SourceOracleUpdateNativeNetworkEncryptionNNE: &sourceOracleUpdateNativeNetworkEncryptionNNE,
		Type: typ,
	}
}

func CreateSourceOracleUpdateEncryptionSourceOracleUpdateTLSEncryptedVerifyCertificate(sourceOracleUpdateTLSEncryptedVerifyCertificate SourceOracleUpdateTLSEncryptedVerifyCertificate) SourceOracleUpdateEncryption {
	typ := SourceOracleUpdateEncryptionTypeSourceOracleUpdateTLSEncryptedVerifyCertificate

	return SourceOracleUpdateEncryption{
		SourceOracleUpdateTLSEncryptedVerifyCertificate: &sourceOracleUpdateTLSEncryptedVerifyCertificate,
		Type: typ,
	}
}

func (u *SourceOracleUpdateEncryption) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var sourceOracleUpdateUnencrypted SourceOracleUpdateUnencrypted = SourceOracleUpdateUnencrypted{}
	if err := utils.UnmarshalJSON(data, &sourceOracleUpdateUnencrypted, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceOracleUpdateEncryptionTypeSourceOracleUpdateUnencrypted,
			Value: &sourceOracleUpdateUnencrypted,
		})
	}

	var sourceOracleUpdateNativeNetworkEncryptionNNE SourceOracleUpdateNativeNetworkEncryptionNNE = SourceOracleUpdateNativeNetworkEncryptionNNE{}
	if err := utils.UnmarshalJSON(data, &sourceOracleUpdateNativeNetworkEncryptionNNE, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceOracleUpdateEncryptionTypeSourceOracleUpdateNativeNetworkEncryptionNNE,
			Value: &sourceOracleUpdateNativeNetworkEncryptionNNE,
		})
	}

	var sourceOracleUpdateTLSEncryptedVerifyCertificate SourceOracleUpdateTLSEncryptedVerifyCertificate = SourceOracleUpdateTLSEncryptedVerifyCertificate{}
	if err := utils.UnmarshalJSON(data, &sourceOracleUpdateTLSEncryptedVerifyCertificate, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceOracleUpdateEncryptionTypeSourceOracleUpdateTLSEncryptedVerifyCertificate,
			Value: &sourceOracleUpdateTLSEncryptedVerifyCertificate,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceOracleUpdateEncryption", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceOracleUpdateEncryption", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceOracleUpdateEncryptionType)
	switch best.Type {
	case SourceOracleUpdateEncryptionTypeSourceOracleUpdateUnencrypted:
		u.SourceOracleUpdateUnencrypted = best.Value.(*SourceOracleUpdateUnencrypted)
		return nil
	case SourceOracleUpdateEncryptionTypeSourceOracleUpdateNativeNetworkEncryptionNNE:
		u.SourceOracleUpdateNativeNetworkEncryptionNNE = best.Value.(*SourceOracleUpdateNativeNetworkEncryptionNNE)
		return nil
	case SourceOracleUpdateEncryptionTypeSourceOracleUpdateTLSEncryptedVerifyCertificate:
		u.SourceOracleUpdateTLSEncryptedVerifyCertificate = best.Value.(*SourceOracleUpdateTLSEncryptedVerifyCertificate)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceOracleUpdateEncryption", string(data))
}

func (u SourceOracleUpdateEncryption) MarshalJSON() ([]byte, error) {
	if u.SourceOracleUpdateUnencrypted != nil {
		return utils.MarshalJSON(u.SourceOracleUpdateUnencrypted, "", true)
	}

	if u.SourceOracleUpdateNativeNetworkEncryptionNNE != nil {
		return utils.MarshalJSON(u.SourceOracleUpdateNativeNetworkEncryptionNNE, "", true)
	}

	if u.SourceOracleUpdateTLSEncryptedVerifyCertificate != nil {
		return utils.MarshalJSON(u.SourceOracleUpdateTLSEncryptedVerifyCertificate, "", true)
	}

	return nil, errors.New("could not marshal union type SourceOracleUpdateEncryption: all fields are null")
}

type SourceOracleUpdatePasswordAuthentication struct {
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost *string `json:"tunnel_host,omitempty"`
	// Connect through a jump server tunnel host using username and password authentication
	tunnelMethod *string `const:"SSH_PASSWORD_AUTH" json:"tunnel_method,omitempty"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser *string `json:"tunnel_user,omitempty"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword *string `json:"tunnel_user_password,omitempty"`
}

func (s SourceOracleUpdatePasswordAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceOracleUpdatePasswordAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceOracleUpdatePasswordAuthentication) GetTunnelHost() *string {
	if s == nil {
		return nil
	}
	return s.TunnelHost
}

func (s *SourceOracleUpdatePasswordAuthentication) GetTunnelMethod() *string {
	return types.Pointer("SSH_PASSWORD_AUTH")
}

func (s *SourceOracleUpdatePasswordAuthentication) GetTunnelPort() *int64 {
	if s == nil {
		return nil
	}
	return s.TunnelPort
}

func (s *SourceOracleUpdatePasswordAuthentication) GetTunnelUser() *string {
	if s == nil {
		return nil
	}
	return s.TunnelUser
}

func (s *SourceOracleUpdatePasswordAuthentication) GetTunnelUserPassword() *string {
	if s == nil {
		return nil
	}
	return s.TunnelUserPassword
}

type SourceOracleUpdateSSHKeyAuthentication struct {
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey *string `json:"ssh_key,omitempty"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost *string `json:"tunnel_host,omitempty"`
	// Connect through a jump server tunnel host using username and ssh key
	tunnelMethod *string `const:"SSH_KEY_AUTH" json:"tunnel_method,omitempty"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host.
	TunnelUser *string `json:"tunnel_user,omitempty"`
}

func (s SourceOracleUpdateSSHKeyAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceOracleUpdateSSHKeyAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceOracleUpdateSSHKeyAuthentication) GetSSHKey() *string {
	if s == nil {
		return nil
	}
	return s.SSHKey
}

func (s *SourceOracleUpdateSSHKeyAuthentication) GetTunnelHost() *string {
	if s == nil {
		return nil
	}
	return s.TunnelHost
}

func (s *SourceOracleUpdateSSHKeyAuthentication) GetTunnelMethod() *string {
	return types.Pointer("SSH_KEY_AUTH")
}

func (s *SourceOracleUpdateSSHKeyAuthentication) GetTunnelPort() *int64 {
	if s == nil {
		return nil
	}
	return s.TunnelPort
}

func (s *SourceOracleUpdateSSHKeyAuthentication) GetTunnelUser() *string {
	if s == nil {
		return nil
	}
	return s.TunnelUser
}

type SourceOracleUpdateNoTunnel struct {
	// No ssh tunnel needed to connect to database
	tunnelMethod *string `const:"NO_TUNNEL" json:"tunnel_method,omitempty"`
}

func (s SourceOracleUpdateNoTunnel) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceOracleUpdateNoTunnel) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceOracleUpdateNoTunnel) GetTunnelMethod() *string {
	return types.Pointer("NO_TUNNEL")
}

type SourceOracleUpdateSSHTunnelMethodType string

const (
	SourceOracleUpdateSSHTunnelMethodTypeSourceOracleUpdateNoTunnel               SourceOracleUpdateSSHTunnelMethodType = "source-oracle-update_No Tunnel"
	SourceOracleUpdateSSHTunnelMethodTypeSourceOracleUpdateSSHKeyAuthentication   SourceOracleUpdateSSHTunnelMethodType = "source-oracle-update_SSH Key Authentication"
	SourceOracleUpdateSSHTunnelMethodTypeSourceOracleUpdatePasswordAuthentication SourceOracleUpdateSSHTunnelMethodType = "source-oracle-update_Password Authentication"
)

// SourceOracleUpdateSSHTunnelMethod - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceOracleUpdateSSHTunnelMethod struct {
	SourceOracleUpdateNoTunnel               *SourceOracleUpdateNoTunnel               `queryParam:"inline" union:"member"`
	SourceOracleUpdateSSHKeyAuthentication   *SourceOracleUpdateSSHKeyAuthentication   `queryParam:"inline" union:"member"`
	SourceOracleUpdatePasswordAuthentication *SourceOracleUpdatePasswordAuthentication `queryParam:"inline" union:"member"`

	Type SourceOracleUpdateSSHTunnelMethodType
}

func CreateSourceOracleUpdateSSHTunnelMethodSourceOracleUpdateNoTunnel(sourceOracleUpdateNoTunnel SourceOracleUpdateNoTunnel) SourceOracleUpdateSSHTunnelMethod {
	typ := SourceOracleUpdateSSHTunnelMethodTypeSourceOracleUpdateNoTunnel

	return SourceOracleUpdateSSHTunnelMethod{
		SourceOracleUpdateNoTunnel: &sourceOracleUpdateNoTunnel,
		Type:                       typ,
	}
}

func CreateSourceOracleUpdateSSHTunnelMethodSourceOracleUpdateSSHKeyAuthentication(sourceOracleUpdateSSHKeyAuthentication SourceOracleUpdateSSHKeyAuthentication) SourceOracleUpdateSSHTunnelMethod {
	typ := SourceOracleUpdateSSHTunnelMethodTypeSourceOracleUpdateSSHKeyAuthentication

	return SourceOracleUpdateSSHTunnelMethod{
		SourceOracleUpdateSSHKeyAuthentication: &sourceOracleUpdateSSHKeyAuthentication,
		Type:                                   typ,
	}
}

func CreateSourceOracleUpdateSSHTunnelMethodSourceOracleUpdatePasswordAuthentication(sourceOracleUpdatePasswordAuthentication SourceOracleUpdatePasswordAuthentication) SourceOracleUpdateSSHTunnelMethod {
	typ := SourceOracleUpdateSSHTunnelMethodTypeSourceOracleUpdatePasswordAuthentication

	return SourceOracleUpdateSSHTunnelMethod{
		SourceOracleUpdatePasswordAuthentication: &sourceOracleUpdatePasswordAuthentication,
		Type:                                     typ,
	}
}

func (u *SourceOracleUpdateSSHTunnelMethod) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var sourceOracleUpdateNoTunnel SourceOracleUpdateNoTunnel = SourceOracleUpdateNoTunnel{}
	if err := utils.UnmarshalJSON(data, &sourceOracleUpdateNoTunnel, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceOracleUpdateSSHTunnelMethodTypeSourceOracleUpdateNoTunnel,
			Value: &sourceOracleUpdateNoTunnel,
		})
	}

	var sourceOracleUpdateSSHKeyAuthentication SourceOracleUpdateSSHKeyAuthentication = SourceOracleUpdateSSHKeyAuthentication{}
	if err := utils.UnmarshalJSON(data, &sourceOracleUpdateSSHKeyAuthentication, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceOracleUpdateSSHTunnelMethodTypeSourceOracleUpdateSSHKeyAuthentication,
			Value: &sourceOracleUpdateSSHKeyAuthentication,
		})
	}

	var sourceOracleUpdatePasswordAuthentication SourceOracleUpdatePasswordAuthentication = SourceOracleUpdatePasswordAuthentication{}
	if err := utils.UnmarshalJSON(data, &sourceOracleUpdatePasswordAuthentication, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceOracleUpdateSSHTunnelMethodTypeSourceOracleUpdatePasswordAuthentication,
			Value: &sourceOracleUpdatePasswordAuthentication,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceOracleUpdateSSHTunnelMethod", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceOracleUpdateSSHTunnelMethod", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceOracleUpdateSSHTunnelMethodType)
	switch best.Type {
	case SourceOracleUpdateSSHTunnelMethodTypeSourceOracleUpdateNoTunnel:
		u.SourceOracleUpdateNoTunnel = best.Value.(*SourceOracleUpdateNoTunnel)
		return nil
	case SourceOracleUpdateSSHTunnelMethodTypeSourceOracleUpdateSSHKeyAuthentication:
		u.SourceOracleUpdateSSHKeyAuthentication = best.Value.(*SourceOracleUpdateSSHKeyAuthentication)
		return nil
	case SourceOracleUpdateSSHTunnelMethodTypeSourceOracleUpdatePasswordAuthentication:
		u.SourceOracleUpdatePasswordAuthentication = best.Value.(*SourceOracleUpdatePasswordAuthentication)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceOracleUpdateSSHTunnelMethod", string(data))
}

func (u SourceOracleUpdateSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.SourceOracleUpdateNoTunnel != nil {
		return utils.MarshalJSON(u.SourceOracleUpdateNoTunnel, "", true)
	}

	if u.SourceOracleUpdateSSHKeyAuthentication != nil {
		return utils.MarshalJSON(u.SourceOracleUpdateSSHKeyAuthentication, "", true)
	}

	if u.SourceOracleUpdatePasswordAuthentication != nil {
		return utils.MarshalJSON(u.SourceOracleUpdatePasswordAuthentication, "", true)
	}

	return nil, errors.New("could not marshal union type SourceOracleUpdateSSHTunnelMethod: all fields are null")
}

type SourceOracleUpdateSourceType string

const (
	SourceOracleUpdateSourceTypeOracle SourceOracleUpdateSourceType = "oracle"
)

func (e SourceOracleUpdateSourceType) ToPointer() *SourceOracleUpdateSourceType {
	return &e
}
func (e *SourceOracleUpdateSourceType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "oracle":
		*e = SourceOracleUpdateSourceType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceOracleUpdateSourceType: %v", v)
	}
}

type SourceOracleUpdate struct {
	// Connect data that will be used for DB connection
	ConnectionData *SourceOracleUpdateConnectBy `json:"connection_data,omitempty"`
	// The encryption method with is used when communicating with the database.
	Encryption *SourceOracleUpdateEncryption `json:"encryption,omitempty"`
	// Hostname of the database.
	Host *string `json:"host,omitempty"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// The password associated with the username.
	Password *string `json:"password,omitempty"`
	// Port of the database.
	// Oracle Corporations recommends the following port numbers:
	// 1521 - Default listening port for client connections to the listener.
	// 2484 - Recommended and officially registered listening port for client connections to the listener using TCP/IP with SSL
	Port *int64 `default:"1521" json:"port"`
	// The list of schemas to sync from. Defaults to user. Case sensitive.
	Schemas []string `json:"schemas,omitempty"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod *SourceOracleUpdateSSHTunnelMethod `json:"tunnel_method,omitempty"`
	// The username which is used to access the database.
	Username   *string                       `json:"username,omitempty"`
	sourceType *SourceOracleUpdateSourceType `const:"oracle" json:"sourceType"`
}

func (s SourceOracleUpdate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceOracleUpdate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceOracleUpdate) GetConnectionData() *SourceOracleUpdateConnectBy {
	if s == nil {
		return nil
	}
	return s.ConnectionData
}

func (s *SourceOracleUpdate) GetEncryption() *SourceOracleUpdateEncryption {
	if s == nil {
		return nil
	}
	return s.Encryption
}

func (s *SourceOracleUpdate) GetHost() *string {
	if s == nil {
		return nil
	}
	return s.Host
}

func (s *SourceOracleUpdate) GetJdbcURLParams() *string {
	if s == nil {
		return nil
	}
	return s.JdbcURLParams
}

func (s *SourceOracleUpdate) GetPassword() *string {
	if s == nil {
		return nil
	}
	return s.Password
}

func (s *SourceOracleUpdate) GetPort() *int64 {
	if s == nil {
		return nil
	}
	return s.Port
}

func (s *SourceOracleUpdate) GetSchemas() []string {
	if s == nil {
		return nil
	}
	return s.Schemas
}

func (s *SourceOracleUpdate) GetTunnelMethod() *SourceOracleUpdateSSHTunnelMethod {
	if s == nil {
		return nil
	}
	return s.TunnelMethod
}

func (s *SourceOracleUpdate) GetUsername() *string {
	if s == nil {
		return nil
	}
	return s.Username
}

func (s *SourceOracleUpdate) GetSourceType() *SourceOracleUpdateSourceType {
	return SourceOracleUpdateSourceTypeOracle.ToPointer()
}
