// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

type SourceTidbPasswordAuthentication struct {
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and password authentication
	tunnelMethod string `const:"SSH_PASSWORD_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser string `json:"tunnel_user"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword string `json:"tunnel_user_password"`
}

func (s SourceTidbPasswordAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceTidbPasswordAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceTidbPasswordAuthentication) GetTunnelHost() string {
	if s == nil {
		return ""
	}
	return s.TunnelHost
}

func (s *SourceTidbPasswordAuthentication) GetTunnelMethod() string {
	return "SSH_PASSWORD_AUTH"
}

func (s *SourceTidbPasswordAuthentication) GetTunnelPort() *int64 {
	if s == nil {
		return nil
	}
	return s.TunnelPort
}

func (s *SourceTidbPasswordAuthentication) GetTunnelUser() string {
	if s == nil {
		return ""
	}
	return s.TunnelUser
}

func (s *SourceTidbPasswordAuthentication) GetTunnelUserPassword() string {
	if s == nil {
		return ""
	}
	return s.TunnelUserPassword
}

type SourceTidbSSHKeyAuthentication struct {
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey string `json:"ssh_key"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and ssh key
	tunnelMethod string `const:"SSH_KEY_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host.
	TunnelUser string `json:"tunnel_user"`
}

func (s SourceTidbSSHKeyAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceTidbSSHKeyAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceTidbSSHKeyAuthentication) GetSSHKey() string {
	if s == nil {
		return ""
	}
	return s.SSHKey
}

func (s *SourceTidbSSHKeyAuthentication) GetTunnelHost() string {
	if s == nil {
		return ""
	}
	return s.TunnelHost
}

func (s *SourceTidbSSHKeyAuthentication) GetTunnelMethod() string {
	return "SSH_KEY_AUTH"
}

func (s *SourceTidbSSHKeyAuthentication) GetTunnelPort() *int64 {
	if s == nil {
		return nil
	}
	return s.TunnelPort
}

func (s *SourceTidbSSHKeyAuthentication) GetTunnelUser() string {
	if s == nil {
		return ""
	}
	return s.TunnelUser
}

type SourceTidbNoTunnel struct {
	// No ssh tunnel needed to connect to database
	tunnelMethod string `const:"NO_TUNNEL" json:"tunnel_method"`
}

func (s SourceTidbNoTunnel) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceTidbNoTunnel) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceTidbNoTunnel) GetTunnelMethod() string {
	return "NO_TUNNEL"
}

type SourceTidbSSHTunnelMethodType string

const (
	SourceTidbSSHTunnelMethodTypeSourceTidbNoTunnel               SourceTidbSSHTunnelMethodType = "source-tidb_No Tunnel"
	SourceTidbSSHTunnelMethodTypeSourceTidbSSHKeyAuthentication   SourceTidbSSHTunnelMethodType = "source-tidb_SSH Key Authentication"
	SourceTidbSSHTunnelMethodTypeSourceTidbPasswordAuthentication SourceTidbSSHTunnelMethodType = "source-tidb_Password Authentication"
)

// SourceTidbSSHTunnelMethod - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceTidbSSHTunnelMethod struct {
	SourceTidbNoTunnel               *SourceTidbNoTunnel               `queryParam:"inline" union:"member"`
	SourceTidbSSHKeyAuthentication   *SourceTidbSSHKeyAuthentication   `queryParam:"inline" union:"member"`
	SourceTidbPasswordAuthentication *SourceTidbPasswordAuthentication `queryParam:"inline" union:"member"`

	Type SourceTidbSSHTunnelMethodType
}

func CreateSourceTidbSSHTunnelMethodSourceTidbNoTunnel(sourceTidbNoTunnel SourceTidbNoTunnel) SourceTidbSSHTunnelMethod {
	typ := SourceTidbSSHTunnelMethodTypeSourceTidbNoTunnel

	return SourceTidbSSHTunnelMethod{
		SourceTidbNoTunnel: &sourceTidbNoTunnel,
		Type:               typ,
	}
}

func CreateSourceTidbSSHTunnelMethodSourceTidbSSHKeyAuthentication(sourceTidbSSHKeyAuthentication SourceTidbSSHKeyAuthentication) SourceTidbSSHTunnelMethod {
	typ := SourceTidbSSHTunnelMethodTypeSourceTidbSSHKeyAuthentication

	return SourceTidbSSHTunnelMethod{
		SourceTidbSSHKeyAuthentication: &sourceTidbSSHKeyAuthentication,
		Type:                           typ,
	}
}

func CreateSourceTidbSSHTunnelMethodSourceTidbPasswordAuthentication(sourceTidbPasswordAuthentication SourceTidbPasswordAuthentication) SourceTidbSSHTunnelMethod {
	typ := SourceTidbSSHTunnelMethodTypeSourceTidbPasswordAuthentication

	return SourceTidbSSHTunnelMethod{
		SourceTidbPasswordAuthentication: &sourceTidbPasswordAuthentication,
		Type:                             typ,
	}
}

func (u *SourceTidbSSHTunnelMethod) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var sourceTidbNoTunnel SourceTidbNoTunnel = SourceTidbNoTunnel{}
	if err := utils.UnmarshalJSON(data, &sourceTidbNoTunnel, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceTidbSSHTunnelMethodTypeSourceTidbNoTunnel,
			Value: &sourceTidbNoTunnel,
		})
	}

	var sourceTidbSSHKeyAuthentication SourceTidbSSHKeyAuthentication = SourceTidbSSHKeyAuthentication{}
	if err := utils.UnmarshalJSON(data, &sourceTidbSSHKeyAuthentication, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceTidbSSHTunnelMethodTypeSourceTidbSSHKeyAuthentication,
			Value: &sourceTidbSSHKeyAuthentication,
		})
	}

	var sourceTidbPasswordAuthentication SourceTidbPasswordAuthentication = SourceTidbPasswordAuthentication{}
	if err := utils.UnmarshalJSON(data, &sourceTidbPasswordAuthentication, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceTidbSSHTunnelMethodTypeSourceTidbPasswordAuthentication,
			Value: &sourceTidbPasswordAuthentication,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceTidbSSHTunnelMethod", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceTidbSSHTunnelMethod", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceTidbSSHTunnelMethodType)
	switch best.Type {
	case SourceTidbSSHTunnelMethodTypeSourceTidbNoTunnel:
		u.SourceTidbNoTunnel = best.Value.(*SourceTidbNoTunnel)
		return nil
	case SourceTidbSSHTunnelMethodTypeSourceTidbSSHKeyAuthentication:
		u.SourceTidbSSHKeyAuthentication = best.Value.(*SourceTidbSSHKeyAuthentication)
		return nil
	case SourceTidbSSHTunnelMethodTypeSourceTidbPasswordAuthentication:
		u.SourceTidbPasswordAuthentication = best.Value.(*SourceTidbPasswordAuthentication)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceTidbSSHTunnelMethod", string(data))
}

func (u SourceTidbSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.SourceTidbNoTunnel != nil {
		return utils.MarshalJSON(u.SourceTidbNoTunnel, "", true)
	}

	if u.SourceTidbSSHKeyAuthentication != nil {
		return utils.MarshalJSON(u.SourceTidbSSHKeyAuthentication, "", true)
	}

	if u.SourceTidbPasswordAuthentication != nil {
		return utils.MarshalJSON(u.SourceTidbPasswordAuthentication, "", true)
	}

	return nil, errors.New("could not marshal union type SourceTidbSSHTunnelMethod: all fields are null")
}

type SourceTidbSourceType string

const (
	SourceTidbSourceTypeTidb SourceTidbSourceType = "tidb"
)

func (e SourceTidbSourceType) ToPointer() *SourceTidbSourceType {
	return &e
}
func (e *SourceTidbSourceType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "tidb":
		*e = SourceTidbSourceType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceTidbSourceType: %v", v)
	}
}

type SourceTidb struct {
	// Name of the database.
	Database string `json:"database"`
	// Hostname of the database.
	Host string `json:"host"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3)
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// Password associated with the username.
	Password *string `json:"password,omitempty"`
	// Port of the database.
	Port *int64 `default:"4000" json:"port"`
	// Encrypt data using SSL.
	Ssl *bool `default:"false" json:"ssl"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod *SourceTidbSSHTunnelMethod `json:"tunnel_method,omitempty"`
	// Username to use to access the database.
	Username   string                `json:"username"`
	sourceType *SourceTidbSourceType `const:"tidb" json:"sourceType"`
}

func (s SourceTidb) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceTidb) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceTidb) GetDatabase() string {
	if s == nil {
		return ""
	}
	return s.Database
}

func (s *SourceTidb) GetHost() string {
	if s == nil {
		return ""
	}
	return s.Host
}

func (s *SourceTidb) GetJdbcURLParams() *string {
	if s == nil {
		return nil
	}
	return s.JdbcURLParams
}

func (s *SourceTidb) GetPassword() *string {
	if s == nil {
		return nil
	}
	return s.Password
}

func (s *SourceTidb) GetPort() *int64 {
	if s == nil {
		return nil
	}
	return s.Port
}

func (s *SourceTidb) GetSsl() *bool {
	if s == nil {
		return nil
	}
	return s.Ssl
}

func (s *SourceTidb) GetTunnelMethod() *SourceTidbSSHTunnelMethod {
	if s == nil {
		return nil
	}
	return s.TunnelMethod
}

func (s *SourceTidb) GetUsername() string {
	if s == nil {
		return ""
	}
	return s.Username
}

func (s *SourceTidb) GetSourceType() *SourceTidbSourceType {
	return SourceTidbSourceTypeTidb.ToPointer()
}
