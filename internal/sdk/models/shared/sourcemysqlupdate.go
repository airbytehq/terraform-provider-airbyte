// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

// SourceMysqlUpdateInvalidCDCPositionBehaviorAdvanced - Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value in the mined logs. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss.
type SourceMysqlUpdateInvalidCDCPositionBehaviorAdvanced string

const (
	SourceMysqlUpdateInvalidCDCPositionBehaviorAdvancedFailSync   SourceMysqlUpdateInvalidCDCPositionBehaviorAdvanced = "Fail sync"
	SourceMysqlUpdateInvalidCDCPositionBehaviorAdvancedReSyncData SourceMysqlUpdateInvalidCDCPositionBehaviorAdvanced = "Re-sync data"
)

func (e SourceMysqlUpdateInvalidCDCPositionBehaviorAdvanced) ToPointer() *SourceMysqlUpdateInvalidCDCPositionBehaviorAdvanced {
	return &e
}
func (e *SourceMysqlUpdateInvalidCDCPositionBehaviorAdvanced) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Fail sync":
		fallthrough
	case "Re-sync data":
		*e = SourceMysqlUpdateInvalidCDCPositionBehaviorAdvanced(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlUpdateInvalidCDCPositionBehaviorAdvanced: %v", v)
	}
}

type SourceMysqlUpdateSchemasMethod string

const (
	SourceMysqlUpdateSchemasMethodCdc SourceMysqlUpdateSchemasMethod = "CDC"
)

func (e SourceMysqlUpdateSchemasMethod) ToPointer() *SourceMysqlUpdateSchemasMethod {
	return &e
}
func (e *SourceMysqlUpdateSchemasMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CDC":
		*e = SourceMysqlUpdateSchemasMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlUpdateSchemasMethod: %v", v)
	}
}

// SourceMysqlUpdateReadChangesUsingChangeDataCaptureCDC - <i>Recommended</i> - Incrementally reads new inserts, updates, and deletes using MySQL's <a href="https://docs.airbyte.com/integrations/sources/mssql/#change-data-capture-cdc"> change data capture feature</a>. This must be enabled on your database.
type SourceMysqlUpdateReadChangesUsingChangeDataCaptureCDC struct {
	// The amount of time an initial load is allowed to continue for before catching up on CDC logs.
	InitialLoadTimeoutHours *int64 `default:"8" json:"initial_load_timeout_hours"`
	// Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value in the mined logs. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss.
	InvalidCdcCursorPositionBehavior *SourceMysqlUpdateInvalidCDCPositionBehaviorAdvanced `default:"Fail sync" json:"invalid_cdc_cursor_position_behavior"`
	Method                           *SourceMysqlUpdateSchemasMethod                      `default:"CDC" json:"method"`
	// Enter the configured MySQL server timezone. This should only be done if the configured timezone in your MySQL instance does not conform to IANNA standard.
	ServerTimezone       *string `json:"server_timezone,omitempty"`
	AdditionalProperties any     `additionalProperties:"true" json:"-"`
}

func (s SourceMysqlUpdateReadChangesUsingChangeDataCaptureCDC) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMysqlUpdateReadChangesUsingChangeDataCaptureCDC) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceMysqlUpdateReadChangesUsingChangeDataCaptureCDC) GetInitialLoadTimeoutHours() *int64 {
	if o == nil {
		return nil
	}
	return o.InitialLoadTimeoutHours
}

func (o *SourceMysqlUpdateReadChangesUsingChangeDataCaptureCDC) GetInvalidCdcCursorPositionBehavior() *SourceMysqlUpdateInvalidCDCPositionBehaviorAdvanced {
	if o == nil {
		return nil
	}
	return o.InvalidCdcCursorPositionBehavior
}

func (o *SourceMysqlUpdateReadChangesUsingChangeDataCaptureCDC) GetMethod() *SourceMysqlUpdateSchemasMethod {
	if o == nil {
		return nil
	}
	return o.Method
}

func (o *SourceMysqlUpdateReadChangesUsingChangeDataCaptureCDC) GetServerTimezone() *string {
	if o == nil {
		return nil
	}
	return o.ServerTimezone
}

func (o *SourceMysqlUpdateReadChangesUsingChangeDataCaptureCDC) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

type SourceMysqlUpdateSchemasReplicationMethodMethod string

const (
	SourceMysqlUpdateSchemasReplicationMethodMethodStandard SourceMysqlUpdateSchemasReplicationMethodMethod = "STANDARD"
)

func (e SourceMysqlUpdateSchemasReplicationMethodMethod) ToPointer() *SourceMysqlUpdateSchemasReplicationMethodMethod {
	return &e
}
func (e *SourceMysqlUpdateSchemasReplicationMethodMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "STANDARD":
		*e = SourceMysqlUpdateSchemasReplicationMethodMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlUpdateSchemasReplicationMethodMethod: %v", v)
	}
}

// SourceMysqlUpdateScanChangesWithUserDefinedCursor - Incrementally detects new inserts and updates using the <a href="https://docs.airbyte.com/understanding-airbyte/connections/incremental-append/#user-defined-cursor">cursor column</a> chosen when configuring a connection (e.g. created_at, updated_at).
type SourceMysqlUpdateScanChangesWithUserDefinedCursor struct {
	Method               *SourceMysqlUpdateSchemasReplicationMethodMethod `default:"STANDARD" json:"method"`
	AdditionalProperties any                                              `additionalProperties:"true" json:"-"`
}

func (s SourceMysqlUpdateScanChangesWithUserDefinedCursor) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMysqlUpdateScanChangesWithUserDefinedCursor) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceMysqlUpdateScanChangesWithUserDefinedCursor) GetMethod() *SourceMysqlUpdateSchemasReplicationMethodMethod {
	if o == nil {
		return nil
	}
	return o.Method
}

func (o *SourceMysqlUpdateScanChangesWithUserDefinedCursor) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

type SourceMysqlUpdateUpdateMethodType string

const (
	SourceMysqlUpdateUpdateMethodTypeSourceMysqlUpdateScanChangesWithUserDefinedCursor     SourceMysqlUpdateUpdateMethodType = "source-mysql-update_Scan Changes with User Defined Cursor"
	SourceMysqlUpdateUpdateMethodTypeSourceMysqlUpdateReadChangesUsingChangeDataCaptureCDC SourceMysqlUpdateUpdateMethodType = "source-mysql-update_Read Changes using Change Data Capture (CDC)"
)

// SourceMysqlUpdateUpdateMethod - Configures how data is extracted from the database.
type SourceMysqlUpdateUpdateMethod struct {
	SourceMysqlUpdateScanChangesWithUserDefinedCursor     *SourceMysqlUpdateScanChangesWithUserDefinedCursor     `queryParam:"inline"`
	SourceMysqlUpdateReadChangesUsingChangeDataCaptureCDC *SourceMysqlUpdateReadChangesUsingChangeDataCaptureCDC `queryParam:"inline"`

	Type SourceMysqlUpdateUpdateMethodType
}

func CreateSourceMysqlUpdateUpdateMethodSourceMysqlUpdateScanChangesWithUserDefinedCursor(sourceMysqlUpdateScanChangesWithUserDefinedCursor SourceMysqlUpdateScanChangesWithUserDefinedCursor) SourceMysqlUpdateUpdateMethod {
	typ := SourceMysqlUpdateUpdateMethodTypeSourceMysqlUpdateScanChangesWithUserDefinedCursor

	return SourceMysqlUpdateUpdateMethod{
		SourceMysqlUpdateScanChangesWithUserDefinedCursor: &sourceMysqlUpdateScanChangesWithUserDefinedCursor,
		Type: typ,
	}
}

func CreateSourceMysqlUpdateUpdateMethodSourceMysqlUpdateReadChangesUsingChangeDataCaptureCDC(sourceMysqlUpdateReadChangesUsingChangeDataCaptureCDC SourceMysqlUpdateReadChangesUsingChangeDataCaptureCDC) SourceMysqlUpdateUpdateMethod {
	typ := SourceMysqlUpdateUpdateMethodTypeSourceMysqlUpdateReadChangesUsingChangeDataCaptureCDC

	return SourceMysqlUpdateUpdateMethod{
		SourceMysqlUpdateReadChangesUsingChangeDataCaptureCDC: &sourceMysqlUpdateReadChangesUsingChangeDataCaptureCDC,
		Type: typ,
	}
}

func (u *SourceMysqlUpdateUpdateMethod) UnmarshalJSON(data []byte) error {

	var sourceMysqlUpdateScanChangesWithUserDefinedCursor SourceMysqlUpdateScanChangesWithUserDefinedCursor = SourceMysqlUpdateScanChangesWithUserDefinedCursor{}
	if err := utils.UnmarshalJSON(data, &sourceMysqlUpdateScanChangesWithUserDefinedCursor, "", true, true); err == nil {
		u.SourceMysqlUpdateScanChangesWithUserDefinedCursor = &sourceMysqlUpdateScanChangesWithUserDefinedCursor
		u.Type = SourceMysqlUpdateUpdateMethodTypeSourceMysqlUpdateScanChangesWithUserDefinedCursor
		return nil
	}

	var sourceMysqlUpdateReadChangesUsingChangeDataCaptureCDC SourceMysqlUpdateReadChangesUsingChangeDataCaptureCDC = SourceMysqlUpdateReadChangesUsingChangeDataCaptureCDC{}
	if err := utils.UnmarshalJSON(data, &sourceMysqlUpdateReadChangesUsingChangeDataCaptureCDC, "", true, true); err == nil {
		u.SourceMysqlUpdateReadChangesUsingChangeDataCaptureCDC = &sourceMysqlUpdateReadChangesUsingChangeDataCaptureCDC
		u.Type = SourceMysqlUpdateUpdateMethodTypeSourceMysqlUpdateReadChangesUsingChangeDataCaptureCDC
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMysqlUpdateUpdateMethod", string(data))
}

func (u SourceMysqlUpdateUpdateMethod) MarshalJSON() ([]byte, error) {
	if u.SourceMysqlUpdateScanChangesWithUserDefinedCursor != nil {
		return utils.MarshalJSON(u.SourceMysqlUpdateScanChangesWithUserDefinedCursor, "", true)
	}

	if u.SourceMysqlUpdateReadChangesUsingChangeDataCaptureCDC != nil {
		return utils.MarshalJSON(u.SourceMysqlUpdateReadChangesUsingChangeDataCaptureCDC, "", true)
	}

	return nil, errors.New("could not marshal union type SourceMysqlUpdateUpdateMethod: all fields are null")
}

type SourceMysqlUpdateSchemasSslModeEncryptionMode string

const (
	SourceMysqlUpdateSchemasSslModeEncryptionModeVerifyIdentity SourceMysqlUpdateSchemasSslModeEncryptionMode = "verify_identity"
)

func (e SourceMysqlUpdateSchemasSslModeEncryptionMode) ToPointer() *SourceMysqlUpdateSchemasSslModeEncryptionMode {
	return &e
}
func (e *SourceMysqlUpdateSchemasSslModeEncryptionMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "verify_identity":
		*e = SourceMysqlUpdateSchemasSslModeEncryptionMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlUpdateSchemasSslModeEncryptionMode: %v", v)
	}
}

// SourceMysqlUpdateVerifyIdentity - To always require encryption and verify that the source has a valid SSL certificate.
type SourceMysqlUpdateVerifyIdentity struct {
	// CA certificate
	CaCertificate string `json:"ca_certificate"`
	// Client certificate (this is not a required field, but if you want to use it, you will need to add the Client key as well)
	ClientCertificate *string `json:"client_certificate,omitempty"`
	// Client key (this is not a required field, but if you want to use it, you will need to add the Client certificate as well)
	ClientKey *string `json:"client_key,omitempty"`
	// Password for keystorage. This field is optional. If you do not add it - the password will be generated automatically.
	ClientKeyPassword    *string                                        `json:"client_key_password,omitempty"`
	Mode                 *SourceMysqlUpdateSchemasSslModeEncryptionMode `default:"verify_identity" json:"mode"`
	AdditionalProperties any                                            `additionalProperties:"true" json:"-"`
}

func (s SourceMysqlUpdateVerifyIdentity) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMysqlUpdateVerifyIdentity) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceMysqlUpdateVerifyIdentity) GetCaCertificate() string {
	if o == nil {
		return ""
	}
	return o.CaCertificate
}

func (o *SourceMysqlUpdateVerifyIdentity) GetClientCertificate() *string {
	if o == nil {
		return nil
	}
	return o.ClientCertificate
}

func (o *SourceMysqlUpdateVerifyIdentity) GetClientKey() *string {
	if o == nil {
		return nil
	}
	return o.ClientKey
}

func (o *SourceMysqlUpdateVerifyIdentity) GetClientKeyPassword() *string {
	if o == nil {
		return nil
	}
	return o.ClientKeyPassword
}

func (o *SourceMysqlUpdateVerifyIdentity) GetMode() *SourceMysqlUpdateSchemasSslModeEncryptionMode {
	if o == nil {
		return nil
	}
	return o.Mode
}

func (o *SourceMysqlUpdateVerifyIdentity) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

type SourceMysqlUpdateSchemasSslModeMode string

const (
	SourceMysqlUpdateSchemasSslModeModeVerifyCa SourceMysqlUpdateSchemasSslModeMode = "verify_ca"
)

func (e SourceMysqlUpdateSchemasSslModeMode) ToPointer() *SourceMysqlUpdateSchemasSslModeMode {
	return &e
}
func (e *SourceMysqlUpdateSchemasSslModeMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "verify_ca":
		*e = SourceMysqlUpdateSchemasSslModeMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlUpdateSchemasSslModeMode: %v", v)
	}
}

// SourceMysqlUpdateVerifyCa - To always require encryption and verify that the source has a valid SSL certificate.
type SourceMysqlUpdateVerifyCa struct {
	// CA certificate
	CaCertificate string `json:"ca_certificate"`
	// Client certificate (this is not a required field, but if you want to use it, you will need to add the Client key as well)
	ClientCertificate *string `json:"client_certificate,omitempty"`
	// Client key (this is not a required field, but if you want to use it, you will need to add the Client certificate as well)
	ClientKey *string `json:"client_key,omitempty"`
	// Password for keystorage. This field is optional. If you do not add it - the password will be generated automatically.
	ClientKeyPassword    *string                              `json:"client_key_password,omitempty"`
	Mode                 *SourceMysqlUpdateSchemasSslModeMode `default:"verify_ca" json:"mode"`
	AdditionalProperties any                                  `additionalProperties:"true" json:"-"`
}

func (s SourceMysqlUpdateVerifyCa) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMysqlUpdateVerifyCa) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceMysqlUpdateVerifyCa) GetCaCertificate() string {
	if o == nil {
		return ""
	}
	return o.CaCertificate
}

func (o *SourceMysqlUpdateVerifyCa) GetClientCertificate() *string {
	if o == nil {
		return nil
	}
	return o.ClientCertificate
}

func (o *SourceMysqlUpdateVerifyCa) GetClientKey() *string {
	if o == nil {
		return nil
	}
	return o.ClientKey
}

func (o *SourceMysqlUpdateVerifyCa) GetClientKeyPassword() *string {
	if o == nil {
		return nil
	}
	return o.ClientKeyPassword
}

func (o *SourceMysqlUpdateVerifyCa) GetMode() *SourceMysqlUpdateSchemasSslModeMode {
	if o == nil {
		return nil
	}
	return o.Mode
}

func (o *SourceMysqlUpdateVerifyCa) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

type SourceMysqlUpdateSchemasMode string

const (
	SourceMysqlUpdateSchemasModeRequired SourceMysqlUpdateSchemasMode = "required"
)

func (e SourceMysqlUpdateSchemasMode) ToPointer() *SourceMysqlUpdateSchemasMode {
	return &e
}
func (e *SourceMysqlUpdateSchemasMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "required":
		*e = SourceMysqlUpdateSchemasMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlUpdateSchemasMode: %v", v)
	}
}

// SourceMysqlUpdateRequired - To always require encryption. Note: The connection will fail if the source doesn't support encryption.
type SourceMysqlUpdateRequired struct {
	Mode                 *SourceMysqlUpdateSchemasMode `default:"required" json:"mode"`
	AdditionalProperties any                           `additionalProperties:"true" json:"-"`
}

func (s SourceMysqlUpdateRequired) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMysqlUpdateRequired) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceMysqlUpdateRequired) GetMode() *SourceMysqlUpdateSchemasMode {
	if o == nil {
		return nil
	}
	return o.Mode
}

func (o *SourceMysqlUpdateRequired) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

type SourceMysqlUpdateMode string

const (
	SourceMysqlUpdateModePreferred SourceMysqlUpdateMode = "preferred"
)

func (e SourceMysqlUpdateMode) ToPointer() *SourceMysqlUpdateMode {
	return &e
}
func (e *SourceMysqlUpdateMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "preferred":
		*e = SourceMysqlUpdateMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlUpdateMode: %v", v)
	}
}

// SourceMysqlUpdatePreferred - To allow unencrypted communication only when the source doesn't support encryption.
type SourceMysqlUpdatePreferred struct {
	Mode                 *SourceMysqlUpdateMode `default:"preferred" json:"mode"`
	AdditionalProperties any                    `additionalProperties:"true" json:"-"`
}

func (s SourceMysqlUpdatePreferred) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMysqlUpdatePreferred) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceMysqlUpdatePreferred) GetMode() *SourceMysqlUpdateMode {
	if o == nil {
		return nil
	}
	return o.Mode
}

func (o *SourceMysqlUpdatePreferred) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

type SourceMysqlUpdateEncryptionType string

const (
	SourceMysqlUpdateEncryptionTypeSourceMysqlUpdatePreferred      SourceMysqlUpdateEncryptionType = "source-mysql-update_preferred"
	SourceMysqlUpdateEncryptionTypeSourceMysqlUpdateRequired       SourceMysqlUpdateEncryptionType = "source-mysql-update_required"
	SourceMysqlUpdateEncryptionTypeSourceMysqlUpdateVerifyCa       SourceMysqlUpdateEncryptionType = "source-mysql-update_verify_ca"
	SourceMysqlUpdateEncryptionTypeSourceMysqlUpdateVerifyIdentity SourceMysqlUpdateEncryptionType = "source-mysql-update_verify_identity"
)

// SourceMysqlUpdateEncryption - The encryption method which is used when communicating with the database.
type SourceMysqlUpdateEncryption struct {
	SourceMysqlUpdatePreferred      *SourceMysqlUpdatePreferred      `queryParam:"inline"`
	SourceMysqlUpdateRequired       *SourceMysqlUpdateRequired       `queryParam:"inline"`
	SourceMysqlUpdateVerifyCa       *SourceMysqlUpdateVerifyCa       `queryParam:"inline"`
	SourceMysqlUpdateVerifyIdentity *SourceMysqlUpdateVerifyIdentity `queryParam:"inline"`

	Type SourceMysqlUpdateEncryptionType
}

func CreateSourceMysqlUpdateEncryptionSourceMysqlUpdatePreferred(sourceMysqlUpdatePreferred SourceMysqlUpdatePreferred) SourceMysqlUpdateEncryption {
	typ := SourceMysqlUpdateEncryptionTypeSourceMysqlUpdatePreferred

	return SourceMysqlUpdateEncryption{
		SourceMysqlUpdatePreferred: &sourceMysqlUpdatePreferred,
		Type:                       typ,
	}
}

func CreateSourceMysqlUpdateEncryptionSourceMysqlUpdateRequired(sourceMysqlUpdateRequired SourceMysqlUpdateRequired) SourceMysqlUpdateEncryption {
	typ := SourceMysqlUpdateEncryptionTypeSourceMysqlUpdateRequired

	return SourceMysqlUpdateEncryption{
		SourceMysqlUpdateRequired: &sourceMysqlUpdateRequired,
		Type:                      typ,
	}
}

func CreateSourceMysqlUpdateEncryptionSourceMysqlUpdateVerifyCa(sourceMysqlUpdateVerifyCa SourceMysqlUpdateVerifyCa) SourceMysqlUpdateEncryption {
	typ := SourceMysqlUpdateEncryptionTypeSourceMysqlUpdateVerifyCa

	return SourceMysqlUpdateEncryption{
		SourceMysqlUpdateVerifyCa: &sourceMysqlUpdateVerifyCa,
		Type:                      typ,
	}
}

func CreateSourceMysqlUpdateEncryptionSourceMysqlUpdateVerifyIdentity(sourceMysqlUpdateVerifyIdentity SourceMysqlUpdateVerifyIdentity) SourceMysqlUpdateEncryption {
	typ := SourceMysqlUpdateEncryptionTypeSourceMysqlUpdateVerifyIdentity

	return SourceMysqlUpdateEncryption{
		SourceMysqlUpdateVerifyIdentity: &sourceMysqlUpdateVerifyIdentity,
		Type:                            typ,
	}
}

func (u *SourceMysqlUpdateEncryption) UnmarshalJSON(data []byte) error {

	var sourceMysqlUpdatePreferred SourceMysqlUpdatePreferred = SourceMysqlUpdatePreferred{}
	if err := utils.UnmarshalJSON(data, &sourceMysqlUpdatePreferred, "", true, true); err == nil {
		u.SourceMysqlUpdatePreferred = &sourceMysqlUpdatePreferred
		u.Type = SourceMysqlUpdateEncryptionTypeSourceMysqlUpdatePreferred
		return nil
	}

	var sourceMysqlUpdateRequired SourceMysqlUpdateRequired = SourceMysqlUpdateRequired{}
	if err := utils.UnmarshalJSON(data, &sourceMysqlUpdateRequired, "", true, true); err == nil {
		u.SourceMysqlUpdateRequired = &sourceMysqlUpdateRequired
		u.Type = SourceMysqlUpdateEncryptionTypeSourceMysqlUpdateRequired
		return nil
	}

	var sourceMysqlUpdateVerifyCa SourceMysqlUpdateVerifyCa = SourceMysqlUpdateVerifyCa{}
	if err := utils.UnmarshalJSON(data, &sourceMysqlUpdateVerifyCa, "", true, true); err == nil {
		u.SourceMysqlUpdateVerifyCa = &sourceMysqlUpdateVerifyCa
		u.Type = SourceMysqlUpdateEncryptionTypeSourceMysqlUpdateVerifyCa
		return nil
	}

	var sourceMysqlUpdateVerifyIdentity SourceMysqlUpdateVerifyIdentity = SourceMysqlUpdateVerifyIdentity{}
	if err := utils.UnmarshalJSON(data, &sourceMysqlUpdateVerifyIdentity, "", true, true); err == nil {
		u.SourceMysqlUpdateVerifyIdentity = &sourceMysqlUpdateVerifyIdentity
		u.Type = SourceMysqlUpdateEncryptionTypeSourceMysqlUpdateVerifyIdentity
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMysqlUpdateEncryption", string(data))
}

func (u SourceMysqlUpdateEncryption) MarshalJSON() ([]byte, error) {
	if u.SourceMysqlUpdatePreferred != nil {
		return utils.MarshalJSON(u.SourceMysqlUpdatePreferred, "", true)
	}

	if u.SourceMysqlUpdateRequired != nil {
		return utils.MarshalJSON(u.SourceMysqlUpdateRequired, "", true)
	}

	if u.SourceMysqlUpdateVerifyCa != nil {
		return utils.MarshalJSON(u.SourceMysqlUpdateVerifyCa, "", true)
	}

	if u.SourceMysqlUpdateVerifyIdentity != nil {
		return utils.MarshalJSON(u.SourceMysqlUpdateVerifyIdentity, "", true)
	}

	return nil, errors.New("could not marshal union type SourceMysqlUpdateEncryption: all fields are null")
}

type SourceMysqlUpdateSchemasTunnelMethodTunnelMethod string

const (
	SourceMysqlUpdateSchemasTunnelMethodTunnelMethodSSHPasswordAuth SourceMysqlUpdateSchemasTunnelMethodTunnelMethod = "SSH_PASSWORD_AUTH"
)

func (e SourceMysqlUpdateSchemasTunnelMethodTunnelMethod) ToPointer() *SourceMysqlUpdateSchemasTunnelMethodTunnelMethod {
	return &e
}
func (e *SourceMysqlUpdateSchemasTunnelMethodTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_PASSWORD_AUTH":
		*e = SourceMysqlUpdateSchemasTunnelMethodTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlUpdateSchemasTunnelMethodTunnelMethod: %v", v)
	}
}

// SourceMysqlUpdatePasswordAuthentication - Connect through a jump server tunnel host using username and password authentication
type SourceMysqlUpdatePasswordAuthentication struct {
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost   string                                            `json:"tunnel_host"`
	TunnelMethod *SourceMysqlUpdateSchemasTunnelMethodTunnelMethod `default:"SSH_PASSWORD_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser string `json:"tunnel_user"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword   string `json:"tunnel_user_password"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (s SourceMysqlUpdatePasswordAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMysqlUpdatePasswordAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceMysqlUpdatePasswordAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *SourceMysqlUpdatePasswordAuthentication) GetTunnelMethod() *SourceMysqlUpdateSchemasTunnelMethodTunnelMethod {
	if o == nil {
		return nil
	}
	return o.TunnelMethod
}

func (o *SourceMysqlUpdatePasswordAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *SourceMysqlUpdatePasswordAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

func (o *SourceMysqlUpdatePasswordAuthentication) GetTunnelUserPassword() string {
	if o == nil {
		return ""
	}
	return o.TunnelUserPassword
}

func (o *SourceMysqlUpdatePasswordAuthentication) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

type SourceMysqlUpdateSchemasTunnelMethod string

const (
	SourceMysqlUpdateSchemasTunnelMethodSSHKeyAuth SourceMysqlUpdateSchemasTunnelMethod = "SSH_KEY_AUTH"
)

func (e SourceMysqlUpdateSchemasTunnelMethod) ToPointer() *SourceMysqlUpdateSchemasTunnelMethod {
	return &e
}
func (e *SourceMysqlUpdateSchemasTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_KEY_AUTH":
		*e = SourceMysqlUpdateSchemasTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlUpdateSchemasTunnelMethod: %v", v)
	}
}

// SourceMysqlUpdateSSHKeyAuthentication - Connect through a jump server tunnel host using username and ssh key
type SourceMysqlUpdateSSHKeyAuthentication struct {
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey string `json:"ssh_key"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost   string                                `json:"tunnel_host"`
	TunnelMethod *SourceMysqlUpdateSchemasTunnelMethod `default:"SSH_KEY_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser           string `json:"tunnel_user"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (s SourceMysqlUpdateSSHKeyAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMysqlUpdateSSHKeyAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceMysqlUpdateSSHKeyAuthentication) GetSSHKey() string {
	if o == nil {
		return ""
	}
	return o.SSHKey
}

func (o *SourceMysqlUpdateSSHKeyAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *SourceMysqlUpdateSSHKeyAuthentication) GetTunnelMethod() *SourceMysqlUpdateSchemasTunnelMethod {
	if o == nil {
		return nil
	}
	return o.TunnelMethod
}

func (o *SourceMysqlUpdateSSHKeyAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *SourceMysqlUpdateSSHKeyAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

func (o *SourceMysqlUpdateSSHKeyAuthentication) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

type SourceMysqlUpdateTunnelMethod string

const (
	SourceMysqlUpdateTunnelMethodNoTunnel SourceMysqlUpdateTunnelMethod = "NO_TUNNEL"
)

func (e SourceMysqlUpdateTunnelMethod) ToPointer() *SourceMysqlUpdateTunnelMethod {
	return &e
}
func (e *SourceMysqlUpdateTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NO_TUNNEL":
		*e = SourceMysqlUpdateTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlUpdateTunnelMethod: %v", v)
	}
}

// SourceMysqlUpdateNoTunnel - No ssh tunnel needed to connect to database
type SourceMysqlUpdateNoTunnel struct {
	TunnelMethod         *SourceMysqlUpdateTunnelMethod `default:"NO_TUNNEL" json:"tunnel_method"`
	AdditionalProperties any                            `additionalProperties:"true" json:"-"`
}

func (s SourceMysqlUpdateNoTunnel) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMysqlUpdateNoTunnel) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceMysqlUpdateNoTunnel) GetTunnelMethod() *SourceMysqlUpdateTunnelMethod {
	if o == nil {
		return nil
	}
	return o.TunnelMethod
}

func (o *SourceMysqlUpdateNoTunnel) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

type SourceMysqlUpdateSSHTunnelMethodType string

const (
	SourceMysqlUpdateSSHTunnelMethodTypeSourceMysqlUpdateNoTunnel               SourceMysqlUpdateSSHTunnelMethodType = "source-mysql-update_No Tunnel"
	SourceMysqlUpdateSSHTunnelMethodTypeSourceMysqlUpdateSSHKeyAuthentication   SourceMysqlUpdateSSHTunnelMethodType = "source-mysql-update_SSH Key Authentication"
	SourceMysqlUpdateSSHTunnelMethodTypeSourceMysqlUpdatePasswordAuthentication SourceMysqlUpdateSSHTunnelMethodType = "source-mysql-update_Password Authentication"
)

// SourceMysqlUpdateSSHTunnelMethod - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceMysqlUpdateSSHTunnelMethod struct {
	SourceMysqlUpdateNoTunnel               *SourceMysqlUpdateNoTunnel               `queryParam:"inline"`
	SourceMysqlUpdateSSHKeyAuthentication   *SourceMysqlUpdateSSHKeyAuthentication   `queryParam:"inline"`
	SourceMysqlUpdatePasswordAuthentication *SourceMysqlUpdatePasswordAuthentication `queryParam:"inline"`

	Type SourceMysqlUpdateSSHTunnelMethodType
}

func CreateSourceMysqlUpdateSSHTunnelMethodSourceMysqlUpdateNoTunnel(sourceMysqlUpdateNoTunnel SourceMysqlUpdateNoTunnel) SourceMysqlUpdateSSHTunnelMethod {
	typ := SourceMysqlUpdateSSHTunnelMethodTypeSourceMysqlUpdateNoTunnel

	return SourceMysqlUpdateSSHTunnelMethod{
		SourceMysqlUpdateNoTunnel: &sourceMysqlUpdateNoTunnel,
		Type:                      typ,
	}
}

func CreateSourceMysqlUpdateSSHTunnelMethodSourceMysqlUpdateSSHKeyAuthentication(sourceMysqlUpdateSSHKeyAuthentication SourceMysqlUpdateSSHKeyAuthentication) SourceMysqlUpdateSSHTunnelMethod {
	typ := SourceMysqlUpdateSSHTunnelMethodTypeSourceMysqlUpdateSSHKeyAuthentication

	return SourceMysqlUpdateSSHTunnelMethod{
		SourceMysqlUpdateSSHKeyAuthentication: &sourceMysqlUpdateSSHKeyAuthentication,
		Type:                                  typ,
	}
}

func CreateSourceMysqlUpdateSSHTunnelMethodSourceMysqlUpdatePasswordAuthentication(sourceMysqlUpdatePasswordAuthentication SourceMysqlUpdatePasswordAuthentication) SourceMysqlUpdateSSHTunnelMethod {
	typ := SourceMysqlUpdateSSHTunnelMethodTypeSourceMysqlUpdatePasswordAuthentication

	return SourceMysqlUpdateSSHTunnelMethod{
		SourceMysqlUpdatePasswordAuthentication: &sourceMysqlUpdatePasswordAuthentication,
		Type:                                    typ,
	}
}

func (u *SourceMysqlUpdateSSHTunnelMethod) UnmarshalJSON(data []byte) error {

	var sourceMysqlUpdateNoTunnel SourceMysqlUpdateNoTunnel = SourceMysqlUpdateNoTunnel{}
	if err := utils.UnmarshalJSON(data, &sourceMysqlUpdateNoTunnel, "", true, true); err == nil {
		u.SourceMysqlUpdateNoTunnel = &sourceMysqlUpdateNoTunnel
		u.Type = SourceMysqlUpdateSSHTunnelMethodTypeSourceMysqlUpdateNoTunnel
		return nil
	}

	var sourceMysqlUpdateSSHKeyAuthentication SourceMysqlUpdateSSHKeyAuthentication = SourceMysqlUpdateSSHKeyAuthentication{}
	if err := utils.UnmarshalJSON(data, &sourceMysqlUpdateSSHKeyAuthentication, "", true, true); err == nil {
		u.SourceMysqlUpdateSSHKeyAuthentication = &sourceMysqlUpdateSSHKeyAuthentication
		u.Type = SourceMysqlUpdateSSHTunnelMethodTypeSourceMysqlUpdateSSHKeyAuthentication
		return nil
	}

	var sourceMysqlUpdatePasswordAuthentication SourceMysqlUpdatePasswordAuthentication = SourceMysqlUpdatePasswordAuthentication{}
	if err := utils.UnmarshalJSON(data, &sourceMysqlUpdatePasswordAuthentication, "", true, true); err == nil {
		u.SourceMysqlUpdatePasswordAuthentication = &sourceMysqlUpdatePasswordAuthentication
		u.Type = SourceMysqlUpdateSSHTunnelMethodTypeSourceMysqlUpdatePasswordAuthentication
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMysqlUpdateSSHTunnelMethod", string(data))
}

func (u SourceMysqlUpdateSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.SourceMysqlUpdateNoTunnel != nil {
		return utils.MarshalJSON(u.SourceMysqlUpdateNoTunnel, "", true)
	}

	if u.SourceMysqlUpdateSSHKeyAuthentication != nil {
		return utils.MarshalJSON(u.SourceMysqlUpdateSSHKeyAuthentication, "", true)
	}

	if u.SourceMysqlUpdatePasswordAuthentication != nil {
		return utils.MarshalJSON(u.SourceMysqlUpdatePasswordAuthentication, "", true)
	}

	return nil, errors.New("could not marshal union type SourceMysqlUpdateSSHTunnelMethod: all fields are null")
}

type SourceMysqlUpdate struct {
	// When this feature is enabled, during schema discovery the connector will query each table or view individually to check access privileges and inaccessible tables, views, or columns therein will be removed. In large schemas, this might cause schema discovery to take too long, in which case it might be advisable to disable this feature.
	CheckPrivileges *bool `default:"true" json:"check_privileges"`
	// How often (in seconds) a stream should checkpoint, when possible.
	CheckpointTargetIntervalSeconds *int64 `default:"300" json:"checkpoint_target_interval_seconds"`
	// Maximum number of concurrent queries to the database.
	Concurrency *int64 `default:"1" json:"concurrency"`
	// The database name.
	Database string `json:"database"`
	// Hostname of the database.
	Host string `json:"host"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// The password associated with the username.
	Password *string `json:"password,omitempty"`
	// Port of the database.
	Port *int64 `default:"3306" json:"port"`
	// Configures how data is extracted from the database.
	ReplicationMethod SourceMysqlUpdateUpdateMethod `json:"replication_method"`
	// The encryption method which is used when communicating with the database.
	SslMode *SourceMysqlUpdateEncryption `json:"ssl_mode,omitempty"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod *SourceMysqlUpdateSSHTunnelMethod `json:"tunnel_method,omitempty"`
	// The username which is used to access the database.
	Username string `json:"username"`
}

func (s SourceMysqlUpdate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMysqlUpdate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *SourceMysqlUpdate) GetCheckPrivileges() *bool {
	if o == nil {
		return nil
	}
	return o.CheckPrivileges
}

func (o *SourceMysqlUpdate) GetCheckpointTargetIntervalSeconds() *int64 {
	if o == nil {
		return nil
	}
	return o.CheckpointTargetIntervalSeconds
}

func (o *SourceMysqlUpdate) GetConcurrency() *int64 {
	if o == nil {
		return nil
	}
	return o.Concurrency
}

func (o *SourceMysqlUpdate) GetDatabase() string {
	if o == nil {
		return ""
	}
	return o.Database
}

func (o *SourceMysqlUpdate) GetHost() string {
	if o == nil {
		return ""
	}
	return o.Host
}

func (o *SourceMysqlUpdate) GetJdbcURLParams() *string {
	if o == nil {
		return nil
	}
	return o.JdbcURLParams
}

func (o *SourceMysqlUpdate) GetPassword() *string {
	if o == nil {
		return nil
	}
	return o.Password
}

func (o *SourceMysqlUpdate) GetPort() *int64 {
	if o == nil {
		return nil
	}
	return o.Port
}

func (o *SourceMysqlUpdate) GetReplicationMethod() SourceMysqlUpdateUpdateMethod {
	if o == nil {
		return SourceMysqlUpdateUpdateMethod{}
	}
	return o.ReplicationMethod
}

func (o *SourceMysqlUpdate) GetSslMode() *SourceMysqlUpdateEncryption {
	if o == nil {
		return nil
	}
	return o.SslMode
}

func (o *SourceMysqlUpdate) GetTunnelMethod() *SourceMysqlUpdateSSHTunnelMethod {
	if o == nil {
		return nil
	}
	return o.TunnelMethod
}

func (o *SourceMysqlUpdate) GetUsername() string {
	if o == nil {
		return ""
	}
	return o.Username
}
