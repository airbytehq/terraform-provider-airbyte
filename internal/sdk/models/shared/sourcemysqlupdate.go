// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

// SourceMysqlUpdateInvalidCDCPositionBehaviorAdvanced - Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value in the mined logs. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss.
type SourceMysqlUpdateInvalidCDCPositionBehaviorAdvanced string

const (
	SourceMysqlUpdateInvalidCDCPositionBehaviorAdvancedFailSync   SourceMysqlUpdateInvalidCDCPositionBehaviorAdvanced = "Fail sync"
	SourceMysqlUpdateInvalidCDCPositionBehaviorAdvancedReSyncData SourceMysqlUpdateInvalidCDCPositionBehaviorAdvanced = "Re-sync data"
)

func (e SourceMysqlUpdateInvalidCDCPositionBehaviorAdvanced) ToPointer() *SourceMysqlUpdateInvalidCDCPositionBehaviorAdvanced {
	return &e
}
func (e *SourceMysqlUpdateInvalidCDCPositionBehaviorAdvanced) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Fail sync":
		fallthrough
	case "Re-sync data":
		*e = SourceMysqlUpdateInvalidCDCPositionBehaviorAdvanced(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlUpdateInvalidCDCPositionBehaviorAdvanced: %v", v)
	}
}

type SourceMysqlUpdateSchemasReplicationMethodMethod string

const (
	SourceMysqlUpdateSchemasReplicationMethodMethodCdc SourceMysqlUpdateSchemasReplicationMethodMethod = "CDC"
)

func (e SourceMysqlUpdateSchemasReplicationMethodMethod) ToPointer() *SourceMysqlUpdateSchemasReplicationMethodMethod {
	return &e
}
func (e *SourceMysqlUpdateSchemasReplicationMethodMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CDC":
		*e = SourceMysqlUpdateSchemasReplicationMethodMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlUpdateSchemasReplicationMethodMethod: %v", v)
	}
}

// SourceMysqlUpdateReadChangesUsingChangeDataCaptureCDC - <i>Recommended</i> - Incrementally reads new inserts, updates, and deletes using MySQL's <a href="https://docs.airbyte.com/integrations/sources/mssql/#change-data-capture-cdc"> change data capture feature</a>. This must be enabled on your database.
type SourceMysqlUpdateReadChangesUsingChangeDataCaptureCDC struct {
	// The amount of time an initial load is allowed to continue for before catching up on CDC logs.
	InitialLoadTimeoutHours *int64 `default:"8" json:"initial_load_timeout_hours"`
	// Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value in the mined logs. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss.
	InvalidCdcCursorPositionBehavior *SourceMysqlUpdateInvalidCDCPositionBehaviorAdvanced `default:"Fail sync" json:"invalid_cdc_cursor_position_behavior"`
	Method                           *SourceMysqlUpdateSchemasReplicationMethodMethod     `default:"CDC" json:"method"`
	// Enter the configured MySQL server timezone. This should only be done if the configured timezone in your MySQL instance does not conform to IANNA standard.
	ServerTimezone       *string `json:"server_timezone,omitempty"`
	AdditionalProperties any     `additionalProperties:"true" json:"-"`
}

func (s SourceMysqlUpdateReadChangesUsingChangeDataCaptureCDC) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMysqlUpdateReadChangesUsingChangeDataCaptureCDC) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceMysqlUpdateReadChangesUsingChangeDataCaptureCDC) GetInitialLoadTimeoutHours() *int64 {
	if s == nil {
		return nil
	}
	return s.InitialLoadTimeoutHours
}

func (s *SourceMysqlUpdateReadChangesUsingChangeDataCaptureCDC) GetInvalidCdcCursorPositionBehavior() *SourceMysqlUpdateInvalidCDCPositionBehaviorAdvanced {
	if s == nil {
		return nil
	}
	return s.InvalidCdcCursorPositionBehavior
}

func (s *SourceMysqlUpdateReadChangesUsingChangeDataCaptureCDC) GetMethod() *SourceMysqlUpdateSchemasReplicationMethodMethod {
	if s == nil {
		return nil
	}
	return s.Method
}

func (s *SourceMysqlUpdateReadChangesUsingChangeDataCaptureCDC) GetServerTimezone() *string {
	if s == nil {
		return nil
	}
	return s.ServerTimezone
}

func (s *SourceMysqlUpdateReadChangesUsingChangeDataCaptureCDC) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceMysqlUpdateSchemasMethod string

const (
	SourceMysqlUpdateSchemasMethodStandard SourceMysqlUpdateSchemasMethod = "STANDARD"
)

func (e SourceMysqlUpdateSchemasMethod) ToPointer() *SourceMysqlUpdateSchemasMethod {
	return &e
}
func (e *SourceMysqlUpdateSchemasMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "STANDARD":
		*e = SourceMysqlUpdateSchemasMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlUpdateSchemasMethod: %v", v)
	}
}

// SourceMysqlUpdateScanChangesWithUserDefinedCursor - Incrementally detects new inserts and updates using the <a href="https://docs.airbyte.com/understanding-airbyte/connections/incremental-append/#user-defined-cursor">cursor column</a> chosen when configuring a connection (e.g. created_at, updated_at).
type SourceMysqlUpdateScanChangesWithUserDefinedCursor struct {
	Method               *SourceMysqlUpdateSchemasMethod `default:"STANDARD" json:"method"`
	AdditionalProperties any                             `additionalProperties:"true" json:"-"`
}

func (s SourceMysqlUpdateScanChangesWithUserDefinedCursor) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMysqlUpdateScanChangesWithUserDefinedCursor) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceMysqlUpdateScanChangesWithUserDefinedCursor) GetMethod() *SourceMysqlUpdateSchemasMethod {
	if s == nil {
		return nil
	}
	return s.Method
}

func (s *SourceMysqlUpdateScanChangesWithUserDefinedCursor) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceMysqlUpdateUpdateMethodType string

const (
	SourceMysqlUpdateUpdateMethodTypeSourceMysqlUpdateScanChangesWithUserDefinedCursor     SourceMysqlUpdateUpdateMethodType = "source-mysql-update_Scan Changes with User Defined Cursor"
	SourceMysqlUpdateUpdateMethodTypeSourceMysqlUpdateReadChangesUsingChangeDataCaptureCDC SourceMysqlUpdateUpdateMethodType = "source-mysql-update_Read Changes using Change Data Capture (CDC)"
)

// SourceMysqlUpdateUpdateMethod - Configures how data is extracted from the database.
type SourceMysqlUpdateUpdateMethod struct {
	SourceMysqlUpdateScanChangesWithUserDefinedCursor     *SourceMysqlUpdateScanChangesWithUserDefinedCursor     `queryParam:"inline" union:"member"`
	SourceMysqlUpdateReadChangesUsingChangeDataCaptureCDC *SourceMysqlUpdateReadChangesUsingChangeDataCaptureCDC `queryParam:"inline" union:"member"`

	Type SourceMysqlUpdateUpdateMethodType
}

func CreateSourceMysqlUpdateUpdateMethodSourceMysqlUpdateScanChangesWithUserDefinedCursor(sourceMysqlUpdateScanChangesWithUserDefinedCursor SourceMysqlUpdateScanChangesWithUserDefinedCursor) SourceMysqlUpdateUpdateMethod {
	typ := SourceMysqlUpdateUpdateMethodTypeSourceMysqlUpdateScanChangesWithUserDefinedCursor

	return SourceMysqlUpdateUpdateMethod{
		SourceMysqlUpdateScanChangesWithUserDefinedCursor: &sourceMysqlUpdateScanChangesWithUserDefinedCursor,
		Type: typ,
	}
}

func CreateSourceMysqlUpdateUpdateMethodSourceMysqlUpdateReadChangesUsingChangeDataCaptureCDC(sourceMysqlUpdateReadChangesUsingChangeDataCaptureCDC SourceMysqlUpdateReadChangesUsingChangeDataCaptureCDC) SourceMysqlUpdateUpdateMethod {
	typ := SourceMysqlUpdateUpdateMethodTypeSourceMysqlUpdateReadChangesUsingChangeDataCaptureCDC

	return SourceMysqlUpdateUpdateMethod{
		SourceMysqlUpdateReadChangesUsingChangeDataCaptureCDC: &sourceMysqlUpdateReadChangesUsingChangeDataCaptureCDC,
		Type: typ,
	}
}

func (u *SourceMysqlUpdateUpdateMethod) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var sourceMysqlUpdateScanChangesWithUserDefinedCursor SourceMysqlUpdateScanChangesWithUserDefinedCursor = SourceMysqlUpdateScanChangesWithUserDefinedCursor{}
	if err := utils.UnmarshalJSON(data, &sourceMysqlUpdateScanChangesWithUserDefinedCursor, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceMysqlUpdateUpdateMethodTypeSourceMysqlUpdateScanChangesWithUserDefinedCursor,
			Value: &sourceMysqlUpdateScanChangesWithUserDefinedCursor,
		})
	}

	var sourceMysqlUpdateReadChangesUsingChangeDataCaptureCDC SourceMysqlUpdateReadChangesUsingChangeDataCaptureCDC = SourceMysqlUpdateReadChangesUsingChangeDataCaptureCDC{}
	if err := utils.UnmarshalJSON(data, &sourceMysqlUpdateReadChangesUsingChangeDataCaptureCDC, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceMysqlUpdateUpdateMethodTypeSourceMysqlUpdateReadChangesUsingChangeDataCaptureCDC,
			Value: &sourceMysqlUpdateReadChangesUsingChangeDataCaptureCDC,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMysqlUpdateUpdateMethod", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMysqlUpdateUpdateMethod", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceMysqlUpdateUpdateMethodType)
	switch best.Type {
	case SourceMysqlUpdateUpdateMethodTypeSourceMysqlUpdateScanChangesWithUserDefinedCursor:
		u.SourceMysqlUpdateScanChangesWithUserDefinedCursor = best.Value.(*SourceMysqlUpdateScanChangesWithUserDefinedCursor)
		return nil
	case SourceMysqlUpdateUpdateMethodTypeSourceMysqlUpdateReadChangesUsingChangeDataCaptureCDC:
		u.SourceMysqlUpdateReadChangesUsingChangeDataCaptureCDC = best.Value.(*SourceMysqlUpdateReadChangesUsingChangeDataCaptureCDC)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMysqlUpdateUpdateMethod", string(data))
}

func (u SourceMysqlUpdateUpdateMethod) MarshalJSON() ([]byte, error) {
	if u.SourceMysqlUpdateScanChangesWithUserDefinedCursor != nil {
		return utils.MarshalJSON(u.SourceMysqlUpdateScanChangesWithUserDefinedCursor, "", true)
	}

	if u.SourceMysqlUpdateReadChangesUsingChangeDataCaptureCDC != nil {
		return utils.MarshalJSON(u.SourceMysqlUpdateReadChangesUsingChangeDataCaptureCDC, "", true)
	}

	return nil, errors.New("could not marshal union type SourceMysqlUpdateUpdateMethod: all fields are null")
}

type SourceMysqlUpdateSchemasSslModeEncryptionMode string

const (
	SourceMysqlUpdateSchemasSslModeEncryptionModeVerifyIdentity SourceMysqlUpdateSchemasSslModeEncryptionMode = "verify_identity"
)

func (e SourceMysqlUpdateSchemasSslModeEncryptionMode) ToPointer() *SourceMysqlUpdateSchemasSslModeEncryptionMode {
	return &e
}
func (e *SourceMysqlUpdateSchemasSslModeEncryptionMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "verify_identity":
		*e = SourceMysqlUpdateSchemasSslModeEncryptionMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlUpdateSchemasSslModeEncryptionMode: %v", v)
	}
}

// SourceMysqlUpdateVerifyIdentity - To always require encryption and verify that the source has a valid SSL certificate.
type SourceMysqlUpdateVerifyIdentity struct {
	// CA certificate
	CaCertificate *string `json:"ca_certificate,omitempty"`
	// Client certificate (this is not a required field, but if you want to use it, you will need to add the Client key as well)
	ClientCertificate *string `json:"client_certificate,omitempty"`
	// Client key (this is not a required field, but if you want to use it, you will need to add the Client certificate as well)
	ClientKey *string `json:"client_key,omitempty"`
	// Password for keystorage. This field is optional. If you do not add it - the password will be generated automatically.
	ClientKeyPassword    *string                                        `json:"client_key_password,omitempty"`
	Mode                 *SourceMysqlUpdateSchemasSslModeEncryptionMode `default:"verify_identity" json:"mode"`
	AdditionalProperties any                                            `additionalProperties:"true" json:"-"`
}

func (s SourceMysqlUpdateVerifyIdentity) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMysqlUpdateVerifyIdentity) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceMysqlUpdateVerifyIdentity) GetCaCertificate() *string {
	if s == nil {
		return nil
	}
	return s.CaCertificate
}

func (s *SourceMysqlUpdateVerifyIdentity) GetClientCertificate() *string {
	if s == nil {
		return nil
	}
	return s.ClientCertificate
}

func (s *SourceMysqlUpdateVerifyIdentity) GetClientKey() *string {
	if s == nil {
		return nil
	}
	return s.ClientKey
}

func (s *SourceMysqlUpdateVerifyIdentity) GetClientKeyPassword() *string {
	if s == nil {
		return nil
	}
	return s.ClientKeyPassword
}

func (s *SourceMysqlUpdateVerifyIdentity) GetMode() *SourceMysqlUpdateSchemasSslModeEncryptionMode {
	if s == nil {
		return nil
	}
	return s.Mode
}

func (s *SourceMysqlUpdateVerifyIdentity) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceMysqlUpdateSchemasSslModeMode string

const (
	SourceMysqlUpdateSchemasSslModeModeVerifyCa SourceMysqlUpdateSchemasSslModeMode = "verify_ca"
)

func (e SourceMysqlUpdateSchemasSslModeMode) ToPointer() *SourceMysqlUpdateSchemasSslModeMode {
	return &e
}
func (e *SourceMysqlUpdateSchemasSslModeMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "verify_ca":
		*e = SourceMysqlUpdateSchemasSslModeMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlUpdateSchemasSslModeMode: %v", v)
	}
}

// SourceMysqlUpdateVerifyCa - To always require encryption and verify that the source has a valid SSL certificate.
type SourceMysqlUpdateVerifyCa struct {
	// CA certificate
	CaCertificate *string `json:"ca_certificate,omitempty"`
	// Client certificate (this is not a required field, but if you want to use it, you will need to add the Client key as well)
	ClientCertificate *string `json:"client_certificate,omitempty"`
	// Client key (this is not a required field, but if you want to use it, you will need to add the Client certificate as well)
	ClientKey *string `json:"client_key,omitempty"`
	// Password for keystorage. This field is optional. If you do not add it - the password will be generated automatically.
	ClientKeyPassword    *string                              `json:"client_key_password,omitempty"`
	Mode                 *SourceMysqlUpdateSchemasSslModeMode `default:"verify_ca" json:"mode"`
	AdditionalProperties any                                  `additionalProperties:"true" json:"-"`
}

func (s SourceMysqlUpdateVerifyCa) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMysqlUpdateVerifyCa) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceMysqlUpdateVerifyCa) GetCaCertificate() *string {
	if s == nil {
		return nil
	}
	return s.CaCertificate
}

func (s *SourceMysqlUpdateVerifyCa) GetClientCertificate() *string {
	if s == nil {
		return nil
	}
	return s.ClientCertificate
}

func (s *SourceMysqlUpdateVerifyCa) GetClientKey() *string {
	if s == nil {
		return nil
	}
	return s.ClientKey
}

func (s *SourceMysqlUpdateVerifyCa) GetClientKeyPassword() *string {
	if s == nil {
		return nil
	}
	return s.ClientKeyPassword
}

func (s *SourceMysqlUpdateVerifyCa) GetMode() *SourceMysqlUpdateSchemasSslModeMode {
	if s == nil {
		return nil
	}
	return s.Mode
}

func (s *SourceMysqlUpdateVerifyCa) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceMysqlUpdateSchemasMode string

const (
	SourceMysqlUpdateSchemasModeRequired SourceMysqlUpdateSchemasMode = "required"
)

func (e SourceMysqlUpdateSchemasMode) ToPointer() *SourceMysqlUpdateSchemasMode {
	return &e
}
func (e *SourceMysqlUpdateSchemasMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "required":
		*e = SourceMysqlUpdateSchemasMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlUpdateSchemasMode: %v", v)
	}
}

// SourceMysqlUpdateRequired - To always require encryption. Note: The connection will fail if the source doesn't support encryption.
type SourceMysqlUpdateRequired struct {
	Mode                 *SourceMysqlUpdateSchemasMode `default:"required" json:"mode"`
	AdditionalProperties any                           `additionalProperties:"true" json:"-"`
}

func (s SourceMysqlUpdateRequired) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMysqlUpdateRequired) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceMysqlUpdateRequired) GetMode() *SourceMysqlUpdateSchemasMode {
	if s == nil {
		return nil
	}
	return s.Mode
}

func (s *SourceMysqlUpdateRequired) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceMysqlUpdateMode string

const (
	SourceMysqlUpdateModePreferred SourceMysqlUpdateMode = "preferred"
)

func (e SourceMysqlUpdateMode) ToPointer() *SourceMysqlUpdateMode {
	return &e
}
func (e *SourceMysqlUpdateMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "preferred":
		*e = SourceMysqlUpdateMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlUpdateMode: %v", v)
	}
}

// SourceMysqlUpdatePreferred - To allow unencrypted communication only when the source doesn't support encryption.
type SourceMysqlUpdatePreferred struct {
	Mode                 *SourceMysqlUpdateMode `default:"preferred" json:"mode"`
	AdditionalProperties any                    `additionalProperties:"true" json:"-"`
}

func (s SourceMysqlUpdatePreferred) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMysqlUpdatePreferred) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceMysqlUpdatePreferred) GetMode() *SourceMysqlUpdateMode {
	if s == nil {
		return nil
	}
	return s.Mode
}

func (s *SourceMysqlUpdatePreferred) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceMysqlUpdateEncryptionType string

const (
	SourceMysqlUpdateEncryptionTypeSourceMysqlUpdatePreferred      SourceMysqlUpdateEncryptionType = "source-mysql-update_preferred"
	SourceMysqlUpdateEncryptionTypeSourceMysqlUpdateRequired       SourceMysqlUpdateEncryptionType = "source-mysql-update_required"
	SourceMysqlUpdateEncryptionTypeSourceMysqlUpdateVerifyCa       SourceMysqlUpdateEncryptionType = "source-mysql-update_verify_ca"
	SourceMysqlUpdateEncryptionTypeSourceMysqlUpdateVerifyIdentity SourceMysqlUpdateEncryptionType = "source-mysql-update_verify_identity"
)

// SourceMysqlUpdateEncryption - The encryption method which is used when communicating with the database.
type SourceMysqlUpdateEncryption struct {
	SourceMysqlUpdatePreferred      *SourceMysqlUpdatePreferred      `queryParam:"inline" union:"member"`
	SourceMysqlUpdateRequired       *SourceMysqlUpdateRequired       `queryParam:"inline" union:"member"`
	SourceMysqlUpdateVerifyCa       *SourceMysqlUpdateVerifyCa       `queryParam:"inline" union:"member"`
	SourceMysqlUpdateVerifyIdentity *SourceMysqlUpdateVerifyIdentity `queryParam:"inline" union:"member"`

	Type SourceMysqlUpdateEncryptionType
}

func CreateSourceMysqlUpdateEncryptionSourceMysqlUpdatePreferred(sourceMysqlUpdatePreferred SourceMysqlUpdatePreferred) SourceMysqlUpdateEncryption {
	typ := SourceMysqlUpdateEncryptionTypeSourceMysqlUpdatePreferred

	return SourceMysqlUpdateEncryption{
		SourceMysqlUpdatePreferred: &sourceMysqlUpdatePreferred,
		Type:                       typ,
	}
}

func CreateSourceMysqlUpdateEncryptionSourceMysqlUpdateRequired(sourceMysqlUpdateRequired SourceMysqlUpdateRequired) SourceMysqlUpdateEncryption {
	typ := SourceMysqlUpdateEncryptionTypeSourceMysqlUpdateRequired

	return SourceMysqlUpdateEncryption{
		SourceMysqlUpdateRequired: &sourceMysqlUpdateRequired,
		Type:                      typ,
	}
}

func CreateSourceMysqlUpdateEncryptionSourceMysqlUpdateVerifyCa(sourceMysqlUpdateVerifyCa SourceMysqlUpdateVerifyCa) SourceMysqlUpdateEncryption {
	typ := SourceMysqlUpdateEncryptionTypeSourceMysqlUpdateVerifyCa

	return SourceMysqlUpdateEncryption{
		SourceMysqlUpdateVerifyCa: &sourceMysqlUpdateVerifyCa,
		Type:                      typ,
	}
}

func CreateSourceMysqlUpdateEncryptionSourceMysqlUpdateVerifyIdentity(sourceMysqlUpdateVerifyIdentity SourceMysqlUpdateVerifyIdentity) SourceMysqlUpdateEncryption {
	typ := SourceMysqlUpdateEncryptionTypeSourceMysqlUpdateVerifyIdentity

	return SourceMysqlUpdateEncryption{
		SourceMysqlUpdateVerifyIdentity: &sourceMysqlUpdateVerifyIdentity,
		Type:                            typ,
	}
}

func (u *SourceMysqlUpdateEncryption) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var sourceMysqlUpdatePreferred SourceMysqlUpdatePreferred = SourceMysqlUpdatePreferred{}
	if err := utils.UnmarshalJSON(data, &sourceMysqlUpdatePreferred, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceMysqlUpdateEncryptionTypeSourceMysqlUpdatePreferred,
			Value: &sourceMysqlUpdatePreferred,
		})
	}

	var sourceMysqlUpdateRequired SourceMysqlUpdateRequired = SourceMysqlUpdateRequired{}
	if err := utils.UnmarshalJSON(data, &sourceMysqlUpdateRequired, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceMysqlUpdateEncryptionTypeSourceMysqlUpdateRequired,
			Value: &sourceMysqlUpdateRequired,
		})
	}

	var sourceMysqlUpdateVerifyCa SourceMysqlUpdateVerifyCa = SourceMysqlUpdateVerifyCa{}
	if err := utils.UnmarshalJSON(data, &sourceMysqlUpdateVerifyCa, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceMysqlUpdateEncryptionTypeSourceMysqlUpdateVerifyCa,
			Value: &sourceMysqlUpdateVerifyCa,
		})
	}

	var sourceMysqlUpdateVerifyIdentity SourceMysqlUpdateVerifyIdentity = SourceMysqlUpdateVerifyIdentity{}
	if err := utils.UnmarshalJSON(data, &sourceMysqlUpdateVerifyIdentity, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceMysqlUpdateEncryptionTypeSourceMysqlUpdateVerifyIdentity,
			Value: &sourceMysqlUpdateVerifyIdentity,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMysqlUpdateEncryption", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMysqlUpdateEncryption", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceMysqlUpdateEncryptionType)
	switch best.Type {
	case SourceMysqlUpdateEncryptionTypeSourceMysqlUpdatePreferred:
		u.SourceMysqlUpdatePreferred = best.Value.(*SourceMysqlUpdatePreferred)
		return nil
	case SourceMysqlUpdateEncryptionTypeSourceMysqlUpdateRequired:
		u.SourceMysqlUpdateRequired = best.Value.(*SourceMysqlUpdateRequired)
		return nil
	case SourceMysqlUpdateEncryptionTypeSourceMysqlUpdateVerifyCa:
		u.SourceMysqlUpdateVerifyCa = best.Value.(*SourceMysqlUpdateVerifyCa)
		return nil
	case SourceMysqlUpdateEncryptionTypeSourceMysqlUpdateVerifyIdentity:
		u.SourceMysqlUpdateVerifyIdentity = best.Value.(*SourceMysqlUpdateVerifyIdentity)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMysqlUpdateEncryption", string(data))
}

func (u SourceMysqlUpdateEncryption) MarshalJSON() ([]byte, error) {
	if u.SourceMysqlUpdatePreferred != nil {
		return utils.MarshalJSON(u.SourceMysqlUpdatePreferred, "", true)
	}

	if u.SourceMysqlUpdateRequired != nil {
		return utils.MarshalJSON(u.SourceMysqlUpdateRequired, "", true)
	}

	if u.SourceMysqlUpdateVerifyCa != nil {
		return utils.MarshalJSON(u.SourceMysqlUpdateVerifyCa, "", true)
	}

	if u.SourceMysqlUpdateVerifyIdentity != nil {
		return utils.MarshalJSON(u.SourceMysqlUpdateVerifyIdentity, "", true)
	}

	return nil, errors.New("could not marshal union type SourceMysqlUpdateEncryption: all fields are null")
}

// SourceMysqlUpdateTableFilter - Inclusion filter configuration for table selection per database.
type SourceMysqlUpdateTableFilter struct {
	// The name of the database to apply this filter to. Should match the database defined in the "Database" field above.
	DatabaseName *string `json:"database_name,omitempty"`
	// List of table name patterns to include. Should be a SQL LIKE pattern.
	TableNamePatterns    []string `json:"table_name_patterns,omitempty"`
	AdditionalProperties any      `additionalProperties:"true" json:"-"`
}

func (s SourceMysqlUpdateTableFilter) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMysqlUpdateTableFilter) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceMysqlUpdateTableFilter) GetDatabaseName() *string {
	if s == nil {
		return nil
	}
	return s.DatabaseName
}

func (s *SourceMysqlUpdateTableFilter) GetTableNamePatterns() []string {
	if s == nil {
		return nil
	}
	return s.TableNamePatterns
}

func (s *SourceMysqlUpdateTableFilter) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceMysqlUpdateSchemasTunnelMethodTunnelMethod string

const (
	SourceMysqlUpdateSchemasTunnelMethodTunnelMethodSSHPasswordAuth SourceMysqlUpdateSchemasTunnelMethodTunnelMethod = "SSH_PASSWORD_AUTH"
)

func (e SourceMysqlUpdateSchemasTunnelMethodTunnelMethod) ToPointer() *SourceMysqlUpdateSchemasTunnelMethodTunnelMethod {
	return &e
}
func (e *SourceMysqlUpdateSchemasTunnelMethodTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_PASSWORD_AUTH":
		*e = SourceMysqlUpdateSchemasTunnelMethodTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlUpdateSchemasTunnelMethodTunnelMethod: %v", v)
	}
}

// SourceMysqlUpdatePasswordAuthentication - Connect through a jump server tunnel host using username and password authentication
type SourceMysqlUpdatePasswordAuthentication struct {
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost   *string                                           `json:"tunnel_host,omitempty"`
	TunnelMethod *SourceMysqlUpdateSchemasTunnelMethodTunnelMethod `default:"SSH_PASSWORD_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser *string `json:"tunnel_user,omitempty"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword   *string `json:"tunnel_user_password,omitempty"`
	AdditionalProperties any     `additionalProperties:"true" json:"-"`
}

func (s SourceMysqlUpdatePasswordAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMysqlUpdatePasswordAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceMysqlUpdatePasswordAuthentication) GetTunnelHost() *string {
	if s == nil {
		return nil
	}
	return s.TunnelHost
}

func (s *SourceMysqlUpdatePasswordAuthentication) GetTunnelMethod() *SourceMysqlUpdateSchemasTunnelMethodTunnelMethod {
	if s == nil {
		return nil
	}
	return s.TunnelMethod
}

func (s *SourceMysqlUpdatePasswordAuthentication) GetTunnelPort() *int64 {
	if s == nil {
		return nil
	}
	return s.TunnelPort
}

func (s *SourceMysqlUpdatePasswordAuthentication) GetTunnelUser() *string {
	if s == nil {
		return nil
	}
	return s.TunnelUser
}

func (s *SourceMysqlUpdatePasswordAuthentication) GetTunnelUserPassword() *string {
	if s == nil {
		return nil
	}
	return s.TunnelUserPassword
}

func (s *SourceMysqlUpdatePasswordAuthentication) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceMysqlUpdateSchemasTunnelMethod string

const (
	SourceMysqlUpdateSchemasTunnelMethodSSHKeyAuth SourceMysqlUpdateSchemasTunnelMethod = "SSH_KEY_AUTH"
)

func (e SourceMysqlUpdateSchemasTunnelMethod) ToPointer() *SourceMysqlUpdateSchemasTunnelMethod {
	return &e
}
func (e *SourceMysqlUpdateSchemasTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_KEY_AUTH":
		*e = SourceMysqlUpdateSchemasTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlUpdateSchemasTunnelMethod: %v", v)
	}
}

// SourceMysqlUpdateSSHKeyAuthentication - Connect through a jump server tunnel host using username and ssh key
type SourceMysqlUpdateSSHKeyAuthentication struct {
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey *string `json:"ssh_key,omitempty"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost   *string                               `json:"tunnel_host,omitempty"`
	TunnelMethod *SourceMysqlUpdateSchemasTunnelMethod `default:"SSH_KEY_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser           *string `json:"tunnel_user,omitempty"`
	AdditionalProperties any     `additionalProperties:"true" json:"-"`
}

func (s SourceMysqlUpdateSSHKeyAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMysqlUpdateSSHKeyAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceMysqlUpdateSSHKeyAuthentication) GetSSHKey() *string {
	if s == nil {
		return nil
	}
	return s.SSHKey
}

func (s *SourceMysqlUpdateSSHKeyAuthentication) GetTunnelHost() *string {
	if s == nil {
		return nil
	}
	return s.TunnelHost
}

func (s *SourceMysqlUpdateSSHKeyAuthentication) GetTunnelMethod() *SourceMysqlUpdateSchemasTunnelMethod {
	if s == nil {
		return nil
	}
	return s.TunnelMethod
}

func (s *SourceMysqlUpdateSSHKeyAuthentication) GetTunnelPort() *int64 {
	if s == nil {
		return nil
	}
	return s.TunnelPort
}

func (s *SourceMysqlUpdateSSHKeyAuthentication) GetTunnelUser() *string {
	if s == nil {
		return nil
	}
	return s.TunnelUser
}

func (s *SourceMysqlUpdateSSHKeyAuthentication) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceMysqlUpdateTunnelMethod string

const (
	SourceMysqlUpdateTunnelMethodNoTunnel SourceMysqlUpdateTunnelMethod = "NO_TUNNEL"
)

func (e SourceMysqlUpdateTunnelMethod) ToPointer() *SourceMysqlUpdateTunnelMethod {
	return &e
}
func (e *SourceMysqlUpdateTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NO_TUNNEL":
		*e = SourceMysqlUpdateTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlUpdateTunnelMethod: %v", v)
	}
}

// SourceMysqlUpdateNoTunnel - No ssh tunnel needed to connect to database
type SourceMysqlUpdateNoTunnel struct {
	TunnelMethod         *SourceMysqlUpdateTunnelMethod `default:"NO_TUNNEL" json:"tunnel_method"`
	AdditionalProperties any                            `additionalProperties:"true" json:"-"`
}

func (s SourceMysqlUpdateNoTunnel) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMysqlUpdateNoTunnel) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceMysqlUpdateNoTunnel) GetTunnelMethod() *SourceMysqlUpdateTunnelMethod {
	if s == nil {
		return nil
	}
	return s.TunnelMethod
}

func (s *SourceMysqlUpdateNoTunnel) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceMysqlUpdateSSHTunnelMethodType string

const (
	SourceMysqlUpdateSSHTunnelMethodTypeSourceMysqlUpdateNoTunnel               SourceMysqlUpdateSSHTunnelMethodType = "source-mysql-update_No Tunnel"
	SourceMysqlUpdateSSHTunnelMethodTypeSourceMysqlUpdateSSHKeyAuthentication   SourceMysqlUpdateSSHTunnelMethodType = "source-mysql-update_SSH Key Authentication"
	SourceMysqlUpdateSSHTunnelMethodTypeSourceMysqlUpdatePasswordAuthentication SourceMysqlUpdateSSHTunnelMethodType = "source-mysql-update_Password Authentication"
)

// SourceMysqlUpdateSSHTunnelMethod - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceMysqlUpdateSSHTunnelMethod struct {
	SourceMysqlUpdateNoTunnel               *SourceMysqlUpdateNoTunnel               `queryParam:"inline" union:"member"`
	SourceMysqlUpdateSSHKeyAuthentication   *SourceMysqlUpdateSSHKeyAuthentication   `queryParam:"inline" union:"member"`
	SourceMysqlUpdatePasswordAuthentication *SourceMysqlUpdatePasswordAuthentication `queryParam:"inline" union:"member"`

	Type SourceMysqlUpdateSSHTunnelMethodType
}

func CreateSourceMysqlUpdateSSHTunnelMethodSourceMysqlUpdateNoTunnel(sourceMysqlUpdateNoTunnel SourceMysqlUpdateNoTunnel) SourceMysqlUpdateSSHTunnelMethod {
	typ := SourceMysqlUpdateSSHTunnelMethodTypeSourceMysqlUpdateNoTunnel

	return SourceMysqlUpdateSSHTunnelMethod{
		SourceMysqlUpdateNoTunnel: &sourceMysqlUpdateNoTunnel,
		Type:                      typ,
	}
}

func CreateSourceMysqlUpdateSSHTunnelMethodSourceMysqlUpdateSSHKeyAuthentication(sourceMysqlUpdateSSHKeyAuthentication SourceMysqlUpdateSSHKeyAuthentication) SourceMysqlUpdateSSHTunnelMethod {
	typ := SourceMysqlUpdateSSHTunnelMethodTypeSourceMysqlUpdateSSHKeyAuthentication

	return SourceMysqlUpdateSSHTunnelMethod{
		SourceMysqlUpdateSSHKeyAuthentication: &sourceMysqlUpdateSSHKeyAuthentication,
		Type:                                  typ,
	}
}

func CreateSourceMysqlUpdateSSHTunnelMethodSourceMysqlUpdatePasswordAuthentication(sourceMysqlUpdatePasswordAuthentication SourceMysqlUpdatePasswordAuthentication) SourceMysqlUpdateSSHTunnelMethod {
	typ := SourceMysqlUpdateSSHTunnelMethodTypeSourceMysqlUpdatePasswordAuthentication

	return SourceMysqlUpdateSSHTunnelMethod{
		SourceMysqlUpdatePasswordAuthentication: &sourceMysqlUpdatePasswordAuthentication,
		Type:                                    typ,
	}
}

func (u *SourceMysqlUpdateSSHTunnelMethod) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var sourceMysqlUpdateNoTunnel SourceMysqlUpdateNoTunnel = SourceMysqlUpdateNoTunnel{}
	if err := utils.UnmarshalJSON(data, &sourceMysqlUpdateNoTunnel, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceMysqlUpdateSSHTunnelMethodTypeSourceMysqlUpdateNoTunnel,
			Value: &sourceMysqlUpdateNoTunnel,
		})
	}

	var sourceMysqlUpdateSSHKeyAuthentication SourceMysqlUpdateSSHKeyAuthentication = SourceMysqlUpdateSSHKeyAuthentication{}
	if err := utils.UnmarshalJSON(data, &sourceMysqlUpdateSSHKeyAuthentication, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceMysqlUpdateSSHTunnelMethodTypeSourceMysqlUpdateSSHKeyAuthentication,
			Value: &sourceMysqlUpdateSSHKeyAuthentication,
		})
	}

	var sourceMysqlUpdatePasswordAuthentication SourceMysqlUpdatePasswordAuthentication = SourceMysqlUpdatePasswordAuthentication{}
	if err := utils.UnmarshalJSON(data, &sourceMysqlUpdatePasswordAuthentication, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceMysqlUpdateSSHTunnelMethodTypeSourceMysqlUpdatePasswordAuthentication,
			Value: &sourceMysqlUpdatePasswordAuthentication,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMysqlUpdateSSHTunnelMethod", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMysqlUpdateSSHTunnelMethod", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceMysqlUpdateSSHTunnelMethodType)
	switch best.Type {
	case SourceMysqlUpdateSSHTunnelMethodTypeSourceMysqlUpdateNoTunnel:
		u.SourceMysqlUpdateNoTunnel = best.Value.(*SourceMysqlUpdateNoTunnel)
		return nil
	case SourceMysqlUpdateSSHTunnelMethodTypeSourceMysqlUpdateSSHKeyAuthentication:
		u.SourceMysqlUpdateSSHKeyAuthentication = best.Value.(*SourceMysqlUpdateSSHKeyAuthentication)
		return nil
	case SourceMysqlUpdateSSHTunnelMethodTypeSourceMysqlUpdatePasswordAuthentication:
		u.SourceMysqlUpdatePasswordAuthentication = best.Value.(*SourceMysqlUpdatePasswordAuthentication)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceMysqlUpdateSSHTunnelMethod", string(data))
}

func (u SourceMysqlUpdateSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.SourceMysqlUpdateNoTunnel != nil {
		return utils.MarshalJSON(u.SourceMysqlUpdateNoTunnel, "", true)
	}

	if u.SourceMysqlUpdateSSHKeyAuthentication != nil {
		return utils.MarshalJSON(u.SourceMysqlUpdateSSHKeyAuthentication, "", true)
	}

	if u.SourceMysqlUpdatePasswordAuthentication != nil {
		return utils.MarshalJSON(u.SourceMysqlUpdatePasswordAuthentication, "", true)
	}

	return nil, errors.New("could not marshal union type SourceMysqlUpdateSSHTunnelMethod: all fields are null")
}

type SourceMysqlUpdateSourceType string

const (
	SourceMysqlUpdateSourceTypeMysql SourceMysqlUpdateSourceType = "mysql"
)

func (e SourceMysqlUpdateSourceType) ToPointer() *SourceMysqlUpdateSourceType {
	return &e
}
func (e *SourceMysqlUpdateSourceType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "mysql":
		*e = SourceMysqlUpdateSourceType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceMysqlUpdateSourceType: %v", v)
	}
}

type SourceMysqlUpdate struct {
	// When this feature is enabled, during schema discovery the connector will query each table or view individually to check access privileges and inaccessible tables, views, or columns therein will be removed. In large schemas, this might cause schema discovery to take too long, in which case it might be advisable to disable this feature.
	CheckPrivileges *bool `default:"true" json:"check_privileges"`
	// How often (in seconds) a stream should checkpoint, when possible.
	CheckpointTargetIntervalSeconds *int64 `default:"300" json:"checkpoint_target_interval_seconds"`
	// Maximum number of concurrent queries to the database.
	Concurrency *int64 `default:"1" json:"concurrency"`
	// The database name.
	Database *string `json:"database,omitempty"`
	// Hostname of the database.
	Host *string `json:"host,omitempty"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// Maximum number of concurrent queries to the database. Leave empty to let Airbyte optimize performance.
	MaxDbConnections *int64 `json:"max_db_connections,omitempty"`
	// The password associated with the username.
	Password *string `json:"password,omitempty"`
	// Port of the database.
	Port *int64 `default:"3306" json:"port"`
	// Configures how data is extracted from the database.
	ReplicationMethod *SourceMysqlUpdateUpdateMethod `json:"replication_method,omitempty"`
	// The encryption method which is used when communicating with the database.
	SslMode *SourceMysqlUpdateEncryption `json:"ssl_mode,omitempty"`
	// Optional filters to include only specific tables from the specified database.
	TableFilters []SourceMysqlUpdateTableFilter `json:"table_filters,omitempty"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod *SourceMysqlUpdateSSHTunnelMethod `json:"tunnel_method,omitempty"`
	// The username which is used to access the database.
	Username             *string                      `json:"username,omitempty"`
	sourceType           *SourceMysqlUpdateSourceType `const:"mysql" json:"sourceType"`
	AdditionalProperties any                          `additionalProperties:"true" json:"-"`
}

func (s SourceMysqlUpdate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceMysqlUpdate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceMysqlUpdate) GetCheckPrivileges() *bool {
	if s == nil {
		return nil
	}
	return s.CheckPrivileges
}

func (s *SourceMysqlUpdate) GetCheckpointTargetIntervalSeconds() *int64 {
	if s == nil {
		return nil
	}
	return s.CheckpointTargetIntervalSeconds
}

func (s *SourceMysqlUpdate) GetConcurrency() *int64 {
	if s == nil {
		return nil
	}
	return s.Concurrency
}

func (s *SourceMysqlUpdate) GetDatabase() *string {
	if s == nil {
		return nil
	}
	return s.Database
}

func (s *SourceMysqlUpdate) GetHost() *string {
	if s == nil {
		return nil
	}
	return s.Host
}

func (s *SourceMysqlUpdate) GetJdbcURLParams() *string {
	if s == nil {
		return nil
	}
	return s.JdbcURLParams
}

func (s *SourceMysqlUpdate) GetMaxDbConnections() *int64 {
	if s == nil {
		return nil
	}
	return s.MaxDbConnections
}

func (s *SourceMysqlUpdate) GetPassword() *string {
	if s == nil {
		return nil
	}
	return s.Password
}

func (s *SourceMysqlUpdate) GetPort() *int64 {
	if s == nil {
		return nil
	}
	return s.Port
}

func (s *SourceMysqlUpdate) GetReplicationMethod() *SourceMysqlUpdateUpdateMethod {
	if s == nil {
		return nil
	}
	return s.ReplicationMethod
}

func (s *SourceMysqlUpdate) GetSslMode() *SourceMysqlUpdateEncryption {
	if s == nil {
		return nil
	}
	return s.SslMode
}

func (s *SourceMysqlUpdate) GetTableFilters() []SourceMysqlUpdateTableFilter {
	if s == nil {
		return nil
	}
	return s.TableFilters
}

func (s *SourceMysqlUpdate) GetTunnelMethod() *SourceMysqlUpdateSSHTunnelMethod {
	if s == nil {
		return nil
	}
	return s.TunnelMethod
}

func (s *SourceMysqlUpdate) GetUsername() *string {
	if s == nil {
		return nil
	}
	return s.Username
}

func (s *SourceMysqlUpdate) GetSourceType() *SourceMysqlUpdateSourceType {
	return SourceMysqlUpdateSourceTypeMysql.ToPointer()
}

func (s *SourceMysqlUpdate) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}
