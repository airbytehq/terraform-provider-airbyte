// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/types"
)

// SourceSinglestoreUpdateReplicationMethod - Replication method to use for extracting data from the database. STANDARD replication requires no setup on the DB side but will not be able to represent deletions incrementally.
type SourceSinglestoreUpdateReplicationMethod string

const (
	SourceSinglestoreUpdateReplicationMethodStandard SourceSinglestoreUpdateReplicationMethod = "STANDARD"
)

func (e SourceSinglestoreUpdateReplicationMethod) ToPointer() *SourceSinglestoreUpdateReplicationMethod {
	return &e
}
func (e *SourceSinglestoreUpdateReplicationMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "STANDARD":
		*e = SourceSinglestoreUpdateReplicationMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceSinglestoreUpdateReplicationMethod: %v", v)
	}
}

// SourceSinglestoreUpdateVerifyFull - Use SSL/TLS for encryption, certificate verification, and hostname verification.
type SourceSinglestoreUpdateVerifyFull struct {
	// CA certificate
	CaCertificate *string `json:"ca_certificate,omitempty"`
	// Client certificate (this is not a required field, but if you want to use it, you will need to add the <b>Client key</b> as well)
	ClientCertificate *string `json:"client_certificate,omitempty"`
	// Client key (this is not a required field, but if you want to use it, you will need to add the <b>Client certificate</b> as well)
	ClientKey *string `json:"client_key,omitempty"`
	// Password for keystorage. This field is optional. If you do not add it - the password will be generated automatically.
	ClientKeyPassword *string `json:"client_key_password,omitempty"`
	mode              *string `const:"verify-full" json:"mode,omitempty"`
}

func (s SourceSinglestoreUpdateVerifyFull) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceSinglestoreUpdateVerifyFull) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceSinglestoreUpdateVerifyFull) GetCaCertificate() *string {
	if s == nil {
		return nil
	}
	return s.CaCertificate
}

func (s *SourceSinglestoreUpdateVerifyFull) GetClientCertificate() *string {
	if s == nil {
		return nil
	}
	return s.ClientCertificate
}

func (s *SourceSinglestoreUpdateVerifyFull) GetClientKey() *string {
	if s == nil {
		return nil
	}
	return s.ClientKey
}

func (s *SourceSinglestoreUpdateVerifyFull) GetClientKeyPassword() *string {
	if s == nil {
		return nil
	}
	return s.ClientKeyPassword
}

func (s *SourceSinglestoreUpdateVerifyFull) GetMode() *string {
	return types.Pointer("verify-full")
}

// SourceSinglestoreUpdateVerifyCA - Use SSL/TLS for encryption and perform certificates verification, but do not perform hostname verification.
type SourceSinglestoreUpdateVerifyCA struct {
	// CA certificate
	CaCertificate *string `json:"ca_certificate,omitempty"`
	// Client certificate (this is not a required field, but if you want to use it, you will need to add the <b>Client key</b> as well)
	ClientCertificate *string `json:"client_certificate,omitempty"`
	// Client key (this is not a required field, but if you want to use it, you will need to add the <b>Client certificate</b> as well)
	ClientKey *string `json:"client_key,omitempty"`
	// Password for keystorage. This field is optional. If you do not add it - the password will be generated automatically.
	ClientKeyPassword *string `json:"client_key_password,omitempty"`
	mode              *string `const:"verify-ca" json:"mode,omitempty"`
}

func (s SourceSinglestoreUpdateVerifyCA) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceSinglestoreUpdateVerifyCA) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceSinglestoreUpdateVerifyCA) GetCaCertificate() *string {
	if s == nil {
		return nil
	}
	return s.CaCertificate
}

func (s *SourceSinglestoreUpdateVerifyCA) GetClientCertificate() *string {
	if s == nil {
		return nil
	}
	return s.ClientCertificate
}

func (s *SourceSinglestoreUpdateVerifyCA) GetClientKey() *string {
	if s == nil {
		return nil
	}
	return s.ClientKey
}

func (s *SourceSinglestoreUpdateVerifyCA) GetClientKeyPassword() *string {
	if s == nil {
		return nil
	}
	return s.ClientKeyPassword
}

func (s *SourceSinglestoreUpdateVerifyCA) GetMode() *string {
	return types.Pointer("verify-ca")
}

// SourceSinglestoreUpdateRequired - Only use SSL/TLS for encryption. Do not perform certificate or hostname verification. This mode is not safe for production applications.
type SourceSinglestoreUpdateRequired struct {
	mode *string `const:"required" json:"mode,omitempty"`
}

func (s SourceSinglestoreUpdateRequired) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceSinglestoreUpdateRequired) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceSinglestoreUpdateRequired) GetMode() *string {
	return types.Pointer("required")
}

// SourceSinglestoreUpdateDisable - Do not use SSL/TLS
type SourceSinglestoreUpdateDisable struct {
	mode *string `const:"disable" json:"mode,omitempty"`
}

func (s SourceSinglestoreUpdateDisable) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceSinglestoreUpdateDisable) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceSinglestoreUpdateDisable) GetMode() *string {
	return types.Pointer("disable")
}

type SourceSinglestoreUpdateSSLModesType string

const (
	SourceSinglestoreUpdateSSLModesTypeSourceSinglestoreUpdateDisable    SourceSinglestoreUpdateSSLModesType = "source-singlestore-update_disable"
	SourceSinglestoreUpdateSSLModesTypeSourceSinglestoreUpdateRequired   SourceSinglestoreUpdateSSLModesType = "source-singlestore-update_required"
	SourceSinglestoreUpdateSSLModesTypeSourceSinglestoreUpdateVerifyCA   SourceSinglestoreUpdateSSLModesType = "source-singlestore-update_Verify CA"
	SourceSinglestoreUpdateSSLModesTypeSourceSinglestoreUpdateVerifyFull SourceSinglestoreUpdateSSLModesType = "source-singlestore-update_Verify Full"
)

// SourceSinglestoreUpdateSSLModes - SSL connection modes.
type SourceSinglestoreUpdateSSLModes struct {
	SourceSinglestoreUpdateDisable    *SourceSinglestoreUpdateDisable    `queryParam:"inline" union:"member"`
	SourceSinglestoreUpdateRequired   *SourceSinglestoreUpdateRequired   `queryParam:"inline" union:"member"`
	SourceSinglestoreUpdateVerifyCA   *SourceSinglestoreUpdateVerifyCA   `queryParam:"inline" union:"member"`
	SourceSinglestoreUpdateVerifyFull *SourceSinglestoreUpdateVerifyFull `queryParam:"inline" union:"member"`

	Type SourceSinglestoreUpdateSSLModesType
}

func CreateSourceSinglestoreUpdateSSLModesSourceSinglestoreUpdateDisable(sourceSinglestoreUpdateDisable SourceSinglestoreUpdateDisable) SourceSinglestoreUpdateSSLModes {
	typ := SourceSinglestoreUpdateSSLModesTypeSourceSinglestoreUpdateDisable

	return SourceSinglestoreUpdateSSLModes{
		SourceSinglestoreUpdateDisable: &sourceSinglestoreUpdateDisable,
		Type:                           typ,
	}
}

func CreateSourceSinglestoreUpdateSSLModesSourceSinglestoreUpdateRequired(sourceSinglestoreUpdateRequired SourceSinglestoreUpdateRequired) SourceSinglestoreUpdateSSLModes {
	typ := SourceSinglestoreUpdateSSLModesTypeSourceSinglestoreUpdateRequired

	return SourceSinglestoreUpdateSSLModes{
		SourceSinglestoreUpdateRequired: &sourceSinglestoreUpdateRequired,
		Type:                            typ,
	}
}

func CreateSourceSinglestoreUpdateSSLModesSourceSinglestoreUpdateVerifyCA(sourceSinglestoreUpdateVerifyCA SourceSinglestoreUpdateVerifyCA) SourceSinglestoreUpdateSSLModes {
	typ := SourceSinglestoreUpdateSSLModesTypeSourceSinglestoreUpdateVerifyCA

	return SourceSinglestoreUpdateSSLModes{
		SourceSinglestoreUpdateVerifyCA: &sourceSinglestoreUpdateVerifyCA,
		Type:                            typ,
	}
}

func CreateSourceSinglestoreUpdateSSLModesSourceSinglestoreUpdateVerifyFull(sourceSinglestoreUpdateVerifyFull SourceSinglestoreUpdateVerifyFull) SourceSinglestoreUpdateSSLModes {
	typ := SourceSinglestoreUpdateSSLModesTypeSourceSinglestoreUpdateVerifyFull

	return SourceSinglestoreUpdateSSLModes{
		SourceSinglestoreUpdateVerifyFull: &sourceSinglestoreUpdateVerifyFull,
		Type:                              typ,
	}
}

func (u *SourceSinglestoreUpdateSSLModes) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var sourceSinglestoreUpdateDisable SourceSinglestoreUpdateDisable = SourceSinglestoreUpdateDisable{}
	if err := utils.UnmarshalJSON(data, &sourceSinglestoreUpdateDisable, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceSinglestoreUpdateSSLModesTypeSourceSinglestoreUpdateDisable,
			Value: &sourceSinglestoreUpdateDisable,
		})
	}

	var sourceSinglestoreUpdateRequired SourceSinglestoreUpdateRequired = SourceSinglestoreUpdateRequired{}
	if err := utils.UnmarshalJSON(data, &sourceSinglestoreUpdateRequired, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceSinglestoreUpdateSSLModesTypeSourceSinglestoreUpdateRequired,
			Value: &sourceSinglestoreUpdateRequired,
		})
	}

	var sourceSinglestoreUpdateVerifyCA SourceSinglestoreUpdateVerifyCA = SourceSinglestoreUpdateVerifyCA{}
	if err := utils.UnmarshalJSON(data, &sourceSinglestoreUpdateVerifyCA, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceSinglestoreUpdateSSLModesTypeSourceSinglestoreUpdateVerifyCA,
			Value: &sourceSinglestoreUpdateVerifyCA,
		})
	}

	var sourceSinglestoreUpdateVerifyFull SourceSinglestoreUpdateVerifyFull = SourceSinglestoreUpdateVerifyFull{}
	if err := utils.UnmarshalJSON(data, &sourceSinglestoreUpdateVerifyFull, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceSinglestoreUpdateSSLModesTypeSourceSinglestoreUpdateVerifyFull,
			Value: &sourceSinglestoreUpdateVerifyFull,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceSinglestoreUpdateSSLModes", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceSinglestoreUpdateSSLModes", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceSinglestoreUpdateSSLModesType)
	switch best.Type {
	case SourceSinglestoreUpdateSSLModesTypeSourceSinglestoreUpdateDisable:
		u.SourceSinglestoreUpdateDisable = best.Value.(*SourceSinglestoreUpdateDisable)
		return nil
	case SourceSinglestoreUpdateSSLModesTypeSourceSinglestoreUpdateRequired:
		u.SourceSinglestoreUpdateRequired = best.Value.(*SourceSinglestoreUpdateRequired)
		return nil
	case SourceSinglestoreUpdateSSLModesTypeSourceSinglestoreUpdateVerifyCA:
		u.SourceSinglestoreUpdateVerifyCA = best.Value.(*SourceSinglestoreUpdateVerifyCA)
		return nil
	case SourceSinglestoreUpdateSSLModesTypeSourceSinglestoreUpdateVerifyFull:
		u.SourceSinglestoreUpdateVerifyFull = best.Value.(*SourceSinglestoreUpdateVerifyFull)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceSinglestoreUpdateSSLModes", string(data))
}

func (u SourceSinglestoreUpdateSSLModes) MarshalJSON() ([]byte, error) {
	if u.SourceSinglestoreUpdateDisable != nil {
		return utils.MarshalJSON(u.SourceSinglestoreUpdateDisable, "", true)
	}

	if u.SourceSinglestoreUpdateRequired != nil {
		return utils.MarshalJSON(u.SourceSinglestoreUpdateRequired, "", true)
	}

	if u.SourceSinglestoreUpdateVerifyCA != nil {
		return utils.MarshalJSON(u.SourceSinglestoreUpdateVerifyCA, "", true)
	}

	if u.SourceSinglestoreUpdateVerifyFull != nil {
		return utils.MarshalJSON(u.SourceSinglestoreUpdateVerifyFull, "", true)
	}

	return nil, errors.New("could not marshal union type SourceSinglestoreUpdateSSLModes: all fields are null")
}

type SourceSinglestoreUpdateSourceType string

const (
	SourceSinglestoreUpdateSourceTypeSinglestore SourceSinglestoreUpdateSourceType = "singlestore"
)

func (e SourceSinglestoreUpdateSourceType) ToPointer() *SourceSinglestoreUpdateSourceType {
	return &e
}
func (e *SourceSinglestoreUpdateSourceType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "singlestore":
		*e = SourceSinglestoreUpdateSourceType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceSinglestoreUpdateSourceType: %v", v)
	}
}

type SourceSinglestoreUpdate struct {
	// Name of the database.
	Database *string `json:"database,omitempty"`
	// Hostname of the database.
	Host *string `json:"host,omitempty"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3). For more information read about <a href="https://docs.singlestore.com/cloud/developer-resources/connect-with-application-development-tools/connect-with-java-jdbc/the-singlestore-jdbc-driver/#connection-string-parameters">JDBC URL parameters</a>.
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// Password associated with the username.
	Password *string `json:"password,omitempty"`
	// Port of the database.
	Port *int64 `default:"3306" json:"port"`
	// Replication method to use for extracting data from the database. STANDARD replication requires no setup on the DB side but will not be able to represent deletions incrementally.
	ReplicationMethod *SourceSinglestoreUpdateReplicationMethod `default:"STANDARD" json:"replication_method"`
	// SSL connection modes.
	SslMode *SourceSinglestoreUpdateSSLModes `json:"ssl_mode,omitempty"`
	// Username to use to access the database.
	Username   *string                            `json:"username,omitempty"`
	sourceType *SourceSinglestoreUpdateSourceType `const:"singlestore" json:"sourceType"`
}

func (s SourceSinglestoreUpdate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceSinglestoreUpdate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceSinglestoreUpdate) GetDatabase() *string {
	if s == nil {
		return nil
	}
	return s.Database
}

func (s *SourceSinglestoreUpdate) GetHost() *string {
	if s == nil {
		return nil
	}
	return s.Host
}

func (s *SourceSinglestoreUpdate) GetJdbcURLParams() *string {
	if s == nil {
		return nil
	}
	return s.JdbcURLParams
}

func (s *SourceSinglestoreUpdate) GetPassword() *string {
	if s == nil {
		return nil
	}
	return s.Password
}

func (s *SourceSinglestoreUpdate) GetPort() *int64 {
	if s == nil {
		return nil
	}
	return s.Port
}

func (s *SourceSinglestoreUpdate) GetReplicationMethod() *SourceSinglestoreUpdateReplicationMethod {
	if s == nil {
		return nil
	}
	return s.ReplicationMethod
}

func (s *SourceSinglestoreUpdate) GetSslMode() *SourceSinglestoreUpdateSSLModes {
	if s == nil {
		return nil
	}
	return s.SslMode
}

func (s *SourceSinglestoreUpdate) GetUsername() *string {
	if s == nil {
		return nil
	}
	return s.Username
}

func (s *SourceSinglestoreUpdate) GetSourceType() *SourceSinglestoreUpdateSourceType {
	return SourceSinglestoreUpdateSourceTypeSinglestore.ToPointer()
}
