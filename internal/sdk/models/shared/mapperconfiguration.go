// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

type MapperConfigurationType string

const (
	MapperConfigurationTypeHashing        MapperConfigurationType = "Hashing"
	MapperConfigurationTypeFieldFiltering MapperConfigurationType = "FieldFiltering"
	MapperConfigurationTypeFieldRenaming  MapperConfigurationType = "FieldRenaming"
	MapperConfigurationTypeRowFiltering   MapperConfigurationType = "RowFiltering"
	MapperConfigurationTypeEncryption     MapperConfigurationType = "Encryption"
)

// MapperConfiguration - The values required to configure the mapper.
type MapperConfiguration struct {
	Hashing        *Hashing        `queryParam:"inline" union:"member"`
	FieldFiltering *FieldFiltering `queryParam:"inline" union:"member"`
	FieldRenaming  *FieldRenaming  `queryParam:"inline" union:"member"`
	RowFiltering   *RowFiltering   `queryParam:"inline" union:"member"`
	Encryption     *Encryption     `queryParam:"inline" union:"member"`

	Type MapperConfigurationType
}

func CreateMapperConfigurationHashing(hashing Hashing) MapperConfiguration {
	typ := MapperConfigurationTypeHashing

	return MapperConfiguration{
		Hashing: &hashing,
		Type:    typ,
	}
}

func CreateMapperConfigurationFieldFiltering(fieldFiltering FieldFiltering) MapperConfiguration {
	typ := MapperConfigurationTypeFieldFiltering

	return MapperConfiguration{
		FieldFiltering: &fieldFiltering,
		Type:           typ,
	}
}

func CreateMapperConfigurationFieldRenaming(fieldRenaming FieldRenaming) MapperConfiguration {
	typ := MapperConfigurationTypeFieldRenaming

	return MapperConfiguration{
		FieldRenaming: &fieldRenaming,
		Type:          typ,
	}
}

func CreateMapperConfigurationRowFiltering(rowFiltering RowFiltering) MapperConfiguration {
	typ := MapperConfigurationTypeRowFiltering

	return MapperConfiguration{
		RowFiltering: &rowFiltering,
		Type:         typ,
	}
}

func CreateMapperConfigurationEncryption(encryption Encryption) MapperConfiguration {
	typ := MapperConfigurationTypeEncryption

	return MapperConfiguration{
		Encryption: &encryption,
		Type:       typ,
	}
}

func (u *MapperConfiguration) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var hashing Hashing = Hashing{}
	if err := utils.UnmarshalJSON(data, &hashing, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  MapperConfigurationTypeHashing,
			Value: &hashing,
		})
	}

	var fieldFiltering FieldFiltering = FieldFiltering{}
	if err := utils.UnmarshalJSON(data, &fieldFiltering, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  MapperConfigurationTypeFieldFiltering,
			Value: &fieldFiltering,
		})
	}

	var fieldRenaming FieldRenaming = FieldRenaming{}
	if err := utils.UnmarshalJSON(data, &fieldRenaming, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  MapperConfigurationTypeFieldRenaming,
			Value: &fieldRenaming,
		})
	}

	var rowFiltering RowFiltering = RowFiltering{}
	if err := utils.UnmarshalJSON(data, &rowFiltering, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  MapperConfigurationTypeRowFiltering,
			Value: &rowFiltering,
		})
	}

	var encryption Encryption = Encryption{}
	if err := utils.UnmarshalJSON(data, &encryption, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  MapperConfigurationTypeEncryption,
			Value: &encryption,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for MapperConfiguration", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for MapperConfiguration", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(MapperConfigurationType)
	switch best.Type {
	case MapperConfigurationTypeHashing:
		u.Hashing = best.Value.(*Hashing)
		return nil
	case MapperConfigurationTypeFieldFiltering:
		u.FieldFiltering = best.Value.(*FieldFiltering)
		return nil
	case MapperConfigurationTypeFieldRenaming:
		u.FieldRenaming = best.Value.(*FieldRenaming)
		return nil
	case MapperConfigurationTypeRowFiltering:
		u.RowFiltering = best.Value.(*RowFiltering)
		return nil
	case MapperConfigurationTypeEncryption:
		u.Encryption = best.Value.(*Encryption)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for MapperConfiguration", string(data))
}

func (u MapperConfiguration) MarshalJSON() ([]byte, error) {
	if u.Hashing != nil {
		return utils.MarshalJSON(u.Hashing, "", true)
	}

	if u.FieldFiltering != nil {
		return utils.MarshalJSON(u.FieldFiltering, "", true)
	}

	if u.FieldRenaming != nil {
		return utils.MarshalJSON(u.FieldRenaming, "", true)
	}

	if u.RowFiltering != nil {
		return utils.MarshalJSON(u.RowFiltering, "", true)
	}

	if u.Encryption != nil {
		return utils.MarshalJSON(u.Encryption, "", true)
	}

	return nil, errors.New("could not marshal union type MapperConfiguration: all fields are null")
}
