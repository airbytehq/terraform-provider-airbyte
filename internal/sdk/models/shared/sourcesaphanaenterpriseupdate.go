// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

type SourceSapHanaEnterpriseUpdateSchemasCursorMethod string

const (
	SourceSapHanaEnterpriseUpdateSchemasCursorMethodCdc SourceSapHanaEnterpriseUpdateSchemasCursorMethod = "cdc"
)

func (e SourceSapHanaEnterpriseUpdateSchemasCursorMethod) ToPointer() *SourceSapHanaEnterpriseUpdateSchemasCursorMethod {
	return &e
}
func (e *SourceSapHanaEnterpriseUpdateSchemasCursorMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "cdc":
		*e = SourceSapHanaEnterpriseUpdateSchemasCursorMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceSapHanaEnterpriseUpdateSchemasCursorMethod: %v", v)
	}
}

// SourceSapHanaEnterpriseUpdateInvalidCDCPositionBehaviorAdvanced - Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value in the mined logs. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss.
type SourceSapHanaEnterpriseUpdateInvalidCDCPositionBehaviorAdvanced string

const (
	SourceSapHanaEnterpriseUpdateInvalidCDCPositionBehaviorAdvancedFailSync   SourceSapHanaEnterpriseUpdateInvalidCDCPositionBehaviorAdvanced = "Fail sync"
	SourceSapHanaEnterpriseUpdateInvalidCDCPositionBehaviorAdvancedReSyncData SourceSapHanaEnterpriseUpdateInvalidCDCPositionBehaviorAdvanced = "Re-sync data"
)

func (e SourceSapHanaEnterpriseUpdateInvalidCDCPositionBehaviorAdvanced) ToPointer() *SourceSapHanaEnterpriseUpdateInvalidCDCPositionBehaviorAdvanced {
	return &e
}
func (e *SourceSapHanaEnterpriseUpdateInvalidCDCPositionBehaviorAdvanced) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Fail sync":
		fallthrough
	case "Re-sync data":
		*e = SourceSapHanaEnterpriseUpdateInvalidCDCPositionBehaviorAdvanced(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceSapHanaEnterpriseUpdateInvalidCDCPositionBehaviorAdvanced: %v", v)
	}
}

// SourceSapHanaEnterpriseUpdateReadChangesUsingChangeDataCaptureCDC - <i>Recommended</i> - Incrementally reads new inserts, updates, and deletes using change data capture feature. This must be enabled on your database.
type SourceSapHanaEnterpriseUpdateReadChangesUsingChangeDataCaptureCDC struct {
	CursorMethod *SourceSapHanaEnterpriseUpdateSchemasCursorMethod `default:"cdc" json:"cursor_method"`
	// The amount of time an initial load is allowed to continue for before catching up on CDC events.
	InitialLoadTimeoutHours *int64 `default:"8" json:"initial_load_timeout_hours"`
	// Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value in the mined logs. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss.
	InvalidCdcCursorPositionBehavior *SourceSapHanaEnterpriseUpdateInvalidCDCPositionBehaviorAdvanced `default:"Fail sync" json:"invalid_cdc_cursor_position_behavior"`
	AdditionalProperties             any                                                              `additionalProperties:"true" json:"-"`
}

func (s SourceSapHanaEnterpriseUpdateReadChangesUsingChangeDataCaptureCDC) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceSapHanaEnterpriseUpdateReadChangesUsingChangeDataCaptureCDC) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceSapHanaEnterpriseUpdateReadChangesUsingChangeDataCaptureCDC) GetCursorMethod() *SourceSapHanaEnterpriseUpdateSchemasCursorMethod {
	if s == nil {
		return nil
	}
	return s.CursorMethod
}

func (s *SourceSapHanaEnterpriseUpdateReadChangesUsingChangeDataCaptureCDC) GetInitialLoadTimeoutHours() *int64 {
	if s == nil {
		return nil
	}
	return s.InitialLoadTimeoutHours
}

func (s *SourceSapHanaEnterpriseUpdateReadChangesUsingChangeDataCaptureCDC) GetInvalidCdcCursorPositionBehavior() *SourceSapHanaEnterpriseUpdateInvalidCDCPositionBehaviorAdvanced {
	if s == nil {
		return nil
	}
	return s.InvalidCdcCursorPositionBehavior
}

func (s *SourceSapHanaEnterpriseUpdateReadChangesUsingChangeDataCaptureCDC) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceSapHanaEnterpriseUpdateCursorMethod string

const (
	SourceSapHanaEnterpriseUpdateCursorMethodUserDefined SourceSapHanaEnterpriseUpdateCursorMethod = "user_defined"
)

func (e SourceSapHanaEnterpriseUpdateCursorMethod) ToPointer() *SourceSapHanaEnterpriseUpdateCursorMethod {
	return &e
}
func (e *SourceSapHanaEnterpriseUpdateCursorMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "user_defined":
		*e = SourceSapHanaEnterpriseUpdateCursorMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceSapHanaEnterpriseUpdateCursorMethod: %v", v)
	}
}

// SourceSapHanaEnterpriseUpdateScanChangesWithUserDefinedCursor - Incrementally detects new inserts and updates using the <a href="https://docs.airbyte.com/understanding-airbyte/connections/incremental-append/#user-defined-cursor">cursor column</a> chosen when configuring a connection (e.g. created_at, updated_at).
type SourceSapHanaEnterpriseUpdateScanChangesWithUserDefinedCursor struct {
	CursorMethod         *SourceSapHanaEnterpriseUpdateCursorMethod `default:"user_defined" json:"cursor_method"`
	AdditionalProperties any                                        `additionalProperties:"true" json:"-"`
}

func (s SourceSapHanaEnterpriseUpdateScanChangesWithUserDefinedCursor) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceSapHanaEnterpriseUpdateScanChangesWithUserDefinedCursor) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceSapHanaEnterpriseUpdateScanChangesWithUserDefinedCursor) GetCursorMethod() *SourceSapHanaEnterpriseUpdateCursorMethod {
	if s == nil {
		return nil
	}
	return s.CursorMethod
}

func (s *SourceSapHanaEnterpriseUpdateScanChangesWithUserDefinedCursor) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceSapHanaEnterpriseUpdateUpdateMethodType string

const (
	SourceSapHanaEnterpriseUpdateUpdateMethodTypeSourceSapHanaEnterpriseUpdateScanChangesWithUserDefinedCursor     SourceSapHanaEnterpriseUpdateUpdateMethodType = "source-sap-hana-enterprise-update_Scan Changes with User Defined Cursor"
	SourceSapHanaEnterpriseUpdateUpdateMethodTypeSourceSapHanaEnterpriseUpdateReadChangesUsingChangeDataCaptureCDC SourceSapHanaEnterpriseUpdateUpdateMethodType = "source-sap-hana-enterprise-update_Read Changes using Change Data Capture (CDC)"
)

// SourceSapHanaEnterpriseUpdateUpdateMethod - Configures how data is extracted from the database.
type SourceSapHanaEnterpriseUpdateUpdateMethod struct {
	SourceSapHanaEnterpriseUpdateScanChangesWithUserDefinedCursor     *SourceSapHanaEnterpriseUpdateScanChangesWithUserDefinedCursor     `queryParam:"inline" union:"member"`
	SourceSapHanaEnterpriseUpdateReadChangesUsingChangeDataCaptureCDC *SourceSapHanaEnterpriseUpdateReadChangesUsingChangeDataCaptureCDC `queryParam:"inline" union:"member"`

	Type SourceSapHanaEnterpriseUpdateUpdateMethodType
}

func CreateSourceSapHanaEnterpriseUpdateUpdateMethodSourceSapHanaEnterpriseUpdateScanChangesWithUserDefinedCursor(sourceSapHanaEnterpriseUpdateScanChangesWithUserDefinedCursor SourceSapHanaEnterpriseUpdateScanChangesWithUserDefinedCursor) SourceSapHanaEnterpriseUpdateUpdateMethod {
	typ := SourceSapHanaEnterpriseUpdateUpdateMethodTypeSourceSapHanaEnterpriseUpdateScanChangesWithUserDefinedCursor

	return SourceSapHanaEnterpriseUpdateUpdateMethod{
		SourceSapHanaEnterpriseUpdateScanChangesWithUserDefinedCursor: &sourceSapHanaEnterpriseUpdateScanChangesWithUserDefinedCursor,
		Type: typ,
	}
}

func CreateSourceSapHanaEnterpriseUpdateUpdateMethodSourceSapHanaEnterpriseUpdateReadChangesUsingChangeDataCaptureCDC(sourceSapHanaEnterpriseUpdateReadChangesUsingChangeDataCaptureCDC SourceSapHanaEnterpriseUpdateReadChangesUsingChangeDataCaptureCDC) SourceSapHanaEnterpriseUpdateUpdateMethod {
	typ := SourceSapHanaEnterpriseUpdateUpdateMethodTypeSourceSapHanaEnterpriseUpdateReadChangesUsingChangeDataCaptureCDC

	return SourceSapHanaEnterpriseUpdateUpdateMethod{
		SourceSapHanaEnterpriseUpdateReadChangesUsingChangeDataCaptureCDC: &sourceSapHanaEnterpriseUpdateReadChangesUsingChangeDataCaptureCDC,
		Type: typ,
	}
}

func (u *SourceSapHanaEnterpriseUpdateUpdateMethod) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var sourceSapHanaEnterpriseUpdateScanChangesWithUserDefinedCursor SourceSapHanaEnterpriseUpdateScanChangesWithUserDefinedCursor = SourceSapHanaEnterpriseUpdateScanChangesWithUserDefinedCursor{}
	if err := utils.UnmarshalJSON(data, &sourceSapHanaEnterpriseUpdateScanChangesWithUserDefinedCursor, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceSapHanaEnterpriseUpdateUpdateMethodTypeSourceSapHanaEnterpriseUpdateScanChangesWithUserDefinedCursor,
			Value: &sourceSapHanaEnterpriseUpdateScanChangesWithUserDefinedCursor,
		})
	}

	var sourceSapHanaEnterpriseUpdateReadChangesUsingChangeDataCaptureCDC SourceSapHanaEnterpriseUpdateReadChangesUsingChangeDataCaptureCDC = SourceSapHanaEnterpriseUpdateReadChangesUsingChangeDataCaptureCDC{}
	if err := utils.UnmarshalJSON(data, &sourceSapHanaEnterpriseUpdateReadChangesUsingChangeDataCaptureCDC, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceSapHanaEnterpriseUpdateUpdateMethodTypeSourceSapHanaEnterpriseUpdateReadChangesUsingChangeDataCaptureCDC,
			Value: &sourceSapHanaEnterpriseUpdateReadChangesUsingChangeDataCaptureCDC,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceSapHanaEnterpriseUpdateUpdateMethod", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceSapHanaEnterpriseUpdateUpdateMethod", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceSapHanaEnterpriseUpdateUpdateMethodType)
	switch best.Type {
	case SourceSapHanaEnterpriseUpdateUpdateMethodTypeSourceSapHanaEnterpriseUpdateScanChangesWithUserDefinedCursor:
		u.SourceSapHanaEnterpriseUpdateScanChangesWithUserDefinedCursor = best.Value.(*SourceSapHanaEnterpriseUpdateScanChangesWithUserDefinedCursor)
		return nil
	case SourceSapHanaEnterpriseUpdateUpdateMethodTypeSourceSapHanaEnterpriseUpdateReadChangesUsingChangeDataCaptureCDC:
		u.SourceSapHanaEnterpriseUpdateReadChangesUsingChangeDataCaptureCDC = best.Value.(*SourceSapHanaEnterpriseUpdateReadChangesUsingChangeDataCaptureCDC)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceSapHanaEnterpriseUpdateUpdateMethod", string(data))
}

func (u SourceSapHanaEnterpriseUpdateUpdateMethod) MarshalJSON() ([]byte, error) {
	if u.SourceSapHanaEnterpriseUpdateScanChangesWithUserDefinedCursor != nil {
		return utils.MarshalJSON(u.SourceSapHanaEnterpriseUpdateScanChangesWithUserDefinedCursor, "", true)
	}

	if u.SourceSapHanaEnterpriseUpdateReadChangesUsingChangeDataCaptureCDC != nil {
		return utils.MarshalJSON(u.SourceSapHanaEnterpriseUpdateReadChangesUsingChangeDataCaptureCDC, "", true)
	}

	return nil, errors.New("could not marshal union type SourceSapHanaEnterpriseUpdateUpdateMethod: all fields are null")
}

type SourceSapHanaEnterpriseUpdateSchemasEncryptionEncryptionMethod string

const (
	SourceSapHanaEnterpriseUpdateSchemasEncryptionEncryptionMethodEncryptedVerifyCertificate SourceSapHanaEnterpriseUpdateSchemasEncryptionEncryptionMethod = "encrypted_verify_certificate"
)

func (e SourceSapHanaEnterpriseUpdateSchemasEncryptionEncryptionMethod) ToPointer() *SourceSapHanaEnterpriseUpdateSchemasEncryptionEncryptionMethod {
	return &e
}
func (e *SourceSapHanaEnterpriseUpdateSchemasEncryptionEncryptionMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "encrypted_verify_certificate":
		*e = SourceSapHanaEnterpriseUpdateSchemasEncryptionEncryptionMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceSapHanaEnterpriseUpdateSchemasEncryptionEncryptionMethod: %v", v)
	}
}

// SourceSapHanaEnterpriseUpdateTLSEncryptedVerifyCertificate - Verify and use the certificate provided by the server.
type SourceSapHanaEnterpriseUpdateTLSEncryptedVerifyCertificate struct {
	EncryptionMethod *SourceSapHanaEnterpriseUpdateSchemasEncryptionEncryptionMethod `default:"encrypted_verify_certificate" json:"encryption_method"`
	// Privacy Enhanced Mail (PEM) files are concatenated certificate containers frequently used in certificate installations.
	SslCertificate       *string `json:"ssl_certificate,omitempty"`
	AdditionalProperties any     `additionalProperties:"true" json:"-"`
}

func (s SourceSapHanaEnterpriseUpdateTLSEncryptedVerifyCertificate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceSapHanaEnterpriseUpdateTLSEncryptedVerifyCertificate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceSapHanaEnterpriseUpdateTLSEncryptedVerifyCertificate) GetEncryptionMethod() *SourceSapHanaEnterpriseUpdateSchemasEncryptionEncryptionMethod {
	if s == nil {
		return nil
	}
	return s.EncryptionMethod
}

func (s *SourceSapHanaEnterpriseUpdateTLSEncryptedVerifyCertificate) GetSslCertificate() *string {
	if s == nil {
		return nil
	}
	return s.SslCertificate
}

func (s *SourceSapHanaEnterpriseUpdateTLSEncryptedVerifyCertificate) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

// SourceSapHanaEnterpriseUpdateEncryptionAlgorithm - This parameter defines what encryption algorithm is used.
type SourceSapHanaEnterpriseUpdateEncryptionAlgorithm string

const (
	SourceSapHanaEnterpriseUpdateEncryptionAlgorithmAes256      SourceSapHanaEnterpriseUpdateEncryptionAlgorithm = "AES256"
	SourceSapHanaEnterpriseUpdateEncryptionAlgorithmRc456       SourceSapHanaEnterpriseUpdateEncryptionAlgorithm = "RC4_56"
	SourceSapHanaEnterpriseUpdateEncryptionAlgorithmThreeDes168 SourceSapHanaEnterpriseUpdateEncryptionAlgorithm = "3DES168"
)

func (e SourceSapHanaEnterpriseUpdateEncryptionAlgorithm) ToPointer() *SourceSapHanaEnterpriseUpdateEncryptionAlgorithm {
	return &e
}
func (e *SourceSapHanaEnterpriseUpdateEncryptionAlgorithm) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "AES256":
		fallthrough
	case "RC4_56":
		fallthrough
	case "3DES168":
		*e = SourceSapHanaEnterpriseUpdateEncryptionAlgorithm(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceSapHanaEnterpriseUpdateEncryptionAlgorithm: %v", v)
	}
}

type SourceSapHanaEnterpriseUpdateSchemasEncryptionMethod string

const (
	SourceSapHanaEnterpriseUpdateSchemasEncryptionMethodClientNne SourceSapHanaEnterpriseUpdateSchemasEncryptionMethod = "client_nne"
)

func (e SourceSapHanaEnterpriseUpdateSchemasEncryptionMethod) ToPointer() *SourceSapHanaEnterpriseUpdateSchemasEncryptionMethod {
	return &e
}
func (e *SourceSapHanaEnterpriseUpdateSchemasEncryptionMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "client_nne":
		*e = SourceSapHanaEnterpriseUpdateSchemasEncryptionMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceSapHanaEnterpriseUpdateSchemasEncryptionMethod: %v", v)
	}
}

// SourceSapHanaEnterpriseUpdateNativeNetworkEncryptionNNE - The native network encryption gives you the ability to encrypt database connections, without the configuration overhead of TCP/IP and SSL/TLS and without the need to open and listen on different ports.
type SourceSapHanaEnterpriseUpdateNativeNetworkEncryptionNNE struct {
	// This parameter defines what encryption algorithm is used.
	EncryptionAlgorithm  *SourceSapHanaEnterpriseUpdateEncryptionAlgorithm     `default:"AES256" json:"encryption_algorithm"`
	EncryptionMethod     *SourceSapHanaEnterpriseUpdateSchemasEncryptionMethod `default:"client_nne" json:"encryption_method"`
	AdditionalProperties any                                                   `additionalProperties:"true" json:"-"`
}

func (s SourceSapHanaEnterpriseUpdateNativeNetworkEncryptionNNE) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceSapHanaEnterpriseUpdateNativeNetworkEncryptionNNE) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceSapHanaEnterpriseUpdateNativeNetworkEncryptionNNE) GetEncryptionAlgorithm() *SourceSapHanaEnterpriseUpdateEncryptionAlgorithm {
	if s == nil {
		return nil
	}
	return s.EncryptionAlgorithm
}

func (s *SourceSapHanaEnterpriseUpdateNativeNetworkEncryptionNNE) GetEncryptionMethod() *SourceSapHanaEnterpriseUpdateSchemasEncryptionMethod {
	if s == nil {
		return nil
	}
	return s.EncryptionMethod
}

func (s *SourceSapHanaEnterpriseUpdateNativeNetworkEncryptionNNE) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceSapHanaEnterpriseUpdateEncryptionMethod string

const (
	SourceSapHanaEnterpriseUpdateEncryptionMethodUnencrypted SourceSapHanaEnterpriseUpdateEncryptionMethod = "unencrypted"
)

func (e SourceSapHanaEnterpriseUpdateEncryptionMethod) ToPointer() *SourceSapHanaEnterpriseUpdateEncryptionMethod {
	return &e
}
func (e *SourceSapHanaEnterpriseUpdateEncryptionMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "unencrypted":
		*e = SourceSapHanaEnterpriseUpdateEncryptionMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceSapHanaEnterpriseUpdateEncryptionMethod: %v", v)
	}
}

// SourceSapHanaEnterpriseUpdateUnencrypted - Data transfer will not be encrypted.
type SourceSapHanaEnterpriseUpdateUnencrypted struct {
	EncryptionMethod     *SourceSapHanaEnterpriseUpdateEncryptionMethod `default:"unencrypted" json:"encryption_method"`
	AdditionalProperties any                                            `additionalProperties:"true" json:"-"`
}

func (s SourceSapHanaEnterpriseUpdateUnencrypted) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceSapHanaEnterpriseUpdateUnencrypted) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceSapHanaEnterpriseUpdateUnencrypted) GetEncryptionMethod() *SourceSapHanaEnterpriseUpdateEncryptionMethod {
	if s == nil {
		return nil
	}
	return s.EncryptionMethod
}

func (s *SourceSapHanaEnterpriseUpdateUnencrypted) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceSapHanaEnterpriseUpdateEncryptionType string

const (
	SourceSapHanaEnterpriseUpdateEncryptionTypeSourceSapHanaEnterpriseUpdateUnencrypted                   SourceSapHanaEnterpriseUpdateEncryptionType = "source-sap-hana-enterprise-update_Unencrypted"
	SourceSapHanaEnterpriseUpdateEncryptionTypeSourceSapHanaEnterpriseUpdateNativeNetworkEncryptionNNE    SourceSapHanaEnterpriseUpdateEncryptionType = "source-sap-hana-enterprise-update_Native Network Encryption (NNE)"
	SourceSapHanaEnterpriseUpdateEncryptionTypeSourceSapHanaEnterpriseUpdateTLSEncryptedVerifyCertificate SourceSapHanaEnterpriseUpdateEncryptionType = "source-sap-hana-enterprise-update_TLS Encrypted (verify certificate)"
)

// SourceSapHanaEnterpriseUpdateEncryption - The encryption method with is used when communicating with the database.
type SourceSapHanaEnterpriseUpdateEncryption struct {
	SourceSapHanaEnterpriseUpdateUnencrypted                   *SourceSapHanaEnterpriseUpdateUnencrypted                   `queryParam:"inline" union:"member"`
	SourceSapHanaEnterpriseUpdateNativeNetworkEncryptionNNE    *SourceSapHanaEnterpriseUpdateNativeNetworkEncryptionNNE    `queryParam:"inline" union:"member"`
	SourceSapHanaEnterpriseUpdateTLSEncryptedVerifyCertificate *SourceSapHanaEnterpriseUpdateTLSEncryptedVerifyCertificate `queryParam:"inline" union:"member"`

	Type SourceSapHanaEnterpriseUpdateEncryptionType
}

func CreateSourceSapHanaEnterpriseUpdateEncryptionSourceSapHanaEnterpriseUpdateUnencrypted(sourceSapHanaEnterpriseUpdateUnencrypted SourceSapHanaEnterpriseUpdateUnencrypted) SourceSapHanaEnterpriseUpdateEncryption {
	typ := SourceSapHanaEnterpriseUpdateEncryptionTypeSourceSapHanaEnterpriseUpdateUnencrypted

	return SourceSapHanaEnterpriseUpdateEncryption{
		SourceSapHanaEnterpriseUpdateUnencrypted: &sourceSapHanaEnterpriseUpdateUnencrypted,
		Type:                                     typ,
	}
}

func CreateSourceSapHanaEnterpriseUpdateEncryptionSourceSapHanaEnterpriseUpdateNativeNetworkEncryptionNNE(sourceSapHanaEnterpriseUpdateNativeNetworkEncryptionNNE SourceSapHanaEnterpriseUpdateNativeNetworkEncryptionNNE) SourceSapHanaEnterpriseUpdateEncryption {
	typ := SourceSapHanaEnterpriseUpdateEncryptionTypeSourceSapHanaEnterpriseUpdateNativeNetworkEncryptionNNE

	return SourceSapHanaEnterpriseUpdateEncryption{
		SourceSapHanaEnterpriseUpdateNativeNetworkEncryptionNNE: &sourceSapHanaEnterpriseUpdateNativeNetworkEncryptionNNE,
		Type: typ,
	}
}

func CreateSourceSapHanaEnterpriseUpdateEncryptionSourceSapHanaEnterpriseUpdateTLSEncryptedVerifyCertificate(sourceSapHanaEnterpriseUpdateTLSEncryptedVerifyCertificate SourceSapHanaEnterpriseUpdateTLSEncryptedVerifyCertificate) SourceSapHanaEnterpriseUpdateEncryption {
	typ := SourceSapHanaEnterpriseUpdateEncryptionTypeSourceSapHanaEnterpriseUpdateTLSEncryptedVerifyCertificate

	return SourceSapHanaEnterpriseUpdateEncryption{
		SourceSapHanaEnterpriseUpdateTLSEncryptedVerifyCertificate: &sourceSapHanaEnterpriseUpdateTLSEncryptedVerifyCertificate,
		Type: typ,
	}
}

func (u *SourceSapHanaEnterpriseUpdateEncryption) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var sourceSapHanaEnterpriseUpdateUnencrypted SourceSapHanaEnterpriseUpdateUnencrypted = SourceSapHanaEnterpriseUpdateUnencrypted{}
	if err := utils.UnmarshalJSON(data, &sourceSapHanaEnterpriseUpdateUnencrypted, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceSapHanaEnterpriseUpdateEncryptionTypeSourceSapHanaEnterpriseUpdateUnencrypted,
			Value: &sourceSapHanaEnterpriseUpdateUnencrypted,
		})
	}

	var sourceSapHanaEnterpriseUpdateNativeNetworkEncryptionNNE SourceSapHanaEnterpriseUpdateNativeNetworkEncryptionNNE = SourceSapHanaEnterpriseUpdateNativeNetworkEncryptionNNE{}
	if err := utils.UnmarshalJSON(data, &sourceSapHanaEnterpriseUpdateNativeNetworkEncryptionNNE, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceSapHanaEnterpriseUpdateEncryptionTypeSourceSapHanaEnterpriseUpdateNativeNetworkEncryptionNNE,
			Value: &sourceSapHanaEnterpriseUpdateNativeNetworkEncryptionNNE,
		})
	}

	var sourceSapHanaEnterpriseUpdateTLSEncryptedVerifyCertificate SourceSapHanaEnterpriseUpdateTLSEncryptedVerifyCertificate = SourceSapHanaEnterpriseUpdateTLSEncryptedVerifyCertificate{}
	if err := utils.UnmarshalJSON(data, &sourceSapHanaEnterpriseUpdateTLSEncryptedVerifyCertificate, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceSapHanaEnterpriseUpdateEncryptionTypeSourceSapHanaEnterpriseUpdateTLSEncryptedVerifyCertificate,
			Value: &sourceSapHanaEnterpriseUpdateTLSEncryptedVerifyCertificate,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceSapHanaEnterpriseUpdateEncryption", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceSapHanaEnterpriseUpdateEncryption", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceSapHanaEnterpriseUpdateEncryptionType)
	switch best.Type {
	case SourceSapHanaEnterpriseUpdateEncryptionTypeSourceSapHanaEnterpriseUpdateUnencrypted:
		u.SourceSapHanaEnterpriseUpdateUnencrypted = best.Value.(*SourceSapHanaEnterpriseUpdateUnencrypted)
		return nil
	case SourceSapHanaEnterpriseUpdateEncryptionTypeSourceSapHanaEnterpriseUpdateNativeNetworkEncryptionNNE:
		u.SourceSapHanaEnterpriseUpdateNativeNetworkEncryptionNNE = best.Value.(*SourceSapHanaEnterpriseUpdateNativeNetworkEncryptionNNE)
		return nil
	case SourceSapHanaEnterpriseUpdateEncryptionTypeSourceSapHanaEnterpriseUpdateTLSEncryptedVerifyCertificate:
		u.SourceSapHanaEnterpriseUpdateTLSEncryptedVerifyCertificate = best.Value.(*SourceSapHanaEnterpriseUpdateTLSEncryptedVerifyCertificate)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceSapHanaEnterpriseUpdateEncryption", string(data))
}

func (u SourceSapHanaEnterpriseUpdateEncryption) MarshalJSON() ([]byte, error) {
	if u.SourceSapHanaEnterpriseUpdateUnencrypted != nil {
		return utils.MarshalJSON(u.SourceSapHanaEnterpriseUpdateUnencrypted, "", true)
	}

	if u.SourceSapHanaEnterpriseUpdateNativeNetworkEncryptionNNE != nil {
		return utils.MarshalJSON(u.SourceSapHanaEnterpriseUpdateNativeNetworkEncryptionNNE, "", true)
	}

	if u.SourceSapHanaEnterpriseUpdateTLSEncryptedVerifyCertificate != nil {
		return utils.MarshalJSON(u.SourceSapHanaEnterpriseUpdateTLSEncryptedVerifyCertificate, "", true)
	}

	return nil, errors.New("could not marshal union type SourceSapHanaEnterpriseUpdateEncryption: all fields are null")
}

// SourceSapHanaEnterpriseUpdateTableFilter - Inclusion filter configuration for table selection per schema.
type SourceSapHanaEnterpriseUpdateTableFilter struct {
	// The name of the schema to apply this filter to. Should match a schema defined in "Schemas" field above.
	SchemaName *string `json:"schema_name,omitempty"`
	// List of table name patterns to include from this schema. Each filter should be a SQL LIKE pattern.
	TableNamePatterns    []string `json:"table_name_patterns,omitempty"`
	AdditionalProperties any      `additionalProperties:"true" json:"-"`
}

func (s SourceSapHanaEnterpriseUpdateTableFilter) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceSapHanaEnterpriseUpdateTableFilter) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceSapHanaEnterpriseUpdateTableFilter) GetSchemaName() *string {
	if s == nil {
		return nil
	}
	return s.SchemaName
}

func (s *SourceSapHanaEnterpriseUpdateTableFilter) GetTableNamePatterns() []string {
	if s == nil {
		return nil
	}
	return s.TableNamePatterns
}

func (s *SourceSapHanaEnterpriseUpdateTableFilter) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceSapHanaEnterpriseUpdateSchemasTunnelMethodTunnelMethod string

const (
	SourceSapHanaEnterpriseUpdateSchemasTunnelMethodTunnelMethodSSHPasswordAuth SourceSapHanaEnterpriseUpdateSchemasTunnelMethodTunnelMethod = "SSH_PASSWORD_AUTH"
)

func (e SourceSapHanaEnterpriseUpdateSchemasTunnelMethodTunnelMethod) ToPointer() *SourceSapHanaEnterpriseUpdateSchemasTunnelMethodTunnelMethod {
	return &e
}
func (e *SourceSapHanaEnterpriseUpdateSchemasTunnelMethodTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_PASSWORD_AUTH":
		*e = SourceSapHanaEnterpriseUpdateSchemasTunnelMethodTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceSapHanaEnterpriseUpdateSchemasTunnelMethodTunnelMethod: %v", v)
	}
}

// SourceSapHanaEnterpriseUpdatePasswordAuthentication - Connect through a jump server tunnel host using username and password authentication
type SourceSapHanaEnterpriseUpdatePasswordAuthentication struct {
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost   *string                                                       `json:"tunnel_host,omitempty"`
	TunnelMethod *SourceSapHanaEnterpriseUpdateSchemasTunnelMethodTunnelMethod `default:"SSH_PASSWORD_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser *string `json:"tunnel_user,omitempty"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword   *string `json:"tunnel_user_password,omitempty"`
	AdditionalProperties any     `additionalProperties:"true" json:"-"`
}

func (s SourceSapHanaEnterpriseUpdatePasswordAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceSapHanaEnterpriseUpdatePasswordAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceSapHanaEnterpriseUpdatePasswordAuthentication) GetTunnelHost() *string {
	if s == nil {
		return nil
	}
	return s.TunnelHost
}

func (s *SourceSapHanaEnterpriseUpdatePasswordAuthentication) GetTunnelMethod() *SourceSapHanaEnterpriseUpdateSchemasTunnelMethodTunnelMethod {
	if s == nil {
		return nil
	}
	return s.TunnelMethod
}

func (s *SourceSapHanaEnterpriseUpdatePasswordAuthentication) GetTunnelPort() *int64 {
	if s == nil {
		return nil
	}
	return s.TunnelPort
}

func (s *SourceSapHanaEnterpriseUpdatePasswordAuthentication) GetTunnelUser() *string {
	if s == nil {
		return nil
	}
	return s.TunnelUser
}

func (s *SourceSapHanaEnterpriseUpdatePasswordAuthentication) GetTunnelUserPassword() *string {
	if s == nil {
		return nil
	}
	return s.TunnelUserPassword
}

func (s *SourceSapHanaEnterpriseUpdatePasswordAuthentication) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceSapHanaEnterpriseUpdateSchemasTunnelMethod string

const (
	SourceSapHanaEnterpriseUpdateSchemasTunnelMethodSSHKeyAuth SourceSapHanaEnterpriseUpdateSchemasTunnelMethod = "SSH_KEY_AUTH"
)

func (e SourceSapHanaEnterpriseUpdateSchemasTunnelMethod) ToPointer() *SourceSapHanaEnterpriseUpdateSchemasTunnelMethod {
	return &e
}
func (e *SourceSapHanaEnterpriseUpdateSchemasTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_KEY_AUTH":
		*e = SourceSapHanaEnterpriseUpdateSchemasTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceSapHanaEnterpriseUpdateSchemasTunnelMethod: %v", v)
	}
}

// SourceSapHanaEnterpriseUpdateSSHKeyAuthentication - Connect through a jump server tunnel host using username and ssh key
type SourceSapHanaEnterpriseUpdateSSHKeyAuthentication struct {
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey *string `json:"ssh_key,omitempty"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost   *string                                           `json:"tunnel_host,omitempty"`
	TunnelMethod *SourceSapHanaEnterpriseUpdateSchemasTunnelMethod `default:"SSH_KEY_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser           *string `json:"tunnel_user,omitempty"`
	AdditionalProperties any     `additionalProperties:"true" json:"-"`
}

func (s SourceSapHanaEnterpriseUpdateSSHKeyAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceSapHanaEnterpriseUpdateSSHKeyAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceSapHanaEnterpriseUpdateSSHKeyAuthentication) GetSSHKey() *string {
	if s == nil {
		return nil
	}
	return s.SSHKey
}

func (s *SourceSapHanaEnterpriseUpdateSSHKeyAuthentication) GetTunnelHost() *string {
	if s == nil {
		return nil
	}
	return s.TunnelHost
}

func (s *SourceSapHanaEnterpriseUpdateSSHKeyAuthentication) GetTunnelMethod() *SourceSapHanaEnterpriseUpdateSchemasTunnelMethod {
	if s == nil {
		return nil
	}
	return s.TunnelMethod
}

func (s *SourceSapHanaEnterpriseUpdateSSHKeyAuthentication) GetTunnelPort() *int64 {
	if s == nil {
		return nil
	}
	return s.TunnelPort
}

func (s *SourceSapHanaEnterpriseUpdateSSHKeyAuthentication) GetTunnelUser() *string {
	if s == nil {
		return nil
	}
	return s.TunnelUser
}

func (s *SourceSapHanaEnterpriseUpdateSSHKeyAuthentication) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceSapHanaEnterpriseUpdateTunnelMethod string

const (
	SourceSapHanaEnterpriseUpdateTunnelMethodNoTunnel SourceSapHanaEnterpriseUpdateTunnelMethod = "NO_TUNNEL"
)

func (e SourceSapHanaEnterpriseUpdateTunnelMethod) ToPointer() *SourceSapHanaEnterpriseUpdateTunnelMethod {
	return &e
}
func (e *SourceSapHanaEnterpriseUpdateTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NO_TUNNEL":
		*e = SourceSapHanaEnterpriseUpdateTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceSapHanaEnterpriseUpdateTunnelMethod: %v", v)
	}
}

// SourceSapHanaEnterpriseUpdateNoTunnel - No ssh tunnel needed to connect to database
type SourceSapHanaEnterpriseUpdateNoTunnel struct {
	TunnelMethod         *SourceSapHanaEnterpriseUpdateTunnelMethod `default:"NO_TUNNEL" json:"tunnel_method"`
	AdditionalProperties any                                        `additionalProperties:"true" json:"-"`
}

func (s SourceSapHanaEnterpriseUpdateNoTunnel) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceSapHanaEnterpriseUpdateNoTunnel) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceSapHanaEnterpriseUpdateNoTunnel) GetTunnelMethod() *SourceSapHanaEnterpriseUpdateTunnelMethod {
	if s == nil {
		return nil
	}
	return s.TunnelMethod
}

func (s *SourceSapHanaEnterpriseUpdateNoTunnel) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceSapHanaEnterpriseUpdateSSHTunnelMethodType string

const (
	SourceSapHanaEnterpriseUpdateSSHTunnelMethodTypeSourceSapHanaEnterpriseUpdateNoTunnel               SourceSapHanaEnterpriseUpdateSSHTunnelMethodType = "source-sap-hana-enterprise-update_No Tunnel"
	SourceSapHanaEnterpriseUpdateSSHTunnelMethodTypeSourceSapHanaEnterpriseUpdateSSHKeyAuthentication   SourceSapHanaEnterpriseUpdateSSHTunnelMethodType = "source-sap-hana-enterprise-update_SSH Key Authentication"
	SourceSapHanaEnterpriseUpdateSSHTunnelMethodTypeSourceSapHanaEnterpriseUpdatePasswordAuthentication SourceSapHanaEnterpriseUpdateSSHTunnelMethodType = "source-sap-hana-enterprise-update_Password Authentication"
)

// SourceSapHanaEnterpriseUpdateSSHTunnelMethod - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceSapHanaEnterpriseUpdateSSHTunnelMethod struct {
	SourceSapHanaEnterpriseUpdateNoTunnel               *SourceSapHanaEnterpriseUpdateNoTunnel               `queryParam:"inline" union:"member"`
	SourceSapHanaEnterpriseUpdateSSHKeyAuthentication   *SourceSapHanaEnterpriseUpdateSSHKeyAuthentication   `queryParam:"inline" union:"member"`
	SourceSapHanaEnterpriseUpdatePasswordAuthentication *SourceSapHanaEnterpriseUpdatePasswordAuthentication `queryParam:"inline" union:"member"`

	Type SourceSapHanaEnterpriseUpdateSSHTunnelMethodType
}

func CreateSourceSapHanaEnterpriseUpdateSSHTunnelMethodSourceSapHanaEnterpriseUpdateNoTunnel(sourceSapHanaEnterpriseUpdateNoTunnel SourceSapHanaEnterpriseUpdateNoTunnel) SourceSapHanaEnterpriseUpdateSSHTunnelMethod {
	typ := SourceSapHanaEnterpriseUpdateSSHTunnelMethodTypeSourceSapHanaEnterpriseUpdateNoTunnel

	return SourceSapHanaEnterpriseUpdateSSHTunnelMethod{
		SourceSapHanaEnterpriseUpdateNoTunnel: &sourceSapHanaEnterpriseUpdateNoTunnel,
		Type:                                  typ,
	}
}

func CreateSourceSapHanaEnterpriseUpdateSSHTunnelMethodSourceSapHanaEnterpriseUpdateSSHKeyAuthentication(sourceSapHanaEnterpriseUpdateSSHKeyAuthentication SourceSapHanaEnterpriseUpdateSSHKeyAuthentication) SourceSapHanaEnterpriseUpdateSSHTunnelMethod {
	typ := SourceSapHanaEnterpriseUpdateSSHTunnelMethodTypeSourceSapHanaEnterpriseUpdateSSHKeyAuthentication

	return SourceSapHanaEnterpriseUpdateSSHTunnelMethod{
		SourceSapHanaEnterpriseUpdateSSHKeyAuthentication: &sourceSapHanaEnterpriseUpdateSSHKeyAuthentication,
		Type: typ,
	}
}

func CreateSourceSapHanaEnterpriseUpdateSSHTunnelMethodSourceSapHanaEnterpriseUpdatePasswordAuthentication(sourceSapHanaEnterpriseUpdatePasswordAuthentication SourceSapHanaEnterpriseUpdatePasswordAuthentication) SourceSapHanaEnterpriseUpdateSSHTunnelMethod {
	typ := SourceSapHanaEnterpriseUpdateSSHTunnelMethodTypeSourceSapHanaEnterpriseUpdatePasswordAuthentication

	return SourceSapHanaEnterpriseUpdateSSHTunnelMethod{
		SourceSapHanaEnterpriseUpdatePasswordAuthentication: &sourceSapHanaEnterpriseUpdatePasswordAuthentication,
		Type: typ,
	}
}

func (u *SourceSapHanaEnterpriseUpdateSSHTunnelMethod) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var sourceSapHanaEnterpriseUpdateNoTunnel SourceSapHanaEnterpriseUpdateNoTunnel = SourceSapHanaEnterpriseUpdateNoTunnel{}
	if err := utils.UnmarshalJSON(data, &sourceSapHanaEnterpriseUpdateNoTunnel, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceSapHanaEnterpriseUpdateSSHTunnelMethodTypeSourceSapHanaEnterpriseUpdateNoTunnel,
			Value: &sourceSapHanaEnterpriseUpdateNoTunnel,
		})
	}

	var sourceSapHanaEnterpriseUpdateSSHKeyAuthentication SourceSapHanaEnterpriseUpdateSSHKeyAuthentication = SourceSapHanaEnterpriseUpdateSSHKeyAuthentication{}
	if err := utils.UnmarshalJSON(data, &sourceSapHanaEnterpriseUpdateSSHKeyAuthentication, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceSapHanaEnterpriseUpdateSSHTunnelMethodTypeSourceSapHanaEnterpriseUpdateSSHKeyAuthentication,
			Value: &sourceSapHanaEnterpriseUpdateSSHKeyAuthentication,
		})
	}

	var sourceSapHanaEnterpriseUpdatePasswordAuthentication SourceSapHanaEnterpriseUpdatePasswordAuthentication = SourceSapHanaEnterpriseUpdatePasswordAuthentication{}
	if err := utils.UnmarshalJSON(data, &sourceSapHanaEnterpriseUpdatePasswordAuthentication, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceSapHanaEnterpriseUpdateSSHTunnelMethodTypeSourceSapHanaEnterpriseUpdatePasswordAuthentication,
			Value: &sourceSapHanaEnterpriseUpdatePasswordAuthentication,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceSapHanaEnterpriseUpdateSSHTunnelMethod", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceSapHanaEnterpriseUpdateSSHTunnelMethod", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceSapHanaEnterpriseUpdateSSHTunnelMethodType)
	switch best.Type {
	case SourceSapHanaEnterpriseUpdateSSHTunnelMethodTypeSourceSapHanaEnterpriseUpdateNoTunnel:
		u.SourceSapHanaEnterpriseUpdateNoTunnel = best.Value.(*SourceSapHanaEnterpriseUpdateNoTunnel)
		return nil
	case SourceSapHanaEnterpriseUpdateSSHTunnelMethodTypeSourceSapHanaEnterpriseUpdateSSHKeyAuthentication:
		u.SourceSapHanaEnterpriseUpdateSSHKeyAuthentication = best.Value.(*SourceSapHanaEnterpriseUpdateSSHKeyAuthentication)
		return nil
	case SourceSapHanaEnterpriseUpdateSSHTunnelMethodTypeSourceSapHanaEnterpriseUpdatePasswordAuthentication:
		u.SourceSapHanaEnterpriseUpdatePasswordAuthentication = best.Value.(*SourceSapHanaEnterpriseUpdatePasswordAuthentication)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceSapHanaEnterpriseUpdateSSHTunnelMethod", string(data))
}

func (u SourceSapHanaEnterpriseUpdateSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.SourceSapHanaEnterpriseUpdateNoTunnel != nil {
		return utils.MarshalJSON(u.SourceSapHanaEnterpriseUpdateNoTunnel, "", true)
	}

	if u.SourceSapHanaEnterpriseUpdateSSHKeyAuthentication != nil {
		return utils.MarshalJSON(u.SourceSapHanaEnterpriseUpdateSSHKeyAuthentication, "", true)
	}

	if u.SourceSapHanaEnterpriseUpdatePasswordAuthentication != nil {
		return utils.MarshalJSON(u.SourceSapHanaEnterpriseUpdatePasswordAuthentication, "", true)
	}

	return nil, errors.New("could not marshal union type SourceSapHanaEnterpriseUpdateSSHTunnelMethod: all fields are null")
}

type SourceSapHanaEnterpriseUpdateSourceType string

const (
	SourceSapHanaEnterpriseUpdateSourceTypeSapHanaEnterprise SourceSapHanaEnterpriseUpdateSourceType = "sap-hana-enterprise"
)

func (e SourceSapHanaEnterpriseUpdateSourceType) ToPointer() *SourceSapHanaEnterpriseUpdateSourceType {
	return &e
}
func (e *SourceSapHanaEnterpriseUpdateSourceType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "sap-hana-enterprise":
		*e = SourceSapHanaEnterpriseUpdateSourceType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceSapHanaEnterpriseUpdateSourceType: %v", v)
	}
}

type SourceSapHanaEnterpriseUpdate struct {
	// When this feature is enabled, during schema discovery the connector will query each table or view individually to check access privileges and inaccessible tables, views, or columns therein will be removed. In large schemas, this might cause schema discovery to take too long, in which case it might be advisable to disable this feature.
	CheckPrivileges *bool `default:"true" json:"check_privileges"`
	// How often (in seconds) a stream should checkpoint, when possible.
	CheckpointTargetIntervalSeconds *int64 `default:"300" json:"checkpoint_target_interval_seconds"`
	// Maximum number of concurrent queries to the database.
	Concurrency *int64 `default:"1" json:"concurrency"`
	// Configures how data is extracted from the database.
	Cursor *SourceSapHanaEnterpriseUpdateUpdateMethod `json:"cursor,omitempty"`
	// The name of the tenant database to connect to. This is required for multi-tenant SAP HANA systems. For single-tenant systems, this can be left empty.
	Database *string `json:"database,omitempty"`
	// The encryption method with is used when communicating with the database.
	Encryption *SourceSapHanaEnterpriseUpdateEncryption `json:"encryption,omitempty"`
	// Inclusion filters for table selection per schema. If no filters are specified for a schema, all tables in that schema will be synced.
	Filters []SourceSapHanaEnterpriseUpdateTableFilter `json:"filters,omitempty"`
	// Hostname of the database.
	Host *string `json:"host,omitempty"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// The password associated with the username.
	Password *string `json:"password,omitempty"`
	// Port of the database. SAP recommends the following port numbers: 443 - Default listening port for SAP HANA Cloud client connections to the listener.
	Port *int64 `default:"443" json:"port"`
	// The list of schemas to sync from. Defaults to user. Case sensitive.
	Schemas []string `json:"schemas,omitempty"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod *SourceSapHanaEnterpriseUpdateSSHTunnelMethod `json:"tunnel_method,omitempty"`
	// The username which is used to access the database.
	Username             *string                                  `json:"username,omitempty"`
	sourceType           *SourceSapHanaEnterpriseUpdateSourceType `const:"sap-hana-enterprise" json:"sourceType"`
	AdditionalProperties any                                      `additionalProperties:"true" json:"-"`
}

func (s SourceSapHanaEnterpriseUpdate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceSapHanaEnterpriseUpdate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceSapHanaEnterpriseUpdate) GetCheckPrivileges() *bool {
	if s == nil {
		return nil
	}
	return s.CheckPrivileges
}

func (s *SourceSapHanaEnterpriseUpdate) GetCheckpointTargetIntervalSeconds() *int64 {
	if s == nil {
		return nil
	}
	return s.CheckpointTargetIntervalSeconds
}

func (s *SourceSapHanaEnterpriseUpdate) GetConcurrency() *int64 {
	if s == nil {
		return nil
	}
	return s.Concurrency
}

func (s *SourceSapHanaEnterpriseUpdate) GetCursor() *SourceSapHanaEnterpriseUpdateUpdateMethod {
	if s == nil {
		return nil
	}
	return s.Cursor
}

func (s *SourceSapHanaEnterpriseUpdate) GetDatabase() *string {
	if s == nil {
		return nil
	}
	return s.Database
}

func (s *SourceSapHanaEnterpriseUpdate) GetEncryption() *SourceSapHanaEnterpriseUpdateEncryption {
	if s == nil {
		return nil
	}
	return s.Encryption
}

func (s *SourceSapHanaEnterpriseUpdate) GetFilters() []SourceSapHanaEnterpriseUpdateTableFilter {
	if s == nil {
		return nil
	}
	return s.Filters
}

func (s *SourceSapHanaEnterpriseUpdate) GetHost() *string {
	if s == nil {
		return nil
	}
	return s.Host
}

func (s *SourceSapHanaEnterpriseUpdate) GetJdbcURLParams() *string {
	if s == nil {
		return nil
	}
	return s.JdbcURLParams
}

func (s *SourceSapHanaEnterpriseUpdate) GetPassword() *string {
	if s == nil {
		return nil
	}
	return s.Password
}

func (s *SourceSapHanaEnterpriseUpdate) GetPort() *int64 {
	if s == nil {
		return nil
	}
	return s.Port
}

func (s *SourceSapHanaEnterpriseUpdate) GetSchemas() []string {
	if s == nil {
		return nil
	}
	return s.Schemas
}

func (s *SourceSapHanaEnterpriseUpdate) GetTunnelMethod() *SourceSapHanaEnterpriseUpdateSSHTunnelMethod {
	if s == nil {
		return nil
	}
	return s.TunnelMethod
}

func (s *SourceSapHanaEnterpriseUpdate) GetUsername() *string {
	if s == nil {
		return nil
	}
	return s.Username
}

func (s *SourceSapHanaEnterpriseUpdate) GetSourceType() *SourceSapHanaEnterpriseUpdateSourceType {
	return SourceSapHanaEnterpriseUpdateSourceTypeSapHanaEnterprise.ToPointer()
}

func (s *SourceSapHanaEnterpriseUpdate) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}
