// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

type DestinationGcsDataLakeUpdateSchemasCatalogType string

const (
	DestinationGcsDataLakeUpdateSchemasCatalogTypePolaris DestinationGcsDataLakeUpdateSchemasCatalogType = "POLARIS"
)

func (e DestinationGcsDataLakeUpdateSchemasCatalogType) ToPointer() *DestinationGcsDataLakeUpdateSchemasCatalogType {
	return &e
}
func (e *DestinationGcsDataLakeUpdateSchemasCatalogType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "POLARIS":
		*e = DestinationGcsDataLakeUpdateSchemasCatalogType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsDataLakeUpdateSchemasCatalogType: %v", v)
	}
}

// DestinationGcsDataLakeUpdatePolarisCatalog - Configuration for Apache Polaris Iceberg catalog.
type DestinationGcsDataLakeUpdatePolarisCatalog struct {
	// The name of the catalog in Polaris. This corresponds to the catalog name created via the Polaris Management API.
	CatalogName *string                                         `json:"catalog_name,omitempty"`
	CatalogType *DestinationGcsDataLakeUpdateSchemasCatalogType `default:"POLARIS" json:"catalog_type"`
	// The OAuth Client ID for authenticating with the Polaris server.
	ClientID *string `json:"client_id,omitempty"`
	// The OAuth Client Secret for authenticating with the Polaris server.
	ClientSecret *string `json:"client_secret,omitempty"`
	// The base URL of the Polaris server. For example: http://localhost:8181/api/catalog
	ServerURI            *string `json:"server_uri,omitempty"`
	AdditionalProperties any     `additionalProperties:"true" json:"-"`
}

func (d DestinationGcsDataLakeUpdatePolarisCatalog) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsDataLakeUpdatePolarisCatalog) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationGcsDataLakeUpdatePolarisCatalog) GetCatalogName() *string {
	if d == nil {
		return nil
	}
	return d.CatalogName
}

func (d *DestinationGcsDataLakeUpdatePolarisCatalog) GetCatalogType() *DestinationGcsDataLakeUpdateSchemasCatalogType {
	if d == nil {
		return nil
	}
	return d.CatalogType
}

func (d *DestinationGcsDataLakeUpdatePolarisCatalog) GetClientID() *string {
	if d == nil {
		return nil
	}
	return d.ClientID
}

func (d *DestinationGcsDataLakeUpdatePolarisCatalog) GetClientSecret() *string {
	if d == nil {
		return nil
	}
	return d.ClientSecret
}

func (d *DestinationGcsDataLakeUpdatePolarisCatalog) GetServerURI() *string {
	if d == nil {
		return nil
	}
	return d.ServerURI
}

func (d *DestinationGcsDataLakeUpdatePolarisCatalog) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationGcsDataLakeUpdateSchemasCatalogTypeCatalogType string

const (
	DestinationGcsDataLakeUpdateSchemasCatalogTypeCatalogTypeBiglake DestinationGcsDataLakeUpdateSchemasCatalogTypeCatalogType = "BIGLAKE"
)

func (e DestinationGcsDataLakeUpdateSchemasCatalogTypeCatalogType) ToPointer() *DestinationGcsDataLakeUpdateSchemasCatalogTypeCatalogType {
	return &e
}
func (e *DestinationGcsDataLakeUpdateSchemasCatalogTypeCatalogType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "BIGLAKE":
		*e = DestinationGcsDataLakeUpdateSchemasCatalogTypeCatalogType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsDataLakeUpdateSchemasCatalogTypeCatalogType: %v", v)
	}
}

// DestinationGcsDataLakeUpdateBigLakeCatalog - Configuration for Google Cloud BigLake Iceberg catalog.
type DestinationGcsDataLakeUpdateBigLakeCatalog struct {
	// The name of the BigLake catalog. This should match the catalog you created in BigLake metastore.
	CatalogName          *string                                                    `json:"catalog_name,omitempty"`
	CatalogType          *DestinationGcsDataLakeUpdateSchemasCatalogTypeCatalogType `default:"BIGLAKE" json:"catalog_type"`
	AdditionalProperties any                                                        `additionalProperties:"true" json:"-"`
}

func (d DestinationGcsDataLakeUpdateBigLakeCatalog) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsDataLakeUpdateBigLakeCatalog) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationGcsDataLakeUpdateBigLakeCatalog) GetCatalogName() *string {
	if d == nil {
		return nil
	}
	return d.CatalogName
}

func (d *DestinationGcsDataLakeUpdateBigLakeCatalog) GetCatalogType() *DestinationGcsDataLakeUpdateSchemasCatalogTypeCatalogType {
	if d == nil {
		return nil
	}
	return d.CatalogType
}

func (d *DestinationGcsDataLakeUpdateBigLakeCatalog) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}

type DestinationGcsDataLakeUpdateCatalogTypeType string

const (
	DestinationGcsDataLakeUpdateCatalogTypeTypeDestinationGcsDataLakeUpdateBigLakeCatalog DestinationGcsDataLakeUpdateCatalogTypeType = "destination-gcs-data-lake-update_BigLake Catalog"
	DestinationGcsDataLakeUpdateCatalogTypeTypeDestinationGcsDataLakeUpdatePolarisCatalog DestinationGcsDataLakeUpdateCatalogTypeType = "destination-gcs-data-lake-update_Polaris Catalog"
)

// DestinationGcsDataLakeUpdateCatalogType - Specifies the type of Iceberg catalog (BigLake or Polaris).
type DestinationGcsDataLakeUpdateCatalogType struct {
	DestinationGcsDataLakeUpdateBigLakeCatalog *DestinationGcsDataLakeUpdateBigLakeCatalog `queryParam:"inline" union:"member"`
	DestinationGcsDataLakeUpdatePolarisCatalog *DestinationGcsDataLakeUpdatePolarisCatalog `queryParam:"inline" union:"member"`

	Type DestinationGcsDataLakeUpdateCatalogTypeType
}

func CreateDestinationGcsDataLakeUpdateCatalogTypeDestinationGcsDataLakeUpdateBigLakeCatalog(destinationGcsDataLakeUpdateBigLakeCatalog DestinationGcsDataLakeUpdateBigLakeCatalog) DestinationGcsDataLakeUpdateCatalogType {
	typ := DestinationGcsDataLakeUpdateCatalogTypeTypeDestinationGcsDataLakeUpdateBigLakeCatalog

	return DestinationGcsDataLakeUpdateCatalogType{
		DestinationGcsDataLakeUpdateBigLakeCatalog: &destinationGcsDataLakeUpdateBigLakeCatalog,
		Type: typ,
	}
}

func CreateDestinationGcsDataLakeUpdateCatalogTypeDestinationGcsDataLakeUpdatePolarisCatalog(destinationGcsDataLakeUpdatePolarisCatalog DestinationGcsDataLakeUpdatePolarisCatalog) DestinationGcsDataLakeUpdateCatalogType {
	typ := DestinationGcsDataLakeUpdateCatalogTypeTypeDestinationGcsDataLakeUpdatePolarisCatalog

	return DestinationGcsDataLakeUpdateCatalogType{
		DestinationGcsDataLakeUpdatePolarisCatalog: &destinationGcsDataLakeUpdatePolarisCatalog,
		Type: typ,
	}
}

func (u *DestinationGcsDataLakeUpdateCatalogType) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var destinationGcsDataLakeUpdateBigLakeCatalog DestinationGcsDataLakeUpdateBigLakeCatalog = DestinationGcsDataLakeUpdateBigLakeCatalog{}
	if err := utils.UnmarshalJSON(data, &destinationGcsDataLakeUpdateBigLakeCatalog, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationGcsDataLakeUpdateCatalogTypeTypeDestinationGcsDataLakeUpdateBigLakeCatalog,
			Value: &destinationGcsDataLakeUpdateBigLakeCatalog,
		})
	}

	var destinationGcsDataLakeUpdatePolarisCatalog DestinationGcsDataLakeUpdatePolarisCatalog = DestinationGcsDataLakeUpdatePolarisCatalog{}
	if err := utils.UnmarshalJSON(data, &destinationGcsDataLakeUpdatePolarisCatalog, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationGcsDataLakeUpdateCatalogTypeTypeDestinationGcsDataLakeUpdatePolarisCatalog,
			Value: &destinationGcsDataLakeUpdatePolarisCatalog,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationGcsDataLakeUpdateCatalogType", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationGcsDataLakeUpdateCatalogType", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(DestinationGcsDataLakeUpdateCatalogTypeType)
	switch best.Type {
	case DestinationGcsDataLakeUpdateCatalogTypeTypeDestinationGcsDataLakeUpdateBigLakeCatalog:
		u.DestinationGcsDataLakeUpdateBigLakeCatalog = best.Value.(*DestinationGcsDataLakeUpdateBigLakeCatalog)
		return nil
	case DestinationGcsDataLakeUpdateCatalogTypeTypeDestinationGcsDataLakeUpdatePolarisCatalog:
		u.DestinationGcsDataLakeUpdatePolarisCatalog = best.Value.(*DestinationGcsDataLakeUpdatePolarisCatalog)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationGcsDataLakeUpdateCatalogType", string(data))
}

func (u DestinationGcsDataLakeUpdateCatalogType) MarshalJSON() ([]byte, error) {
	if u.DestinationGcsDataLakeUpdateBigLakeCatalog != nil {
		return utils.MarshalJSON(u.DestinationGcsDataLakeUpdateBigLakeCatalog, "", true)
	}

	if u.DestinationGcsDataLakeUpdatePolarisCatalog != nil {
		return utils.MarshalJSON(u.DestinationGcsDataLakeUpdatePolarisCatalog, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationGcsDataLakeUpdateCatalogType: all fields are null")
}

type DestinationGcsDataLakeUpdateDestinationType string

const (
	DestinationGcsDataLakeUpdateDestinationTypeGcsDataLake DestinationGcsDataLakeUpdateDestinationType = "gcs-data-lake"
)

func (e DestinationGcsDataLakeUpdateDestinationType) ToPointer() *DestinationGcsDataLakeUpdateDestinationType {
	return &e
}
func (e *DestinationGcsDataLakeUpdateDestinationType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "gcs-data-lake":
		*e = DestinationGcsDataLakeUpdateDestinationType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsDataLakeUpdateDestinationType: %v", v)
	}
}

// DestinationGcsDataLakeUpdate - Configuration for GCS Data Lake destination using Apache Iceberg format
type DestinationGcsDataLakeUpdate struct {
	// Specifies the type of Iceberg catalog (BigLake or Polaris).
	CatalogType *DestinationGcsDataLakeUpdateCatalogType `json:"catalog_type,omitempty"`
	// The GCP location (region) for BigLake metastore resources. For example: "us-central1" or "us". See <a href="https://cloud.google.com/biglake/docs/locations">BigLake locations</a> for available regions.
	GcpLocation *string `json:"gcp_location,omitempty"`
	// The GCP project ID where resources are located. If not specified, it will be extracted from the service account credentials.
	GcpProjectID *string `json:"gcp_project_id,omitempty"`
	// The name of the GCS bucket that will host the Iceberg data.
	GcsBucketName *string `json:"gcs_bucket_name,omitempty"`
	// Optional custom GCS endpoint URL. Use this for testing with local GCS emulators.
	GcsEndpoint *string `json:"gcs_endpoint,omitempty"`
	// The primary or default branch name in the catalog. Most query engines will use "main" by default. See <a href="https://iceberg.apache.org/docs/latest/branching/">Iceberg documentation</a> for more information.
	MainBranchName *string `json:"main_branch_name,omitempty"`
	// The default namespace to use for tables. This will ONLY be used if the `Destination Namespace` setting is set to `Destination-defined` or `Source-defined`
	Namespace *string `json:"namespace,omitempty"`
	// The contents of the JSON service account key file. See the <a href="https://cloud.google.com/iam/docs/creating-managing-service-account-keys">Google Cloud documentation</a> for more information on how to obtain this.
	ServiceAccountJSON *string `json:"service_account_json,omitempty"`
	// The root location of the data warehouse used by the Iceberg catalog. Must include the storage protocol "gs://" for Google Cloud Storage. For example: "gs://your-bucket/path/to/warehouse/
	WarehouseLocation    *string                                      `json:"warehouse_location,omitempty"`
	destinationType      *DestinationGcsDataLakeUpdateDestinationType `const:"gcs-data-lake" json:"destinationType"`
	AdditionalProperties any                                          `additionalProperties:"true" json:"-"`
}

func (d DestinationGcsDataLakeUpdate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsDataLakeUpdate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationGcsDataLakeUpdate) GetCatalogType() *DestinationGcsDataLakeUpdateCatalogType {
	if d == nil {
		return nil
	}
	return d.CatalogType
}

func (d *DestinationGcsDataLakeUpdate) GetGcpLocation() *string {
	if d == nil {
		return nil
	}
	return d.GcpLocation
}

func (d *DestinationGcsDataLakeUpdate) GetGcpProjectID() *string {
	if d == nil {
		return nil
	}
	return d.GcpProjectID
}

func (d *DestinationGcsDataLakeUpdate) GetGcsBucketName() *string {
	if d == nil {
		return nil
	}
	return d.GcsBucketName
}

func (d *DestinationGcsDataLakeUpdate) GetGcsEndpoint() *string {
	if d == nil {
		return nil
	}
	return d.GcsEndpoint
}

func (d *DestinationGcsDataLakeUpdate) GetMainBranchName() *string {
	if d == nil {
		return nil
	}
	return d.MainBranchName
}

func (d *DestinationGcsDataLakeUpdate) GetNamespace() *string {
	if d == nil {
		return nil
	}
	return d.Namespace
}

func (d *DestinationGcsDataLakeUpdate) GetServiceAccountJSON() *string {
	if d == nil {
		return nil
	}
	return d.ServiceAccountJSON
}

func (d *DestinationGcsDataLakeUpdate) GetWarehouseLocation() *string {
	if d == nil {
		return nil
	}
	return d.WarehouseLocation
}

func (d *DestinationGcsDataLakeUpdate) GetDestinationType() *DestinationGcsDataLakeUpdateDestinationType {
	return DestinationGcsDataLakeUpdateDestinationTypeGcsDataLake.ToPointer()
}

func (d *DestinationGcsDataLakeUpdate) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}
