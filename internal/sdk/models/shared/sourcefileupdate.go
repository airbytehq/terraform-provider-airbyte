// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

// SourceFileUpdateFileFormat - The Format of the file which should be replicated (Warning: some formats may be experimental, please refer to the docs).
type SourceFileUpdateFileFormat string

const (
	SourceFileUpdateFileFormatCsv         SourceFileUpdateFileFormat = "csv"
	SourceFileUpdateFileFormatJSON        SourceFileUpdateFileFormat = "json"
	SourceFileUpdateFileFormatJsonl       SourceFileUpdateFileFormat = "jsonl"
	SourceFileUpdateFileFormatExcel       SourceFileUpdateFileFormat = "excel"
	SourceFileUpdateFileFormatExcelBinary SourceFileUpdateFileFormat = "excel_binary"
	SourceFileUpdateFileFormatFwf         SourceFileUpdateFileFormat = "fwf"
	SourceFileUpdateFileFormatFeather     SourceFileUpdateFileFormat = "feather"
	SourceFileUpdateFileFormatParquet     SourceFileUpdateFileFormat = "parquet"
	SourceFileUpdateFileFormatYaml        SourceFileUpdateFileFormat = "yaml"
)

func (e SourceFileUpdateFileFormat) ToPointer() *SourceFileUpdateFileFormat {
	return &e
}
func (e *SourceFileUpdateFileFormat) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "csv":
		fallthrough
	case "json":
		fallthrough
	case "jsonl":
		fallthrough
	case "excel":
		fallthrough
	case "excel_binary":
		fallthrough
	case "fwf":
		fallthrough
	case "feather":
		fallthrough
	case "parquet":
		fallthrough
	case "yaml":
		*e = SourceFileUpdateFileFormat(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceFileUpdateFileFormat: %v", v)
	}
}

// SourceFileUpdateSchemasProviderStorageProvider8Storage - WARNING: Note that the local storage URL available for reading must start with the local mount "/local/" at the moment until we implement more advanced docker mounting options.
type SourceFileUpdateSchemasProviderStorageProvider8Storage string

const (
	SourceFileUpdateSchemasProviderStorageProvider8StorageLocal SourceFileUpdateSchemasProviderStorageProvider8Storage = "local"
)

func (e SourceFileUpdateSchemasProviderStorageProvider8Storage) ToPointer() *SourceFileUpdateSchemasProviderStorageProvider8Storage {
	return &e
}
func (e *SourceFileUpdateSchemasProviderStorageProvider8Storage) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "local":
		*e = SourceFileUpdateSchemasProviderStorageProvider8Storage(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceFileUpdateSchemasProviderStorageProvider8Storage: %v", v)
	}
}

type SourceFileUpdateLocalFilesystemLimited struct {
	// WARNING: Note that the local storage URL available for reading must start with the local mount "/local/" at the moment until we implement more advanced docker mounting options.
	storage SourceFileUpdateSchemasProviderStorageProvider8Storage `const:"local" json:"storage"`
}

func (s SourceFileUpdateLocalFilesystemLimited) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceFileUpdateLocalFilesystemLimited) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceFileUpdateLocalFilesystemLimited) GetStorage() SourceFileUpdateSchemasProviderStorageProvider8Storage {
	return SourceFileUpdateSchemasProviderStorageProvider8StorageLocal
}

type SourceFileUpdateSchemasProviderStorageProvider7Storage string

const (
	SourceFileUpdateSchemasProviderStorageProvider7StorageSftp SourceFileUpdateSchemasProviderStorageProvider7Storage = "SFTP"
)

func (e SourceFileUpdateSchemasProviderStorageProvider7Storage) ToPointer() *SourceFileUpdateSchemasProviderStorageProvider7Storage {
	return &e
}
func (e *SourceFileUpdateSchemasProviderStorageProvider7Storage) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SFTP":
		*e = SourceFileUpdateSchemasProviderStorageProvider7Storage(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceFileUpdateSchemasProviderStorageProvider7Storage: %v", v)
	}
}

type SourceFileUpdateSFTPSecureFileTransferProtocol struct {
	storage  SourceFileUpdateSchemasProviderStorageProvider7Storage `const:"SFTP" json:"storage"`
	User     string                                                 `json:"user"`
	Password *string                                                `json:"password,omitempty"`
	Host     string                                                 `json:"host"`
	Port     *string                                                `default:"22" json:"port"`
}

func (s SourceFileUpdateSFTPSecureFileTransferProtocol) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceFileUpdateSFTPSecureFileTransferProtocol) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceFileUpdateSFTPSecureFileTransferProtocol) GetStorage() SourceFileUpdateSchemasProviderStorageProvider7Storage {
	return SourceFileUpdateSchemasProviderStorageProvider7StorageSftp
}

func (o *SourceFileUpdateSFTPSecureFileTransferProtocol) GetUser() string {
	if o == nil {
		return ""
	}
	return o.User
}

func (o *SourceFileUpdateSFTPSecureFileTransferProtocol) GetPassword() *string {
	if o == nil {
		return nil
	}
	return o.Password
}

func (o *SourceFileUpdateSFTPSecureFileTransferProtocol) GetHost() string {
	if o == nil {
		return ""
	}
	return o.Host
}

func (o *SourceFileUpdateSFTPSecureFileTransferProtocol) GetPort() *string {
	if o == nil {
		return nil
	}
	return o.Port
}

type SourceFileUpdateSchemasProviderStorageProvider6Storage string

const (
	SourceFileUpdateSchemasProviderStorageProvider6StorageScp SourceFileUpdateSchemasProviderStorageProvider6Storage = "SCP"
)

func (e SourceFileUpdateSchemasProviderStorageProvider6Storage) ToPointer() *SourceFileUpdateSchemasProviderStorageProvider6Storage {
	return &e
}
func (e *SourceFileUpdateSchemasProviderStorageProvider6Storage) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SCP":
		*e = SourceFileUpdateSchemasProviderStorageProvider6Storage(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceFileUpdateSchemasProviderStorageProvider6Storage: %v", v)
	}
}

type SourceFileUpdateSCPSecureCopyProtocol struct {
	storage  SourceFileUpdateSchemasProviderStorageProvider6Storage `const:"SCP" json:"storage"`
	User     string                                                 `json:"user"`
	Password *string                                                `json:"password,omitempty"`
	Host     string                                                 `json:"host"`
	Port     *string                                                `default:"22" json:"port"`
}

func (s SourceFileUpdateSCPSecureCopyProtocol) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceFileUpdateSCPSecureCopyProtocol) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceFileUpdateSCPSecureCopyProtocol) GetStorage() SourceFileUpdateSchemasProviderStorageProvider6Storage {
	return SourceFileUpdateSchemasProviderStorageProvider6StorageScp
}

func (o *SourceFileUpdateSCPSecureCopyProtocol) GetUser() string {
	if o == nil {
		return ""
	}
	return o.User
}

func (o *SourceFileUpdateSCPSecureCopyProtocol) GetPassword() *string {
	if o == nil {
		return nil
	}
	return o.Password
}

func (o *SourceFileUpdateSCPSecureCopyProtocol) GetHost() string {
	if o == nil {
		return ""
	}
	return o.Host
}

func (o *SourceFileUpdateSCPSecureCopyProtocol) GetPort() *string {
	if o == nil {
		return nil
	}
	return o.Port
}

type SourceFileUpdateSchemasProviderStorageProvider5Storage string

const (
	SourceFileUpdateSchemasProviderStorageProvider5StorageSSH SourceFileUpdateSchemasProviderStorageProvider5Storage = "SSH"
)

func (e SourceFileUpdateSchemasProviderStorageProvider5Storage) ToPointer() *SourceFileUpdateSchemasProviderStorageProvider5Storage {
	return &e
}
func (e *SourceFileUpdateSchemasProviderStorageProvider5Storage) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH":
		*e = SourceFileUpdateSchemasProviderStorageProvider5Storage(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceFileUpdateSchemasProviderStorageProvider5Storage: %v", v)
	}
}

type SourceFileUpdateSSHSecureShell struct {
	storage  SourceFileUpdateSchemasProviderStorageProvider5Storage `const:"SSH" json:"storage"`
	User     string                                                 `json:"user"`
	Password *string                                                `json:"password,omitempty"`
	Host     string                                                 `json:"host"`
	Port     *string                                                `default:"22" json:"port"`
}

func (s SourceFileUpdateSSHSecureShell) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceFileUpdateSSHSecureShell) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceFileUpdateSSHSecureShell) GetStorage() SourceFileUpdateSchemasProviderStorageProvider5Storage {
	return SourceFileUpdateSchemasProviderStorageProvider5StorageSSH
}

func (o *SourceFileUpdateSSHSecureShell) GetUser() string {
	if o == nil {
		return ""
	}
	return o.User
}

func (o *SourceFileUpdateSSHSecureShell) GetPassword() *string {
	if o == nil {
		return nil
	}
	return o.Password
}

func (o *SourceFileUpdateSSHSecureShell) GetHost() string {
	if o == nil {
		return ""
	}
	return o.Host
}

func (o *SourceFileUpdateSSHSecureShell) GetPort() *string {
	if o == nil {
		return nil
	}
	return o.Port
}

type SourceFileUpdateSchemasProviderStorageProviderStorage string

const (
	SourceFileUpdateSchemasProviderStorageProviderStorageAzBlob SourceFileUpdateSchemasProviderStorageProviderStorage = "AzBlob"
)

func (e SourceFileUpdateSchemasProviderStorageProviderStorage) ToPointer() *SourceFileUpdateSchemasProviderStorageProviderStorage {
	return &e
}
func (e *SourceFileUpdateSchemasProviderStorageProviderStorage) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "AzBlob":
		*e = SourceFileUpdateSchemasProviderStorageProviderStorage(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceFileUpdateSchemasProviderStorageProviderStorage: %v", v)
	}
}

type SourceFileUpdateAzBlobAzureBlobStorage struct {
	storage SourceFileUpdateSchemasProviderStorageProviderStorage `const:"AzBlob" json:"storage"`
	// The globally unique name of the storage account that the desired blob sits within. See <a href="https://docs.microsoft.com/en-us/azure/storage/common/storage-account-overview" target="_blank">here</a> for more details.
	StorageAccount string `json:"storage_account"`
	// To access Azure Blob Storage, this connector would need credentials with the proper permissions. One option is a SAS (Shared Access Signature) token. If accessing publicly available data, this field is not necessary.
	SasToken *string `json:"sas_token,omitempty"`
	// To access Azure Blob Storage, this connector would need credentials with the proper permissions. One option is a storage account shared key (aka account key or access key). If accessing publicly available data, this field is not necessary.
	SharedKey *string `json:"shared_key,omitempty"`
}

func (s SourceFileUpdateAzBlobAzureBlobStorage) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceFileUpdateAzBlobAzureBlobStorage) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceFileUpdateAzBlobAzureBlobStorage) GetStorage() SourceFileUpdateSchemasProviderStorageProviderStorage {
	return SourceFileUpdateSchemasProviderStorageProviderStorageAzBlob
}

func (o *SourceFileUpdateAzBlobAzureBlobStorage) GetStorageAccount() string {
	if o == nil {
		return ""
	}
	return o.StorageAccount
}

func (o *SourceFileUpdateAzBlobAzureBlobStorage) GetSasToken() *string {
	if o == nil {
		return nil
	}
	return o.SasToken
}

func (o *SourceFileUpdateAzBlobAzureBlobStorage) GetSharedKey() *string {
	if o == nil {
		return nil
	}
	return o.SharedKey
}

type SourceFileUpdateSchemasProviderStorage string

const (
	SourceFileUpdateSchemasProviderStorageS3 SourceFileUpdateSchemasProviderStorage = "S3"
)

func (e SourceFileUpdateSchemasProviderStorage) ToPointer() *SourceFileUpdateSchemasProviderStorage {
	return &e
}
func (e *SourceFileUpdateSchemasProviderStorage) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "S3":
		*e = SourceFileUpdateSchemasProviderStorage(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceFileUpdateSchemasProviderStorage: %v", v)
	}
}

type SourceFileUpdateS3AmazonWebServices struct {
	storage SourceFileUpdateSchemasProviderStorage `const:"S3" json:"storage"`
	// In order to access private Buckets stored on AWS S3, this connector would need credentials with the proper permissions. If accessing publicly available data, this field is not necessary.
	AwsAccessKeyID *string `json:"aws_access_key_id,omitempty"`
	// In order to access private Buckets stored on AWS S3, this connector would need credentials with the proper permissions. If accessing publicly available data, this field is not necessary.
	AwsSecretAccessKey *string `json:"aws_secret_access_key,omitempty"`
}

func (s SourceFileUpdateS3AmazonWebServices) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceFileUpdateS3AmazonWebServices) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceFileUpdateS3AmazonWebServices) GetStorage() SourceFileUpdateSchemasProviderStorage {
	return SourceFileUpdateSchemasProviderStorageS3
}

func (o *SourceFileUpdateS3AmazonWebServices) GetAwsAccessKeyID() *string {
	if o == nil {
		return nil
	}
	return o.AwsAccessKeyID
}

func (o *SourceFileUpdateS3AmazonWebServices) GetAwsSecretAccessKey() *string {
	if o == nil {
		return nil
	}
	return o.AwsSecretAccessKey
}

type SourceFileUpdateSchemasStorage string

const (
	SourceFileUpdateSchemasStorageGcs SourceFileUpdateSchemasStorage = "GCS"
)

func (e SourceFileUpdateSchemasStorage) ToPointer() *SourceFileUpdateSchemasStorage {
	return &e
}
func (e *SourceFileUpdateSchemasStorage) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "GCS":
		*e = SourceFileUpdateSchemasStorage(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceFileUpdateSchemasStorage: %v", v)
	}
}

type SourceFileUpdateGCSGoogleCloudStorage struct {
	storage SourceFileUpdateSchemasStorage `const:"GCS" json:"storage"`
	// In order to access private Buckets stored on Google Cloud, this connector would need a service account json credentials with the proper permissions as described <a href="https://cloud.google.com/iam/docs/service-accounts" target="_blank">here</a>. Please generate the credentials.json file and copy/paste its content to this field (expecting JSON formats). If accessing publicly available data, this field is not necessary.
	ServiceAccountJSON *string `json:"service_account_json,omitempty"`
}

func (s SourceFileUpdateGCSGoogleCloudStorage) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceFileUpdateGCSGoogleCloudStorage) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceFileUpdateGCSGoogleCloudStorage) GetStorage() SourceFileUpdateSchemasStorage {
	return SourceFileUpdateSchemasStorageGcs
}

func (o *SourceFileUpdateGCSGoogleCloudStorage) GetServiceAccountJSON() *string {
	if o == nil {
		return nil
	}
	return o.ServiceAccountJSON
}

type SourceFileUpdateStorage string

const (
	SourceFileUpdateStorageHTTPS SourceFileUpdateStorage = "HTTPS"
)

func (e SourceFileUpdateStorage) ToPointer() *SourceFileUpdateStorage {
	return &e
}
func (e *SourceFileUpdateStorage) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "HTTPS":
		*e = SourceFileUpdateStorage(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceFileUpdateStorage: %v", v)
	}
}

type SourceFileUpdateHTTPSPublicWeb struct {
	storage SourceFileUpdateStorage `const:"HTTPS" json:"storage"`
	// Add User-Agent to request
	UserAgent *bool `default:"false" json:"user_agent"`
}

func (s SourceFileUpdateHTTPSPublicWeb) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceFileUpdateHTTPSPublicWeb) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourceFileUpdateHTTPSPublicWeb) GetStorage() SourceFileUpdateStorage {
	return SourceFileUpdateStorageHTTPS
}

func (o *SourceFileUpdateHTTPSPublicWeb) GetUserAgent() *bool {
	if o == nil {
		return nil
	}
	return o.UserAgent
}

type SourceFileUpdateStorageProviderType string

const (
	SourceFileUpdateStorageProviderTypeSourceFileUpdateHTTPSPublicWeb                 SourceFileUpdateStorageProviderType = "source-file-update_HTTPS: Public Web"
	SourceFileUpdateStorageProviderTypeSourceFileUpdateGCSGoogleCloudStorage          SourceFileUpdateStorageProviderType = "source-file-update_GCS: Google Cloud Storage"
	SourceFileUpdateStorageProviderTypeSourceFileUpdateS3AmazonWebServices            SourceFileUpdateStorageProviderType = "source-file-update_S3: Amazon Web Services"
	SourceFileUpdateStorageProviderTypeSourceFileUpdateAzBlobAzureBlobStorage         SourceFileUpdateStorageProviderType = "source-file-update_AzBlob: Azure Blob Storage"
	SourceFileUpdateStorageProviderTypeSourceFileUpdateSSHSecureShell                 SourceFileUpdateStorageProviderType = "source-file-update_SSH: Secure Shell"
	SourceFileUpdateStorageProviderTypeSourceFileUpdateSCPSecureCopyProtocol          SourceFileUpdateStorageProviderType = "source-file-update_SCP: Secure copy protocol"
	SourceFileUpdateStorageProviderTypeSourceFileUpdateSFTPSecureFileTransferProtocol SourceFileUpdateStorageProviderType = "source-file-update_SFTP: Secure File Transfer Protocol"
	SourceFileUpdateStorageProviderTypeSourceFileUpdateLocalFilesystemLimited         SourceFileUpdateStorageProviderType = "source-file-update_Local Filesystem (limited)"
)

// SourceFileUpdateStorageProvider - The storage Provider or Location of the file(s) which should be replicated.
type SourceFileUpdateStorageProvider struct {
	SourceFileUpdateHTTPSPublicWeb                 *SourceFileUpdateHTTPSPublicWeb                 `queryParam:"inline"`
	SourceFileUpdateGCSGoogleCloudStorage          *SourceFileUpdateGCSGoogleCloudStorage          `queryParam:"inline"`
	SourceFileUpdateS3AmazonWebServices            *SourceFileUpdateS3AmazonWebServices            `queryParam:"inline"`
	SourceFileUpdateAzBlobAzureBlobStorage         *SourceFileUpdateAzBlobAzureBlobStorage         `queryParam:"inline"`
	SourceFileUpdateSSHSecureShell                 *SourceFileUpdateSSHSecureShell                 `queryParam:"inline"`
	SourceFileUpdateSCPSecureCopyProtocol          *SourceFileUpdateSCPSecureCopyProtocol          `queryParam:"inline"`
	SourceFileUpdateSFTPSecureFileTransferProtocol *SourceFileUpdateSFTPSecureFileTransferProtocol `queryParam:"inline"`
	SourceFileUpdateLocalFilesystemLimited         *SourceFileUpdateLocalFilesystemLimited         `queryParam:"inline"`

	Type SourceFileUpdateStorageProviderType
}

func CreateSourceFileUpdateStorageProviderSourceFileUpdateHTTPSPublicWeb(sourceFileUpdateHTTPSPublicWeb SourceFileUpdateHTTPSPublicWeb) SourceFileUpdateStorageProvider {
	typ := SourceFileUpdateStorageProviderTypeSourceFileUpdateHTTPSPublicWeb

	return SourceFileUpdateStorageProvider{
		SourceFileUpdateHTTPSPublicWeb: &sourceFileUpdateHTTPSPublicWeb,
		Type:                           typ,
	}
}

func CreateSourceFileUpdateStorageProviderSourceFileUpdateGCSGoogleCloudStorage(sourceFileUpdateGCSGoogleCloudStorage SourceFileUpdateGCSGoogleCloudStorage) SourceFileUpdateStorageProvider {
	typ := SourceFileUpdateStorageProviderTypeSourceFileUpdateGCSGoogleCloudStorage

	return SourceFileUpdateStorageProvider{
		SourceFileUpdateGCSGoogleCloudStorage: &sourceFileUpdateGCSGoogleCloudStorage,
		Type:                                  typ,
	}
}

func CreateSourceFileUpdateStorageProviderSourceFileUpdateS3AmazonWebServices(sourceFileUpdateS3AmazonWebServices SourceFileUpdateS3AmazonWebServices) SourceFileUpdateStorageProvider {
	typ := SourceFileUpdateStorageProviderTypeSourceFileUpdateS3AmazonWebServices

	return SourceFileUpdateStorageProvider{
		SourceFileUpdateS3AmazonWebServices: &sourceFileUpdateS3AmazonWebServices,
		Type:                                typ,
	}
}

func CreateSourceFileUpdateStorageProviderSourceFileUpdateAzBlobAzureBlobStorage(sourceFileUpdateAzBlobAzureBlobStorage SourceFileUpdateAzBlobAzureBlobStorage) SourceFileUpdateStorageProvider {
	typ := SourceFileUpdateStorageProviderTypeSourceFileUpdateAzBlobAzureBlobStorage

	return SourceFileUpdateStorageProvider{
		SourceFileUpdateAzBlobAzureBlobStorage: &sourceFileUpdateAzBlobAzureBlobStorage,
		Type:                                   typ,
	}
}

func CreateSourceFileUpdateStorageProviderSourceFileUpdateSSHSecureShell(sourceFileUpdateSSHSecureShell SourceFileUpdateSSHSecureShell) SourceFileUpdateStorageProvider {
	typ := SourceFileUpdateStorageProviderTypeSourceFileUpdateSSHSecureShell

	return SourceFileUpdateStorageProvider{
		SourceFileUpdateSSHSecureShell: &sourceFileUpdateSSHSecureShell,
		Type:                           typ,
	}
}

func CreateSourceFileUpdateStorageProviderSourceFileUpdateSCPSecureCopyProtocol(sourceFileUpdateSCPSecureCopyProtocol SourceFileUpdateSCPSecureCopyProtocol) SourceFileUpdateStorageProvider {
	typ := SourceFileUpdateStorageProviderTypeSourceFileUpdateSCPSecureCopyProtocol

	return SourceFileUpdateStorageProvider{
		SourceFileUpdateSCPSecureCopyProtocol: &sourceFileUpdateSCPSecureCopyProtocol,
		Type:                                  typ,
	}
}

func CreateSourceFileUpdateStorageProviderSourceFileUpdateSFTPSecureFileTransferProtocol(sourceFileUpdateSFTPSecureFileTransferProtocol SourceFileUpdateSFTPSecureFileTransferProtocol) SourceFileUpdateStorageProvider {
	typ := SourceFileUpdateStorageProviderTypeSourceFileUpdateSFTPSecureFileTransferProtocol

	return SourceFileUpdateStorageProvider{
		SourceFileUpdateSFTPSecureFileTransferProtocol: &sourceFileUpdateSFTPSecureFileTransferProtocol,
		Type: typ,
	}
}

func CreateSourceFileUpdateStorageProviderSourceFileUpdateLocalFilesystemLimited(sourceFileUpdateLocalFilesystemLimited SourceFileUpdateLocalFilesystemLimited) SourceFileUpdateStorageProvider {
	typ := SourceFileUpdateStorageProviderTypeSourceFileUpdateLocalFilesystemLimited

	return SourceFileUpdateStorageProvider{
		SourceFileUpdateLocalFilesystemLimited: &sourceFileUpdateLocalFilesystemLimited,
		Type:                                   typ,
	}
}

func (u *SourceFileUpdateStorageProvider) UnmarshalJSON(data []byte) error {

	var sourceFileUpdateLocalFilesystemLimited SourceFileUpdateLocalFilesystemLimited = SourceFileUpdateLocalFilesystemLimited{}
	if err := utils.UnmarshalJSON(data, &sourceFileUpdateLocalFilesystemLimited, "", true, true); err == nil {
		u.SourceFileUpdateLocalFilesystemLimited = &sourceFileUpdateLocalFilesystemLimited
		u.Type = SourceFileUpdateStorageProviderTypeSourceFileUpdateLocalFilesystemLimited
		return nil
	}

	var sourceFileUpdateHTTPSPublicWeb SourceFileUpdateHTTPSPublicWeb = SourceFileUpdateHTTPSPublicWeb{}
	if err := utils.UnmarshalJSON(data, &sourceFileUpdateHTTPSPublicWeb, "", true, true); err == nil {
		u.SourceFileUpdateHTTPSPublicWeb = &sourceFileUpdateHTTPSPublicWeb
		u.Type = SourceFileUpdateStorageProviderTypeSourceFileUpdateHTTPSPublicWeb
		return nil
	}

	var sourceFileUpdateGCSGoogleCloudStorage SourceFileUpdateGCSGoogleCloudStorage = SourceFileUpdateGCSGoogleCloudStorage{}
	if err := utils.UnmarshalJSON(data, &sourceFileUpdateGCSGoogleCloudStorage, "", true, true); err == nil {
		u.SourceFileUpdateGCSGoogleCloudStorage = &sourceFileUpdateGCSGoogleCloudStorage
		u.Type = SourceFileUpdateStorageProviderTypeSourceFileUpdateGCSGoogleCloudStorage
		return nil
	}

	var sourceFileUpdateS3AmazonWebServices SourceFileUpdateS3AmazonWebServices = SourceFileUpdateS3AmazonWebServices{}
	if err := utils.UnmarshalJSON(data, &sourceFileUpdateS3AmazonWebServices, "", true, true); err == nil {
		u.SourceFileUpdateS3AmazonWebServices = &sourceFileUpdateS3AmazonWebServices
		u.Type = SourceFileUpdateStorageProviderTypeSourceFileUpdateS3AmazonWebServices
		return nil
	}

	var sourceFileUpdateAzBlobAzureBlobStorage SourceFileUpdateAzBlobAzureBlobStorage = SourceFileUpdateAzBlobAzureBlobStorage{}
	if err := utils.UnmarshalJSON(data, &sourceFileUpdateAzBlobAzureBlobStorage, "", true, true); err == nil {
		u.SourceFileUpdateAzBlobAzureBlobStorage = &sourceFileUpdateAzBlobAzureBlobStorage
		u.Type = SourceFileUpdateStorageProviderTypeSourceFileUpdateAzBlobAzureBlobStorage
		return nil
	}

	var sourceFileUpdateSSHSecureShell SourceFileUpdateSSHSecureShell = SourceFileUpdateSSHSecureShell{}
	if err := utils.UnmarshalJSON(data, &sourceFileUpdateSSHSecureShell, "", true, true); err == nil {
		u.SourceFileUpdateSSHSecureShell = &sourceFileUpdateSSHSecureShell
		u.Type = SourceFileUpdateStorageProviderTypeSourceFileUpdateSSHSecureShell
		return nil
	}

	var sourceFileUpdateSCPSecureCopyProtocol SourceFileUpdateSCPSecureCopyProtocol = SourceFileUpdateSCPSecureCopyProtocol{}
	if err := utils.UnmarshalJSON(data, &sourceFileUpdateSCPSecureCopyProtocol, "", true, true); err == nil {
		u.SourceFileUpdateSCPSecureCopyProtocol = &sourceFileUpdateSCPSecureCopyProtocol
		u.Type = SourceFileUpdateStorageProviderTypeSourceFileUpdateSCPSecureCopyProtocol
		return nil
	}

	var sourceFileUpdateSFTPSecureFileTransferProtocol SourceFileUpdateSFTPSecureFileTransferProtocol = SourceFileUpdateSFTPSecureFileTransferProtocol{}
	if err := utils.UnmarshalJSON(data, &sourceFileUpdateSFTPSecureFileTransferProtocol, "", true, true); err == nil {
		u.SourceFileUpdateSFTPSecureFileTransferProtocol = &sourceFileUpdateSFTPSecureFileTransferProtocol
		u.Type = SourceFileUpdateStorageProviderTypeSourceFileUpdateSFTPSecureFileTransferProtocol
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceFileUpdateStorageProvider", string(data))
}

func (u SourceFileUpdateStorageProvider) MarshalJSON() ([]byte, error) {
	if u.SourceFileUpdateHTTPSPublicWeb != nil {
		return utils.MarshalJSON(u.SourceFileUpdateHTTPSPublicWeb, "", true)
	}

	if u.SourceFileUpdateGCSGoogleCloudStorage != nil {
		return utils.MarshalJSON(u.SourceFileUpdateGCSGoogleCloudStorage, "", true)
	}

	if u.SourceFileUpdateS3AmazonWebServices != nil {
		return utils.MarshalJSON(u.SourceFileUpdateS3AmazonWebServices, "", true)
	}

	if u.SourceFileUpdateAzBlobAzureBlobStorage != nil {
		return utils.MarshalJSON(u.SourceFileUpdateAzBlobAzureBlobStorage, "", true)
	}

	if u.SourceFileUpdateSSHSecureShell != nil {
		return utils.MarshalJSON(u.SourceFileUpdateSSHSecureShell, "", true)
	}

	if u.SourceFileUpdateSCPSecureCopyProtocol != nil {
		return utils.MarshalJSON(u.SourceFileUpdateSCPSecureCopyProtocol, "", true)
	}

	if u.SourceFileUpdateSFTPSecureFileTransferProtocol != nil {
		return utils.MarshalJSON(u.SourceFileUpdateSFTPSecureFileTransferProtocol, "", true)
	}

	if u.SourceFileUpdateLocalFilesystemLimited != nil {
		return utils.MarshalJSON(u.SourceFileUpdateLocalFilesystemLimited, "", true)
	}

	return nil, errors.New("could not marshal union type SourceFileUpdateStorageProvider: all fields are null")
}

type SourceFileUpdate struct {
	// The Name of the final table to replicate this file into (should include letters, numbers dash and underscores only).
	DatasetName string `json:"dataset_name"`
	// The Format of the file which should be replicated (Warning: some formats may be experimental, please refer to the docs).
	Format *SourceFileUpdateFileFormat `default:"csv" json:"format"`
	// This should be a string in JSON format. It depends on the chosen file format to provide additional options and tune its behavior.
	ReaderOptions *string `json:"reader_options,omitempty"`
	// The URL path to access the file which should be replicated.
	URL string `json:"url"`
	// The storage Provider or Location of the file(s) which should be replicated.
	Provider SourceFileUpdateStorageProvider `json:"provider"`
}

func (s SourceFileUpdate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceFileUpdate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *SourceFileUpdate) GetDatasetName() string {
	if o == nil {
		return ""
	}
	return o.DatasetName
}

func (o *SourceFileUpdate) GetFormat() *SourceFileUpdateFileFormat {
	if o == nil {
		return nil
	}
	return o.Format
}

func (o *SourceFileUpdate) GetReaderOptions() *string {
	if o == nil {
		return nil
	}
	return o.ReaderOptions
}

func (o *SourceFileUpdate) GetURL() string {
	if o == nil {
		return ""
	}
	return o.URL
}

func (o *SourceFileUpdate) GetProvider() SourceFileUpdateStorageProvider {
	if o == nil {
		return SourceFileUpdateStorageProvider{}
	}
	return o.Provider
}
