// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/types"
)

// SourceFileUpdateFileFormat - The Format of the file which should be replicated (Warning: some formats may be experimental, please refer to the docs).
type SourceFileUpdateFileFormat string

const (
	SourceFileUpdateFileFormatCsv         SourceFileUpdateFileFormat = "csv"
	SourceFileUpdateFileFormatJSON        SourceFileUpdateFileFormat = "json"
	SourceFileUpdateFileFormatJsonl       SourceFileUpdateFileFormat = "jsonl"
	SourceFileUpdateFileFormatExcel       SourceFileUpdateFileFormat = "excel"
	SourceFileUpdateFileFormatExcelBinary SourceFileUpdateFileFormat = "excel_binary"
	SourceFileUpdateFileFormatFwf         SourceFileUpdateFileFormat = "fwf"
	SourceFileUpdateFileFormatFeather     SourceFileUpdateFileFormat = "feather"
	SourceFileUpdateFileFormatParquet     SourceFileUpdateFileFormat = "parquet"
	SourceFileUpdateFileFormatYaml        SourceFileUpdateFileFormat = "yaml"
)

func (e SourceFileUpdateFileFormat) ToPointer() *SourceFileUpdateFileFormat {
	return &e
}
func (e *SourceFileUpdateFileFormat) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "csv":
		fallthrough
	case "json":
		fallthrough
	case "jsonl":
		fallthrough
	case "excel":
		fallthrough
	case "excel_binary":
		fallthrough
	case "fwf":
		fallthrough
	case "feather":
		fallthrough
	case "parquet":
		fallthrough
	case "yaml":
		*e = SourceFileUpdateFileFormat(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceFileUpdateFileFormat: %v", v)
	}
}

type SourceFileUpdateSFTPSecureFileTransferProtocol struct {
	Host     *string `json:"host,omitempty"`
	Password *string `json:"password,omitempty"`
	Port     *string `default:"22" json:"port"`
	storage  *string `const:"SFTP" json:"storage,omitempty"`
	User     *string `json:"user,omitempty"`
}

func (s SourceFileUpdateSFTPSecureFileTransferProtocol) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceFileUpdateSFTPSecureFileTransferProtocol) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceFileUpdateSFTPSecureFileTransferProtocol) GetHost() *string {
	if s == nil {
		return nil
	}
	return s.Host
}

func (s *SourceFileUpdateSFTPSecureFileTransferProtocol) GetPassword() *string {
	if s == nil {
		return nil
	}
	return s.Password
}

func (s *SourceFileUpdateSFTPSecureFileTransferProtocol) GetPort() *string {
	if s == nil {
		return nil
	}
	return s.Port
}

func (s *SourceFileUpdateSFTPSecureFileTransferProtocol) GetStorage() *string {
	return types.Pointer("SFTP")
}

func (s *SourceFileUpdateSFTPSecureFileTransferProtocol) GetUser() *string {
	if s == nil {
		return nil
	}
	return s.User
}

type SourceFileUpdateSCPSecureCopyProtocol struct {
	Host     *string `json:"host,omitempty"`
	Password *string `json:"password,omitempty"`
	Port     *string `default:"22" json:"port"`
	storage  *string `const:"SCP" json:"storage,omitempty"`
	User     *string `json:"user,omitempty"`
}

func (s SourceFileUpdateSCPSecureCopyProtocol) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceFileUpdateSCPSecureCopyProtocol) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceFileUpdateSCPSecureCopyProtocol) GetHost() *string {
	if s == nil {
		return nil
	}
	return s.Host
}

func (s *SourceFileUpdateSCPSecureCopyProtocol) GetPassword() *string {
	if s == nil {
		return nil
	}
	return s.Password
}

func (s *SourceFileUpdateSCPSecureCopyProtocol) GetPort() *string {
	if s == nil {
		return nil
	}
	return s.Port
}

func (s *SourceFileUpdateSCPSecureCopyProtocol) GetStorage() *string {
	return types.Pointer("SCP")
}

func (s *SourceFileUpdateSCPSecureCopyProtocol) GetUser() *string {
	if s == nil {
		return nil
	}
	return s.User
}

type SourceFileUpdateSSHSecureShell struct {
	Host     *string `json:"host,omitempty"`
	Password *string `json:"password,omitempty"`
	Port     *string `default:"22" json:"port"`
	storage  *string `const:"SSH" json:"storage,omitempty"`
	User     *string `json:"user,omitempty"`
}

func (s SourceFileUpdateSSHSecureShell) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceFileUpdateSSHSecureShell) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceFileUpdateSSHSecureShell) GetHost() *string {
	if s == nil {
		return nil
	}
	return s.Host
}

func (s *SourceFileUpdateSSHSecureShell) GetPassword() *string {
	if s == nil {
		return nil
	}
	return s.Password
}

func (s *SourceFileUpdateSSHSecureShell) GetPort() *string {
	if s == nil {
		return nil
	}
	return s.Port
}

func (s *SourceFileUpdateSSHSecureShell) GetStorage() *string {
	return types.Pointer("SSH")
}

func (s *SourceFileUpdateSSHSecureShell) GetUser() *string {
	if s == nil {
		return nil
	}
	return s.User
}

type SourceFileUpdateAzBlobAzureBlobStorage struct {
	// To access Azure Blob Storage, this connector would need credentials with the proper permissions. One option is a SAS (Shared Access Signature) token. If accessing publicly available data, this field is not necessary.
	SasToken *string `json:"sas_token,omitempty"`
	// To access Azure Blob Storage, this connector would need credentials with the proper permissions. One option is a storage account shared key (aka account key or access key). If accessing publicly available data, this field is not necessary.
	SharedKey *string `json:"shared_key,omitempty"`
	storage   *string `const:"AzBlob" json:"storage,omitempty"`
	// The globally unique name of the storage account that the desired blob sits within. See <a href="https://docs.microsoft.com/en-us/azure/storage/common/storage-account-overview" target="_blank">here</a> for more details.
	StorageAccount *string `json:"storage_account,omitempty"`
}

func (s SourceFileUpdateAzBlobAzureBlobStorage) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceFileUpdateAzBlobAzureBlobStorage) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceFileUpdateAzBlobAzureBlobStorage) GetSasToken() *string {
	if s == nil {
		return nil
	}
	return s.SasToken
}

func (s *SourceFileUpdateAzBlobAzureBlobStorage) GetSharedKey() *string {
	if s == nil {
		return nil
	}
	return s.SharedKey
}

func (s *SourceFileUpdateAzBlobAzureBlobStorage) GetStorage() *string {
	return types.Pointer("AzBlob")
}

func (s *SourceFileUpdateAzBlobAzureBlobStorage) GetStorageAccount() *string {
	if s == nil {
		return nil
	}
	return s.StorageAccount
}

type SourceFileUpdateS3AmazonWebServices struct {
	// In order to access private Buckets stored on AWS S3, this connector would need credentials with the proper permissions. If accessing publicly available data, this field is not necessary.
	AwsAccessKeyID *string `json:"aws_access_key_id,omitempty"`
	// In order to access private Buckets stored on AWS S3, this connector would need credentials with the proper permissions. If accessing publicly available data, this field is not necessary.
	AwsSecretAccessKey *string `json:"aws_secret_access_key,omitempty"`
	storage            *string `const:"S3" json:"storage,omitempty"`
}

func (s SourceFileUpdateS3AmazonWebServices) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceFileUpdateS3AmazonWebServices) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceFileUpdateS3AmazonWebServices) GetAwsAccessKeyID() *string {
	if s == nil {
		return nil
	}
	return s.AwsAccessKeyID
}

func (s *SourceFileUpdateS3AmazonWebServices) GetAwsSecretAccessKey() *string {
	if s == nil {
		return nil
	}
	return s.AwsSecretAccessKey
}

func (s *SourceFileUpdateS3AmazonWebServices) GetStorage() *string {
	return types.Pointer("S3")
}

type SourceFileUpdateGCSGoogleCloudStorage struct {
	// In order to access private Buckets stored on Google Cloud, this connector would need a service account json credentials with the proper permissions as described <a href="https://cloud.google.com/iam/docs/service-accounts" target="_blank">here</a>. Please generate the credentials.json file and copy/paste its content to this field (expecting JSON formats). If accessing publicly available data, this field is not necessary.
	ServiceAccountJSON *string `json:"service_account_json,omitempty"`
	storage            *string `const:"GCS" json:"storage,omitempty"`
}

func (s SourceFileUpdateGCSGoogleCloudStorage) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceFileUpdateGCSGoogleCloudStorage) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceFileUpdateGCSGoogleCloudStorage) GetServiceAccountJSON() *string {
	if s == nil {
		return nil
	}
	return s.ServiceAccountJSON
}

func (s *SourceFileUpdateGCSGoogleCloudStorage) GetStorage() *string {
	return types.Pointer("GCS")
}

type SourceFileUpdateHTTPSPublicWeb struct {
	storage *string `const:"HTTPS" json:"storage,omitempty"`
	// Add User-Agent to request
	UserAgent *bool `default:"false" json:"user_agent"`
}

func (s SourceFileUpdateHTTPSPublicWeb) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceFileUpdateHTTPSPublicWeb) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceFileUpdateHTTPSPublicWeb) GetStorage() *string {
	return types.Pointer("HTTPS")
}

func (s *SourceFileUpdateHTTPSPublicWeb) GetUserAgent() *bool {
	if s == nil {
		return nil
	}
	return s.UserAgent
}

type SourceFileUpdateStorageProviderType string

const (
	SourceFileUpdateStorageProviderTypeSourceFileUpdateHTTPSPublicWeb                 SourceFileUpdateStorageProviderType = "source-file-update_HTTPS: Public Web"
	SourceFileUpdateStorageProviderTypeSourceFileUpdateGCSGoogleCloudStorage          SourceFileUpdateStorageProviderType = "source-file-update_GCS: Google Cloud Storage"
	SourceFileUpdateStorageProviderTypeSourceFileUpdateS3AmazonWebServices            SourceFileUpdateStorageProviderType = "source-file-update_S3: Amazon Web Services"
	SourceFileUpdateStorageProviderTypeSourceFileUpdateAzBlobAzureBlobStorage         SourceFileUpdateStorageProviderType = "source-file-update_AzBlob: Azure Blob Storage"
	SourceFileUpdateStorageProviderTypeSourceFileUpdateSSHSecureShell                 SourceFileUpdateStorageProviderType = "source-file-update_SSH: Secure Shell"
	SourceFileUpdateStorageProviderTypeSourceFileUpdateSCPSecureCopyProtocol          SourceFileUpdateStorageProviderType = "source-file-update_SCP: Secure copy protocol"
	SourceFileUpdateStorageProviderTypeSourceFileUpdateSFTPSecureFileTransferProtocol SourceFileUpdateStorageProviderType = "source-file-update_SFTP: Secure File Transfer Protocol"
)

// SourceFileUpdateStorageProvider - The storage Provider or Location of the file(s) which should be replicated.
type SourceFileUpdateStorageProvider struct {
	SourceFileUpdateHTTPSPublicWeb                 *SourceFileUpdateHTTPSPublicWeb                 `queryParam:"inline" union:"member"`
	SourceFileUpdateGCSGoogleCloudStorage          *SourceFileUpdateGCSGoogleCloudStorage          `queryParam:"inline" union:"member"`
	SourceFileUpdateS3AmazonWebServices            *SourceFileUpdateS3AmazonWebServices            `queryParam:"inline" union:"member"`
	SourceFileUpdateAzBlobAzureBlobStorage         *SourceFileUpdateAzBlobAzureBlobStorage         `queryParam:"inline" union:"member"`
	SourceFileUpdateSSHSecureShell                 *SourceFileUpdateSSHSecureShell                 `queryParam:"inline" union:"member"`
	SourceFileUpdateSCPSecureCopyProtocol          *SourceFileUpdateSCPSecureCopyProtocol          `queryParam:"inline" union:"member"`
	SourceFileUpdateSFTPSecureFileTransferProtocol *SourceFileUpdateSFTPSecureFileTransferProtocol `queryParam:"inline" union:"member"`

	Type SourceFileUpdateStorageProviderType
}

func CreateSourceFileUpdateStorageProviderSourceFileUpdateHTTPSPublicWeb(sourceFileUpdateHTTPSPublicWeb SourceFileUpdateHTTPSPublicWeb) SourceFileUpdateStorageProvider {
	typ := SourceFileUpdateStorageProviderTypeSourceFileUpdateHTTPSPublicWeb

	return SourceFileUpdateStorageProvider{
		SourceFileUpdateHTTPSPublicWeb: &sourceFileUpdateHTTPSPublicWeb,
		Type:                           typ,
	}
}

func CreateSourceFileUpdateStorageProviderSourceFileUpdateGCSGoogleCloudStorage(sourceFileUpdateGCSGoogleCloudStorage SourceFileUpdateGCSGoogleCloudStorage) SourceFileUpdateStorageProvider {
	typ := SourceFileUpdateStorageProviderTypeSourceFileUpdateGCSGoogleCloudStorage

	return SourceFileUpdateStorageProvider{
		SourceFileUpdateGCSGoogleCloudStorage: &sourceFileUpdateGCSGoogleCloudStorage,
		Type:                                  typ,
	}
}

func CreateSourceFileUpdateStorageProviderSourceFileUpdateS3AmazonWebServices(sourceFileUpdateS3AmazonWebServices SourceFileUpdateS3AmazonWebServices) SourceFileUpdateStorageProvider {
	typ := SourceFileUpdateStorageProviderTypeSourceFileUpdateS3AmazonWebServices

	return SourceFileUpdateStorageProvider{
		SourceFileUpdateS3AmazonWebServices: &sourceFileUpdateS3AmazonWebServices,
		Type:                                typ,
	}
}

func CreateSourceFileUpdateStorageProviderSourceFileUpdateAzBlobAzureBlobStorage(sourceFileUpdateAzBlobAzureBlobStorage SourceFileUpdateAzBlobAzureBlobStorage) SourceFileUpdateStorageProvider {
	typ := SourceFileUpdateStorageProviderTypeSourceFileUpdateAzBlobAzureBlobStorage

	return SourceFileUpdateStorageProvider{
		SourceFileUpdateAzBlobAzureBlobStorage: &sourceFileUpdateAzBlobAzureBlobStorage,
		Type:                                   typ,
	}
}

func CreateSourceFileUpdateStorageProviderSourceFileUpdateSSHSecureShell(sourceFileUpdateSSHSecureShell SourceFileUpdateSSHSecureShell) SourceFileUpdateStorageProvider {
	typ := SourceFileUpdateStorageProviderTypeSourceFileUpdateSSHSecureShell

	return SourceFileUpdateStorageProvider{
		SourceFileUpdateSSHSecureShell: &sourceFileUpdateSSHSecureShell,
		Type:                           typ,
	}
}

func CreateSourceFileUpdateStorageProviderSourceFileUpdateSCPSecureCopyProtocol(sourceFileUpdateSCPSecureCopyProtocol SourceFileUpdateSCPSecureCopyProtocol) SourceFileUpdateStorageProvider {
	typ := SourceFileUpdateStorageProviderTypeSourceFileUpdateSCPSecureCopyProtocol

	return SourceFileUpdateStorageProvider{
		SourceFileUpdateSCPSecureCopyProtocol: &sourceFileUpdateSCPSecureCopyProtocol,
		Type:                                  typ,
	}
}

func CreateSourceFileUpdateStorageProviderSourceFileUpdateSFTPSecureFileTransferProtocol(sourceFileUpdateSFTPSecureFileTransferProtocol SourceFileUpdateSFTPSecureFileTransferProtocol) SourceFileUpdateStorageProvider {
	typ := SourceFileUpdateStorageProviderTypeSourceFileUpdateSFTPSecureFileTransferProtocol

	return SourceFileUpdateStorageProvider{
		SourceFileUpdateSFTPSecureFileTransferProtocol: &sourceFileUpdateSFTPSecureFileTransferProtocol,
		Type: typ,
	}
}

func (u *SourceFileUpdateStorageProvider) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var sourceFileUpdateHTTPSPublicWeb SourceFileUpdateHTTPSPublicWeb = SourceFileUpdateHTTPSPublicWeb{}
	if err := utils.UnmarshalJSON(data, &sourceFileUpdateHTTPSPublicWeb, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceFileUpdateStorageProviderTypeSourceFileUpdateHTTPSPublicWeb,
			Value: &sourceFileUpdateHTTPSPublicWeb,
		})
	}

	var sourceFileUpdateGCSGoogleCloudStorage SourceFileUpdateGCSGoogleCloudStorage = SourceFileUpdateGCSGoogleCloudStorage{}
	if err := utils.UnmarshalJSON(data, &sourceFileUpdateGCSGoogleCloudStorage, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceFileUpdateStorageProviderTypeSourceFileUpdateGCSGoogleCloudStorage,
			Value: &sourceFileUpdateGCSGoogleCloudStorage,
		})
	}

	var sourceFileUpdateS3AmazonWebServices SourceFileUpdateS3AmazonWebServices = SourceFileUpdateS3AmazonWebServices{}
	if err := utils.UnmarshalJSON(data, &sourceFileUpdateS3AmazonWebServices, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceFileUpdateStorageProviderTypeSourceFileUpdateS3AmazonWebServices,
			Value: &sourceFileUpdateS3AmazonWebServices,
		})
	}

	var sourceFileUpdateAzBlobAzureBlobStorage SourceFileUpdateAzBlobAzureBlobStorage = SourceFileUpdateAzBlobAzureBlobStorage{}
	if err := utils.UnmarshalJSON(data, &sourceFileUpdateAzBlobAzureBlobStorage, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceFileUpdateStorageProviderTypeSourceFileUpdateAzBlobAzureBlobStorage,
			Value: &sourceFileUpdateAzBlobAzureBlobStorage,
		})
	}

	var sourceFileUpdateSSHSecureShell SourceFileUpdateSSHSecureShell = SourceFileUpdateSSHSecureShell{}
	if err := utils.UnmarshalJSON(data, &sourceFileUpdateSSHSecureShell, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceFileUpdateStorageProviderTypeSourceFileUpdateSSHSecureShell,
			Value: &sourceFileUpdateSSHSecureShell,
		})
	}

	var sourceFileUpdateSCPSecureCopyProtocol SourceFileUpdateSCPSecureCopyProtocol = SourceFileUpdateSCPSecureCopyProtocol{}
	if err := utils.UnmarshalJSON(data, &sourceFileUpdateSCPSecureCopyProtocol, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceFileUpdateStorageProviderTypeSourceFileUpdateSCPSecureCopyProtocol,
			Value: &sourceFileUpdateSCPSecureCopyProtocol,
		})
	}

	var sourceFileUpdateSFTPSecureFileTransferProtocol SourceFileUpdateSFTPSecureFileTransferProtocol = SourceFileUpdateSFTPSecureFileTransferProtocol{}
	if err := utils.UnmarshalJSON(data, &sourceFileUpdateSFTPSecureFileTransferProtocol, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceFileUpdateStorageProviderTypeSourceFileUpdateSFTPSecureFileTransferProtocol,
			Value: &sourceFileUpdateSFTPSecureFileTransferProtocol,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceFileUpdateStorageProvider", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceFileUpdateStorageProvider", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceFileUpdateStorageProviderType)
	switch best.Type {
	case SourceFileUpdateStorageProviderTypeSourceFileUpdateHTTPSPublicWeb:
		u.SourceFileUpdateHTTPSPublicWeb = best.Value.(*SourceFileUpdateHTTPSPublicWeb)
		return nil
	case SourceFileUpdateStorageProviderTypeSourceFileUpdateGCSGoogleCloudStorage:
		u.SourceFileUpdateGCSGoogleCloudStorage = best.Value.(*SourceFileUpdateGCSGoogleCloudStorage)
		return nil
	case SourceFileUpdateStorageProviderTypeSourceFileUpdateS3AmazonWebServices:
		u.SourceFileUpdateS3AmazonWebServices = best.Value.(*SourceFileUpdateS3AmazonWebServices)
		return nil
	case SourceFileUpdateStorageProviderTypeSourceFileUpdateAzBlobAzureBlobStorage:
		u.SourceFileUpdateAzBlobAzureBlobStorage = best.Value.(*SourceFileUpdateAzBlobAzureBlobStorage)
		return nil
	case SourceFileUpdateStorageProviderTypeSourceFileUpdateSSHSecureShell:
		u.SourceFileUpdateSSHSecureShell = best.Value.(*SourceFileUpdateSSHSecureShell)
		return nil
	case SourceFileUpdateStorageProviderTypeSourceFileUpdateSCPSecureCopyProtocol:
		u.SourceFileUpdateSCPSecureCopyProtocol = best.Value.(*SourceFileUpdateSCPSecureCopyProtocol)
		return nil
	case SourceFileUpdateStorageProviderTypeSourceFileUpdateSFTPSecureFileTransferProtocol:
		u.SourceFileUpdateSFTPSecureFileTransferProtocol = best.Value.(*SourceFileUpdateSFTPSecureFileTransferProtocol)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceFileUpdateStorageProvider", string(data))
}

func (u SourceFileUpdateStorageProvider) MarshalJSON() ([]byte, error) {
	if u.SourceFileUpdateHTTPSPublicWeb != nil {
		return utils.MarshalJSON(u.SourceFileUpdateHTTPSPublicWeb, "", true)
	}

	if u.SourceFileUpdateGCSGoogleCloudStorage != nil {
		return utils.MarshalJSON(u.SourceFileUpdateGCSGoogleCloudStorage, "", true)
	}

	if u.SourceFileUpdateS3AmazonWebServices != nil {
		return utils.MarshalJSON(u.SourceFileUpdateS3AmazonWebServices, "", true)
	}

	if u.SourceFileUpdateAzBlobAzureBlobStorage != nil {
		return utils.MarshalJSON(u.SourceFileUpdateAzBlobAzureBlobStorage, "", true)
	}

	if u.SourceFileUpdateSSHSecureShell != nil {
		return utils.MarshalJSON(u.SourceFileUpdateSSHSecureShell, "", true)
	}

	if u.SourceFileUpdateSCPSecureCopyProtocol != nil {
		return utils.MarshalJSON(u.SourceFileUpdateSCPSecureCopyProtocol, "", true)
	}

	if u.SourceFileUpdateSFTPSecureFileTransferProtocol != nil {
		return utils.MarshalJSON(u.SourceFileUpdateSFTPSecureFileTransferProtocol, "", true)
	}

	return nil, errors.New("could not marshal union type SourceFileUpdateStorageProvider: all fields are null")
}

type SourceFileUpdateSourceType string

const (
	SourceFileUpdateSourceTypeFile SourceFileUpdateSourceType = "file"
)

func (e SourceFileUpdateSourceType) ToPointer() *SourceFileUpdateSourceType {
	return &e
}
func (e *SourceFileUpdateSourceType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "file":
		*e = SourceFileUpdateSourceType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceFileUpdateSourceType: %v", v)
	}
}

type SourceFileUpdate struct {
	// The Name of the final table to replicate this file into (should include letters, numbers dash and underscores only).
	DatasetName *string `json:"dataset_name,omitempty"`
	// The Format of the file which should be replicated (Warning: some formats may be experimental, please refer to the docs).
	Format *SourceFileUpdateFileFormat `default:"csv" json:"format"`
	// The storage Provider or Location of the file(s) which should be replicated.
	Provider *SourceFileUpdateStorageProvider `json:"provider,omitempty"`
	// This should be a string in JSON format. It depends on the chosen file format to provide additional options and tune its behavior.
	ReaderOptions *string `json:"reader_options,omitempty"`
	// The URL path to access the file which should be replicated.
	URL                  *string                     `json:"url,omitempty"`
	sourceType           *SourceFileUpdateSourceType `const:"file" json:"sourceType"`
	AdditionalProperties any                         `additionalProperties:"true" json:"-"`
}

func (s SourceFileUpdate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceFileUpdate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceFileUpdate) GetDatasetName() *string {
	if s == nil {
		return nil
	}
	return s.DatasetName
}

func (s *SourceFileUpdate) GetFormat() *SourceFileUpdateFileFormat {
	if s == nil {
		return nil
	}
	return s.Format
}

func (s *SourceFileUpdate) GetProvider() *SourceFileUpdateStorageProvider {
	if s == nil {
		return nil
	}
	return s.Provider
}

func (s *SourceFileUpdate) GetReaderOptions() *string {
	if s == nil {
		return nil
	}
	return s.ReaderOptions
}

func (s *SourceFileUpdate) GetURL() *string {
	if s == nil {
		return nil
	}
	return s.URL
}

func (s *SourceFileUpdate) GetSourceType() *SourceFileUpdateSourceType {
	return SourceFileUpdateSourceTypeFile.ToPointer()
}

func (s *SourceFileUpdate) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}
