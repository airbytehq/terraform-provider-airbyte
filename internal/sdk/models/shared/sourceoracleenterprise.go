// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

type SourceOracleEnterpriseConnectionType string

const (
	SourceOracleEnterpriseConnectionTypeSid SourceOracleEnterpriseConnectionType = "sid"
)

func (e SourceOracleEnterpriseConnectionType) ToPointer() *SourceOracleEnterpriseConnectionType {
	return &e
}
func (e *SourceOracleEnterpriseConnectionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "sid":
		*e = SourceOracleEnterpriseConnectionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceOracleEnterpriseConnectionType: %v", v)
	}
}

// SourceOracleEnterpriseSystemIDSID - Use Oracle System Identifier.
type SourceOracleEnterpriseSystemIDSID struct {
	ConnectionType       *SourceOracleEnterpriseConnectionType `default:"sid" json:"connection_type"`
	Sid                  string                                `json:"sid"`
	AdditionalProperties any                                   `additionalProperties:"true" json:"-"`
}

func (s SourceOracleEnterpriseSystemIDSID) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceOracleEnterpriseSystemIDSID) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceOracleEnterpriseSystemIDSID) GetConnectionType() *SourceOracleEnterpriseConnectionType {
	if s == nil {
		return nil
	}
	return s.ConnectionType
}

func (s *SourceOracleEnterpriseSystemIDSID) GetSid() string {
	if s == nil {
		return ""
	}
	return s.Sid
}

func (s *SourceOracleEnterpriseSystemIDSID) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type ConnectionType string

const (
	ConnectionTypeServiceName ConnectionType = "service_name"
)

func (e ConnectionType) ToPointer() *ConnectionType {
	return &e
}
func (e *ConnectionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "service_name":
		*e = ConnectionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ConnectionType: %v", v)
	}
}

// SourceOracleEnterpriseServiceName - Use service name.
type SourceOracleEnterpriseServiceName struct {
	ConnectionType       *ConnectionType `default:"service_name" json:"connection_type"`
	ServiceName          string          `json:"service_name"`
	AdditionalProperties any             `additionalProperties:"true" json:"-"`
}

func (s SourceOracleEnterpriseServiceName) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceOracleEnterpriseServiceName) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceOracleEnterpriseServiceName) GetConnectionType() *ConnectionType {
	if s == nil {
		return nil
	}
	return s.ConnectionType
}

func (s *SourceOracleEnterpriseServiceName) GetServiceName() string {
	if s == nil {
		return ""
	}
	return s.ServiceName
}

func (s *SourceOracleEnterpriseServiceName) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceOracleEnterpriseConnectByType string

const (
	SourceOracleEnterpriseConnectByTypeSourceOracleEnterpriseServiceName SourceOracleEnterpriseConnectByType = "source-oracle-enterprise_Service name"
	SourceOracleEnterpriseConnectByTypeSourceOracleEnterpriseSystemIDSID SourceOracleEnterpriseConnectByType = "source-oracle-enterprise_System ID (SID)"
)

// SourceOracleEnterpriseConnectBy - The scheme by which to establish a database connection.
type SourceOracleEnterpriseConnectBy struct {
	SourceOracleEnterpriseServiceName *SourceOracleEnterpriseServiceName `queryParam:"inline" union:"member"`
	SourceOracleEnterpriseSystemIDSID *SourceOracleEnterpriseSystemIDSID `queryParam:"inline" union:"member"`

	Type SourceOracleEnterpriseConnectByType
}

func CreateSourceOracleEnterpriseConnectBySourceOracleEnterpriseServiceName(sourceOracleEnterpriseServiceName SourceOracleEnterpriseServiceName) SourceOracleEnterpriseConnectBy {
	typ := SourceOracleEnterpriseConnectByTypeSourceOracleEnterpriseServiceName

	return SourceOracleEnterpriseConnectBy{
		SourceOracleEnterpriseServiceName: &sourceOracleEnterpriseServiceName,
		Type:                              typ,
	}
}

func CreateSourceOracleEnterpriseConnectBySourceOracleEnterpriseSystemIDSID(sourceOracleEnterpriseSystemIDSID SourceOracleEnterpriseSystemIDSID) SourceOracleEnterpriseConnectBy {
	typ := SourceOracleEnterpriseConnectByTypeSourceOracleEnterpriseSystemIDSID

	return SourceOracleEnterpriseConnectBy{
		SourceOracleEnterpriseSystemIDSID: &sourceOracleEnterpriseSystemIDSID,
		Type:                              typ,
	}
}

func (u *SourceOracleEnterpriseConnectBy) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var sourceOracleEnterpriseServiceName SourceOracleEnterpriseServiceName = SourceOracleEnterpriseServiceName{}
	if err := utils.UnmarshalJSON(data, &sourceOracleEnterpriseServiceName, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceOracleEnterpriseConnectByTypeSourceOracleEnterpriseServiceName,
			Value: &sourceOracleEnterpriseServiceName,
		})
	}

	var sourceOracleEnterpriseSystemIDSID SourceOracleEnterpriseSystemIDSID = SourceOracleEnterpriseSystemIDSID{}
	if err := utils.UnmarshalJSON(data, &sourceOracleEnterpriseSystemIDSID, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceOracleEnterpriseConnectByTypeSourceOracleEnterpriseSystemIDSID,
			Value: &sourceOracleEnterpriseSystemIDSID,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceOracleEnterpriseConnectBy", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceOracleEnterpriseConnectBy", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceOracleEnterpriseConnectByType)
	switch best.Type {
	case SourceOracleEnterpriseConnectByTypeSourceOracleEnterpriseServiceName:
		u.SourceOracleEnterpriseServiceName = best.Value.(*SourceOracleEnterpriseServiceName)
		return nil
	case SourceOracleEnterpriseConnectByTypeSourceOracleEnterpriseSystemIDSID:
		u.SourceOracleEnterpriseSystemIDSID = best.Value.(*SourceOracleEnterpriseSystemIDSID)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceOracleEnterpriseConnectBy", string(data))
}

func (u SourceOracleEnterpriseConnectBy) MarshalJSON() ([]byte, error) {
	if u.SourceOracleEnterpriseServiceName != nil {
		return utils.MarshalJSON(u.SourceOracleEnterpriseServiceName, "", true)
	}

	if u.SourceOracleEnterpriseSystemIDSID != nil {
		return utils.MarshalJSON(u.SourceOracleEnterpriseSystemIDSID, "", true)
	}

	return nil, errors.New("could not marshal union type SourceOracleEnterpriseConnectBy: all fields are null")
}

type SourceOracleEnterpriseSchemasCursorMethod string

const (
	SourceOracleEnterpriseSchemasCursorMethodCdc SourceOracleEnterpriseSchemasCursorMethod = "cdc"
)

func (e SourceOracleEnterpriseSchemasCursorMethod) ToPointer() *SourceOracleEnterpriseSchemasCursorMethod {
	return &e
}
func (e *SourceOracleEnterpriseSchemasCursorMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "cdc":
		*e = SourceOracleEnterpriseSchemasCursorMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceOracleEnterpriseSchemasCursorMethod: %v", v)
	}
}

// SourceOracleEnterpriseInvalidCDCPositionBehaviorAdvanced - Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value in the mined logs. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss.
type SourceOracleEnterpriseInvalidCDCPositionBehaviorAdvanced string

const (
	SourceOracleEnterpriseInvalidCDCPositionBehaviorAdvancedFailSync   SourceOracleEnterpriseInvalidCDCPositionBehaviorAdvanced = "Fail sync"
	SourceOracleEnterpriseInvalidCDCPositionBehaviorAdvancedReSyncData SourceOracleEnterpriseInvalidCDCPositionBehaviorAdvanced = "Re-sync data"
)

func (e SourceOracleEnterpriseInvalidCDCPositionBehaviorAdvanced) ToPointer() *SourceOracleEnterpriseInvalidCDCPositionBehaviorAdvanced {
	return &e
}
func (e *SourceOracleEnterpriseInvalidCDCPositionBehaviorAdvanced) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Fail sync":
		fallthrough
	case "Re-sync data":
		*e = SourceOracleEnterpriseInvalidCDCPositionBehaviorAdvanced(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceOracleEnterpriseInvalidCDCPositionBehaviorAdvanced: %v", v)
	}
}

// SourceOracleEnterpriseReadChangesUsingChangeDataCaptureCDC - <i>Recommended</i> - Incrementally reads new inserts, updates, and deletes using Oracle's <a href="https://docs.airbyte.com/integrations/enterprise-connectors/source-oracle#getting-started"> change data capture feature</a>. This must be enabled on your database.
type SourceOracleEnterpriseReadChangesUsingChangeDataCaptureCDC struct {
	CursorMethod *SourceOracleEnterpriseSchemasCursorMethod `default:"cdc" json:"cursor_method"`
	// The amount of time to allow the Debezium Engine to shut down, in seconds.
	DebeziumShutdownTimeoutSeconds *int64 `default:"60" json:"debezium_shutdown_timeout_seconds"`
	// The amount of time an initial load is allowed to continue for before catching up on CDC events.
	InitialLoadTimeoutHours *int64 `default:"8" json:"initial_load_timeout_hours"`
	// Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value in the mined logs. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss.
	InvalidCdcCursorPositionBehavior *SourceOracleEnterpriseInvalidCDCPositionBehaviorAdvanced `default:"Fail sync" json:"invalid_cdc_cursor_position_behavior"`
	AdditionalProperties             any                                                       `additionalProperties:"true" json:"-"`
}

func (s SourceOracleEnterpriseReadChangesUsingChangeDataCaptureCDC) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceOracleEnterpriseReadChangesUsingChangeDataCaptureCDC) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceOracleEnterpriseReadChangesUsingChangeDataCaptureCDC) GetCursorMethod() *SourceOracleEnterpriseSchemasCursorMethod {
	if s == nil {
		return nil
	}
	return s.CursorMethod
}

func (s *SourceOracleEnterpriseReadChangesUsingChangeDataCaptureCDC) GetDebeziumShutdownTimeoutSeconds() *int64 {
	if s == nil {
		return nil
	}
	return s.DebeziumShutdownTimeoutSeconds
}

func (s *SourceOracleEnterpriseReadChangesUsingChangeDataCaptureCDC) GetInitialLoadTimeoutHours() *int64 {
	if s == nil {
		return nil
	}
	return s.InitialLoadTimeoutHours
}

func (s *SourceOracleEnterpriseReadChangesUsingChangeDataCaptureCDC) GetInvalidCdcCursorPositionBehavior() *SourceOracleEnterpriseInvalidCDCPositionBehaviorAdvanced {
	if s == nil {
		return nil
	}
	return s.InvalidCdcCursorPositionBehavior
}

func (s *SourceOracleEnterpriseReadChangesUsingChangeDataCaptureCDC) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceOracleEnterpriseCursorMethod string

const (
	SourceOracleEnterpriseCursorMethodUserDefined SourceOracleEnterpriseCursorMethod = "user_defined"
)

func (e SourceOracleEnterpriseCursorMethod) ToPointer() *SourceOracleEnterpriseCursorMethod {
	return &e
}
func (e *SourceOracleEnterpriseCursorMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "user_defined":
		*e = SourceOracleEnterpriseCursorMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceOracleEnterpriseCursorMethod: %v", v)
	}
}

// SourceOracleEnterpriseScanChangesWithUserDefinedCursor - Incrementally detects new inserts and updates using the <a href="https://docs.airbyte.com/understanding-airbyte/connections/incremental-append/#user-defined-cursor">cursor column</a> chosen when configuring a connection (e.g. created_at, updated_at).
type SourceOracleEnterpriseScanChangesWithUserDefinedCursor struct {
	CursorMethod         *SourceOracleEnterpriseCursorMethod `default:"user_defined" json:"cursor_method"`
	AdditionalProperties any                                 `additionalProperties:"true" json:"-"`
}

func (s SourceOracleEnterpriseScanChangesWithUserDefinedCursor) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceOracleEnterpriseScanChangesWithUserDefinedCursor) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceOracleEnterpriseScanChangesWithUserDefinedCursor) GetCursorMethod() *SourceOracleEnterpriseCursorMethod {
	if s == nil {
		return nil
	}
	return s.CursorMethod
}

func (s *SourceOracleEnterpriseScanChangesWithUserDefinedCursor) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceOracleEnterpriseUpdateMethodType string

const (
	SourceOracleEnterpriseUpdateMethodTypeSourceOracleEnterpriseScanChangesWithUserDefinedCursor     SourceOracleEnterpriseUpdateMethodType = "source-oracle-enterprise_Scan Changes with User Defined Cursor"
	SourceOracleEnterpriseUpdateMethodTypeSourceOracleEnterpriseReadChangesUsingChangeDataCaptureCDC SourceOracleEnterpriseUpdateMethodType = "source-oracle-enterprise_Read Changes using Change Data Capture (CDC)"
)

// SourceOracleEnterpriseUpdateMethod - Configures how data is extracted from the database.
type SourceOracleEnterpriseUpdateMethod struct {
	SourceOracleEnterpriseScanChangesWithUserDefinedCursor     *SourceOracleEnterpriseScanChangesWithUserDefinedCursor     `queryParam:"inline" union:"member"`
	SourceOracleEnterpriseReadChangesUsingChangeDataCaptureCDC *SourceOracleEnterpriseReadChangesUsingChangeDataCaptureCDC `queryParam:"inline" union:"member"`

	Type SourceOracleEnterpriseUpdateMethodType
}

func CreateSourceOracleEnterpriseUpdateMethodSourceOracleEnterpriseScanChangesWithUserDefinedCursor(sourceOracleEnterpriseScanChangesWithUserDefinedCursor SourceOracleEnterpriseScanChangesWithUserDefinedCursor) SourceOracleEnterpriseUpdateMethod {
	typ := SourceOracleEnterpriseUpdateMethodTypeSourceOracleEnterpriseScanChangesWithUserDefinedCursor

	return SourceOracleEnterpriseUpdateMethod{
		SourceOracleEnterpriseScanChangesWithUserDefinedCursor: &sourceOracleEnterpriseScanChangesWithUserDefinedCursor,
		Type: typ,
	}
}

func CreateSourceOracleEnterpriseUpdateMethodSourceOracleEnterpriseReadChangesUsingChangeDataCaptureCDC(sourceOracleEnterpriseReadChangesUsingChangeDataCaptureCDC SourceOracleEnterpriseReadChangesUsingChangeDataCaptureCDC) SourceOracleEnterpriseUpdateMethod {
	typ := SourceOracleEnterpriseUpdateMethodTypeSourceOracleEnterpriseReadChangesUsingChangeDataCaptureCDC

	return SourceOracleEnterpriseUpdateMethod{
		SourceOracleEnterpriseReadChangesUsingChangeDataCaptureCDC: &sourceOracleEnterpriseReadChangesUsingChangeDataCaptureCDC,
		Type: typ,
	}
}

func (u *SourceOracleEnterpriseUpdateMethod) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var sourceOracleEnterpriseScanChangesWithUserDefinedCursor SourceOracleEnterpriseScanChangesWithUserDefinedCursor = SourceOracleEnterpriseScanChangesWithUserDefinedCursor{}
	if err := utils.UnmarshalJSON(data, &sourceOracleEnterpriseScanChangesWithUserDefinedCursor, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceOracleEnterpriseUpdateMethodTypeSourceOracleEnterpriseScanChangesWithUserDefinedCursor,
			Value: &sourceOracleEnterpriseScanChangesWithUserDefinedCursor,
		})
	}

	var sourceOracleEnterpriseReadChangesUsingChangeDataCaptureCDC SourceOracleEnterpriseReadChangesUsingChangeDataCaptureCDC = SourceOracleEnterpriseReadChangesUsingChangeDataCaptureCDC{}
	if err := utils.UnmarshalJSON(data, &sourceOracleEnterpriseReadChangesUsingChangeDataCaptureCDC, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceOracleEnterpriseUpdateMethodTypeSourceOracleEnterpriseReadChangesUsingChangeDataCaptureCDC,
			Value: &sourceOracleEnterpriseReadChangesUsingChangeDataCaptureCDC,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceOracleEnterpriseUpdateMethod", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceOracleEnterpriseUpdateMethod", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceOracleEnterpriseUpdateMethodType)
	switch best.Type {
	case SourceOracleEnterpriseUpdateMethodTypeSourceOracleEnterpriseScanChangesWithUserDefinedCursor:
		u.SourceOracleEnterpriseScanChangesWithUserDefinedCursor = best.Value.(*SourceOracleEnterpriseScanChangesWithUserDefinedCursor)
		return nil
	case SourceOracleEnterpriseUpdateMethodTypeSourceOracleEnterpriseReadChangesUsingChangeDataCaptureCDC:
		u.SourceOracleEnterpriseReadChangesUsingChangeDataCaptureCDC = best.Value.(*SourceOracleEnterpriseReadChangesUsingChangeDataCaptureCDC)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceOracleEnterpriseUpdateMethod", string(data))
}

func (u SourceOracleEnterpriseUpdateMethod) MarshalJSON() ([]byte, error) {
	if u.SourceOracleEnterpriseScanChangesWithUserDefinedCursor != nil {
		return utils.MarshalJSON(u.SourceOracleEnterpriseScanChangesWithUserDefinedCursor, "", true)
	}

	if u.SourceOracleEnterpriseReadChangesUsingChangeDataCaptureCDC != nil {
		return utils.MarshalJSON(u.SourceOracleEnterpriseReadChangesUsingChangeDataCaptureCDC, "", true)
	}

	return nil, errors.New("could not marshal union type SourceOracleEnterpriseUpdateMethod: all fields are null")
}

type SourceOracleEnterpriseSchemasEncryptionEncryptionMethod string

const (
	SourceOracleEnterpriseSchemasEncryptionEncryptionMethodEncryptedVerifyCertificate SourceOracleEnterpriseSchemasEncryptionEncryptionMethod = "encrypted_verify_certificate"
)

func (e SourceOracleEnterpriseSchemasEncryptionEncryptionMethod) ToPointer() *SourceOracleEnterpriseSchemasEncryptionEncryptionMethod {
	return &e
}
func (e *SourceOracleEnterpriseSchemasEncryptionEncryptionMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "encrypted_verify_certificate":
		*e = SourceOracleEnterpriseSchemasEncryptionEncryptionMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceOracleEnterpriseSchemasEncryptionEncryptionMethod: %v", v)
	}
}

// SourceOracleEnterpriseTLSEncryptedVerifyCertificate - Verify and use the certificate provided by the server.
type SourceOracleEnterpriseTLSEncryptedVerifyCertificate struct {
	EncryptionMethod *SourceOracleEnterpriseSchemasEncryptionEncryptionMethod `default:"encrypted_verify_certificate" json:"encryption_method"`
	// Privacy Enhanced Mail (PEM) files are concatenated certificate containers frequently used in certificate installations.
	SslCertificate       string `json:"ssl_certificate"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (s SourceOracleEnterpriseTLSEncryptedVerifyCertificate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceOracleEnterpriseTLSEncryptedVerifyCertificate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceOracleEnterpriseTLSEncryptedVerifyCertificate) GetEncryptionMethod() *SourceOracleEnterpriseSchemasEncryptionEncryptionMethod {
	if s == nil {
		return nil
	}
	return s.EncryptionMethod
}

func (s *SourceOracleEnterpriseTLSEncryptedVerifyCertificate) GetSslCertificate() string {
	if s == nil {
		return ""
	}
	return s.SslCertificate
}

func (s *SourceOracleEnterpriseTLSEncryptedVerifyCertificate) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

// SourceOracleEnterpriseEncryptionAlgorithm - This parameter defines what encryption algorithm is used.
type SourceOracleEnterpriseEncryptionAlgorithm string

const (
	SourceOracleEnterpriseEncryptionAlgorithmAes256      SourceOracleEnterpriseEncryptionAlgorithm = "AES256"
	SourceOracleEnterpriseEncryptionAlgorithmAes192      SourceOracleEnterpriseEncryptionAlgorithm = "AES192"
	SourceOracleEnterpriseEncryptionAlgorithmAes128      SourceOracleEnterpriseEncryptionAlgorithm = "AES128"
	SourceOracleEnterpriseEncryptionAlgorithmThreeDes168 SourceOracleEnterpriseEncryptionAlgorithm = "3DES168"
	SourceOracleEnterpriseEncryptionAlgorithmThreeDes112 SourceOracleEnterpriseEncryptionAlgorithm = "3DES112"
	SourceOracleEnterpriseEncryptionAlgorithmDes         SourceOracleEnterpriseEncryptionAlgorithm = "DES"
)

func (e SourceOracleEnterpriseEncryptionAlgorithm) ToPointer() *SourceOracleEnterpriseEncryptionAlgorithm {
	return &e
}
func (e *SourceOracleEnterpriseEncryptionAlgorithm) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "AES256":
		fallthrough
	case "AES192":
		fallthrough
	case "AES128":
		fallthrough
	case "3DES168":
		fallthrough
	case "3DES112":
		fallthrough
	case "DES":
		*e = SourceOracleEnterpriseEncryptionAlgorithm(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceOracleEnterpriseEncryptionAlgorithm: %v", v)
	}
}

type SourceOracleEnterpriseSchemasEncryptionMethod string

const (
	SourceOracleEnterpriseSchemasEncryptionMethodClientNne SourceOracleEnterpriseSchemasEncryptionMethod = "client_nne"
)

func (e SourceOracleEnterpriseSchemasEncryptionMethod) ToPointer() *SourceOracleEnterpriseSchemasEncryptionMethod {
	return &e
}
func (e *SourceOracleEnterpriseSchemasEncryptionMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "client_nne":
		*e = SourceOracleEnterpriseSchemasEncryptionMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceOracleEnterpriseSchemasEncryptionMethod: %v", v)
	}
}

// SourceOracleEnterpriseNativeNetworkEncryptionNNE - The native network encryption gives you the ability to encrypt database connections, without the configuration overhead of TCP/IP and SSL/TLS and without the need to open and listen on different ports.
type SourceOracleEnterpriseNativeNetworkEncryptionNNE struct {
	// This parameter defines what encryption algorithm is used.
	EncryptionAlgorithm  *SourceOracleEnterpriseEncryptionAlgorithm     `default:"AES256" json:"encryption_algorithm"`
	EncryptionMethod     *SourceOracleEnterpriseSchemasEncryptionMethod `default:"client_nne" json:"encryption_method"`
	AdditionalProperties any                                            `additionalProperties:"true" json:"-"`
}

func (s SourceOracleEnterpriseNativeNetworkEncryptionNNE) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceOracleEnterpriseNativeNetworkEncryptionNNE) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceOracleEnterpriseNativeNetworkEncryptionNNE) GetEncryptionAlgorithm() *SourceOracleEnterpriseEncryptionAlgorithm {
	if s == nil {
		return nil
	}
	return s.EncryptionAlgorithm
}

func (s *SourceOracleEnterpriseNativeNetworkEncryptionNNE) GetEncryptionMethod() *SourceOracleEnterpriseSchemasEncryptionMethod {
	if s == nil {
		return nil
	}
	return s.EncryptionMethod
}

func (s *SourceOracleEnterpriseNativeNetworkEncryptionNNE) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceOracleEnterpriseEncryptionMethod string

const (
	SourceOracleEnterpriseEncryptionMethodUnencrypted SourceOracleEnterpriseEncryptionMethod = "unencrypted"
)

func (e SourceOracleEnterpriseEncryptionMethod) ToPointer() *SourceOracleEnterpriseEncryptionMethod {
	return &e
}
func (e *SourceOracleEnterpriseEncryptionMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "unencrypted":
		*e = SourceOracleEnterpriseEncryptionMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceOracleEnterpriseEncryptionMethod: %v", v)
	}
}

// SourceOracleEnterpriseUnencrypted - Data transfer will not be encrypted.
type SourceOracleEnterpriseUnencrypted struct {
	EncryptionMethod     *SourceOracleEnterpriseEncryptionMethod `default:"unencrypted" json:"encryption_method"`
	AdditionalProperties any                                     `additionalProperties:"true" json:"-"`
}

func (s SourceOracleEnterpriseUnencrypted) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceOracleEnterpriseUnencrypted) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceOracleEnterpriseUnencrypted) GetEncryptionMethod() *SourceOracleEnterpriseEncryptionMethod {
	if s == nil {
		return nil
	}
	return s.EncryptionMethod
}

func (s *SourceOracleEnterpriseUnencrypted) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceOracleEnterpriseEncryptionType string

const (
	SourceOracleEnterpriseEncryptionTypeSourceOracleEnterpriseUnencrypted                   SourceOracleEnterpriseEncryptionType = "source-oracle-enterprise_Unencrypted"
	SourceOracleEnterpriseEncryptionTypeSourceOracleEnterpriseNativeNetworkEncryptionNNE    SourceOracleEnterpriseEncryptionType = "source-oracle-enterprise_Native Network Encryption (NNE)"
	SourceOracleEnterpriseEncryptionTypeSourceOracleEnterpriseTLSEncryptedVerifyCertificate SourceOracleEnterpriseEncryptionType = "source-oracle-enterprise_TLS Encrypted (verify certificate)"
)

// SourceOracleEnterpriseEncryption - The encryption method with is used when communicating with the database.
type SourceOracleEnterpriseEncryption struct {
	SourceOracleEnterpriseUnencrypted                   *SourceOracleEnterpriseUnencrypted                   `queryParam:"inline" union:"member"`
	SourceOracleEnterpriseNativeNetworkEncryptionNNE    *SourceOracleEnterpriseNativeNetworkEncryptionNNE    `queryParam:"inline" union:"member"`
	SourceOracleEnterpriseTLSEncryptedVerifyCertificate *SourceOracleEnterpriseTLSEncryptedVerifyCertificate `queryParam:"inline" union:"member"`

	Type SourceOracleEnterpriseEncryptionType
}

func CreateSourceOracleEnterpriseEncryptionSourceOracleEnterpriseUnencrypted(sourceOracleEnterpriseUnencrypted SourceOracleEnterpriseUnencrypted) SourceOracleEnterpriseEncryption {
	typ := SourceOracleEnterpriseEncryptionTypeSourceOracleEnterpriseUnencrypted

	return SourceOracleEnterpriseEncryption{
		SourceOracleEnterpriseUnencrypted: &sourceOracleEnterpriseUnencrypted,
		Type:                              typ,
	}
}

func CreateSourceOracleEnterpriseEncryptionSourceOracleEnterpriseNativeNetworkEncryptionNNE(sourceOracleEnterpriseNativeNetworkEncryptionNNE SourceOracleEnterpriseNativeNetworkEncryptionNNE) SourceOracleEnterpriseEncryption {
	typ := SourceOracleEnterpriseEncryptionTypeSourceOracleEnterpriseNativeNetworkEncryptionNNE

	return SourceOracleEnterpriseEncryption{
		SourceOracleEnterpriseNativeNetworkEncryptionNNE: &sourceOracleEnterpriseNativeNetworkEncryptionNNE,
		Type: typ,
	}
}

func CreateSourceOracleEnterpriseEncryptionSourceOracleEnterpriseTLSEncryptedVerifyCertificate(sourceOracleEnterpriseTLSEncryptedVerifyCertificate SourceOracleEnterpriseTLSEncryptedVerifyCertificate) SourceOracleEnterpriseEncryption {
	typ := SourceOracleEnterpriseEncryptionTypeSourceOracleEnterpriseTLSEncryptedVerifyCertificate

	return SourceOracleEnterpriseEncryption{
		SourceOracleEnterpriseTLSEncryptedVerifyCertificate: &sourceOracleEnterpriseTLSEncryptedVerifyCertificate,
		Type: typ,
	}
}

func (u *SourceOracleEnterpriseEncryption) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var sourceOracleEnterpriseUnencrypted SourceOracleEnterpriseUnencrypted = SourceOracleEnterpriseUnencrypted{}
	if err := utils.UnmarshalJSON(data, &sourceOracleEnterpriseUnencrypted, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceOracleEnterpriseEncryptionTypeSourceOracleEnterpriseUnencrypted,
			Value: &sourceOracleEnterpriseUnencrypted,
		})
	}

	var sourceOracleEnterpriseNativeNetworkEncryptionNNE SourceOracleEnterpriseNativeNetworkEncryptionNNE = SourceOracleEnterpriseNativeNetworkEncryptionNNE{}
	if err := utils.UnmarshalJSON(data, &sourceOracleEnterpriseNativeNetworkEncryptionNNE, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceOracleEnterpriseEncryptionTypeSourceOracleEnterpriseNativeNetworkEncryptionNNE,
			Value: &sourceOracleEnterpriseNativeNetworkEncryptionNNE,
		})
	}

	var sourceOracleEnterpriseTLSEncryptedVerifyCertificate SourceOracleEnterpriseTLSEncryptedVerifyCertificate = SourceOracleEnterpriseTLSEncryptedVerifyCertificate{}
	if err := utils.UnmarshalJSON(data, &sourceOracleEnterpriseTLSEncryptedVerifyCertificate, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceOracleEnterpriseEncryptionTypeSourceOracleEnterpriseTLSEncryptedVerifyCertificate,
			Value: &sourceOracleEnterpriseTLSEncryptedVerifyCertificate,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceOracleEnterpriseEncryption", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceOracleEnterpriseEncryption", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceOracleEnterpriseEncryptionType)
	switch best.Type {
	case SourceOracleEnterpriseEncryptionTypeSourceOracleEnterpriseUnencrypted:
		u.SourceOracleEnterpriseUnencrypted = best.Value.(*SourceOracleEnterpriseUnencrypted)
		return nil
	case SourceOracleEnterpriseEncryptionTypeSourceOracleEnterpriseNativeNetworkEncryptionNNE:
		u.SourceOracleEnterpriseNativeNetworkEncryptionNNE = best.Value.(*SourceOracleEnterpriseNativeNetworkEncryptionNNE)
		return nil
	case SourceOracleEnterpriseEncryptionTypeSourceOracleEnterpriseTLSEncryptedVerifyCertificate:
		u.SourceOracleEnterpriseTLSEncryptedVerifyCertificate = best.Value.(*SourceOracleEnterpriseTLSEncryptedVerifyCertificate)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceOracleEnterpriseEncryption", string(data))
}

func (u SourceOracleEnterpriseEncryption) MarshalJSON() ([]byte, error) {
	if u.SourceOracleEnterpriseUnencrypted != nil {
		return utils.MarshalJSON(u.SourceOracleEnterpriseUnencrypted, "", true)
	}

	if u.SourceOracleEnterpriseNativeNetworkEncryptionNNE != nil {
		return utils.MarshalJSON(u.SourceOracleEnterpriseNativeNetworkEncryptionNNE, "", true)
	}

	if u.SourceOracleEnterpriseTLSEncryptedVerifyCertificate != nil {
		return utils.MarshalJSON(u.SourceOracleEnterpriseTLSEncryptedVerifyCertificate, "", true)
	}

	return nil, errors.New("could not marshal union type SourceOracleEnterpriseEncryption: all fields are null")
}

// SourceOracleEnterpriseTableFilter - Inclusion filter configuration for table selection per schema.
type SourceOracleEnterpriseTableFilter struct {
	// The name of the schema to apply this filter to. Should match a schema defined in "Schemas" field above.
	SchemaName string `json:"schema_name"`
	// List of table name patterns to include from this schema. Should be a SQL LIKE pattern.
	TableNamePatterns    []string `json:"table_name_patterns"`
	AdditionalProperties any      `additionalProperties:"true" json:"-"`
}

func (s SourceOracleEnterpriseTableFilter) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceOracleEnterpriseTableFilter) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceOracleEnterpriseTableFilter) GetSchemaName() string {
	if s == nil {
		return ""
	}
	return s.SchemaName
}

func (s *SourceOracleEnterpriseTableFilter) GetTableNamePatterns() []string {
	if s == nil {
		return []string{}
	}
	return s.TableNamePatterns
}

func (s *SourceOracleEnterpriseTableFilter) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceOracleEnterpriseSchemasTunnelMethodTunnelMethod string

const (
	SourceOracleEnterpriseSchemasTunnelMethodTunnelMethodSSHPasswordAuth SourceOracleEnterpriseSchemasTunnelMethodTunnelMethod = "SSH_PASSWORD_AUTH"
)

func (e SourceOracleEnterpriseSchemasTunnelMethodTunnelMethod) ToPointer() *SourceOracleEnterpriseSchemasTunnelMethodTunnelMethod {
	return &e
}
func (e *SourceOracleEnterpriseSchemasTunnelMethodTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_PASSWORD_AUTH":
		*e = SourceOracleEnterpriseSchemasTunnelMethodTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceOracleEnterpriseSchemasTunnelMethodTunnelMethod: %v", v)
	}
}

// SourceOracleEnterprisePasswordAuthentication - Connect through a jump server tunnel host using username and password authentication
type SourceOracleEnterprisePasswordAuthentication struct {
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost   string                                                 `json:"tunnel_host"`
	TunnelMethod *SourceOracleEnterpriseSchemasTunnelMethodTunnelMethod `default:"SSH_PASSWORD_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser string `json:"tunnel_user"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword   string `json:"tunnel_user_password"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (s SourceOracleEnterprisePasswordAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceOracleEnterprisePasswordAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceOracleEnterprisePasswordAuthentication) GetTunnelHost() string {
	if s == nil {
		return ""
	}
	return s.TunnelHost
}

func (s *SourceOracleEnterprisePasswordAuthentication) GetTunnelMethod() *SourceOracleEnterpriseSchemasTunnelMethodTunnelMethod {
	if s == nil {
		return nil
	}
	return s.TunnelMethod
}

func (s *SourceOracleEnterprisePasswordAuthentication) GetTunnelPort() *int64 {
	if s == nil {
		return nil
	}
	return s.TunnelPort
}

func (s *SourceOracleEnterprisePasswordAuthentication) GetTunnelUser() string {
	if s == nil {
		return ""
	}
	return s.TunnelUser
}

func (s *SourceOracleEnterprisePasswordAuthentication) GetTunnelUserPassword() string {
	if s == nil {
		return ""
	}
	return s.TunnelUserPassword
}

func (s *SourceOracleEnterprisePasswordAuthentication) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceOracleEnterpriseSchemasTunnelMethod string

const (
	SourceOracleEnterpriseSchemasTunnelMethodSSHKeyAuth SourceOracleEnterpriseSchemasTunnelMethod = "SSH_KEY_AUTH"
)

func (e SourceOracleEnterpriseSchemasTunnelMethod) ToPointer() *SourceOracleEnterpriseSchemasTunnelMethod {
	return &e
}
func (e *SourceOracleEnterpriseSchemasTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_KEY_AUTH":
		*e = SourceOracleEnterpriseSchemasTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceOracleEnterpriseSchemasTunnelMethod: %v", v)
	}
}

// SourceOracleEnterpriseSSHKeyAuthentication - Connect through a jump server tunnel host using username and ssh key
type SourceOracleEnterpriseSSHKeyAuthentication struct {
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey string `json:"ssh_key"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost   string                                     `json:"tunnel_host"`
	TunnelMethod *SourceOracleEnterpriseSchemasTunnelMethod `default:"SSH_KEY_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser           string `json:"tunnel_user"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (s SourceOracleEnterpriseSSHKeyAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceOracleEnterpriseSSHKeyAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceOracleEnterpriseSSHKeyAuthentication) GetSSHKey() string {
	if s == nil {
		return ""
	}
	return s.SSHKey
}

func (s *SourceOracleEnterpriseSSHKeyAuthentication) GetTunnelHost() string {
	if s == nil {
		return ""
	}
	return s.TunnelHost
}

func (s *SourceOracleEnterpriseSSHKeyAuthentication) GetTunnelMethod() *SourceOracleEnterpriseSchemasTunnelMethod {
	if s == nil {
		return nil
	}
	return s.TunnelMethod
}

func (s *SourceOracleEnterpriseSSHKeyAuthentication) GetTunnelPort() *int64 {
	if s == nil {
		return nil
	}
	return s.TunnelPort
}

func (s *SourceOracleEnterpriseSSHKeyAuthentication) GetTunnelUser() string {
	if s == nil {
		return ""
	}
	return s.TunnelUser
}

func (s *SourceOracleEnterpriseSSHKeyAuthentication) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceOracleEnterpriseTunnelMethod string

const (
	SourceOracleEnterpriseTunnelMethodNoTunnel SourceOracleEnterpriseTunnelMethod = "NO_TUNNEL"
)

func (e SourceOracleEnterpriseTunnelMethod) ToPointer() *SourceOracleEnterpriseTunnelMethod {
	return &e
}
func (e *SourceOracleEnterpriseTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NO_TUNNEL":
		*e = SourceOracleEnterpriseTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceOracleEnterpriseTunnelMethod: %v", v)
	}
}

// SourceOracleEnterpriseNoTunnel - No ssh tunnel needed to connect to database
type SourceOracleEnterpriseNoTunnel struct {
	TunnelMethod         *SourceOracleEnterpriseTunnelMethod `default:"NO_TUNNEL" json:"tunnel_method"`
	AdditionalProperties any                                 `additionalProperties:"true" json:"-"`
}

func (s SourceOracleEnterpriseNoTunnel) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceOracleEnterpriseNoTunnel) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceOracleEnterpriseNoTunnel) GetTunnelMethod() *SourceOracleEnterpriseTunnelMethod {
	if s == nil {
		return nil
	}
	return s.TunnelMethod
}

func (s *SourceOracleEnterpriseNoTunnel) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceOracleEnterpriseSSHTunnelMethodType string

const (
	SourceOracleEnterpriseSSHTunnelMethodTypeSourceOracleEnterpriseNoTunnel               SourceOracleEnterpriseSSHTunnelMethodType = "source-oracle-enterprise_No Tunnel"
	SourceOracleEnterpriseSSHTunnelMethodTypeSourceOracleEnterpriseSSHKeyAuthentication   SourceOracleEnterpriseSSHTunnelMethodType = "source-oracle-enterprise_SSH Key Authentication"
	SourceOracleEnterpriseSSHTunnelMethodTypeSourceOracleEnterprisePasswordAuthentication SourceOracleEnterpriseSSHTunnelMethodType = "source-oracle-enterprise_Password Authentication"
)

// SourceOracleEnterpriseSSHTunnelMethod - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceOracleEnterpriseSSHTunnelMethod struct {
	SourceOracleEnterpriseNoTunnel               *SourceOracleEnterpriseNoTunnel               `queryParam:"inline" union:"member"`
	SourceOracleEnterpriseSSHKeyAuthentication   *SourceOracleEnterpriseSSHKeyAuthentication   `queryParam:"inline" union:"member"`
	SourceOracleEnterprisePasswordAuthentication *SourceOracleEnterprisePasswordAuthentication `queryParam:"inline" union:"member"`

	Type SourceOracleEnterpriseSSHTunnelMethodType
}

func CreateSourceOracleEnterpriseSSHTunnelMethodSourceOracleEnterpriseNoTunnel(sourceOracleEnterpriseNoTunnel SourceOracleEnterpriseNoTunnel) SourceOracleEnterpriseSSHTunnelMethod {
	typ := SourceOracleEnterpriseSSHTunnelMethodTypeSourceOracleEnterpriseNoTunnel

	return SourceOracleEnterpriseSSHTunnelMethod{
		SourceOracleEnterpriseNoTunnel: &sourceOracleEnterpriseNoTunnel,
		Type:                           typ,
	}
}

func CreateSourceOracleEnterpriseSSHTunnelMethodSourceOracleEnterpriseSSHKeyAuthentication(sourceOracleEnterpriseSSHKeyAuthentication SourceOracleEnterpriseSSHKeyAuthentication) SourceOracleEnterpriseSSHTunnelMethod {
	typ := SourceOracleEnterpriseSSHTunnelMethodTypeSourceOracleEnterpriseSSHKeyAuthentication

	return SourceOracleEnterpriseSSHTunnelMethod{
		SourceOracleEnterpriseSSHKeyAuthentication: &sourceOracleEnterpriseSSHKeyAuthentication,
		Type: typ,
	}
}

func CreateSourceOracleEnterpriseSSHTunnelMethodSourceOracleEnterprisePasswordAuthentication(sourceOracleEnterprisePasswordAuthentication SourceOracleEnterprisePasswordAuthentication) SourceOracleEnterpriseSSHTunnelMethod {
	typ := SourceOracleEnterpriseSSHTunnelMethodTypeSourceOracleEnterprisePasswordAuthentication

	return SourceOracleEnterpriseSSHTunnelMethod{
		SourceOracleEnterprisePasswordAuthentication: &sourceOracleEnterprisePasswordAuthentication,
		Type: typ,
	}
}

func (u *SourceOracleEnterpriseSSHTunnelMethod) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var sourceOracleEnterpriseNoTunnel SourceOracleEnterpriseNoTunnel = SourceOracleEnterpriseNoTunnel{}
	if err := utils.UnmarshalJSON(data, &sourceOracleEnterpriseNoTunnel, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceOracleEnterpriseSSHTunnelMethodTypeSourceOracleEnterpriseNoTunnel,
			Value: &sourceOracleEnterpriseNoTunnel,
		})
	}

	var sourceOracleEnterpriseSSHKeyAuthentication SourceOracleEnterpriseSSHKeyAuthentication = SourceOracleEnterpriseSSHKeyAuthentication{}
	if err := utils.UnmarshalJSON(data, &sourceOracleEnterpriseSSHKeyAuthentication, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceOracleEnterpriseSSHTunnelMethodTypeSourceOracleEnterpriseSSHKeyAuthentication,
			Value: &sourceOracleEnterpriseSSHKeyAuthentication,
		})
	}

	var sourceOracleEnterprisePasswordAuthentication SourceOracleEnterprisePasswordAuthentication = SourceOracleEnterprisePasswordAuthentication{}
	if err := utils.UnmarshalJSON(data, &sourceOracleEnterprisePasswordAuthentication, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceOracleEnterpriseSSHTunnelMethodTypeSourceOracleEnterprisePasswordAuthentication,
			Value: &sourceOracleEnterprisePasswordAuthentication,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceOracleEnterpriseSSHTunnelMethod", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceOracleEnterpriseSSHTunnelMethod", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceOracleEnterpriseSSHTunnelMethodType)
	switch best.Type {
	case SourceOracleEnterpriseSSHTunnelMethodTypeSourceOracleEnterpriseNoTunnel:
		u.SourceOracleEnterpriseNoTunnel = best.Value.(*SourceOracleEnterpriseNoTunnel)
		return nil
	case SourceOracleEnterpriseSSHTunnelMethodTypeSourceOracleEnterpriseSSHKeyAuthentication:
		u.SourceOracleEnterpriseSSHKeyAuthentication = best.Value.(*SourceOracleEnterpriseSSHKeyAuthentication)
		return nil
	case SourceOracleEnterpriseSSHTunnelMethodTypeSourceOracleEnterprisePasswordAuthentication:
		u.SourceOracleEnterprisePasswordAuthentication = best.Value.(*SourceOracleEnterprisePasswordAuthentication)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceOracleEnterpriseSSHTunnelMethod", string(data))
}

func (u SourceOracleEnterpriseSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.SourceOracleEnterpriseNoTunnel != nil {
		return utils.MarshalJSON(u.SourceOracleEnterpriseNoTunnel, "", true)
	}

	if u.SourceOracleEnterpriseSSHKeyAuthentication != nil {
		return utils.MarshalJSON(u.SourceOracleEnterpriseSSHKeyAuthentication, "", true)
	}

	if u.SourceOracleEnterprisePasswordAuthentication != nil {
		return utils.MarshalJSON(u.SourceOracleEnterprisePasswordAuthentication, "", true)
	}

	return nil, errors.New("could not marshal union type SourceOracleEnterpriseSSHTunnelMethod: all fields are null")
}

type SourceOracleEnterpriseSourceType string

const (
	SourceOracleEnterpriseSourceTypeOracleEnterprise SourceOracleEnterpriseSourceType = "oracle-enterprise"
)

func (e SourceOracleEnterpriseSourceType) ToPointer() *SourceOracleEnterpriseSourceType {
	return &e
}
func (e *SourceOracleEnterpriseSourceType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "oracle-enterprise":
		*e = SourceOracleEnterpriseSourceType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceOracleEnterpriseSourceType: %v", v)
	}
}

type SourceOracleEnterprise struct {
	// When this feature is enabled, during schema discovery the connector will query each table or view individually to check access privileges and inaccessible tables, views, or columns therein will be removed. In large schemas, this might cause schema discovery to take too long, in which case it might be advisable to disable this feature.
	CheckPrivileges *bool `default:"true" json:"check_privileges"`
	// How often (in seconds) a stream should checkpoint, when possible.
	CheckpointTargetIntervalSeconds *int64 `default:"300" json:"checkpoint_target_interval_seconds"`
	// Maximum number of concurrent queries to the database.
	Concurrency *int64 `default:"1" json:"concurrency"`
	// The scheme by which to establish a database connection.
	ConnectionData SourceOracleEnterpriseConnectBy `json:"connection_data"`
	// Configures how data is extracted from the database.
	Cursor SourceOracleEnterpriseUpdateMethod `json:"cursor"`
	// The encryption method with is used when communicating with the database.
	Encryption SourceOracleEnterpriseEncryption `json:"encryption"`
	// Hostname of the database.
	Host string `json:"host"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// The password associated with the username.
	Password *string `json:"password,omitempty"`
	// Port of the database.
	// Oracle Corporations recommends the following port numbers:
	// 1521 - Default listening port for client connections to the listener.
	// 2484 - Recommended and officially registered listening port for client connections to the listener using TCP/IP with SSL.
	Port *int64 `default:"1521" json:"port"`
	// The list of schemas to sync from. Defaults to user. Case sensitive.
	Schemas []string `json:"schemas,omitempty"`
	// Inclusion filters for table selection per schema. If no filters are specified for a schema, all tables in that schema will be synced.
	TableFilters []SourceOracleEnterpriseTableFilter `json:"table_filters,omitempty"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod SourceOracleEnterpriseSSHTunnelMethod `json:"tunnel_method"`
	// The username which is used to access the database.
	Username             string                            `json:"username"`
	sourceType           *SourceOracleEnterpriseSourceType `const:"oracle-enterprise" json:"sourceType"`
	AdditionalProperties any                               `additionalProperties:"true" json:"-"`
}

func (s SourceOracleEnterprise) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceOracleEnterprise) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceOracleEnterprise) GetCheckPrivileges() *bool {
	if s == nil {
		return nil
	}
	return s.CheckPrivileges
}

func (s *SourceOracleEnterprise) GetCheckpointTargetIntervalSeconds() *int64 {
	if s == nil {
		return nil
	}
	return s.CheckpointTargetIntervalSeconds
}

func (s *SourceOracleEnterprise) GetConcurrency() *int64 {
	if s == nil {
		return nil
	}
	return s.Concurrency
}

func (s *SourceOracleEnterprise) GetConnectionData() SourceOracleEnterpriseConnectBy {
	if s == nil {
		return SourceOracleEnterpriseConnectBy{}
	}
	return s.ConnectionData
}

func (s *SourceOracleEnterprise) GetCursor() SourceOracleEnterpriseUpdateMethod {
	if s == nil {
		return SourceOracleEnterpriseUpdateMethod{}
	}
	return s.Cursor
}

func (s *SourceOracleEnterprise) GetEncryption() SourceOracleEnterpriseEncryption {
	if s == nil {
		return SourceOracleEnterpriseEncryption{}
	}
	return s.Encryption
}

func (s *SourceOracleEnterprise) GetHost() string {
	if s == nil {
		return ""
	}
	return s.Host
}

func (s *SourceOracleEnterprise) GetJdbcURLParams() *string {
	if s == nil {
		return nil
	}
	return s.JdbcURLParams
}

func (s *SourceOracleEnterprise) GetPassword() *string {
	if s == nil {
		return nil
	}
	return s.Password
}

func (s *SourceOracleEnterprise) GetPort() *int64 {
	if s == nil {
		return nil
	}
	return s.Port
}

func (s *SourceOracleEnterprise) GetSchemas() []string {
	if s == nil {
		return nil
	}
	return s.Schemas
}

func (s *SourceOracleEnterprise) GetTableFilters() []SourceOracleEnterpriseTableFilter {
	if s == nil {
		return nil
	}
	return s.TableFilters
}

func (s *SourceOracleEnterprise) GetTunnelMethod() SourceOracleEnterpriseSSHTunnelMethod {
	if s == nil {
		return SourceOracleEnterpriseSSHTunnelMethod{}
	}
	return s.TunnelMethod
}

func (s *SourceOracleEnterprise) GetUsername() string {
	if s == nil {
		return ""
	}
	return s.Username
}

func (s *SourceOracleEnterprise) GetSourceType() *SourceOracleEnterpriseSourceType {
	return SourceOracleEnterpriseSourceTypeOracleEnterprise.ToPointer()
}

func (s *SourceOracleEnterprise) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}
