// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

type SourceSapHanaEnterpriseSchemasCursorMethod string

const (
	SourceSapHanaEnterpriseSchemasCursorMethodCdc SourceSapHanaEnterpriseSchemasCursorMethod = "cdc"
)

func (e SourceSapHanaEnterpriseSchemasCursorMethod) ToPointer() *SourceSapHanaEnterpriseSchemasCursorMethod {
	return &e
}
func (e *SourceSapHanaEnterpriseSchemasCursorMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "cdc":
		*e = SourceSapHanaEnterpriseSchemasCursorMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceSapHanaEnterpriseSchemasCursorMethod: %v", v)
	}
}

// SourceSapHanaEnterpriseInvalidCDCPositionBehaviorAdvanced - Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value in the mined logs. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss.
type SourceSapHanaEnterpriseInvalidCDCPositionBehaviorAdvanced string

const (
	SourceSapHanaEnterpriseInvalidCDCPositionBehaviorAdvancedFailSync   SourceSapHanaEnterpriseInvalidCDCPositionBehaviorAdvanced = "Fail sync"
	SourceSapHanaEnterpriseInvalidCDCPositionBehaviorAdvancedReSyncData SourceSapHanaEnterpriseInvalidCDCPositionBehaviorAdvanced = "Re-sync data"
)

func (e SourceSapHanaEnterpriseInvalidCDCPositionBehaviorAdvanced) ToPointer() *SourceSapHanaEnterpriseInvalidCDCPositionBehaviorAdvanced {
	return &e
}
func (e *SourceSapHanaEnterpriseInvalidCDCPositionBehaviorAdvanced) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Fail sync":
		fallthrough
	case "Re-sync data":
		*e = SourceSapHanaEnterpriseInvalidCDCPositionBehaviorAdvanced(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceSapHanaEnterpriseInvalidCDCPositionBehaviorAdvanced: %v", v)
	}
}

// SourceSapHanaEnterpriseReadChangesUsingChangeDataCaptureCDC - <i>Recommended</i> - Incrementally reads new inserts, updates, and deletes using change data capture feature. This must be enabled on your database.
type SourceSapHanaEnterpriseReadChangesUsingChangeDataCaptureCDC struct {
	CursorMethod *SourceSapHanaEnterpriseSchemasCursorMethod `default:"cdc" json:"cursor_method"`
	// The amount of time an initial load is allowed to continue for before catching up on CDC events.
	InitialLoadTimeoutHours *int64 `default:"8" json:"initial_load_timeout_hours"`
	// Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value in the mined logs. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss.
	InvalidCdcCursorPositionBehavior *SourceSapHanaEnterpriseInvalidCDCPositionBehaviorAdvanced `default:"Fail sync" json:"invalid_cdc_cursor_position_behavior"`
	AdditionalProperties             any                                                        `additionalProperties:"true" json:"-"`
}

func (s SourceSapHanaEnterpriseReadChangesUsingChangeDataCaptureCDC) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceSapHanaEnterpriseReadChangesUsingChangeDataCaptureCDC) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceSapHanaEnterpriseReadChangesUsingChangeDataCaptureCDC) GetCursorMethod() *SourceSapHanaEnterpriseSchemasCursorMethod {
	if s == nil {
		return nil
	}
	return s.CursorMethod
}

func (s *SourceSapHanaEnterpriseReadChangesUsingChangeDataCaptureCDC) GetInitialLoadTimeoutHours() *int64 {
	if s == nil {
		return nil
	}
	return s.InitialLoadTimeoutHours
}

func (s *SourceSapHanaEnterpriseReadChangesUsingChangeDataCaptureCDC) GetInvalidCdcCursorPositionBehavior() *SourceSapHanaEnterpriseInvalidCDCPositionBehaviorAdvanced {
	if s == nil {
		return nil
	}
	return s.InvalidCdcCursorPositionBehavior
}

func (s *SourceSapHanaEnterpriseReadChangesUsingChangeDataCaptureCDC) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceSapHanaEnterpriseCursorMethod string

const (
	SourceSapHanaEnterpriseCursorMethodUserDefined SourceSapHanaEnterpriseCursorMethod = "user_defined"
)

func (e SourceSapHanaEnterpriseCursorMethod) ToPointer() *SourceSapHanaEnterpriseCursorMethod {
	return &e
}
func (e *SourceSapHanaEnterpriseCursorMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "user_defined":
		*e = SourceSapHanaEnterpriseCursorMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceSapHanaEnterpriseCursorMethod: %v", v)
	}
}

// SourceSapHanaEnterpriseScanChangesWithUserDefinedCursor - Incrementally detects new inserts and updates using the <a href="https://docs.airbyte.com/understanding-airbyte/connections/incremental-append/#user-defined-cursor">cursor column</a> chosen when configuring a connection (e.g. created_at, updated_at).
type SourceSapHanaEnterpriseScanChangesWithUserDefinedCursor struct {
	CursorMethod         *SourceSapHanaEnterpriseCursorMethod `default:"user_defined" json:"cursor_method"`
	AdditionalProperties any                                  `additionalProperties:"true" json:"-"`
}

func (s SourceSapHanaEnterpriseScanChangesWithUserDefinedCursor) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceSapHanaEnterpriseScanChangesWithUserDefinedCursor) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceSapHanaEnterpriseScanChangesWithUserDefinedCursor) GetCursorMethod() *SourceSapHanaEnterpriseCursorMethod {
	if s == nil {
		return nil
	}
	return s.CursorMethod
}

func (s *SourceSapHanaEnterpriseScanChangesWithUserDefinedCursor) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceSapHanaEnterpriseUpdateMethodType string

const (
	SourceSapHanaEnterpriseUpdateMethodTypeSourceSapHanaEnterpriseScanChangesWithUserDefinedCursor     SourceSapHanaEnterpriseUpdateMethodType = "source-sap-hana-enterprise_Scan Changes with User Defined Cursor"
	SourceSapHanaEnterpriseUpdateMethodTypeSourceSapHanaEnterpriseReadChangesUsingChangeDataCaptureCDC SourceSapHanaEnterpriseUpdateMethodType = "source-sap-hana-enterprise_Read Changes using Change Data Capture (CDC)"
)

// SourceSapHanaEnterpriseUpdateMethod - Configures how data is extracted from the database.
type SourceSapHanaEnterpriseUpdateMethod struct {
	SourceSapHanaEnterpriseScanChangesWithUserDefinedCursor     *SourceSapHanaEnterpriseScanChangesWithUserDefinedCursor     `queryParam:"inline" union:"member"`
	SourceSapHanaEnterpriseReadChangesUsingChangeDataCaptureCDC *SourceSapHanaEnterpriseReadChangesUsingChangeDataCaptureCDC `queryParam:"inline" union:"member"`

	Type SourceSapHanaEnterpriseUpdateMethodType
}

func CreateSourceSapHanaEnterpriseUpdateMethodSourceSapHanaEnterpriseScanChangesWithUserDefinedCursor(sourceSapHanaEnterpriseScanChangesWithUserDefinedCursor SourceSapHanaEnterpriseScanChangesWithUserDefinedCursor) SourceSapHanaEnterpriseUpdateMethod {
	typ := SourceSapHanaEnterpriseUpdateMethodTypeSourceSapHanaEnterpriseScanChangesWithUserDefinedCursor

	return SourceSapHanaEnterpriseUpdateMethod{
		SourceSapHanaEnterpriseScanChangesWithUserDefinedCursor: &sourceSapHanaEnterpriseScanChangesWithUserDefinedCursor,
		Type: typ,
	}
}

func CreateSourceSapHanaEnterpriseUpdateMethodSourceSapHanaEnterpriseReadChangesUsingChangeDataCaptureCDC(sourceSapHanaEnterpriseReadChangesUsingChangeDataCaptureCDC SourceSapHanaEnterpriseReadChangesUsingChangeDataCaptureCDC) SourceSapHanaEnterpriseUpdateMethod {
	typ := SourceSapHanaEnterpriseUpdateMethodTypeSourceSapHanaEnterpriseReadChangesUsingChangeDataCaptureCDC

	return SourceSapHanaEnterpriseUpdateMethod{
		SourceSapHanaEnterpriseReadChangesUsingChangeDataCaptureCDC: &sourceSapHanaEnterpriseReadChangesUsingChangeDataCaptureCDC,
		Type: typ,
	}
}

func (u *SourceSapHanaEnterpriseUpdateMethod) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var sourceSapHanaEnterpriseScanChangesWithUserDefinedCursor SourceSapHanaEnterpriseScanChangesWithUserDefinedCursor = SourceSapHanaEnterpriseScanChangesWithUserDefinedCursor{}
	if err := utils.UnmarshalJSON(data, &sourceSapHanaEnterpriseScanChangesWithUserDefinedCursor, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceSapHanaEnterpriseUpdateMethodTypeSourceSapHanaEnterpriseScanChangesWithUserDefinedCursor,
			Value: &sourceSapHanaEnterpriseScanChangesWithUserDefinedCursor,
		})
	}

	var sourceSapHanaEnterpriseReadChangesUsingChangeDataCaptureCDC SourceSapHanaEnterpriseReadChangesUsingChangeDataCaptureCDC = SourceSapHanaEnterpriseReadChangesUsingChangeDataCaptureCDC{}
	if err := utils.UnmarshalJSON(data, &sourceSapHanaEnterpriseReadChangesUsingChangeDataCaptureCDC, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceSapHanaEnterpriseUpdateMethodTypeSourceSapHanaEnterpriseReadChangesUsingChangeDataCaptureCDC,
			Value: &sourceSapHanaEnterpriseReadChangesUsingChangeDataCaptureCDC,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceSapHanaEnterpriseUpdateMethod", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceSapHanaEnterpriseUpdateMethod", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceSapHanaEnterpriseUpdateMethodType)
	switch best.Type {
	case SourceSapHanaEnterpriseUpdateMethodTypeSourceSapHanaEnterpriseScanChangesWithUserDefinedCursor:
		u.SourceSapHanaEnterpriseScanChangesWithUserDefinedCursor = best.Value.(*SourceSapHanaEnterpriseScanChangesWithUserDefinedCursor)
		return nil
	case SourceSapHanaEnterpriseUpdateMethodTypeSourceSapHanaEnterpriseReadChangesUsingChangeDataCaptureCDC:
		u.SourceSapHanaEnterpriseReadChangesUsingChangeDataCaptureCDC = best.Value.(*SourceSapHanaEnterpriseReadChangesUsingChangeDataCaptureCDC)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceSapHanaEnterpriseUpdateMethod", string(data))
}

func (u SourceSapHanaEnterpriseUpdateMethod) MarshalJSON() ([]byte, error) {
	if u.SourceSapHanaEnterpriseScanChangesWithUserDefinedCursor != nil {
		return utils.MarshalJSON(u.SourceSapHanaEnterpriseScanChangesWithUserDefinedCursor, "", true)
	}

	if u.SourceSapHanaEnterpriseReadChangesUsingChangeDataCaptureCDC != nil {
		return utils.MarshalJSON(u.SourceSapHanaEnterpriseReadChangesUsingChangeDataCaptureCDC, "", true)
	}

	return nil, errors.New("could not marshal union type SourceSapHanaEnterpriseUpdateMethod: all fields are null")
}

type SourceSapHanaEnterpriseSchemasEncryptionEncryptionMethod string

const (
	SourceSapHanaEnterpriseSchemasEncryptionEncryptionMethodEncryptedVerifyCertificate SourceSapHanaEnterpriseSchemasEncryptionEncryptionMethod = "encrypted_verify_certificate"
)

func (e SourceSapHanaEnterpriseSchemasEncryptionEncryptionMethod) ToPointer() *SourceSapHanaEnterpriseSchemasEncryptionEncryptionMethod {
	return &e
}
func (e *SourceSapHanaEnterpriseSchemasEncryptionEncryptionMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "encrypted_verify_certificate":
		*e = SourceSapHanaEnterpriseSchemasEncryptionEncryptionMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceSapHanaEnterpriseSchemasEncryptionEncryptionMethod: %v", v)
	}
}

// SourceSapHanaEnterpriseTLSEncryptedVerifyCertificate - Verify and use the certificate provided by the server.
type SourceSapHanaEnterpriseTLSEncryptedVerifyCertificate struct {
	EncryptionMethod *SourceSapHanaEnterpriseSchemasEncryptionEncryptionMethod `default:"encrypted_verify_certificate" json:"encryption_method"`
	// Privacy Enhanced Mail (PEM) files are concatenated certificate containers frequently used in certificate installations.
	SslCertificate       string `json:"ssl_certificate"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (s SourceSapHanaEnterpriseTLSEncryptedVerifyCertificate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceSapHanaEnterpriseTLSEncryptedVerifyCertificate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceSapHanaEnterpriseTLSEncryptedVerifyCertificate) GetEncryptionMethod() *SourceSapHanaEnterpriseSchemasEncryptionEncryptionMethod {
	if s == nil {
		return nil
	}
	return s.EncryptionMethod
}

func (s *SourceSapHanaEnterpriseTLSEncryptedVerifyCertificate) GetSslCertificate() string {
	if s == nil {
		return ""
	}
	return s.SslCertificate
}

func (s *SourceSapHanaEnterpriseTLSEncryptedVerifyCertificate) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

// SourceSapHanaEnterpriseEncryptionAlgorithm - This parameter defines what encryption algorithm is used.
type SourceSapHanaEnterpriseEncryptionAlgorithm string

const (
	SourceSapHanaEnterpriseEncryptionAlgorithmAes256      SourceSapHanaEnterpriseEncryptionAlgorithm = "AES256"
	SourceSapHanaEnterpriseEncryptionAlgorithmRc456       SourceSapHanaEnterpriseEncryptionAlgorithm = "RC4_56"
	SourceSapHanaEnterpriseEncryptionAlgorithmThreeDes168 SourceSapHanaEnterpriseEncryptionAlgorithm = "3DES168"
)

func (e SourceSapHanaEnterpriseEncryptionAlgorithm) ToPointer() *SourceSapHanaEnterpriseEncryptionAlgorithm {
	return &e
}
func (e *SourceSapHanaEnterpriseEncryptionAlgorithm) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "AES256":
		fallthrough
	case "RC4_56":
		fallthrough
	case "3DES168":
		*e = SourceSapHanaEnterpriseEncryptionAlgorithm(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceSapHanaEnterpriseEncryptionAlgorithm: %v", v)
	}
}

type SourceSapHanaEnterpriseSchemasEncryptionMethod string

const (
	SourceSapHanaEnterpriseSchemasEncryptionMethodClientNne SourceSapHanaEnterpriseSchemasEncryptionMethod = "client_nne"
)

func (e SourceSapHanaEnterpriseSchemasEncryptionMethod) ToPointer() *SourceSapHanaEnterpriseSchemasEncryptionMethod {
	return &e
}
func (e *SourceSapHanaEnterpriseSchemasEncryptionMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "client_nne":
		*e = SourceSapHanaEnterpriseSchemasEncryptionMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceSapHanaEnterpriseSchemasEncryptionMethod: %v", v)
	}
}

// SourceSapHanaEnterpriseNativeNetworkEncryptionNNE - The native network encryption gives you the ability to encrypt database connections, without the configuration overhead of TCP/IP and SSL/TLS and without the need to open and listen on different ports.
type SourceSapHanaEnterpriseNativeNetworkEncryptionNNE struct {
	// This parameter defines what encryption algorithm is used.
	EncryptionAlgorithm  *SourceSapHanaEnterpriseEncryptionAlgorithm     `default:"AES256" json:"encryption_algorithm"`
	EncryptionMethod     *SourceSapHanaEnterpriseSchemasEncryptionMethod `default:"client_nne" json:"encryption_method"`
	AdditionalProperties any                                             `additionalProperties:"true" json:"-"`
}

func (s SourceSapHanaEnterpriseNativeNetworkEncryptionNNE) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceSapHanaEnterpriseNativeNetworkEncryptionNNE) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceSapHanaEnterpriseNativeNetworkEncryptionNNE) GetEncryptionAlgorithm() *SourceSapHanaEnterpriseEncryptionAlgorithm {
	if s == nil {
		return nil
	}
	return s.EncryptionAlgorithm
}

func (s *SourceSapHanaEnterpriseNativeNetworkEncryptionNNE) GetEncryptionMethod() *SourceSapHanaEnterpriseSchemasEncryptionMethod {
	if s == nil {
		return nil
	}
	return s.EncryptionMethod
}

func (s *SourceSapHanaEnterpriseNativeNetworkEncryptionNNE) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceSapHanaEnterpriseEncryptionMethod string

const (
	SourceSapHanaEnterpriseEncryptionMethodUnencrypted SourceSapHanaEnterpriseEncryptionMethod = "unencrypted"
)

func (e SourceSapHanaEnterpriseEncryptionMethod) ToPointer() *SourceSapHanaEnterpriseEncryptionMethod {
	return &e
}
func (e *SourceSapHanaEnterpriseEncryptionMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "unencrypted":
		*e = SourceSapHanaEnterpriseEncryptionMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceSapHanaEnterpriseEncryptionMethod: %v", v)
	}
}

// SourceSapHanaEnterpriseUnencrypted - Data transfer will not be encrypted.
type SourceSapHanaEnterpriseUnencrypted struct {
	EncryptionMethod     *SourceSapHanaEnterpriseEncryptionMethod `default:"unencrypted" json:"encryption_method"`
	AdditionalProperties any                                      `additionalProperties:"true" json:"-"`
}

func (s SourceSapHanaEnterpriseUnencrypted) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceSapHanaEnterpriseUnencrypted) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceSapHanaEnterpriseUnencrypted) GetEncryptionMethod() *SourceSapHanaEnterpriseEncryptionMethod {
	if s == nil {
		return nil
	}
	return s.EncryptionMethod
}

func (s *SourceSapHanaEnterpriseUnencrypted) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceSapHanaEnterpriseEncryptionType string

const (
	SourceSapHanaEnterpriseEncryptionTypeSourceSapHanaEnterpriseUnencrypted                   SourceSapHanaEnterpriseEncryptionType = "source-sap-hana-enterprise_Unencrypted"
	SourceSapHanaEnterpriseEncryptionTypeSourceSapHanaEnterpriseNativeNetworkEncryptionNNE    SourceSapHanaEnterpriseEncryptionType = "source-sap-hana-enterprise_Native Network Encryption (NNE)"
	SourceSapHanaEnterpriseEncryptionTypeSourceSapHanaEnterpriseTLSEncryptedVerifyCertificate SourceSapHanaEnterpriseEncryptionType = "source-sap-hana-enterprise_TLS Encrypted (verify certificate)"
)

// SourceSapHanaEnterpriseEncryption - The encryption method with is used when communicating with the database.
type SourceSapHanaEnterpriseEncryption struct {
	SourceSapHanaEnterpriseUnencrypted                   *SourceSapHanaEnterpriseUnencrypted                   `queryParam:"inline" union:"member"`
	SourceSapHanaEnterpriseNativeNetworkEncryptionNNE    *SourceSapHanaEnterpriseNativeNetworkEncryptionNNE    `queryParam:"inline" union:"member"`
	SourceSapHanaEnterpriseTLSEncryptedVerifyCertificate *SourceSapHanaEnterpriseTLSEncryptedVerifyCertificate `queryParam:"inline" union:"member"`

	Type SourceSapHanaEnterpriseEncryptionType
}

func CreateSourceSapHanaEnterpriseEncryptionSourceSapHanaEnterpriseUnencrypted(sourceSapHanaEnterpriseUnencrypted SourceSapHanaEnterpriseUnencrypted) SourceSapHanaEnterpriseEncryption {
	typ := SourceSapHanaEnterpriseEncryptionTypeSourceSapHanaEnterpriseUnencrypted

	return SourceSapHanaEnterpriseEncryption{
		SourceSapHanaEnterpriseUnencrypted: &sourceSapHanaEnterpriseUnencrypted,
		Type:                               typ,
	}
}

func CreateSourceSapHanaEnterpriseEncryptionSourceSapHanaEnterpriseNativeNetworkEncryptionNNE(sourceSapHanaEnterpriseNativeNetworkEncryptionNNE SourceSapHanaEnterpriseNativeNetworkEncryptionNNE) SourceSapHanaEnterpriseEncryption {
	typ := SourceSapHanaEnterpriseEncryptionTypeSourceSapHanaEnterpriseNativeNetworkEncryptionNNE

	return SourceSapHanaEnterpriseEncryption{
		SourceSapHanaEnterpriseNativeNetworkEncryptionNNE: &sourceSapHanaEnterpriseNativeNetworkEncryptionNNE,
		Type: typ,
	}
}

func CreateSourceSapHanaEnterpriseEncryptionSourceSapHanaEnterpriseTLSEncryptedVerifyCertificate(sourceSapHanaEnterpriseTLSEncryptedVerifyCertificate SourceSapHanaEnterpriseTLSEncryptedVerifyCertificate) SourceSapHanaEnterpriseEncryption {
	typ := SourceSapHanaEnterpriseEncryptionTypeSourceSapHanaEnterpriseTLSEncryptedVerifyCertificate

	return SourceSapHanaEnterpriseEncryption{
		SourceSapHanaEnterpriseTLSEncryptedVerifyCertificate: &sourceSapHanaEnterpriseTLSEncryptedVerifyCertificate,
		Type: typ,
	}
}

func (u *SourceSapHanaEnterpriseEncryption) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var sourceSapHanaEnterpriseUnencrypted SourceSapHanaEnterpriseUnencrypted = SourceSapHanaEnterpriseUnencrypted{}
	if err := utils.UnmarshalJSON(data, &sourceSapHanaEnterpriseUnencrypted, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceSapHanaEnterpriseEncryptionTypeSourceSapHanaEnterpriseUnencrypted,
			Value: &sourceSapHanaEnterpriseUnencrypted,
		})
	}

	var sourceSapHanaEnterpriseNativeNetworkEncryptionNNE SourceSapHanaEnterpriseNativeNetworkEncryptionNNE = SourceSapHanaEnterpriseNativeNetworkEncryptionNNE{}
	if err := utils.UnmarshalJSON(data, &sourceSapHanaEnterpriseNativeNetworkEncryptionNNE, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceSapHanaEnterpriseEncryptionTypeSourceSapHanaEnterpriseNativeNetworkEncryptionNNE,
			Value: &sourceSapHanaEnterpriseNativeNetworkEncryptionNNE,
		})
	}

	var sourceSapHanaEnterpriseTLSEncryptedVerifyCertificate SourceSapHanaEnterpriseTLSEncryptedVerifyCertificate = SourceSapHanaEnterpriseTLSEncryptedVerifyCertificate{}
	if err := utils.UnmarshalJSON(data, &sourceSapHanaEnterpriseTLSEncryptedVerifyCertificate, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceSapHanaEnterpriseEncryptionTypeSourceSapHanaEnterpriseTLSEncryptedVerifyCertificate,
			Value: &sourceSapHanaEnterpriseTLSEncryptedVerifyCertificate,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceSapHanaEnterpriseEncryption", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceSapHanaEnterpriseEncryption", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceSapHanaEnterpriseEncryptionType)
	switch best.Type {
	case SourceSapHanaEnterpriseEncryptionTypeSourceSapHanaEnterpriseUnencrypted:
		u.SourceSapHanaEnterpriseUnencrypted = best.Value.(*SourceSapHanaEnterpriseUnencrypted)
		return nil
	case SourceSapHanaEnterpriseEncryptionTypeSourceSapHanaEnterpriseNativeNetworkEncryptionNNE:
		u.SourceSapHanaEnterpriseNativeNetworkEncryptionNNE = best.Value.(*SourceSapHanaEnterpriseNativeNetworkEncryptionNNE)
		return nil
	case SourceSapHanaEnterpriseEncryptionTypeSourceSapHanaEnterpriseTLSEncryptedVerifyCertificate:
		u.SourceSapHanaEnterpriseTLSEncryptedVerifyCertificate = best.Value.(*SourceSapHanaEnterpriseTLSEncryptedVerifyCertificate)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceSapHanaEnterpriseEncryption", string(data))
}

func (u SourceSapHanaEnterpriseEncryption) MarshalJSON() ([]byte, error) {
	if u.SourceSapHanaEnterpriseUnencrypted != nil {
		return utils.MarshalJSON(u.SourceSapHanaEnterpriseUnencrypted, "", true)
	}

	if u.SourceSapHanaEnterpriseNativeNetworkEncryptionNNE != nil {
		return utils.MarshalJSON(u.SourceSapHanaEnterpriseNativeNetworkEncryptionNNE, "", true)
	}

	if u.SourceSapHanaEnterpriseTLSEncryptedVerifyCertificate != nil {
		return utils.MarshalJSON(u.SourceSapHanaEnterpriseTLSEncryptedVerifyCertificate, "", true)
	}

	return nil, errors.New("could not marshal union type SourceSapHanaEnterpriseEncryption: all fields are null")
}

// SourceSapHanaEnterpriseTableFilter - Inclusion filter configuration for table selection per schema.
type SourceSapHanaEnterpriseTableFilter struct {
	// The name of the schema to apply this filter to. Should match a schema defined in "Schemas" field above.
	SchemaName string `json:"schema_name"`
	// List of table name patterns to include from this schema. Each filter should be a SQL LIKE pattern.
	TableNamePatterns    []string `json:"table_name_patterns"`
	AdditionalProperties any      `additionalProperties:"true" json:"-"`
}

func (s SourceSapHanaEnterpriseTableFilter) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceSapHanaEnterpriseTableFilter) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceSapHanaEnterpriseTableFilter) GetSchemaName() string {
	if s == nil {
		return ""
	}
	return s.SchemaName
}

func (s *SourceSapHanaEnterpriseTableFilter) GetTableNamePatterns() []string {
	if s == nil {
		return []string{}
	}
	return s.TableNamePatterns
}

func (s *SourceSapHanaEnterpriseTableFilter) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceSapHanaEnterpriseSchemasTunnelMethodTunnelMethod string

const (
	SourceSapHanaEnterpriseSchemasTunnelMethodTunnelMethodSSHPasswordAuth SourceSapHanaEnterpriseSchemasTunnelMethodTunnelMethod = "SSH_PASSWORD_AUTH"
)

func (e SourceSapHanaEnterpriseSchemasTunnelMethodTunnelMethod) ToPointer() *SourceSapHanaEnterpriseSchemasTunnelMethodTunnelMethod {
	return &e
}
func (e *SourceSapHanaEnterpriseSchemasTunnelMethodTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_PASSWORD_AUTH":
		*e = SourceSapHanaEnterpriseSchemasTunnelMethodTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceSapHanaEnterpriseSchemasTunnelMethodTunnelMethod: %v", v)
	}
}

// SourceSapHanaEnterprisePasswordAuthentication - Connect through a jump server tunnel host using username and password authentication
type SourceSapHanaEnterprisePasswordAuthentication struct {
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost   string                                                  `json:"tunnel_host"`
	TunnelMethod *SourceSapHanaEnterpriseSchemasTunnelMethodTunnelMethod `default:"SSH_PASSWORD_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser string `json:"tunnel_user"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword   string `json:"tunnel_user_password"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (s SourceSapHanaEnterprisePasswordAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceSapHanaEnterprisePasswordAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceSapHanaEnterprisePasswordAuthentication) GetTunnelHost() string {
	if s == nil {
		return ""
	}
	return s.TunnelHost
}

func (s *SourceSapHanaEnterprisePasswordAuthentication) GetTunnelMethod() *SourceSapHanaEnterpriseSchemasTunnelMethodTunnelMethod {
	if s == nil {
		return nil
	}
	return s.TunnelMethod
}

func (s *SourceSapHanaEnterprisePasswordAuthentication) GetTunnelPort() *int64 {
	if s == nil {
		return nil
	}
	return s.TunnelPort
}

func (s *SourceSapHanaEnterprisePasswordAuthentication) GetTunnelUser() string {
	if s == nil {
		return ""
	}
	return s.TunnelUser
}

func (s *SourceSapHanaEnterprisePasswordAuthentication) GetTunnelUserPassword() string {
	if s == nil {
		return ""
	}
	return s.TunnelUserPassword
}

func (s *SourceSapHanaEnterprisePasswordAuthentication) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceSapHanaEnterpriseSchemasTunnelMethod string

const (
	SourceSapHanaEnterpriseSchemasTunnelMethodSSHKeyAuth SourceSapHanaEnterpriseSchemasTunnelMethod = "SSH_KEY_AUTH"
)

func (e SourceSapHanaEnterpriseSchemasTunnelMethod) ToPointer() *SourceSapHanaEnterpriseSchemasTunnelMethod {
	return &e
}
func (e *SourceSapHanaEnterpriseSchemasTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_KEY_AUTH":
		*e = SourceSapHanaEnterpriseSchemasTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceSapHanaEnterpriseSchemasTunnelMethod: %v", v)
	}
}

// SourceSapHanaEnterpriseSSHKeyAuthentication - Connect through a jump server tunnel host using username and ssh key
type SourceSapHanaEnterpriseSSHKeyAuthentication struct {
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey string `json:"ssh_key"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost   string                                      `json:"tunnel_host"`
	TunnelMethod *SourceSapHanaEnterpriseSchemasTunnelMethod `default:"SSH_KEY_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser           string `json:"tunnel_user"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (s SourceSapHanaEnterpriseSSHKeyAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceSapHanaEnterpriseSSHKeyAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceSapHanaEnterpriseSSHKeyAuthentication) GetSSHKey() string {
	if s == nil {
		return ""
	}
	return s.SSHKey
}

func (s *SourceSapHanaEnterpriseSSHKeyAuthentication) GetTunnelHost() string {
	if s == nil {
		return ""
	}
	return s.TunnelHost
}

func (s *SourceSapHanaEnterpriseSSHKeyAuthentication) GetTunnelMethod() *SourceSapHanaEnterpriseSchemasTunnelMethod {
	if s == nil {
		return nil
	}
	return s.TunnelMethod
}

func (s *SourceSapHanaEnterpriseSSHKeyAuthentication) GetTunnelPort() *int64 {
	if s == nil {
		return nil
	}
	return s.TunnelPort
}

func (s *SourceSapHanaEnterpriseSSHKeyAuthentication) GetTunnelUser() string {
	if s == nil {
		return ""
	}
	return s.TunnelUser
}

func (s *SourceSapHanaEnterpriseSSHKeyAuthentication) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceSapHanaEnterpriseTunnelMethod string

const (
	SourceSapHanaEnterpriseTunnelMethodNoTunnel SourceSapHanaEnterpriseTunnelMethod = "NO_TUNNEL"
)

func (e SourceSapHanaEnterpriseTunnelMethod) ToPointer() *SourceSapHanaEnterpriseTunnelMethod {
	return &e
}
func (e *SourceSapHanaEnterpriseTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NO_TUNNEL":
		*e = SourceSapHanaEnterpriseTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceSapHanaEnterpriseTunnelMethod: %v", v)
	}
}

// SourceSapHanaEnterpriseNoTunnel - No ssh tunnel needed to connect to database
type SourceSapHanaEnterpriseNoTunnel struct {
	TunnelMethod         *SourceSapHanaEnterpriseTunnelMethod `default:"NO_TUNNEL" json:"tunnel_method"`
	AdditionalProperties any                                  `additionalProperties:"true" json:"-"`
}

func (s SourceSapHanaEnterpriseNoTunnel) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceSapHanaEnterpriseNoTunnel) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceSapHanaEnterpriseNoTunnel) GetTunnelMethod() *SourceSapHanaEnterpriseTunnelMethod {
	if s == nil {
		return nil
	}
	return s.TunnelMethod
}

func (s *SourceSapHanaEnterpriseNoTunnel) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceSapHanaEnterpriseSSHTunnelMethodType string

const (
	SourceSapHanaEnterpriseSSHTunnelMethodTypeSourceSapHanaEnterpriseNoTunnel               SourceSapHanaEnterpriseSSHTunnelMethodType = "source-sap-hana-enterprise_No Tunnel"
	SourceSapHanaEnterpriseSSHTunnelMethodTypeSourceSapHanaEnterpriseSSHKeyAuthentication   SourceSapHanaEnterpriseSSHTunnelMethodType = "source-sap-hana-enterprise_SSH Key Authentication"
	SourceSapHanaEnterpriseSSHTunnelMethodTypeSourceSapHanaEnterprisePasswordAuthentication SourceSapHanaEnterpriseSSHTunnelMethodType = "source-sap-hana-enterprise_Password Authentication"
)

// SourceSapHanaEnterpriseSSHTunnelMethod - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourceSapHanaEnterpriseSSHTunnelMethod struct {
	SourceSapHanaEnterpriseNoTunnel               *SourceSapHanaEnterpriseNoTunnel               `queryParam:"inline" union:"member"`
	SourceSapHanaEnterpriseSSHKeyAuthentication   *SourceSapHanaEnterpriseSSHKeyAuthentication   `queryParam:"inline" union:"member"`
	SourceSapHanaEnterprisePasswordAuthentication *SourceSapHanaEnterprisePasswordAuthentication `queryParam:"inline" union:"member"`

	Type SourceSapHanaEnterpriseSSHTunnelMethodType
}

func CreateSourceSapHanaEnterpriseSSHTunnelMethodSourceSapHanaEnterpriseNoTunnel(sourceSapHanaEnterpriseNoTunnel SourceSapHanaEnterpriseNoTunnel) SourceSapHanaEnterpriseSSHTunnelMethod {
	typ := SourceSapHanaEnterpriseSSHTunnelMethodTypeSourceSapHanaEnterpriseNoTunnel

	return SourceSapHanaEnterpriseSSHTunnelMethod{
		SourceSapHanaEnterpriseNoTunnel: &sourceSapHanaEnterpriseNoTunnel,
		Type:                            typ,
	}
}

func CreateSourceSapHanaEnterpriseSSHTunnelMethodSourceSapHanaEnterpriseSSHKeyAuthentication(sourceSapHanaEnterpriseSSHKeyAuthentication SourceSapHanaEnterpriseSSHKeyAuthentication) SourceSapHanaEnterpriseSSHTunnelMethod {
	typ := SourceSapHanaEnterpriseSSHTunnelMethodTypeSourceSapHanaEnterpriseSSHKeyAuthentication

	return SourceSapHanaEnterpriseSSHTunnelMethod{
		SourceSapHanaEnterpriseSSHKeyAuthentication: &sourceSapHanaEnterpriseSSHKeyAuthentication,
		Type: typ,
	}
}

func CreateSourceSapHanaEnterpriseSSHTunnelMethodSourceSapHanaEnterprisePasswordAuthentication(sourceSapHanaEnterprisePasswordAuthentication SourceSapHanaEnterprisePasswordAuthentication) SourceSapHanaEnterpriseSSHTunnelMethod {
	typ := SourceSapHanaEnterpriseSSHTunnelMethodTypeSourceSapHanaEnterprisePasswordAuthentication

	return SourceSapHanaEnterpriseSSHTunnelMethod{
		SourceSapHanaEnterprisePasswordAuthentication: &sourceSapHanaEnterprisePasswordAuthentication,
		Type: typ,
	}
}

func (u *SourceSapHanaEnterpriseSSHTunnelMethod) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var sourceSapHanaEnterpriseNoTunnel SourceSapHanaEnterpriseNoTunnel = SourceSapHanaEnterpriseNoTunnel{}
	if err := utils.UnmarshalJSON(data, &sourceSapHanaEnterpriseNoTunnel, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceSapHanaEnterpriseSSHTunnelMethodTypeSourceSapHanaEnterpriseNoTunnel,
			Value: &sourceSapHanaEnterpriseNoTunnel,
		})
	}

	var sourceSapHanaEnterpriseSSHKeyAuthentication SourceSapHanaEnterpriseSSHKeyAuthentication = SourceSapHanaEnterpriseSSHKeyAuthentication{}
	if err := utils.UnmarshalJSON(data, &sourceSapHanaEnterpriseSSHKeyAuthentication, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceSapHanaEnterpriseSSHTunnelMethodTypeSourceSapHanaEnterpriseSSHKeyAuthentication,
			Value: &sourceSapHanaEnterpriseSSHKeyAuthentication,
		})
	}

	var sourceSapHanaEnterprisePasswordAuthentication SourceSapHanaEnterprisePasswordAuthentication = SourceSapHanaEnterprisePasswordAuthentication{}
	if err := utils.UnmarshalJSON(data, &sourceSapHanaEnterprisePasswordAuthentication, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceSapHanaEnterpriseSSHTunnelMethodTypeSourceSapHanaEnterprisePasswordAuthentication,
			Value: &sourceSapHanaEnterprisePasswordAuthentication,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceSapHanaEnterpriseSSHTunnelMethod", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceSapHanaEnterpriseSSHTunnelMethod", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceSapHanaEnterpriseSSHTunnelMethodType)
	switch best.Type {
	case SourceSapHanaEnterpriseSSHTunnelMethodTypeSourceSapHanaEnterpriseNoTunnel:
		u.SourceSapHanaEnterpriseNoTunnel = best.Value.(*SourceSapHanaEnterpriseNoTunnel)
		return nil
	case SourceSapHanaEnterpriseSSHTunnelMethodTypeSourceSapHanaEnterpriseSSHKeyAuthentication:
		u.SourceSapHanaEnterpriseSSHKeyAuthentication = best.Value.(*SourceSapHanaEnterpriseSSHKeyAuthentication)
		return nil
	case SourceSapHanaEnterpriseSSHTunnelMethodTypeSourceSapHanaEnterprisePasswordAuthentication:
		u.SourceSapHanaEnterprisePasswordAuthentication = best.Value.(*SourceSapHanaEnterprisePasswordAuthentication)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceSapHanaEnterpriseSSHTunnelMethod", string(data))
}

func (u SourceSapHanaEnterpriseSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.SourceSapHanaEnterpriseNoTunnel != nil {
		return utils.MarshalJSON(u.SourceSapHanaEnterpriseNoTunnel, "", true)
	}

	if u.SourceSapHanaEnterpriseSSHKeyAuthentication != nil {
		return utils.MarshalJSON(u.SourceSapHanaEnterpriseSSHKeyAuthentication, "", true)
	}

	if u.SourceSapHanaEnterprisePasswordAuthentication != nil {
		return utils.MarshalJSON(u.SourceSapHanaEnterprisePasswordAuthentication, "", true)
	}

	return nil, errors.New("could not marshal union type SourceSapHanaEnterpriseSSHTunnelMethod: all fields are null")
}

type SourceSapHanaEnterpriseSourceType string

const (
	SourceSapHanaEnterpriseSourceTypeSapHanaEnterprise SourceSapHanaEnterpriseSourceType = "sap-hana-enterprise"
)

func (e SourceSapHanaEnterpriseSourceType) ToPointer() *SourceSapHanaEnterpriseSourceType {
	return &e
}
func (e *SourceSapHanaEnterpriseSourceType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "sap-hana-enterprise":
		*e = SourceSapHanaEnterpriseSourceType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceSapHanaEnterpriseSourceType: %v", v)
	}
}

type SourceSapHanaEnterprise struct {
	// When this feature is enabled, during schema discovery the connector will query each table or view individually to check access privileges and inaccessible tables, views, or columns therein will be removed. In large schemas, this might cause schema discovery to take too long, in which case it might be advisable to disable this feature.
	CheckPrivileges *bool `default:"true" json:"check_privileges"`
	// How often (in seconds) a stream should checkpoint, when possible.
	CheckpointTargetIntervalSeconds *int64 `default:"300" json:"checkpoint_target_interval_seconds"`
	// Maximum number of concurrent queries to the database.
	Concurrency *int64 `default:"1" json:"concurrency"`
	// Configures how data is extracted from the database.
	Cursor SourceSapHanaEnterpriseUpdateMethod `json:"cursor"`
	// The name of the tenant database to connect to. This is required for multi-tenant SAP HANA systems. For single-tenant systems, this can be left empty.
	Database *string `json:"database,omitempty"`
	// The encryption method with is used when communicating with the database.
	Encryption SourceSapHanaEnterpriseEncryption `json:"encryption"`
	// Inclusion filters for table selection per schema. If no filters are specified for a schema, all tables in that schema will be synced.
	Filters []SourceSapHanaEnterpriseTableFilter `json:"filters,omitempty"`
	// Hostname of the database.
	Host string `json:"host"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// The password associated with the username.
	Password *string `json:"password,omitempty"`
	// Port of the database. SAP recommends the following port numbers: 443 - Default listening port for SAP HANA Cloud client connections to the listener.
	Port *int64 `default:"443" json:"port"`
	// The list of schemas to sync from. Defaults to user. Case sensitive.
	Schemas []string `json:"schemas,omitempty"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod SourceSapHanaEnterpriseSSHTunnelMethod `json:"tunnel_method"`
	// The username which is used to access the database.
	Username             string                             `json:"username"`
	sourceType           *SourceSapHanaEnterpriseSourceType `const:"sap-hana-enterprise" json:"sourceType"`
	AdditionalProperties any                                `additionalProperties:"true" json:"-"`
}

func (s SourceSapHanaEnterprise) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceSapHanaEnterprise) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceSapHanaEnterprise) GetCheckPrivileges() *bool {
	if s == nil {
		return nil
	}
	return s.CheckPrivileges
}

func (s *SourceSapHanaEnterprise) GetCheckpointTargetIntervalSeconds() *int64 {
	if s == nil {
		return nil
	}
	return s.CheckpointTargetIntervalSeconds
}

func (s *SourceSapHanaEnterprise) GetConcurrency() *int64 {
	if s == nil {
		return nil
	}
	return s.Concurrency
}

func (s *SourceSapHanaEnterprise) GetCursor() SourceSapHanaEnterpriseUpdateMethod {
	if s == nil {
		return SourceSapHanaEnterpriseUpdateMethod{}
	}
	return s.Cursor
}

func (s *SourceSapHanaEnterprise) GetDatabase() *string {
	if s == nil {
		return nil
	}
	return s.Database
}

func (s *SourceSapHanaEnterprise) GetEncryption() SourceSapHanaEnterpriseEncryption {
	if s == nil {
		return SourceSapHanaEnterpriseEncryption{}
	}
	return s.Encryption
}

func (s *SourceSapHanaEnterprise) GetFilters() []SourceSapHanaEnterpriseTableFilter {
	if s == nil {
		return nil
	}
	return s.Filters
}

func (s *SourceSapHanaEnterprise) GetHost() string {
	if s == nil {
		return ""
	}
	return s.Host
}

func (s *SourceSapHanaEnterprise) GetJdbcURLParams() *string {
	if s == nil {
		return nil
	}
	return s.JdbcURLParams
}

func (s *SourceSapHanaEnterprise) GetPassword() *string {
	if s == nil {
		return nil
	}
	return s.Password
}

func (s *SourceSapHanaEnterprise) GetPort() *int64 {
	if s == nil {
		return nil
	}
	return s.Port
}

func (s *SourceSapHanaEnterprise) GetSchemas() []string {
	if s == nil {
		return nil
	}
	return s.Schemas
}

func (s *SourceSapHanaEnterprise) GetTunnelMethod() SourceSapHanaEnterpriseSSHTunnelMethod {
	if s == nil {
		return SourceSapHanaEnterpriseSSHTunnelMethod{}
	}
	return s.TunnelMethod
}

func (s *SourceSapHanaEnterprise) GetUsername() string {
	if s == nil {
		return ""
	}
	return s.Username
}

func (s *SourceSapHanaEnterprise) GetSourceType() *SourceSapHanaEnterpriseSourceType {
	return SourceSapHanaEnterpriseSourceTypeSapHanaEnterprise.ToPointer()
}

func (s *SourceSapHanaEnterprise) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}
