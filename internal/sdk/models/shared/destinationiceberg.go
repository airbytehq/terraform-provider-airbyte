// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

type DestinationIcebergSchemasCatalogConfigIcebergCatalogConfig5CatalogType string

const (
	DestinationIcebergSchemasCatalogConfigIcebergCatalogConfig5CatalogTypeGlue DestinationIcebergSchemasCatalogConfigIcebergCatalogConfig5CatalogType = "Glue"
)

func (e DestinationIcebergSchemasCatalogConfigIcebergCatalogConfig5CatalogType) ToPointer() *DestinationIcebergSchemasCatalogConfigIcebergCatalogConfig5CatalogType {
	return &e
}
func (e *DestinationIcebergSchemasCatalogConfigIcebergCatalogConfig5CatalogType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Glue":
		*e = DestinationIcebergSchemasCatalogConfigIcebergCatalogConfig5CatalogType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationIcebergSchemasCatalogConfigIcebergCatalogConfig5CatalogType: %v", v)
	}
}

// DestinationIcebergGlueCatalog - The GlueCatalog connects to a AWS Glue Catalog
type DestinationIcebergGlueCatalog struct {
	CatalogType *DestinationIcebergSchemasCatalogConfigIcebergCatalogConfig5CatalogType `default:"Glue" json:"catalog_type"`
	// The default schema tables are written to if the source does not specify a namespace. The usual value for this field is "public".
	Database *string `default:"public" json:"database"`
}

func (d DestinationIcebergGlueCatalog) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationIcebergGlueCatalog) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationIcebergGlueCatalog) GetCatalogType() *DestinationIcebergSchemasCatalogConfigIcebergCatalogConfig5CatalogType {
	if o == nil {
		return nil
	}
	return o.CatalogType
}

func (o *DestinationIcebergGlueCatalog) GetDatabase() *string {
	if o == nil {
		return nil
	}
	return o.Database
}

type DestinationIcebergSchemasCatalogConfigIcebergCatalogConfigCatalogType string

const (
	DestinationIcebergSchemasCatalogConfigIcebergCatalogConfigCatalogTypeRest DestinationIcebergSchemasCatalogConfigIcebergCatalogConfigCatalogType = "Rest"
)

func (e DestinationIcebergSchemasCatalogConfigIcebergCatalogConfigCatalogType) ToPointer() *DestinationIcebergSchemasCatalogConfigIcebergCatalogConfigCatalogType {
	return &e
}
func (e *DestinationIcebergSchemasCatalogConfigIcebergCatalogConfigCatalogType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Rest":
		*e = DestinationIcebergSchemasCatalogConfigIcebergCatalogConfigCatalogType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationIcebergSchemasCatalogConfigIcebergCatalogConfigCatalogType: %v", v)
	}
}

// DestinationIcebergRESTCatalog - The RESTCatalog connects to a REST server at the specified URI
type DestinationIcebergRESTCatalog struct {
	CatalogType    *DestinationIcebergSchemasCatalogConfigIcebergCatalogConfigCatalogType `default:"Rest" json:"catalog_type"`
	RestCredential *string                                                                `json:"rest_credential,omitempty"`
	RestToken      *string                                                                `json:"rest_token,omitempty"`
	RestURI        string                                                                 `json:"rest_uri"`
}

func (d DestinationIcebergRESTCatalog) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationIcebergRESTCatalog) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationIcebergRESTCatalog) GetCatalogType() *DestinationIcebergSchemasCatalogConfigIcebergCatalogConfigCatalogType {
	if o == nil {
		return nil
	}
	return o.CatalogType
}

func (o *DestinationIcebergRESTCatalog) GetRestCredential() *string {
	if o == nil {
		return nil
	}
	return o.RestCredential
}

func (o *DestinationIcebergRESTCatalog) GetRestToken() *string {
	if o == nil {
		return nil
	}
	return o.RestToken
}

func (o *DestinationIcebergRESTCatalog) GetRestURI() string {
	if o == nil {
		return ""
	}
	return o.RestURI
}

type DestinationIcebergSchemasCatalogConfigCatalogType string

const (
	DestinationIcebergSchemasCatalogConfigCatalogTypeJdbc DestinationIcebergSchemasCatalogConfigCatalogType = "Jdbc"
)

func (e DestinationIcebergSchemasCatalogConfigCatalogType) ToPointer() *DestinationIcebergSchemasCatalogConfigCatalogType {
	return &e
}
func (e *DestinationIcebergSchemasCatalogConfigCatalogType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Jdbc":
		*e = DestinationIcebergSchemasCatalogConfigCatalogType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationIcebergSchemasCatalogConfigCatalogType: %v", v)
	}
}

// DestinationIcebergJdbcCatalogUseRelationalDatabase - Using a table in a relational database to manage Iceberg tables through JDBC. Read more <a href="https://iceberg.apache.org/docs/latest/jdbc/">here</a>. Supporting: PostgreSQL
type DestinationIcebergJdbcCatalogUseRelationalDatabase struct {
	// Iceberg catalog metadata tables are written to catalog schema. The usual value for this field is "public".
	CatalogSchema *string                                            `default:"public" json:"catalog_schema"`
	CatalogType   *DestinationIcebergSchemasCatalogConfigCatalogType `default:"Jdbc" json:"catalog_type"`
	// The default schema tables are written to if the source does not specify a namespace. The usual value for this field is "public".
	Database *string `default:"public" json:"database"`
	JdbcURL  *string `json:"jdbc_url,omitempty"`
	// Password associated with the username.
	Password *string `json:"password,omitempty"`
	// Encrypt data using SSL. When activating SSL, please select one of the connection modes.
	Ssl *bool `default:"false" json:"ssl"`
	// Username to use to access the database.
	Username *string `json:"username,omitempty"`
}

func (d DestinationIcebergJdbcCatalogUseRelationalDatabase) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationIcebergJdbcCatalogUseRelationalDatabase) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationIcebergJdbcCatalogUseRelationalDatabase) GetCatalogSchema() *string {
	if o == nil {
		return nil
	}
	return o.CatalogSchema
}

func (o *DestinationIcebergJdbcCatalogUseRelationalDatabase) GetCatalogType() *DestinationIcebergSchemasCatalogConfigCatalogType {
	if o == nil {
		return nil
	}
	return o.CatalogType
}

func (o *DestinationIcebergJdbcCatalogUseRelationalDatabase) GetDatabase() *string {
	if o == nil {
		return nil
	}
	return o.Database
}

func (o *DestinationIcebergJdbcCatalogUseRelationalDatabase) GetJdbcURL() *string {
	if o == nil {
		return nil
	}
	return o.JdbcURL
}

func (o *DestinationIcebergJdbcCatalogUseRelationalDatabase) GetPassword() *string {
	if o == nil {
		return nil
	}
	return o.Password
}

func (o *DestinationIcebergJdbcCatalogUseRelationalDatabase) GetSsl() *bool {
	if o == nil {
		return nil
	}
	return o.Ssl
}

func (o *DestinationIcebergJdbcCatalogUseRelationalDatabase) GetUsername() *string {
	if o == nil {
		return nil
	}
	return o.Username
}

type DestinationIcebergSchemasCatalogType string

const (
	DestinationIcebergSchemasCatalogTypeHadoop DestinationIcebergSchemasCatalogType = "Hadoop"
)

func (e DestinationIcebergSchemasCatalogType) ToPointer() *DestinationIcebergSchemasCatalogType {
	return &e
}
func (e *DestinationIcebergSchemasCatalogType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Hadoop":
		*e = DestinationIcebergSchemasCatalogType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationIcebergSchemasCatalogType: %v", v)
	}
}

// DestinationIcebergHadoopCatalogUseHierarchicalFileSystemsAsSameAsStorageConfig - A Hadoop catalog doesnâ€™t need to connect to a Hive MetaStore, but can only be used with HDFS or similar file systems that support atomic rename.
type DestinationIcebergHadoopCatalogUseHierarchicalFileSystemsAsSameAsStorageConfig struct {
	CatalogType *DestinationIcebergSchemasCatalogType `default:"Hadoop" json:"catalog_type"`
	// The default database tables are written to if the source does not specify a namespace. The usual value for this field is "default".
	Database *string `default:"default" json:"database"`
}

func (d DestinationIcebergHadoopCatalogUseHierarchicalFileSystemsAsSameAsStorageConfig) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationIcebergHadoopCatalogUseHierarchicalFileSystemsAsSameAsStorageConfig) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationIcebergHadoopCatalogUseHierarchicalFileSystemsAsSameAsStorageConfig) GetCatalogType() *DestinationIcebergSchemasCatalogType {
	if o == nil {
		return nil
	}
	return o.CatalogType
}

func (o *DestinationIcebergHadoopCatalogUseHierarchicalFileSystemsAsSameAsStorageConfig) GetDatabase() *string {
	if o == nil {
		return nil
	}
	return o.Database
}

type DestinationIcebergCatalogType string

const (
	DestinationIcebergCatalogTypeHive DestinationIcebergCatalogType = "Hive"
)

func (e DestinationIcebergCatalogType) ToPointer() *DestinationIcebergCatalogType {
	return &e
}
func (e *DestinationIcebergCatalogType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Hive":
		*e = DestinationIcebergCatalogType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationIcebergCatalogType: %v", v)
	}
}

type DestinationIcebergHiveCatalogUseApacheHiveMetaStore struct {
	CatalogType *DestinationIcebergCatalogType `default:"Hive" json:"catalog_type"`
	// The default database tables are written to if the source does not specify a namespace. The usual value for this field is "default".
	Database *string `default:"default" json:"database"`
	// Hive MetaStore thrift server uri of iceberg catalog.
	HiveThriftURI string `json:"hive_thrift_uri"`
}

func (d DestinationIcebergHiveCatalogUseApacheHiveMetaStore) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationIcebergHiveCatalogUseApacheHiveMetaStore) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationIcebergHiveCatalogUseApacheHiveMetaStore) GetCatalogType() *DestinationIcebergCatalogType {
	if o == nil {
		return nil
	}
	return o.CatalogType
}

func (o *DestinationIcebergHiveCatalogUseApacheHiveMetaStore) GetDatabase() *string {
	if o == nil {
		return nil
	}
	return o.Database
}

func (o *DestinationIcebergHiveCatalogUseApacheHiveMetaStore) GetHiveThriftURI() string {
	if o == nil {
		return ""
	}
	return o.HiveThriftURI
}

type DestinationIcebergIcebergCatalogConfigType string

const (
	DestinationIcebergIcebergCatalogConfigTypeDestinationIcebergHiveCatalogUseApacheHiveMetaStore                            DestinationIcebergIcebergCatalogConfigType = "destination-iceberg_HiveCatalog: Use Apache Hive MetaStore"
	DestinationIcebergIcebergCatalogConfigTypeDestinationIcebergHadoopCatalogUseHierarchicalFileSystemsAsSameAsStorageConfig DestinationIcebergIcebergCatalogConfigType = "destination-iceberg_HadoopCatalog: Use hierarchical file systems as same as storage config"
	DestinationIcebergIcebergCatalogConfigTypeDestinationIcebergJdbcCatalogUseRelationalDatabase                             DestinationIcebergIcebergCatalogConfigType = "destination-iceberg_JdbcCatalog: Use relational database"
	DestinationIcebergIcebergCatalogConfigTypeDestinationIcebergRESTCatalog                                                  DestinationIcebergIcebergCatalogConfigType = "destination-iceberg_RESTCatalog"
	DestinationIcebergIcebergCatalogConfigTypeDestinationIcebergGlueCatalog                                                  DestinationIcebergIcebergCatalogConfigType = "destination-iceberg_GlueCatalog"
)

// DestinationIcebergIcebergCatalogConfig - Catalog config of Iceberg.
type DestinationIcebergIcebergCatalogConfig struct {
	DestinationIcebergHiveCatalogUseApacheHiveMetaStore                            *DestinationIcebergHiveCatalogUseApacheHiveMetaStore
	DestinationIcebergHadoopCatalogUseHierarchicalFileSystemsAsSameAsStorageConfig *DestinationIcebergHadoopCatalogUseHierarchicalFileSystemsAsSameAsStorageConfig
	DestinationIcebergJdbcCatalogUseRelationalDatabase                             *DestinationIcebergJdbcCatalogUseRelationalDatabase
	DestinationIcebergRESTCatalog                                                  *DestinationIcebergRESTCatalog
	DestinationIcebergGlueCatalog                                                  *DestinationIcebergGlueCatalog

	Type DestinationIcebergIcebergCatalogConfigType
}

func CreateDestinationIcebergIcebergCatalogConfigDestinationIcebergHiveCatalogUseApacheHiveMetaStore(destinationIcebergHiveCatalogUseApacheHiveMetaStore DestinationIcebergHiveCatalogUseApacheHiveMetaStore) DestinationIcebergIcebergCatalogConfig {
	typ := DestinationIcebergIcebergCatalogConfigTypeDestinationIcebergHiveCatalogUseApacheHiveMetaStore

	return DestinationIcebergIcebergCatalogConfig{
		DestinationIcebergHiveCatalogUseApacheHiveMetaStore: &destinationIcebergHiveCatalogUseApacheHiveMetaStore,
		Type: typ,
	}
}

func CreateDestinationIcebergIcebergCatalogConfigDestinationIcebergHadoopCatalogUseHierarchicalFileSystemsAsSameAsStorageConfig(destinationIcebergHadoopCatalogUseHierarchicalFileSystemsAsSameAsStorageConfig DestinationIcebergHadoopCatalogUseHierarchicalFileSystemsAsSameAsStorageConfig) DestinationIcebergIcebergCatalogConfig {
	typ := DestinationIcebergIcebergCatalogConfigTypeDestinationIcebergHadoopCatalogUseHierarchicalFileSystemsAsSameAsStorageConfig

	return DestinationIcebergIcebergCatalogConfig{
		DestinationIcebergHadoopCatalogUseHierarchicalFileSystemsAsSameAsStorageConfig: &destinationIcebergHadoopCatalogUseHierarchicalFileSystemsAsSameAsStorageConfig,
		Type: typ,
	}
}

func CreateDestinationIcebergIcebergCatalogConfigDestinationIcebergJdbcCatalogUseRelationalDatabase(destinationIcebergJdbcCatalogUseRelationalDatabase DestinationIcebergJdbcCatalogUseRelationalDatabase) DestinationIcebergIcebergCatalogConfig {
	typ := DestinationIcebergIcebergCatalogConfigTypeDestinationIcebergJdbcCatalogUseRelationalDatabase

	return DestinationIcebergIcebergCatalogConfig{
		DestinationIcebergJdbcCatalogUseRelationalDatabase: &destinationIcebergJdbcCatalogUseRelationalDatabase,
		Type: typ,
	}
}

func CreateDestinationIcebergIcebergCatalogConfigDestinationIcebergRESTCatalog(destinationIcebergRESTCatalog DestinationIcebergRESTCatalog) DestinationIcebergIcebergCatalogConfig {
	typ := DestinationIcebergIcebergCatalogConfigTypeDestinationIcebergRESTCatalog

	return DestinationIcebergIcebergCatalogConfig{
		DestinationIcebergRESTCatalog: &destinationIcebergRESTCatalog,
		Type:                          typ,
	}
}

func CreateDestinationIcebergIcebergCatalogConfigDestinationIcebergGlueCatalog(destinationIcebergGlueCatalog DestinationIcebergGlueCatalog) DestinationIcebergIcebergCatalogConfig {
	typ := DestinationIcebergIcebergCatalogConfigTypeDestinationIcebergGlueCatalog

	return DestinationIcebergIcebergCatalogConfig{
		DestinationIcebergGlueCatalog: &destinationIcebergGlueCatalog,
		Type:                          typ,
	}
}

func (u *DestinationIcebergIcebergCatalogConfig) UnmarshalJSON(data []byte) error {

	var destinationIcebergHadoopCatalogUseHierarchicalFileSystemsAsSameAsStorageConfig DestinationIcebergHadoopCatalogUseHierarchicalFileSystemsAsSameAsStorageConfig = DestinationIcebergHadoopCatalogUseHierarchicalFileSystemsAsSameAsStorageConfig{}
	if err := utils.UnmarshalJSON(data, &destinationIcebergHadoopCatalogUseHierarchicalFileSystemsAsSameAsStorageConfig, "", true, true); err == nil {
		u.DestinationIcebergHadoopCatalogUseHierarchicalFileSystemsAsSameAsStorageConfig = &destinationIcebergHadoopCatalogUseHierarchicalFileSystemsAsSameAsStorageConfig
		u.Type = DestinationIcebergIcebergCatalogConfigTypeDestinationIcebergHadoopCatalogUseHierarchicalFileSystemsAsSameAsStorageConfig
		return nil
	}

	var destinationIcebergGlueCatalog DestinationIcebergGlueCatalog = DestinationIcebergGlueCatalog{}
	if err := utils.UnmarshalJSON(data, &destinationIcebergGlueCatalog, "", true, true); err == nil {
		u.DestinationIcebergGlueCatalog = &destinationIcebergGlueCatalog
		u.Type = DestinationIcebergIcebergCatalogConfigTypeDestinationIcebergGlueCatalog
		return nil
	}

	var destinationIcebergHiveCatalogUseApacheHiveMetaStore DestinationIcebergHiveCatalogUseApacheHiveMetaStore = DestinationIcebergHiveCatalogUseApacheHiveMetaStore{}
	if err := utils.UnmarshalJSON(data, &destinationIcebergHiveCatalogUseApacheHiveMetaStore, "", true, true); err == nil {
		u.DestinationIcebergHiveCatalogUseApacheHiveMetaStore = &destinationIcebergHiveCatalogUseApacheHiveMetaStore
		u.Type = DestinationIcebergIcebergCatalogConfigTypeDestinationIcebergHiveCatalogUseApacheHiveMetaStore
		return nil
	}

	var destinationIcebergRESTCatalog DestinationIcebergRESTCatalog = DestinationIcebergRESTCatalog{}
	if err := utils.UnmarshalJSON(data, &destinationIcebergRESTCatalog, "", true, true); err == nil {
		u.DestinationIcebergRESTCatalog = &destinationIcebergRESTCatalog
		u.Type = DestinationIcebergIcebergCatalogConfigTypeDestinationIcebergRESTCatalog
		return nil
	}

	var destinationIcebergJdbcCatalogUseRelationalDatabase DestinationIcebergJdbcCatalogUseRelationalDatabase = DestinationIcebergJdbcCatalogUseRelationalDatabase{}
	if err := utils.UnmarshalJSON(data, &destinationIcebergJdbcCatalogUseRelationalDatabase, "", true, true); err == nil {
		u.DestinationIcebergJdbcCatalogUseRelationalDatabase = &destinationIcebergJdbcCatalogUseRelationalDatabase
		u.Type = DestinationIcebergIcebergCatalogConfigTypeDestinationIcebergJdbcCatalogUseRelationalDatabase
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationIcebergIcebergCatalogConfig", string(data))
}

func (u DestinationIcebergIcebergCatalogConfig) MarshalJSON() ([]byte, error) {
	if u.DestinationIcebergHiveCatalogUseApacheHiveMetaStore != nil {
		return utils.MarshalJSON(u.DestinationIcebergHiveCatalogUseApacheHiveMetaStore, "", true)
	}

	if u.DestinationIcebergHadoopCatalogUseHierarchicalFileSystemsAsSameAsStorageConfig != nil {
		return utils.MarshalJSON(u.DestinationIcebergHadoopCatalogUseHierarchicalFileSystemsAsSameAsStorageConfig, "", true)
	}

	if u.DestinationIcebergJdbcCatalogUseRelationalDatabase != nil {
		return utils.MarshalJSON(u.DestinationIcebergJdbcCatalogUseRelationalDatabase, "", true)
	}

	if u.DestinationIcebergRESTCatalog != nil {
		return utils.MarshalJSON(u.DestinationIcebergRESTCatalog, "", true)
	}

	if u.DestinationIcebergGlueCatalog != nil {
		return utils.MarshalJSON(u.DestinationIcebergGlueCatalog, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationIcebergIcebergCatalogConfig: all fields are null")
}

type Iceberg string

const (
	IcebergIceberg Iceberg = "iceberg"
)

func (e Iceberg) ToPointer() *Iceberg {
	return &e
}
func (e *Iceberg) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "iceberg":
		*e = Iceberg(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Iceberg: %v", v)
	}
}

type DestinationIcebergFileStorageFormat string

const (
	DestinationIcebergFileStorageFormatParquet DestinationIcebergFileStorageFormat = "Parquet"
	DestinationIcebergFileStorageFormatAvro    DestinationIcebergFileStorageFormat = "Avro"
)

func (e DestinationIcebergFileStorageFormat) ToPointer() *DestinationIcebergFileStorageFormat {
	return &e
}
func (e *DestinationIcebergFileStorageFormat) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Parquet":
		fallthrough
	case "Avro":
		*e = DestinationIcebergFileStorageFormat(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationIcebergFileStorageFormat: %v", v)
	}
}

// DestinationIcebergFileFormat - File format of Iceberg storage.
type DestinationIcebergFileFormat struct {
	// Auto compact data files when stream close
	AutoCompact *bool `default:"false" json:"auto_compact"`
	// Specify the target size of Iceberg data file when performing a compaction action.
	CompactTargetFileSizeInMb *int64 `default:"100" json:"compact_target_file_size_in_mb"`
	// Iceberg data file flush batch size. Incoming rows write to cache firstly; When cache size reaches this 'batch size', flush into real Iceberg data file.
	FlushBatchSize *int64                               `default:"10000" json:"flush_batch_size"`
	Format         *DestinationIcebergFileStorageFormat `default:"Parquet" json:"format"`
}

func (d DestinationIcebergFileFormat) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationIcebergFileFormat) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *DestinationIcebergFileFormat) GetAutoCompact() *bool {
	if o == nil {
		return nil
	}
	return o.AutoCompact
}

func (o *DestinationIcebergFileFormat) GetCompactTargetFileSizeInMb() *int64 {
	if o == nil {
		return nil
	}
	return o.CompactTargetFileSizeInMb
}

func (o *DestinationIcebergFileFormat) GetFlushBatchSize() *int64 {
	if o == nil {
		return nil
	}
	return o.FlushBatchSize
}

func (o *DestinationIcebergFileFormat) GetFormat() *DestinationIcebergFileStorageFormat {
	if o == nil {
		return nil
	}
	return o.Format
}

type DestinationIcebergSchemasStorageType string

const (
	DestinationIcebergSchemasStorageTypeManaged DestinationIcebergSchemasStorageType = "MANAGED"
)

func (e DestinationIcebergSchemasStorageType) ToPointer() *DestinationIcebergSchemasStorageType {
	return &e
}
func (e *DestinationIcebergSchemasStorageType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "MANAGED":
		*e = DestinationIcebergSchemasStorageType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationIcebergSchemasStorageType: %v", v)
	}
}

// DestinationIcebergServerManaged - Server-managed object storage
type DestinationIcebergServerManaged struct {
	// The name of the managed warehouse
	ManagedWarehouseName string                                `json:"managed_warehouse_name"`
	StorageType          *DestinationIcebergSchemasStorageType `default:"MANAGED" json:"storage_type"`
}

func (d DestinationIcebergServerManaged) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationIcebergServerManaged) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationIcebergServerManaged) GetManagedWarehouseName() string {
	if o == nil {
		return ""
	}
	return o.ManagedWarehouseName
}

func (o *DestinationIcebergServerManaged) GetStorageType() *DestinationIcebergSchemasStorageType {
	if o == nil {
		return nil
	}
	return o.StorageType
}

// DestinationIcebergS3BucketRegion - The region of the S3 bucket. See <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-available-regions">here</a> for all region codes.
type DestinationIcebergS3BucketRegion string

const (
	DestinationIcebergS3BucketRegionUnknown      DestinationIcebergS3BucketRegion = ""
	DestinationIcebergS3BucketRegionAfSouth1     DestinationIcebergS3BucketRegion = "af-south-1"
	DestinationIcebergS3BucketRegionApEast1      DestinationIcebergS3BucketRegion = "ap-east-1"
	DestinationIcebergS3BucketRegionApNortheast1 DestinationIcebergS3BucketRegion = "ap-northeast-1"
	DestinationIcebergS3BucketRegionApNortheast2 DestinationIcebergS3BucketRegion = "ap-northeast-2"
	DestinationIcebergS3BucketRegionApNortheast3 DestinationIcebergS3BucketRegion = "ap-northeast-3"
	DestinationIcebergS3BucketRegionApSouth1     DestinationIcebergS3BucketRegion = "ap-south-1"
	DestinationIcebergS3BucketRegionApSouth2     DestinationIcebergS3BucketRegion = "ap-south-2"
	DestinationIcebergS3BucketRegionApSoutheast1 DestinationIcebergS3BucketRegion = "ap-southeast-1"
	DestinationIcebergS3BucketRegionApSoutheast2 DestinationIcebergS3BucketRegion = "ap-southeast-2"
	DestinationIcebergS3BucketRegionApSoutheast3 DestinationIcebergS3BucketRegion = "ap-southeast-3"
	DestinationIcebergS3BucketRegionApSoutheast4 DestinationIcebergS3BucketRegion = "ap-southeast-4"
	DestinationIcebergS3BucketRegionCaCentral1   DestinationIcebergS3BucketRegion = "ca-central-1"
	DestinationIcebergS3BucketRegionCaWest1      DestinationIcebergS3BucketRegion = "ca-west-1"
	DestinationIcebergS3BucketRegionCnNorth1     DestinationIcebergS3BucketRegion = "cn-north-1"
	DestinationIcebergS3BucketRegionCnNorthwest1 DestinationIcebergS3BucketRegion = "cn-northwest-1"
	DestinationIcebergS3BucketRegionEuCentral1   DestinationIcebergS3BucketRegion = "eu-central-1"
	DestinationIcebergS3BucketRegionEuCentral2   DestinationIcebergS3BucketRegion = "eu-central-2"
	DestinationIcebergS3BucketRegionEuNorth1     DestinationIcebergS3BucketRegion = "eu-north-1"
	DestinationIcebergS3BucketRegionEuSouth1     DestinationIcebergS3BucketRegion = "eu-south-1"
	DestinationIcebergS3BucketRegionEuSouth2     DestinationIcebergS3BucketRegion = "eu-south-2"
	DestinationIcebergS3BucketRegionEuWest1      DestinationIcebergS3BucketRegion = "eu-west-1"
	DestinationIcebergS3BucketRegionEuWest2      DestinationIcebergS3BucketRegion = "eu-west-2"
	DestinationIcebergS3BucketRegionEuWest3      DestinationIcebergS3BucketRegion = "eu-west-3"
	DestinationIcebergS3BucketRegionIlCentral1   DestinationIcebergS3BucketRegion = "il-central-1"
	DestinationIcebergS3BucketRegionMeCentral1   DestinationIcebergS3BucketRegion = "me-central-1"
	DestinationIcebergS3BucketRegionMeSouth1     DestinationIcebergS3BucketRegion = "me-south-1"
	DestinationIcebergS3BucketRegionSaEast1      DestinationIcebergS3BucketRegion = "sa-east-1"
	DestinationIcebergS3BucketRegionUsEast1      DestinationIcebergS3BucketRegion = "us-east-1"
	DestinationIcebergS3BucketRegionUsEast2      DestinationIcebergS3BucketRegion = "us-east-2"
	DestinationIcebergS3BucketRegionUsGovEast1   DestinationIcebergS3BucketRegion = "us-gov-east-1"
	DestinationIcebergS3BucketRegionUsGovWest1   DestinationIcebergS3BucketRegion = "us-gov-west-1"
	DestinationIcebergS3BucketRegionUsWest1      DestinationIcebergS3BucketRegion = "us-west-1"
	DestinationIcebergS3BucketRegionUsWest2      DestinationIcebergS3BucketRegion = "us-west-2"
)

func (e DestinationIcebergS3BucketRegion) ToPointer() *DestinationIcebergS3BucketRegion {
	return &e
}
func (e *DestinationIcebergS3BucketRegion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "":
		fallthrough
	case "af-south-1":
		fallthrough
	case "ap-east-1":
		fallthrough
	case "ap-northeast-1":
		fallthrough
	case "ap-northeast-2":
		fallthrough
	case "ap-northeast-3":
		fallthrough
	case "ap-south-1":
		fallthrough
	case "ap-south-2":
		fallthrough
	case "ap-southeast-1":
		fallthrough
	case "ap-southeast-2":
		fallthrough
	case "ap-southeast-3":
		fallthrough
	case "ap-southeast-4":
		fallthrough
	case "ca-central-1":
		fallthrough
	case "ca-west-1":
		fallthrough
	case "cn-north-1":
		fallthrough
	case "cn-northwest-1":
		fallthrough
	case "eu-central-1":
		fallthrough
	case "eu-central-2":
		fallthrough
	case "eu-north-1":
		fallthrough
	case "eu-south-1":
		fallthrough
	case "eu-south-2":
		fallthrough
	case "eu-west-1":
		fallthrough
	case "eu-west-2":
		fallthrough
	case "eu-west-3":
		fallthrough
	case "il-central-1":
		fallthrough
	case "me-central-1":
		fallthrough
	case "me-south-1":
		fallthrough
	case "sa-east-1":
		fallthrough
	case "us-east-1":
		fallthrough
	case "us-east-2":
		fallthrough
	case "us-gov-east-1":
		fallthrough
	case "us-gov-west-1":
		fallthrough
	case "us-west-1":
		fallthrough
	case "us-west-2":
		*e = DestinationIcebergS3BucketRegion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationIcebergS3BucketRegion: %v", v)
	}
}

type DestinationIcebergStorageType string

const (
	DestinationIcebergStorageTypeS3 DestinationIcebergStorageType = "S3"
)

func (e DestinationIcebergStorageType) ToPointer() *DestinationIcebergStorageType {
	return &e
}
func (e *DestinationIcebergStorageType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "S3":
		*e = DestinationIcebergStorageType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationIcebergStorageType: %v", v)
	}
}

// DestinationIcebergS3 - S3 object storage
type DestinationIcebergS3 struct {
	// The access key ID to access the S3 bucket. Airbyte requires Read and Write permissions to the given bucket. Read more <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">here</a>.
	AccessKeyID string `json:"access_key_id"`
	// The region of the S3 bucket. See <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-available-regions">here</a> for all region codes.
	S3BucketRegion *DestinationIcebergS3BucketRegion `default:"" json:"s3_bucket_region"`
	// Your S3 endpoint url. Read more <a href="https://docs.aws.amazon.com/general/latest/gr/s3.html#:~:text=Service%20endpoints-,Amazon%20S3%20endpoints,-When%20you%20use">here</a>
	S3Endpoint *string `default:"" json:"s3_endpoint"`
	// Use path style access
	S3PathStyleAccess *bool `default:"true" json:"s3_path_style_access"`
	// The Warehouse Uri for Iceberg
	S3WarehouseURI string `json:"s3_warehouse_uri"`
	// The corresponding secret to the access key ID. Read more <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">here</a>
	SecretAccessKey string                         `json:"secret_access_key"`
	StorageType     *DestinationIcebergStorageType `default:"S3" json:"storage_type"`
}

func (d DestinationIcebergS3) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationIcebergS3) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationIcebergS3) GetAccessKeyID() string {
	if o == nil {
		return ""
	}
	return o.AccessKeyID
}

func (o *DestinationIcebergS3) GetS3BucketRegion() *DestinationIcebergS3BucketRegion {
	if o == nil {
		return nil
	}
	return o.S3BucketRegion
}

func (o *DestinationIcebergS3) GetS3Endpoint() *string {
	if o == nil {
		return nil
	}
	return o.S3Endpoint
}

func (o *DestinationIcebergS3) GetS3PathStyleAccess() *bool {
	if o == nil {
		return nil
	}
	return o.S3PathStyleAccess
}

func (o *DestinationIcebergS3) GetS3WarehouseURI() string {
	if o == nil {
		return ""
	}
	return o.S3WarehouseURI
}

func (o *DestinationIcebergS3) GetSecretAccessKey() string {
	if o == nil {
		return ""
	}
	return o.SecretAccessKey
}

func (o *DestinationIcebergS3) GetStorageType() *DestinationIcebergStorageType {
	if o == nil {
		return nil
	}
	return o.StorageType
}

type DestinationIcebergStorageConfigType string

const (
	DestinationIcebergStorageConfigTypeDestinationIcebergS3            DestinationIcebergStorageConfigType = "destination-iceberg_S3"
	DestinationIcebergStorageConfigTypeDestinationIcebergServerManaged DestinationIcebergStorageConfigType = "destination-iceberg_Server-managed"
)

// DestinationIcebergStorageConfig - Storage config of Iceberg.
type DestinationIcebergStorageConfig struct {
	DestinationIcebergS3            *DestinationIcebergS3
	DestinationIcebergServerManaged *DestinationIcebergServerManaged

	Type DestinationIcebergStorageConfigType
}

func CreateDestinationIcebergStorageConfigDestinationIcebergS3(destinationIcebergS3 DestinationIcebergS3) DestinationIcebergStorageConfig {
	typ := DestinationIcebergStorageConfigTypeDestinationIcebergS3

	return DestinationIcebergStorageConfig{
		DestinationIcebergS3: &destinationIcebergS3,
		Type:                 typ,
	}
}

func CreateDestinationIcebergStorageConfigDestinationIcebergServerManaged(destinationIcebergServerManaged DestinationIcebergServerManaged) DestinationIcebergStorageConfig {
	typ := DestinationIcebergStorageConfigTypeDestinationIcebergServerManaged

	return DestinationIcebergStorageConfig{
		DestinationIcebergServerManaged: &destinationIcebergServerManaged,
		Type:                            typ,
	}
}

func (u *DestinationIcebergStorageConfig) UnmarshalJSON(data []byte) error {

	var destinationIcebergServerManaged DestinationIcebergServerManaged = DestinationIcebergServerManaged{}
	if err := utils.UnmarshalJSON(data, &destinationIcebergServerManaged, "", true, true); err == nil {
		u.DestinationIcebergServerManaged = &destinationIcebergServerManaged
		u.Type = DestinationIcebergStorageConfigTypeDestinationIcebergServerManaged
		return nil
	}

	var destinationIcebergS3 DestinationIcebergS3 = DestinationIcebergS3{}
	if err := utils.UnmarshalJSON(data, &destinationIcebergS3, "", true, true); err == nil {
		u.DestinationIcebergS3 = &destinationIcebergS3
		u.Type = DestinationIcebergStorageConfigTypeDestinationIcebergS3
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationIcebergStorageConfig", string(data))
}

func (u DestinationIcebergStorageConfig) MarshalJSON() ([]byte, error) {
	if u.DestinationIcebergS3 != nil {
		return utils.MarshalJSON(u.DestinationIcebergS3, "", true)
	}

	if u.DestinationIcebergServerManaged != nil {
		return utils.MarshalJSON(u.DestinationIcebergServerManaged, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationIcebergStorageConfig: all fields are null")
}

type DestinationIceberg struct {
	// Catalog config of Iceberg.
	CatalogConfig   DestinationIcebergIcebergCatalogConfig `json:"catalog_config"`
	destinationType Iceberg                                `const:"iceberg" json:"destinationType"`
	// File format of Iceberg storage.
	FormatConfig DestinationIcebergFileFormat `json:"format_config"`
	// Storage config of Iceberg.
	StorageConfig DestinationIcebergStorageConfig `json:"storage_config"`
}

func (d DestinationIceberg) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationIceberg) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *DestinationIceberg) GetCatalogConfig() DestinationIcebergIcebergCatalogConfig {
	if o == nil {
		return DestinationIcebergIcebergCatalogConfig{}
	}
	return o.CatalogConfig
}

func (o *DestinationIceberg) GetDestinationType() Iceberg {
	return IcebergIceberg
}

func (o *DestinationIceberg) GetFormatConfig() DestinationIcebergFileFormat {
	if o == nil {
		return DestinationIcebergFileFormat{}
	}
	return o.FormatConfig
}

func (o *DestinationIceberg) GetStorageConfig() DestinationIcebergStorageConfig {
	if o == nil {
		return DestinationIcebergStorageConfig{}
	}
	return o.StorageConfig
}
