// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/types"
)

type AuthenticateWithPersonalAccessToken struct {
	// PAT Credentials
	optionTitle *string `const:"PAT Credentials" json:"option_title,omitempty"`
	// Asana Personal Access Token (generate yours <a href="https://app.asana.com/0/developer-console">here</a>).
	PersonalAccessToken string `json:"personal_access_token"`
}

func (a AuthenticateWithPersonalAccessToken) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AuthenticateWithPersonalAccessToken) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (a *AuthenticateWithPersonalAccessToken) GetOptionTitle() *string {
	return types.Pointer("PAT Credentials")
}

func (a *AuthenticateWithPersonalAccessToken) GetPersonalAccessToken() string {
	if a == nil {
		return ""
	}
	return a.PersonalAccessToken
}

type AuthenticateViaAsanaOauth struct {
	ClientID     string `json:"client_id"`
	ClientSecret string `json:"client_secret"`
	// OAuth Credentials
	optionTitle  *string `const:"OAuth Credentials" json:"option_title,omitempty"`
	RefreshToken string  `json:"refresh_token"`
}

func (a AuthenticateViaAsanaOauth) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AuthenticateViaAsanaOauth) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (a *AuthenticateViaAsanaOauth) GetClientID() string {
	if a == nil {
		return ""
	}
	return a.ClientID
}

func (a *AuthenticateViaAsanaOauth) GetClientSecret() string {
	if a == nil {
		return ""
	}
	return a.ClientSecret
}

func (a *AuthenticateViaAsanaOauth) GetOptionTitle() *string {
	return types.Pointer("OAuth Credentials")
}

func (a *AuthenticateViaAsanaOauth) GetRefreshToken() string {
	if a == nil {
		return ""
	}
	return a.RefreshToken
}

type AuthenticationMechanismType string

const (
	AuthenticationMechanismTypeAuthenticateViaAsanaOauth           AuthenticationMechanismType = "Authenticate via Asana (Oauth)"
	AuthenticationMechanismTypeAuthenticateWithPersonalAccessToken AuthenticationMechanismType = "Authenticate with Personal Access Token"
)

// AuthenticationMechanism - Choose how to authenticate to Github
type AuthenticationMechanism struct {
	AuthenticateViaAsanaOauth           *AuthenticateViaAsanaOauth           `queryParam:"inline" union:"member"`
	AuthenticateWithPersonalAccessToken *AuthenticateWithPersonalAccessToken `queryParam:"inline" union:"member"`

	Type AuthenticationMechanismType
}

func CreateAuthenticationMechanismAuthenticateViaAsanaOauth(authenticateViaAsanaOauth AuthenticateViaAsanaOauth) AuthenticationMechanism {
	typ := AuthenticationMechanismTypeAuthenticateViaAsanaOauth

	return AuthenticationMechanism{
		AuthenticateViaAsanaOauth: &authenticateViaAsanaOauth,
		Type:                      typ,
	}
}

func CreateAuthenticationMechanismAuthenticateWithPersonalAccessToken(authenticateWithPersonalAccessToken AuthenticateWithPersonalAccessToken) AuthenticationMechanism {
	typ := AuthenticationMechanismTypeAuthenticateWithPersonalAccessToken

	return AuthenticationMechanism{
		AuthenticateWithPersonalAccessToken: &authenticateWithPersonalAccessToken,
		Type:                                typ,
	}
}

func (u *AuthenticationMechanism) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var authenticateViaAsanaOauth AuthenticateViaAsanaOauth = AuthenticateViaAsanaOauth{}
	if err := utils.UnmarshalJSON(data, &authenticateViaAsanaOauth, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  AuthenticationMechanismTypeAuthenticateViaAsanaOauth,
			Value: &authenticateViaAsanaOauth,
		})
	}

	var authenticateWithPersonalAccessToken AuthenticateWithPersonalAccessToken = AuthenticateWithPersonalAccessToken{}
	if err := utils.UnmarshalJSON(data, &authenticateWithPersonalAccessToken, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  AuthenticationMechanismTypeAuthenticateWithPersonalAccessToken,
			Value: &authenticateWithPersonalAccessToken,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for AuthenticationMechanism", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for AuthenticationMechanism", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(AuthenticationMechanismType)
	switch best.Type {
	case AuthenticationMechanismTypeAuthenticateViaAsanaOauth:
		u.AuthenticateViaAsanaOauth = best.Value.(*AuthenticateViaAsanaOauth)
		return nil
	case AuthenticationMechanismTypeAuthenticateWithPersonalAccessToken:
		u.AuthenticateWithPersonalAccessToken = best.Value.(*AuthenticateWithPersonalAccessToken)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for AuthenticationMechanism", string(data))
}

func (u AuthenticationMechanism) MarshalJSON() ([]byte, error) {
	if u.AuthenticateViaAsanaOauth != nil {
		return utils.MarshalJSON(u.AuthenticateViaAsanaOauth, "", true)
	}

	if u.AuthenticateWithPersonalAccessToken != nil {
		return utils.MarshalJSON(u.AuthenticateWithPersonalAccessToken, "", true)
	}

	return nil, errors.New("could not marshal union type AuthenticationMechanism: all fields are null")
}

type SourceAsanaSourceType string

const (
	SourceAsanaSourceTypeAsana SourceAsanaSourceType = "asana"
)

func (e SourceAsanaSourceType) ToPointer() *SourceAsanaSourceType {
	return &e
}
func (e *SourceAsanaSourceType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "asana":
		*e = SourceAsanaSourceType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceAsanaSourceType: %v", v)
	}
}

type SourceAsana struct {
	// Choose how to authenticate to Github
	Credentials *AuthenticationMechanism `json:"credentials,omitempty"`
	// The number of worker threads to use for the sync. The performance upper boundary is based on the limit of your Asana pricing plan. More info about the rate limit tiers can be found on Asana's API <a href="https://developers.asana.com/docs/rate-limits">docs</a>.
	NumWorkers *int64 `default:"10" json:"num_workers"`
	// Globally unique identifiers for the organization exports
	OrganizationExportIds []string `json:"organization_export_ids,omitempty"`
	// This flag is used for testing purposes for certain streams that return a lot of data. This flag is not meant to be enabled for prod.
	TestMode             *bool                  `json:"test_mode,omitempty"`
	sourceType           *SourceAsanaSourceType `const:"asana" json:"sourceType"`
	AdditionalProperties any                    `additionalProperties:"true" json:"-"`
}

func (s SourceAsana) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceAsana) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceAsana) GetCredentials() *AuthenticationMechanism {
	if s == nil {
		return nil
	}
	return s.Credentials
}

func (s *SourceAsana) GetNumWorkers() *int64 {
	if s == nil {
		return nil
	}
	return s.NumWorkers
}

func (s *SourceAsana) GetOrganizationExportIds() []string {
	if s == nil {
		return nil
	}
	return s.OrganizationExportIds
}

func (s *SourceAsana) GetTestMode() *bool {
	if s == nil {
		return nil
	}
	return s.TestMode
}

func (s *SourceAsana) GetSourceType() *SourceAsanaSourceType {
	return SourceAsanaSourceTypeAsana.ToPointer()
}

func (s *SourceAsana) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}
