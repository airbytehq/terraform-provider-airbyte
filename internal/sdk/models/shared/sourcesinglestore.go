// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

// ReplicationMethod - Replication method to use for extracting data from the database. STANDARD replication requires no setup on the DB side but will not be able to represent deletions incrementally.
type ReplicationMethod string

const (
	ReplicationMethodStandard ReplicationMethod = "STANDARD"
)

func (e ReplicationMethod) ToPointer() *ReplicationMethod {
	return &e
}
func (e *ReplicationMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "STANDARD":
		*e = ReplicationMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ReplicationMethod: %v", v)
	}
}

// SourceSinglestoreVerifyFull - Use SSL/TLS for encryption, certificate verification, and hostname verification.
type SourceSinglestoreVerifyFull struct {
	// CA certificate
	CaCertificate string `json:"ca_certificate"`
	// Client certificate (this is not a required field, but if you want to use it, you will need to add the <b>Client key</b> as well)
	ClientCertificate *string `json:"client_certificate,omitempty"`
	// Client key (this is not a required field, but if you want to use it, you will need to add the <b>Client certificate</b> as well)
	ClientKey *string `json:"client_key,omitempty"`
	// Password for keystorage. This field is optional. If you do not add it - the password will be generated automatically.
	ClientKeyPassword *string `json:"client_key_password,omitempty"`
	mode              string  `const:"verify-full" json:"mode"`
}

func (s SourceSinglestoreVerifyFull) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceSinglestoreVerifyFull) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceSinglestoreVerifyFull) GetCaCertificate() string {
	if s == nil {
		return ""
	}
	return s.CaCertificate
}

func (s *SourceSinglestoreVerifyFull) GetClientCertificate() *string {
	if s == nil {
		return nil
	}
	return s.ClientCertificate
}

func (s *SourceSinglestoreVerifyFull) GetClientKey() *string {
	if s == nil {
		return nil
	}
	return s.ClientKey
}

func (s *SourceSinglestoreVerifyFull) GetClientKeyPassword() *string {
	if s == nil {
		return nil
	}
	return s.ClientKeyPassword
}

func (s *SourceSinglestoreVerifyFull) GetMode() string {
	return "verify-full"
}

// SourceSinglestoreVerifyCA - Use SSL/TLS for encryption and perform certificates verification, but do not perform hostname verification.
type SourceSinglestoreVerifyCA struct {
	// CA certificate
	CaCertificate string `json:"ca_certificate"`
	// Client certificate (this is not a required field, but if you want to use it, you will need to add the <b>Client key</b> as well)
	ClientCertificate *string `json:"client_certificate,omitempty"`
	// Client key (this is not a required field, but if you want to use it, you will need to add the <b>Client certificate</b> as well)
	ClientKey *string `json:"client_key,omitempty"`
	// Password for keystorage. This field is optional. If you do not add it - the password will be generated automatically.
	ClientKeyPassword *string `json:"client_key_password,omitempty"`
	mode              string  `const:"verify-ca" json:"mode"`
}

func (s SourceSinglestoreVerifyCA) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceSinglestoreVerifyCA) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceSinglestoreVerifyCA) GetCaCertificate() string {
	if s == nil {
		return ""
	}
	return s.CaCertificate
}

func (s *SourceSinglestoreVerifyCA) GetClientCertificate() *string {
	if s == nil {
		return nil
	}
	return s.ClientCertificate
}

func (s *SourceSinglestoreVerifyCA) GetClientKey() *string {
	if s == nil {
		return nil
	}
	return s.ClientKey
}

func (s *SourceSinglestoreVerifyCA) GetClientKeyPassword() *string {
	if s == nil {
		return nil
	}
	return s.ClientKeyPassword
}

func (s *SourceSinglestoreVerifyCA) GetMode() string {
	return "verify-ca"
}

// SourceSinglestoreRequired - Only use SSL/TLS for encryption. Do not perform certificate or hostname verification. This mode is not safe for production applications.
type SourceSinglestoreRequired struct {
	mode string `const:"required" json:"mode"`
}

func (s SourceSinglestoreRequired) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceSinglestoreRequired) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceSinglestoreRequired) GetMode() string {
	return "required"
}

// SourceSinglestoreDisable - Do not use SSL/TLS
type SourceSinglestoreDisable struct {
	mode string `const:"disable" json:"mode"`
}

func (s SourceSinglestoreDisable) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceSinglestoreDisable) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceSinglestoreDisable) GetMode() string {
	return "disable"
}

type SourceSinglestoreSSLModesType string

const (
	SourceSinglestoreSSLModesTypeSourceSinglestoreDisable    SourceSinglestoreSSLModesType = "source-singlestore_disable"
	SourceSinglestoreSSLModesTypeSourceSinglestoreRequired   SourceSinglestoreSSLModesType = "source-singlestore_required"
	SourceSinglestoreSSLModesTypeSourceSinglestoreVerifyCA   SourceSinglestoreSSLModesType = "source-singlestore_Verify CA"
	SourceSinglestoreSSLModesTypeSourceSinglestoreVerifyFull SourceSinglestoreSSLModesType = "source-singlestore_Verify Full"
)

// SourceSinglestoreSSLModes - SSL connection modes.
type SourceSinglestoreSSLModes struct {
	SourceSinglestoreDisable    *SourceSinglestoreDisable    `queryParam:"inline" union:"member"`
	SourceSinglestoreRequired   *SourceSinglestoreRequired   `queryParam:"inline" union:"member"`
	SourceSinglestoreVerifyCA   *SourceSinglestoreVerifyCA   `queryParam:"inline" union:"member"`
	SourceSinglestoreVerifyFull *SourceSinglestoreVerifyFull `queryParam:"inline" union:"member"`

	Type SourceSinglestoreSSLModesType
}

func CreateSourceSinglestoreSSLModesSourceSinglestoreDisable(sourceSinglestoreDisable SourceSinglestoreDisable) SourceSinglestoreSSLModes {
	typ := SourceSinglestoreSSLModesTypeSourceSinglestoreDisable

	return SourceSinglestoreSSLModes{
		SourceSinglestoreDisable: &sourceSinglestoreDisable,
		Type:                     typ,
	}
}

func CreateSourceSinglestoreSSLModesSourceSinglestoreRequired(sourceSinglestoreRequired SourceSinglestoreRequired) SourceSinglestoreSSLModes {
	typ := SourceSinglestoreSSLModesTypeSourceSinglestoreRequired

	return SourceSinglestoreSSLModes{
		SourceSinglestoreRequired: &sourceSinglestoreRequired,
		Type:                      typ,
	}
}

func CreateSourceSinglestoreSSLModesSourceSinglestoreVerifyCA(sourceSinglestoreVerifyCA SourceSinglestoreVerifyCA) SourceSinglestoreSSLModes {
	typ := SourceSinglestoreSSLModesTypeSourceSinglestoreVerifyCA

	return SourceSinglestoreSSLModes{
		SourceSinglestoreVerifyCA: &sourceSinglestoreVerifyCA,
		Type:                      typ,
	}
}

func CreateSourceSinglestoreSSLModesSourceSinglestoreVerifyFull(sourceSinglestoreVerifyFull SourceSinglestoreVerifyFull) SourceSinglestoreSSLModes {
	typ := SourceSinglestoreSSLModesTypeSourceSinglestoreVerifyFull

	return SourceSinglestoreSSLModes{
		SourceSinglestoreVerifyFull: &sourceSinglestoreVerifyFull,
		Type:                        typ,
	}
}

func (u *SourceSinglestoreSSLModes) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var sourceSinglestoreDisable SourceSinglestoreDisable = SourceSinglestoreDisable{}
	if err := utils.UnmarshalJSON(data, &sourceSinglestoreDisable, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceSinglestoreSSLModesTypeSourceSinglestoreDisable,
			Value: &sourceSinglestoreDisable,
		})
	}

	var sourceSinglestoreRequired SourceSinglestoreRequired = SourceSinglestoreRequired{}
	if err := utils.UnmarshalJSON(data, &sourceSinglestoreRequired, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceSinglestoreSSLModesTypeSourceSinglestoreRequired,
			Value: &sourceSinglestoreRequired,
		})
	}

	var sourceSinglestoreVerifyCA SourceSinglestoreVerifyCA = SourceSinglestoreVerifyCA{}
	if err := utils.UnmarshalJSON(data, &sourceSinglestoreVerifyCA, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceSinglestoreSSLModesTypeSourceSinglestoreVerifyCA,
			Value: &sourceSinglestoreVerifyCA,
		})
	}

	var sourceSinglestoreVerifyFull SourceSinglestoreVerifyFull = SourceSinglestoreVerifyFull{}
	if err := utils.UnmarshalJSON(data, &sourceSinglestoreVerifyFull, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceSinglestoreSSLModesTypeSourceSinglestoreVerifyFull,
			Value: &sourceSinglestoreVerifyFull,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceSinglestoreSSLModes", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceSinglestoreSSLModes", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceSinglestoreSSLModesType)
	switch best.Type {
	case SourceSinglestoreSSLModesTypeSourceSinglestoreDisable:
		u.SourceSinglestoreDisable = best.Value.(*SourceSinglestoreDisable)
		return nil
	case SourceSinglestoreSSLModesTypeSourceSinglestoreRequired:
		u.SourceSinglestoreRequired = best.Value.(*SourceSinglestoreRequired)
		return nil
	case SourceSinglestoreSSLModesTypeSourceSinglestoreVerifyCA:
		u.SourceSinglestoreVerifyCA = best.Value.(*SourceSinglestoreVerifyCA)
		return nil
	case SourceSinglestoreSSLModesTypeSourceSinglestoreVerifyFull:
		u.SourceSinglestoreVerifyFull = best.Value.(*SourceSinglestoreVerifyFull)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceSinglestoreSSLModes", string(data))
}

func (u SourceSinglestoreSSLModes) MarshalJSON() ([]byte, error) {
	if u.SourceSinglestoreDisable != nil {
		return utils.MarshalJSON(u.SourceSinglestoreDisable, "", true)
	}

	if u.SourceSinglestoreRequired != nil {
		return utils.MarshalJSON(u.SourceSinglestoreRequired, "", true)
	}

	if u.SourceSinglestoreVerifyCA != nil {
		return utils.MarshalJSON(u.SourceSinglestoreVerifyCA, "", true)
	}

	if u.SourceSinglestoreVerifyFull != nil {
		return utils.MarshalJSON(u.SourceSinglestoreVerifyFull, "", true)
	}

	return nil, errors.New("could not marshal union type SourceSinglestoreSSLModes: all fields are null")
}

type SourceSinglestoreSourceType string

const (
	SourceSinglestoreSourceTypeSinglestore SourceSinglestoreSourceType = "singlestore"
)

func (e SourceSinglestoreSourceType) ToPointer() *SourceSinglestoreSourceType {
	return &e
}
func (e *SourceSinglestoreSourceType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "singlestore":
		*e = SourceSinglestoreSourceType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceSinglestoreSourceType: %v", v)
	}
}

type SourceSinglestore struct {
	// Name of the database.
	Database string `json:"database"`
	// Hostname of the database.
	Host string `json:"host"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3). For more information read about <a href="https://docs.singlestore.com/cloud/developer-resources/connect-with-application-development-tools/connect-with-java-jdbc/the-singlestore-jdbc-driver/#connection-string-parameters">JDBC URL parameters</a>.
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// Password associated with the username.
	Password *string `json:"password,omitempty"`
	// Port of the database.
	Port *int64 `default:"3306" json:"port"`
	// Replication method to use for extracting data from the database. STANDARD replication requires no setup on the DB side but will not be able to represent deletions incrementally.
	ReplicationMethod *ReplicationMethod `default:"STANDARD" json:"replication_method"`
	// SSL connection modes.
	SslMode *SourceSinglestoreSSLModes `json:"ssl_mode,omitempty"`
	// Username to use to access the database.
	Username   string                       `json:"username"`
	sourceType *SourceSinglestoreSourceType `const:"singlestore" json:"sourceType"`
}

func (s SourceSinglestore) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceSinglestore) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceSinglestore) GetDatabase() string {
	if s == nil {
		return ""
	}
	return s.Database
}

func (s *SourceSinglestore) GetHost() string {
	if s == nil {
		return ""
	}
	return s.Host
}

func (s *SourceSinglestore) GetJdbcURLParams() *string {
	if s == nil {
		return nil
	}
	return s.JdbcURLParams
}

func (s *SourceSinglestore) GetPassword() *string {
	if s == nil {
		return nil
	}
	return s.Password
}

func (s *SourceSinglestore) GetPort() *int64 {
	if s == nil {
		return nil
	}
	return s.Port
}

func (s *SourceSinglestore) GetReplicationMethod() *ReplicationMethod {
	if s == nil {
		return nil
	}
	return s.ReplicationMethod
}

func (s *SourceSinglestore) GetSslMode() *SourceSinglestoreSSLModes {
	if s == nil {
		return nil
	}
	return s.SslMode
}

func (s *SourceSinglestore) GetUsername() string {
	if s == nil {
		return ""
	}
	return s.Username
}

func (s *SourceSinglestore) GetSourceType() *SourceSinglestoreSourceType {
	return SourceSinglestoreSourceTypeSinglestore.ToPointer()
}
