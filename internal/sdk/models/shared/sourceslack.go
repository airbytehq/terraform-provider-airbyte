// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
	"time"
)

type SourceSlackAPIToken struct {
	// A Slack bot token. See the <a href="https://docs.airbyte.com/integrations/sources/slack">docs</a> for instructions on how to generate it.
	APIToken    string `json:"api_token"`
	optionTitle string `const:"API Token Credentials" json:"option_title"`
}

func (s SourceSlackAPIToken) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceSlackAPIToken) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceSlackAPIToken) GetAPIToken() string {
	if s == nil {
		return ""
	}
	return s.APIToken
}

func (s *SourceSlackAPIToken) GetOptionTitle() string {
	return "API Token Credentials"
}

type SignInViaSlackOAuth struct {
	// Slack access_token. See our <a href="https://docs.airbyte.com/integrations/sources/slack">docs</a> if you need help generating the token.
	AccessToken string `json:"access_token"`
	// Slack client_id. See our <a href="https://docs.airbyte.com/integrations/sources/slack">docs</a> if you need help finding this id.
	ClientID string `json:"client_id"`
	// Slack client_secret. See our <a href="https://docs.airbyte.com/integrations/sources/slack">docs</a> if you need help finding this secret.
	ClientSecret string `json:"client_secret"`
	optionTitle  string `const:"Default OAuth2.0 authorization" json:"option_title"`
}

func (s SignInViaSlackOAuth) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SignInViaSlackOAuth) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SignInViaSlackOAuth) GetAccessToken() string {
	if s == nil {
		return ""
	}
	return s.AccessToken
}

func (s *SignInViaSlackOAuth) GetClientID() string {
	if s == nil {
		return ""
	}
	return s.ClientID
}

func (s *SignInViaSlackOAuth) GetClientSecret() string {
	if s == nil {
		return ""
	}
	return s.ClientSecret
}

func (s *SignInViaSlackOAuth) GetOptionTitle() string {
	return "Default OAuth2.0 authorization"
}

type SourceSlackAuthenticationMechanismType string

const (
	SourceSlackAuthenticationMechanismTypeSignInViaSlackOAuth SourceSlackAuthenticationMechanismType = "Sign in via Slack (OAuth)"
	SourceSlackAuthenticationMechanismTypeSourceSlackAPIToken SourceSlackAuthenticationMechanismType = "source-slack_API Token"
)

// SourceSlackAuthenticationMechanism - Choose how to authenticate into Slack
type SourceSlackAuthenticationMechanism struct {
	SignInViaSlackOAuth *SignInViaSlackOAuth `queryParam:"inline" union:"member"`
	SourceSlackAPIToken *SourceSlackAPIToken `queryParam:"inline" union:"member"`

	Type SourceSlackAuthenticationMechanismType
}

func CreateSourceSlackAuthenticationMechanismSignInViaSlackOAuth(signInViaSlackOAuth SignInViaSlackOAuth) SourceSlackAuthenticationMechanism {
	typ := SourceSlackAuthenticationMechanismTypeSignInViaSlackOAuth

	return SourceSlackAuthenticationMechanism{
		SignInViaSlackOAuth: &signInViaSlackOAuth,
		Type:                typ,
	}
}

func CreateSourceSlackAuthenticationMechanismSourceSlackAPIToken(sourceSlackAPIToken SourceSlackAPIToken) SourceSlackAuthenticationMechanism {
	typ := SourceSlackAuthenticationMechanismTypeSourceSlackAPIToken

	return SourceSlackAuthenticationMechanism{
		SourceSlackAPIToken: &sourceSlackAPIToken,
		Type:                typ,
	}
}

func (u *SourceSlackAuthenticationMechanism) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var signInViaSlackOAuth SignInViaSlackOAuth = SignInViaSlackOAuth{}
	if err := utils.UnmarshalJSON(data, &signInViaSlackOAuth, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceSlackAuthenticationMechanismTypeSignInViaSlackOAuth,
			Value: &signInViaSlackOAuth,
		})
	}

	var sourceSlackAPIToken SourceSlackAPIToken = SourceSlackAPIToken{}
	if err := utils.UnmarshalJSON(data, &sourceSlackAPIToken, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceSlackAuthenticationMechanismTypeSourceSlackAPIToken,
			Value: &sourceSlackAPIToken,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceSlackAuthenticationMechanism", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceSlackAuthenticationMechanism", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceSlackAuthenticationMechanismType)
	switch best.Type {
	case SourceSlackAuthenticationMechanismTypeSignInViaSlackOAuth:
		u.SignInViaSlackOAuth = best.Value.(*SignInViaSlackOAuth)
		return nil
	case SourceSlackAuthenticationMechanismTypeSourceSlackAPIToken:
		u.SourceSlackAPIToken = best.Value.(*SourceSlackAPIToken)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceSlackAuthenticationMechanism", string(data))
}

func (u SourceSlackAuthenticationMechanism) MarshalJSON() ([]byte, error) {
	if u.SignInViaSlackOAuth != nil {
		return utils.MarshalJSON(u.SignInViaSlackOAuth, "", true)
	}

	if u.SourceSlackAPIToken != nil {
		return utils.MarshalJSON(u.SourceSlackAPIToken, "", true)
	}

	return nil, errors.New("could not marshal union type SourceSlackAuthenticationMechanism: all fields are null")
}

type SourceSlackSourceType string

const (
	SourceSlackSourceTypeSlack SourceSlackSourceType = "slack"
)

func (e SourceSlackSourceType) ToPointer() *SourceSlackSourceType {
	return &e
}
func (e *SourceSlackSourceType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "slack":
		*e = SourceSlackSourceType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceSlackSourceType: %v", v)
	}
}

type SourceSlack struct {
	// A channel name list (without leading '#' char) which limit the channels from which you'd like to sync. Empty list means no filter.
	ChannelFilter []string `json:"channel_filter,omitempty"`
	// The size (in days) of the date window that will be used while syncing data from the channel messages stream. A smaller window will allow for greater parallelization when syncing records, but can lead to rate limiting errors.
	ChannelMessagesWindowSize *int64 `default:"100" json:"channel_messages_window_size"`
	// Choose how to authenticate into Slack
	Credentials *SourceSlackAuthenticationMechanism `json:"credentials,omitempty"`
	// Whether to read information from private channels that the bot is already in.  If false, only public channels will be read.  If true, the bot must be manually added to private channels.
	IncludePrivateChannels *bool `default:"false" json:"include_private_channels"`
	// Whether to join all channels or to sync data only from channels the bot is already in.  If false, you''ll need to manually add the bot to all the channels from which you''d like to sync messages.
	JoinChannels *bool `default:"true" json:"join_channels"`
	// How far into the past to look for messages in threads, default is 0 days
	LookbackWindow *int64 `default:"0" json:"lookback_window"`
	// The number of worker threads to use for the sync.
	NumWorkers *int64 `default:"2" json:"num_workers"`
	// UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
	StartDate            time.Time              `json:"start_date"`
	sourceType           *SourceSlackSourceType `const:"slack" json:"sourceType"`
	AdditionalProperties any                    `additionalProperties:"true" json:"-"`
}

func (s SourceSlack) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceSlack) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceSlack) GetChannelFilter() []string {
	if s == nil {
		return nil
	}
	return s.ChannelFilter
}

func (s *SourceSlack) GetChannelMessagesWindowSize() *int64 {
	if s == nil {
		return nil
	}
	return s.ChannelMessagesWindowSize
}

func (s *SourceSlack) GetCredentials() *SourceSlackAuthenticationMechanism {
	if s == nil {
		return nil
	}
	return s.Credentials
}

func (s *SourceSlack) GetIncludePrivateChannels() *bool {
	if s == nil {
		return nil
	}
	return s.IncludePrivateChannels
}

func (s *SourceSlack) GetJoinChannels() *bool {
	if s == nil {
		return nil
	}
	return s.JoinChannels
}

func (s *SourceSlack) GetLookbackWindow() *int64 {
	if s == nil {
		return nil
	}
	return s.LookbackWindow
}

func (s *SourceSlack) GetNumWorkers() *int64 {
	if s == nil {
		return nil
	}
	return s.NumWorkers
}

func (s *SourceSlack) GetStartDate() time.Time {
	if s == nil {
		return time.Time{}
	}
	return s.StartDate
}

func (s *SourceSlack) GetSourceType() *SourceSlackSourceType {
	return SourceSlackSourceTypeSlack.ToPointer()
}

func (s *SourceSlack) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}
