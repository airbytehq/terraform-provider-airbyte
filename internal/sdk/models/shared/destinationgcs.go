// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

type DestinationGcsCredentialType string

const (
	DestinationGcsCredentialTypeHmacKey DestinationGcsCredentialType = "HMAC_KEY"
)

func (e DestinationGcsCredentialType) ToPointer() *DestinationGcsCredentialType {
	return &e
}

func (e *DestinationGcsCredentialType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "HMAC_KEY":
		*e = DestinationGcsCredentialType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsCredentialType: %v", v)
	}
}

type DestinationGcsHMACKey struct {
	CredentialType *DestinationGcsCredentialType `default:"HMAC_KEY" json:"credential_type"`
	// When linked to a service account, this ID is 61 characters long; when linked to a user account, it is 24 characters long. Read more <a href="https://cloud.google.com/storage/docs/authentication/hmackeys#overview">here</a>.
	HmacKeyAccessID string `json:"hmac_key_access_id"`
	// The corresponding secret for the access ID. It is a 40-character base-64 encoded string.  Read more <a href="https://cloud.google.com/storage/docs/authentication/hmackeys#secrets">here</a>.
	HmacKeySecret string `json:"hmac_key_secret"`
}

func (d DestinationGcsHMACKey) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsHMACKey) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationGcsHMACKey) GetCredentialType() *DestinationGcsCredentialType {
	if o == nil {
		return nil
	}
	return o.CredentialType
}

func (o *DestinationGcsHMACKey) GetHmacKeyAccessID() string {
	if o == nil {
		return ""
	}
	return o.HmacKeyAccessID
}

func (o *DestinationGcsHMACKey) GetHmacKeySecret() string {
	if o == nil {
		return ""
	}
	return o.HmacKeySecret
}

type DestinationGcsAuthenticationType string

const (
	DestinationGcsAuthenticationTypeDestinationGcsHMACKey DestinationGcsAuthenticationType = "destination-gcs_HMAC Key"
)

// DestinationGcsAuthentication - An HMAC key is a type of credential and can be associated with a service account or a user account in Cloud Storage. Read more <a href="https://cloud.google.com/storage/docs/authentication/hmackeys">here</a>.
type DestinationGcsAuthentication struct {
	DestinationGcsHMACKey *DestinationGcsHMACKey

	Type DestinationGcsAuthenticationType
}

func CreateDestinationGcsAuthenticationDestinationGcsHMACKey(destinationGcsHMACKey DestinationGcsHMACKey) DestinationGcsAuthentication {
	typ := DestinationGcsAuthenticationTypeDestinationGcsHMACKey

	return DestinationGcsAuthentication{
		DestinationGcsHMACKey: &destinationGcsHMACKey,
		Type:                  typ,
	}
}

func (u *DestinationGcsAuthentication) UnmarshalJSON(data []byte) error {

	var destinationGcsHMACKey DestinationGcsHMACKey = DestinationGcsHMACKey{}
	if err := utils.UnmarshalJSON(data, &destinationGcsHMACKey, "", true, true); err == nil {
		u.DestinationGcsHMACKey = &destinationGcsHMACKey
		u.Type = DestinationGcsAuthenticationTypeDestinationGcsHMACKey
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u DestinationGcsAuthentication) MarshalJSON() ([]byte, error) {
	if u.DestinationGcsHMACKey != nil {
		return utils.MarshalJSON(u.DestinationGcsHMACKey, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type Gcs string

const (
	GcsGcs Gcs = "gcs"
)

func (e Gcs) ToPointer() *Gcs {
	return &e
}

func (e *Gcs) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "gcs":
		*e = Gcs(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Gcs: %v", v)
	}
}

// DestinationGcsSchemasCompressionCodec - The compression algorithm used to compress data pages.
type DestinationGcsSchemasCompressionCodec string

const (
	DestinationGcsSchemasCompressionCodecUncompressed DestinationGcsSchemasCompressionCodec = "UNCOMPRESSED"
	DestinationGcsSchemasCompressionCodecSnappy       DestinationGcsSchemasCompressionCodec = "SNAPPY"
	DestinationGcsSchemasCompressionCodecGzip         DestinationGcsSchemasCompressionCodec = "GZIP"
	DestinationGcsSchemasCompressionCodecLzo          DestinationGcsSchemasCompressionCodec = "LZO"
	DestinationGcsSchemasCompressionCodecBrotli       DestinationGcsSchemasCompressionCodec = "BROTLI"
	DestinationGcsSchemasCompressionCodecLz4          DestinationGcsSchemasCompressionCodec = "LZ4"
	DestinationGcsSchemasCompressionCodecZstd         DestinationGcsSchemasCompressionCodec = "ZSTD"
)

func (e DestinationGcsSchemasCompressionCodec) ToPointer() *DestinationGcsSchemasCompressionCodec {
	return &e
}

func (e *DestinationGcsSchemasCompressionCodec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "UNCOMPRESSED":
		fallthrough
	case "SNAPPY":
		fallthrough
	case "GZIP":
		fallthrough
	case "LZO":
		fallthrough
	case "BROTLI":
		fallthrough
	case "LZ4":
		fallthrough
	case "ZSTD":
		*e = DestinationGcsSchemasCompressionCodec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsSchemasCompressionCodec: %v", v)
	}
}

type DestinationGcsSchemasFormatOutputFormatFormatType string

const (
	DestinationGcsSchemasFormatOutputFormatFormatTypeParquet DestinationGcsSchemasFormatOutputFormatFormatType = "Parquet"
)

func (e DestinationGcsSchemasFormatOutputFormatFormatType) ToPointer() *DestinationGcsSchemasFormatOutputFormatFormatType {
	return &e
}

func (e *DestinationGcsSchemasFormatOutputFormatFormatType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Parquet":
		*e = DestinationGcsSchemasFormatOutputFormatFormatType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsSchemasFormatOutputFormatFormatType: %v", v)
	}
}

type DestinationGcsParquetColumnarStorage struct {
	// This is the size of a row group being buffered in memory. It limits the memory usage when writing. Larger values will improve the IO when reading, but consume more memory when writing. Default: 128 MB.
	BlockSizeMb *int64 `default:"128" json:"block_size_mb"`
	// The compression algorithm used to compress data pages.
	CompressionCodec *DestinationGcsSchemasCompressionCodec `default:"UNCOMPRESSED" json:"compression_codec"`
	// Default: true.
	DictionaryEncoding *bool `default:"true" json:"dictionary_encoding"`
	// There is one dictionary page per column per row group when dictionary encoding is used. The dictionary page size works like the page size but for dictionary. Default: 1024 KB.
	DictionaryPageSizeKb *int64                                             `default:"1024" json:"dictionary_page_size_kb"`
	FormatType           *DestinationGcsSchemasFormatOutputFormatFormatType `default:"Parquet" json:"format_type"`
	// Maximum size allowed as padding to align row groups. This is also the minimum size of a row group. Default: 8 MB.
	MaxPaddingSizeMb *int64 `default:"8" json:"max_padding_size_mb"`
	// The page size is for compression. A block is composed of pages. A page is the smallest unit that must be read fully to access a single record. If this value is too small, the compression will deteriorate. Default: 1024 KB.
	PageSizeKb *int64 `default:"1024" json:"page_size_kb"`
}

func (d DestinationGcsParquetColumnarStorage) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsParquetColumnarStorage) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationGcsParquetColumnarStorage) GetBlockSizeMb() *int64 {
	if o == nil {
		return nil
	}
	return o.BlockSizeMb
}

func (o *DestinationGcsParquetColumnarStorage) GetCompressionCodec() *DestinationGcsSchemasCompressionCodec {
	if o == nil {
		return nil
	}
	return o.CompressionCodec
}

func (o *DestinationGcsParquetColumnarStorage) GetDictionaryEncoding() *bool {
	if o == nil {
		return nil
	}
	return o.DictionaryEncoding
}

func (o *DestinationGcsParquetColumnarStorage) GetDictionaryPageSizeKb() *int64 {
	if o == nil {
		return nil
	}
	return o.DictionaryPageSizeKb
}

func (o *DestinationGcsParquetColumnarStorage) GetFormatType() *DestinationGcsSchemasFormatOutputFormatFormatType {
	if o == nil {
		return nil
	}
	return o.FormatType
}

func (o *DestinationGcsParquetColumnarStorage) GetMaxPaddingSizeMb() *int64 {
	if o == nil {
		return nil
	}
	return o.MaxPaddingSizeMb
}

func (o *DestinationGcsParquetColumnarStorage) GetPageSizeKb() *int64 {
	if o == nil {
		return nil
	}
	return o.PageSizeKb
}

type DestinationGcsSchemasFormatOutputFormatCompressionType string

const (
	DestinationGcsSchemasFormatOutputFormatCompressionTypeGzip DestinationGcsSchemasFormatOutputFormatCompressionType = "GZIP"
)

func (e DestinationGcsSchemasFormatOutputFormatCompressionType) ToPointer() *DestinationGcsSchemasFormatOutputFormatCompressionType {
	return &e
}

func (e *DestinationGcsSchemasFormatOutputFormatCompressionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "GZIP":
		*e = DestinationGcsSchemasFormatOutputFormatCompressionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsSchemasFormatOutputFormatCompressionType: %v", v)
	}
}

type DestinationGcsSchemasGZIP struct {
	CompressionType *DestinationGcsSchemasFormatOutputFormatCompressionType `default:"GZIP" json:"compression_type"`
}

func (d DestinationGcsSchemasGZIP) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsSchemasGZIP) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationGcsSchemasGZIP) GetCompressionType() *DestinationGcsSchemasFormatOutputFormatCompressionType {
	if o == nil {
		return nil
	}
	return o.CompressionType
}

type DestinationGcsSchemasFormatCompressionType string

const (
	DestinationGcsSchemasFormatCompressionTypeNoCompression DestinationGcsSchemasFormatCompressionType = "No Compression"
)

func (e DestinationGcsSchemasFormatCompressionType) ToPointer() *DestinationGcsSchemasFormatCompressionType {
	return &e
}

func (e *DestinationGcsSchemasFormatCompressionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "No Compression":
		*e = DestinationGcsSchemasFormatCompressionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsSchemasFormatCompressionType: %v", v)
	}
}

type DestinationGcsSchemasFormatNoCompression struct {
	CompressionType *DestinationGcsSchemasFormatCompressionType `default:"No Compression" json:"compression_type"`
}

func (d DestinationGcsSchemasFormatNoCompression) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsSchemasFormatNoCompression) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationGcsSchemasFormatNoCompression) GetCompressionType() *DestinationGcsSchemasFormatCompressionType {
	if o == nil {
		return nil
	}
	return o.CompressionType
}

type DestinationGcsSchemasCompressionUnionType string

const (
	DestinationGcsSchemasCompressionUnionTypeDestinationGcsSchemasFormatNoCompression DestinationGcsSchemasCompressionUnionType = "destination-gcs_Schemas_format_No Compression"
	DestinationGcsSchemasCompressionUnionTypeDestinationGcsSchemasGZIP                DestinationGcsSchemasCompressionUnionType = "destination-gcs_Schemas_GZIP"
)

// DestinationGcsSchemasCompression - Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").
type DestinationGcsSchemasCompression struct {
	DestinationGcsSchemasFormatNoCompression *DestinationGcsSchemasFormatNoCompression
	DestinationGcsSchemasGZIP                *DestinationGcsSchemasGZIP

	Type DestinationGcsSchemasCompressionUnionType
}

func CreateDestinationGcsSchemasCompressionDestinationGcsSchemasFormatNoCompression(destinationGcsSchemasFormatNoCompression DestinationGcsSchemasFormatNoCompression) DestinationGcsSchemasCompression {
	typ := DestinationGcsSchemasCompressionUnionTypeDestinationGcsSchemasFormatNoCompression

	return DestinationGcsSchemasCompression{
		DestinationGcsSchemasFormatNoCompression: &destinationGcsSchemasFormatNoCompression,
		Type:                                     typ,
	}
}

func CreateDestinationGcsSchemasCompressionDestinationGcsSchemasGZIP(destinationGcsSchemasGZIP DestinationGcsSchemasGZIP) DestinationGcsSchemasCompression {
	typ := DestinationGcsSchemasCompressionUnionTypeDestinationGcsSchemasGZIP

	return DestinationGcsSchemasCompression{
		DestinationGcsSchemasGZIP: &destinationGcsSchemasGZIP,
		Type:                      typ,
	}
}

func (u *DestinationGcsSchemasCompression) UnmarshalJSON(data []byte) error {

	var destinationGcsSchemasFormatNoCompression DestinationGcsSchemasFormatNoCompression = DestinationGcsSchemasFormatNoCompression{}
	if err := utils.UnmarshalJSON(data, &destinationGcsSchemasFormatNoCompression, "", true, true); err == nil {
		u.DestinationGcsSchemasFormatNoCompression = &destinationGcsSchemasFormatNoCompression
		u.Type = DestinationGcsSchemasCompressionUnionTypeDestinationGcsSchemasFormatNoCompression
		return nil
	}

	var destinationGcsSchemasGZIP DestinationGcsSchemasGZIP = DestinationGcsSchemasGZIP{}
	if err := utils.UnmarshalJSON(data, &destinationGcsSchemasGZIP, "", true, true); err == nil {
		u.DestinationGcsSchemasGZIP = &destinationGcsSchemasGZIP
		u.Type = DestinationGcsSchemasCompressionUnionTypeDestinationGcsSchemasGZIP
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u DestinationGcsSchemasCompression) MarshalJSON() ([]byte, error) {
	if u.DestinationGcsSchemasFormatNoCompression != nil {
		return utils.MarshalJSON(u.DestinationGcsSchemasFormatNoCompression, "", true)
	}

	if u.DestinationGcsSchemasGZIP != nil {
		return utils.MarshalJSON(u.DestinationGcsSchemasGZIP, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type DestinationGcsSchemasFormatFormatType string

const (
	DestinationGcsSchemasFormatFormatTypeJsonl DestinationGcsSchemasFormatFormatType = "JSONL"
)

func (e DestinationGcsSchemasFormatFormatType) ToPointer() *DestinationGcsSchemasFormatFormatType {
	return &e
}

func (e *DestinationGcsSchemasFormatFormatType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "JSONL":
		*e = DestinationGcsSchemasFormatFormatType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsSchemasFormatFormatType: %v", v)
	}
}

type DestinationGcsJSONLinesNewlineDelimitedJSON struct {
	// Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").
	Compression *DestinationGcsSchemasCompression      `json:"compression,omitempty"`
	FormatType  *DestinationGcsSchemasFormatFormatType `default:"JSONL" json:"format_type"`
}

func (d DestinationGcsJSONLinesNewlineDelimitedJSON) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsJSONLinesNewlineDelimitedJSON) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationGcsJSONLinesNewlineDelimitedJSON) GetCompression() *DestinationGcsSchemasCompression {
	if o == nil {
		return nil
	}
	return o.Compression
}

func (o *DestinationGcsJSONLinesNewlineDelimitedJSON) GetFormatType() *DestinationGcsSchemasFormatFormatType {
	if o == nil {
		return nil
	}
	return o.FormatType
}

type DestinationGcsSchemasCompressionType string

const (
	DestinationGcsSchemasCompressionTypeGzip DestinationGcsSchemasCompressionType = "GZIP"
)

func (e DestinationGcsSchemasCompressionType) ToPointer() *DestinationGcsSchemasCompressionType {
	return &e
}

func (e *DestinationGcsSchemasCompressionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "GZIP":
		*e = DestinationGcsSchemasCompressionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsSchemasCompressionType: %v", v)
	}
}

type DestinationGcsGZIP struct {
	CompressionType *DestinationGcsSchemasCompressionType `default:"GZIP" json:"compression_type"`
}

func (d DestinationGcsGZIP) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsGZIP) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationGcsGZIP) GetCompressionType() *DestinationGcsSchemasCompressionType {
	if o == nil {
		return nil
	}
	return o.CompressionType
}

type DestinationGcsCompressionType string

const (
	DestinationGcsCompressionTypeNoCompression DestinationGcsCompressionType = "No Compression"
)

func (e DestinationGcsCompressionType) ToPointer() *DestinationGcsCompressionType {
	return &e
}

func (e *DestinationGcsCompressionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "No Compression":
		*e = DestinationGcsCompressionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsCompressionType: %v", v)
	}
}

type DestinationGcsSchemasNoCompression struct {
	CompressionType *DestinationGcsCompressionType `default:"No Compression" json:"compression_type"`
}

func (d DestinationGcsSchemasNoCompression) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsSchemasNoCompression) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationGcsSchemasNoCompression) GetCompressionType() *DestinationGcsCompressionType {
	if o == nil {
		return nil
	}
	return o.CompressionType
}

type DestinationGcsCompressionUnionType string

const (
	DestinationGcsCompressionUnionTypeDestinationGcsSchemasNoCompression DestinationGcsCompressionUnionType = "destination-gcs_Schemas_No Compression"
	DestinationGcsCompressionUnionTypeDestinationGcsGZIP                 DestinationGcsCompressionUnionType = "destination-gcs_GZIP"
)

// DestinationGcsCompression - Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".csv.gz").
type DestinationGcsCompression struct {
	DestinationGcsSchemasNoCompression *DestinationGcsSchemasNoCompression
	DestinationGcsGZIP                 *DestinationGcsGZIP

	Type DestinationGcsCompressionUnionType
}

func CreateDestinationGcsCompressionDestinationGcsSchemasNoCompression(destinationGcsSchemasNoCompression DestinationGcsSchemasNoCompression) DestinationGcsCompression {
	typ := DestinationGcsCompressionUnionTypeDestinationGcsSchemasNoCompression

	return DestinationGcsCompression{
		DestinationGcsSchemasNoCompression: &destinationGcsSchemasNoCompression,
		Type:                               typ,
	}
}

func CreateDestinationGcsCompressionDestinationGcsGZIP(destinationGcsGZIP DestinationGcsGZIP) DestinationGcsCompression {
	typ := DestinationGcsCompressionUnionTypeDestinationGcsGZIP

	return DestinationGcsCompression{
		DestinationGcsGZIP: &destinationGcsGZIP,
		Type:               typ,
	}
}

func (u *DestinationGcsCompression) UnmarshalJSON(data []byte) error {

	var destinationGcsSchemasNoCompression DestinationGcsSchemasNoCompression = DestinationGcsSchemasNoCompression{}
	if err := utils.UnmarshalJSON(data, &destinationGcsSchemasNoCompression, "", true, true); err == nil {
		u.DestinationGcsSchemasNoCompression = &destinationGcsSchemasNoCompression
		u.Type = DestinationGcsCompressionUnionTypeDestinationGcsSchemasNoCompression
		return nil
	}

	var destinationGcsGZIP DestinationGcsGZIP = DestinationGcsGZIP{}
	if err := utils.UnmarshalJSON(data, &destinationGcsGZIP, "", true, true); err == nil {
		u.DestinationGcsGZIP = &destinationGcsGZIP
		u.Type = DestinationGcsCompressionUnionTypeDestinationGcsGZIP
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u DestinationGcsCompression) MarshalJSON() ([]byte, error) {
	if u.DestinationGcsSchemasNoCompression != nil {
		return utils.MarshalJSON(u.DestinationGcsSchemasNoCompression, "", true)
	}

	if u.DestinationGcsGZIP != nil {
		return utils.MarshalJSON(u.DestinationGcsGZIP, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

// DestinationGcsNormalization - Whether the input JSON data should be normalized (flattened) in the output CSV. Please refer to docs for details.
type DestinationGcsNormalization string

const (
	DestinationGcsNormalizationNoFlattening        DestinationGcsNormalization = "No flattening"
	DestinationGcsNormalizationRootLevelFlattening DestinationGcsNormalization = "Root level flattening"
)

func (e DestinationGcsNormalization) ToPointer() *DestinationGcsNormalization {
	return &e
}

func (e *DestinationGcsNormalization) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "No flattening":
		fallthrough
	case "Root level flattening":
		*e = DestinationGcsNormalization(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsNormalization: %v", v)
	}
}

type DestinationGcsSchemasFormatType string

const (
	DestinationGcsSchemasFormatTypeCsv DestinationGcsSchemasFormatType = "CSV"
)

func (e DestinationGcsSchemasFormatType) ToPointer() *DestinationGcsSchemasFormatType {
	return &e
}

func (e *DestinationGcsSchemasFormatType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CSV":
		*e = DestinationGcsSchemasFormatType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsSchemasFormatType: %v", v)
	}
}

type DestinationGcsCSVCommaSeparatedValues struct {
	// Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".csv.gz").
	Compression *DestinationGcsCompression `json:"compression,omitempty"`
	// Whether the input JSON data should be normalized (flattened) in the output CSV. Please refer to docs for details.
	Flattening *DestinationGcsNormalization     `default:"No flattening" json:"flattening"`
	FormatType *DestinationGcsSchemasFormatType `default:"CSV" json:"format_type"`
}

func (d DestinationGcsCSVCommaSeparatedValues) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsCSVCommaSeparatedValues) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationGcsCSVCommaSeparatedValues) GetCompression() *DestinationGcsCompression {
	if o == nil {
		return nil
	}
	return o.Compression
}

func (o *DestinationGcsCSVCommaSeparatedValues) GetFlattening() *DestinationGcsNormalization {
	if o == nil {
		return nil
	}
	return o.Flattening
}

func (o *DestinationGcsCSVCommaSeparatedValues) GetFormatType() *DestinationGcsSchemasFormatType {
	if o == nil {
		return nil
	}
	return o.FormatType
}

type DestinationGcsSchemasFormatOutputFormat1CompressionCodecCodec string

const (
	DestinationGcsSchemasFormatOutputFormat1CompressionCodecCodecSnappy DestinationGcsSchemasFormatOutputFormat1CompressionCodecCodec = "snappy"
)

func (e DestinationGcsSchemasFormatOutputFormat1CompressionCodecCodec) ToPointer() *DestinationGcsSchemasFormatOutputFormat1CompressionCodecCodec {
	return &e
}

func (e *DestinationGcsSchemasFormatOutputFormat1CompressionCodecCodec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "snappy":
		*e = DestinationGcsSchemasFormatOutputFormat1CompressionCodecCodec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsSchemasFormatOutputFormat1CompressionCodecCodec: %v", v)
	}
}

type DestinationGcsSnappy struct {
	Codec *DestinationGcsSchemasFormatOutputFormat1CompressionCodecCodec `default:"snappy" json:"codec"`
}

func (d DestinationGcsSnappy) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsSnappy) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationGcsSnappy) GetCodec() *DestinationGcsSchemasFormatOutputFormat1CompressionCodecCodec {
	if o == nil {
		return nil
	}
	return o.Codec
}

type DestinationGcsSchemasFormatOutputFormat1Codec string

const (
	DestinationGcsSchemasFormatOutputFormat1CodecZstandard DestinationGcsSchemasFormatOutputFormat1Codec = "zstandard"
)

func (e DestinationGcsSchemasFormatOutputFormat1Codec) ToPointer() *DestinationGcsSchemasFormatOutputFormat1Codec {
	return &e
}

func (e *DestinationGcsSchemasFormatOutputFormat1Codec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "zstandard":
		*e = DestinationGcsSchemasFormatOutputFormat1Codec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsSchemasFormatOutputFormat1Codec: %v", v)
	}
}

type DestinationGcsZstandard struct {
	Codec *DestinationGcsSchemasFormatOutputFormat1Codec `default:"zstandard" json:"codec"`
	// Negative levels are 'fast' modes akin to lz4 or snappy, levels above 9 are generally for archival purposes, and levels above 18 use a lot of memory.
	CompressionLevel *int64 `default:"3" json:"compression_level"`
	// If true, include a checksum with each data block.
	IncludeChecksum *bool `default:"false" json:"include_checksum"`
}

func (d DestinationGcsZstandard) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsZstandard) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationGcsZstandard) GetCodec() *DestinationGcsSchemasFormatOutputFormat1Codec {
	if o == nil {
		return nil
	}
	return o.Codec
}

func (o *DestinationGcsZstandard) GetCompressionLevel() *int64 {
	if o == nil {
		return nil
	}
	return o.CompressionLevel
}

func (o *DestinationGcsZstandard) GetIncludeChecksum() *bool {
	if o == nil {
		return nil
	}
	return o.IncludeChecksum
}

type DestinationGcsSchemasFormatOutputFormatCodec string

const (
	DestinationGcsSchemasFormatOutputFormatCodecXz DestinationGcsSchemasFormatOutputFormatCodec = "xz"
)

func (e DestinationGcsSchemasFormatOutputFormatCodec) ToPointer() *DestinationGcsSchemasFormatOutputFormatCodec {
	return &e
}

func (e *DestinationGcsSchemasFormatOutputFormatCodec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "xz":
		*e = DestinationGcsSchemasFormatOutputFormatCodec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsSchemasFormatOutputFormatCodec: %v", v)
	}
}

type DestinationGcsXz struct {
	Codec *DestinationGcsSchemasFormatOutputFormatCodec `default:"xz" json:"codec"`
	// The presets 0-3 are fast presets with medium compression. The presets 4-6 are fairly slow presets with high compression. The default preset is 6. The presets 7-9 are like the preset 6 but use bigger dictionaries and have higher compressor and decompressor memory requirements. Unless the uncompressed size of the file exceeds 8 MiB, 16 MiB, or 32 MiB, it is waste of memory to use the presets 7, 8, or 9, respectively. Read more <a href="https://commons.apache.org/proper/commons-compress/apidocs/org/apache/commons/compress/compressors/xz/XZCompressorOutputStream.html#XZCompressorOutputStream-java.io.OutputStream-int-">here</a> for details.
	CompressionLevel *int64 `default:"6" json:"compression_level"`
}

func (d DestinationGcsXz) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsXz) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationGcsXz) GetCodec() *DestinationGcsSchemasFormatOutputFormatCodec {
	if o == nil {
		return nil
	}
	return o.Codec
}

func (o *DestinationGcsXz) GetCompressionLevel() *int64 {
	if o == nil {
		return nil
	}
	return o.CompressionLevel
}

type DestinationGcsSchemasFormatCodec string

const (
	DestinationGcsSchemasFormatCodecBzip2 DestinationGcsSchemasFormatCodec = "bzip2"
)

func (e DestinationGcsSchemasFormatCodec) ToPointer() *DestinationGcsSchemasFormatCodec {
	return &e
}

func (e *DestinationGcsSchemasFormatCodec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "bzip2":
		*e = DestinationGcsSchemasFormatCodec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsSchemasFormatCodec: %v", v)
	}
}

type DestinationGcsBzip2 struct {
	Codec *DestinationGcsSchemasFormatCodec `default:"bzip2" json:"codec"`
}

func (d DestinationGcsBzip2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsBzip2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationGcsBzip2) GetCodec() *DestinationGcsSchemasFormatCodec {
	if o == nil {
		return nil
	}
	return o.Codec
}

type DestinationGcsSchemasCodec string

const (
	DestinationGcsSchemasCodecDeflate DestinationGcsSchemasCodec = "Deflate"
)

func (e DestinationGcsSchemasCodec) ToPointer() *DestinationGcsSchemasCodec {
	return &e
}

func (e *DestinationGcsSchemasCodec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Deflate":
		*e = DestinationGcsSchemasCodec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsSchemasCodec: %v", v)
	}
}

type DestinationGcsDeflate struct {
	Codec *DestinationGcsSchemasCodec `default:"Deflate" json:"codec"`
	// 0: no compression & fastest, 9: best compression & slowest.
	CompressionLevel *int64 `default:"0" json:"compression_level"`
}

func (d DestinationGcsDeflate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsDeflate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationGcsDeflate) GetCodec() *DestinationGcsSchemasCodec {
	if o == nil {
		return nil
	}
	return o.Codec
}

func (o *DestinationGcsDeflate) GetCompressionLevel() *int64 {
	if o == nil {
		return nil
	}
	return o.CompressionLevel
}

type DestinationGcsCodec string

const (
	DestinationGcsCodecNoCompression DestinationGcsCodec = "no compression"
)

func (e DestinationGcsCodec) ToPointer() *DestinationGcsCodec {
	return &e
}

func (e *DestinationGcsCodec) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "no compression":
		*e = DestinationGcsCodec(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsCodec: %v", v)
	}
}

type DestinationGcsNoCompression struct {
	Codec *DestinationGcsCodec `default:"no compression" json:"codec"`
}

func (d DestinationGcsNoCompression) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsNoCompression) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationGcsNoCompression) GetCodec() *DestinationGcsCodec {
	if o == nil {
		return nil
	}
	return o.Codec
}

type DestinationGcsCompressionCodecType string

const (
	DestinationGcsCompressionCodecTypeDestinationGcsNoCompression DestinationGcsCompressionCodecType = "destination-gcs_No Compression"
	DestinationGcsCompressionCodecTypeDestinationGcsDeflate       DestinationGcsCompressionCodecType = "destination-gcs_Deflate"
	DestinationGcsCompressionCodecTypeDestinationGcsBzip2         DestinationGcsCompressionCodecType = "destination-gcs_bzip2"
	DestinationGcsCompressionCodecTypeDestinationGcsXz            DestinationGcsCompressionCodecType = "destination-gcs_xz"
	DestinationGcsCompressionCodecTypeDestinationGcsZstandard     DestinationGcsCompressionCodecType = "destination-gcs_zstandard"
	DestinationGcsCompressionCodecTypeDestinationGcsSnappy        DestinationGcsCompressionCodecType = "destination-gcs_snappy"
)

// DestinationGcsCompressionCodec - The compression algorithm used to compress data. Default to no compression.
type DestinationGcsCompressionCodec struct {
	DestinationGcsNoCompression *DestinationGcsNoCompression
	DestinationGcsDeflate       *DestinationGcsDeflate
	DestinationGcsBzip2         *DestinationGcsBzip2
	DestinationGcsXz            *DestinationGcsXz
	DestinationGcsZstandard     *DestinationGcsZstandard
	DestinationGcsSnappy        *DestinationGcsSnappy

	Type DestinationGcsCompressionCodecType
}

func CreateDestinationGcsCompressionCodecDestinationGcsNoCompression(destinationGcsNoCompression DestinationGcsNoCompression) DestinationGcsCompressionCodec {
	typ := DestinationGcsCompressionCodecTypeDestinationGcsNoCompression

	return DestinationGcsCompressionCodec{
		DestinationGcsNoCompression: &destinationGcsNoCompression,
		Type:                        typ,
	}
}

func CreateDestinationGcsCompressionCodecDestinationGcsDeflate(destinationGcsDeflate DestinationGcsDeflate) DestinationGcsCompressionCodec {
	typ := DestinationGcsCompressionCodecTypeDestinationGcsDeflate

	return DestinationGcsCompressionCodec{
		DestinationGcsDeflate: &destinationGcsDeflate,
		Type:                  typ,
	}
}

func CreateDestinationGcsCompressionCodecDestinationGcsBzip2(destinationGcsBzip2 DestinationGcsBzip2) DestinationGcsCompressionCodec {
	typ := DestinationGcsCompressionCodecTypeDestinationGcsBzip2

	return DestinationGcsCompressionCodec{
		DestinationGcsBzip2: &destinationGcsBzip2,
		Type:                typ,
	}
}

func CreateDestinationGcsCompressionCodecDestinationGcsXz(destinationGcsXz DestinationGcsXz) DestinationGcsCompressionCodec {
	typ := DestinationGcsCompressionCodecTypeDestinationGcsXz

	return DestinationGcsCompressionCodec{
		DestinationGcsXz: &destinationGcsXz,
		Type:             typ,
	}
}

func CreateDestinationGcsCompressionCodecDestinationGcsZstandard(destinationGcsZstandard DestinationGcsZstandard) DestinationGcsCompressionCodec {
	typ := DestinationGcsCompressionCodecTypeDestinationGcsZstandard

	return DestinationGcsCompressionCodec{
		DestinationGcsZstandard: &destinationGcsZstandard,
		Type:                    typ,
	}
}

func CreateDestinationGcsCompressionCodecDestinationGcsSnappy(destinationGcsSnappy DestinationGcsSnappy) DestinationGcsCompressionCodec {
	typ := DestinationGcsCompressionCodecTypeDestinationGcsSnappy

	return DestinationGcsCompressionCodec{
		DestinationGcsSnappy: &destinationGcsSnappy,
		Type:                 typ,
	}
}

func (u *DestinationGcsCompressionCodec) UnmarshalJSON(data []byte) error {

	var destinationGcsNoCompression DestinationGcsNoCompression = DestinationGcsNoCompression{}
	if err := utils.UnmarshalJSON(data, &destinationGcsNoCompression, "", true, true); err == nil {
		u.DestinationGcsNoCompression = &destinationGcsNoCompression
		u.Type = DestinationGcsCompressionCodecTypeDestinationGcsNoCompression
		return nil
	}

	var destinationGcsBzip2 DestinationGcsBzip2 = DestinationGcsBzip2{}
	if err := utils.UnmarshalJSON(data, &destinationGcsBzip2, "", true, true); err == nil {
		u.DestinationGcsBzip2 = &destinationGcsBzip2
		u.Type = DestinationGcsCompressionCodecTypeDestinationGcsBzip2
		return nil
	}

	var destinationGcsSnappy DestinationGcsSnappy = DestinationGcsSnappy{}
	if err := utils.UnmarshalJSON(data, &destinationGcsSnappy, "", true, true); err == nil {
		u.DestinationGcsSnappy = &destinationGcsSnappy
		u.Type = DestinationGcsCompressionCodecTypeDestinationGcsSnappy
		return nil
	}

	var destinationGcsDeflate DestinationGcsDeflate = DestinationGcsDeflate{}
	if err := utils.UnmarshalJSON(data, &destinationGcsDeflate, "", true, true); err == nil {
		u.DestinationGcsDeflate = &destinationGcsDeflate
		u.Type = DestinationGcsCompressionCodecTypeDestinationGcsDeflate
		return nil
	}

	var destinationGcsXz DestinationGcsXz = DestinationGcsXz{}
	if err := utils.UnmarshalJSON(data, &destinationGcsXz, "", true, true); err == nil {
		u.DestinationGcsXz = &destinationGcsXz
		u.Type = DestinationGcsCompressionCodecTypeDestinationGcsXz
		return nil
	}

	var destinationGcsZstandard DestinationGcsZstandard = DestinationGcsZstandard{}
	if err := utils.UnmarshalJSON(data, &destinationGcsZstandard, "", true, true); err == nil {
		u.DestinationGcsZstandard = &destinationGcsZstandard
		u.Type = DestinationGcsCompressionCodecTypeDestinationGcsZstandard
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u DestinationGcsCompressionCodec) MarshalJSON() ([]byte, error) {
	if u.DestinationGcsNoCompression != nil {
		return utils.MarshalJSON(u.DestinationGcsNoCompression, "", true)
	}

	if u.DestinationGcsDeflate != nil {
		return utils.MarshalJSON(u.DestinationGcsDeflate, "", true)
	}

	if u.DestinationGcsBzip2 != nil {
		return utils.MarshalJSON(u.DestinationGcsBzip2, "", true)
	}

	if u.DestinationGcsXz != nil {
		return utils.MarshalJSON(u.DestinationGcsXz, "", true)
	}

	if u.DestinationGcsZstandard != nil {
		return utils.MarshalJSON(u.DestinationGcsZstandard, "", true)
	}

	if u.DestinationGcsSnappy != nil {
		return utils.MarshalJSON(u.DestinationGcsSnappy, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type DestinationGcsFormatType string

const (
	DestinationGcsFormatTypeAvro DestinationGcsFormatType = "Avro"
)

func (e DestinationGcsFormatType) ToPointer() *DestinationGcsFormatType {
	return &e
}

func (e *DestinationGcsFormatType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Avro":
		*e = DestinationGcsFormatType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsFormatType: %v", v)
	}
}

type DestinationGcsAvroApacheAvro struct {
	// The compression algorithm used to compress data. Default to no compression.
	CompressionCodec DestinationGcsCompressionCodec `json:"compression_codec"`
	FormatType       *DestinationGcsFormatType      `default:"Avro" json:"format_type"`
}

func (d DestinationGcsAvroApacheAvro) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsAvroApacheAvro) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DestinationGcsAvroApacheAvro) GetCompressionCodec() DestinationGcsCompressionCodec {
	if o == nil {
		return DestinationGcsCompressionCodec{}
	}
	return o.CompressionCodec
}

func (o *DestinationGcsAvroApacheAvro) GetFormatType() *DestinationGcsFormatType {
	if o == nil {
		return nil
	}
	return o.FormatType
}

type DestinationGcsOutputFormatType string

const (
	DestinationGcsOutputFormatTypeDestinationGcsAvroApacheAvro                DestinationGcsOutputFormatType = "destination-gcs_Avro: Apache Avro"
	DestinationGcsOutputFormatTypeDestinationGcsCSVCommaSeparatedValues       DestinationGcsOutputFormatType = "destination-gcs_CSV: Comma-Separated Values"
	DestinationGcsOutputFormatTypeDestinationGcsJSONLinesNewlineDelimitedJSON DestinationGcsOutputFormatType = "destination-gcs_JSON Lines: newline-delimited JSON"
	DestinationGcsOutputFormatTypeDestinationGcsParquetColumnarStorage        DestinationGcsOutputFormatType = "destination-gcs_Parquet: Columnar Storage"
)

// DestinationGcsOutputFormat - Output data format. One of the following formats must be selected - <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-avro#advantages_of_avro">AVRO</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-parquet#parquet_schemas">PARQUET</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-csv#loading_csv_data_into_a_table">CSV</a> format, or <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-json#loading_json_data_into_a_new_table">JSONL</a> format.
type DestinationGcsOutputFormat struct {
	DestinationGcsAvroApacheAvro                *DestinationGcsAvroApacheAvro
	DestinationGcsCSVCommaSeparatedValues       *DestinationGcsCSVCommaSeparatedValues
	DestinationGcsJSONLinesNewlineDelimitedJSON *DestinationGcsJSONLinesNewlineDelimitedJSON
	DestinationGcsParquetColumnarStorage        *DestinationGcsParquetColumnarStorage

	Type DestinationGcsOutputFormatType
}

func CreateDestinationGcsOutputFormatDestinationGcsAvroApacheAvro(destinationGcsAvroApacheAvro DestinationGcsAvroApacheAvro) DestinationGcsOutputFormat {
	typ := DestinationGcsOutputFormatTypeDestinationGcsAvroApacheAvro

	return DestinationGcsOutputFormat{
		DestinationGcsAvroApacheAvro: &destinationGcsAvroApacheAvro,
		Type:                         typ,
	}
}

func CreateDestinationGcsOutputFormatDestinationGcsCSVCommaSeparatedValues(destinationGcsCSVCommaSeparatedValues DestinationGcsCSVCommaSeparatedValues) DestinationGcsOutputFormat {
	typ := DestinationGcsOutputFormatTypeDestinationGcsCSVCommaSeparatedValues

	return DestinationGcsOutputFormat{
		DestinationGcsCSVCommaSeparatedValues: &destinationGcsCSVCommaSeparatedValues,
		Type:                                  typ,
	}
}

func CreateDestinationGcsOutputFormatDestinationGcsJSONLinesNewlineDelimitedJSON(destinationGcsJSONLinesNewlineDelimitedJSON DestinationGcsJSONLinesNewlineDelimitedJSON) DestinationGcsOutputFormat {
	typ := DestinationGcsOutputFormatTypeDestinationGcsJSONLinesNewlineDelimitedJSON

	return DestinationGcsOutputFormat{
		DestinationGcsJSONLinesNewlineDelimitedJSON: &destinationGcsJSONLinesNewlineDelimitedJSON,
		Type: typ,
	}
}

func CreateDestinationGcsOutputFormatDestinationGcsParquetColumnarStorage(destinationGcsParquetColumnarStorage DestinationGcsParquetColumnarStorage) DestinationGcsOutputFormat {
	typ := DestinationGcsOutputFormatTypeDestinationGcsParquetColumnarStorage

	return DestinationGcsOutputFormat{
		DestinationGcsParquetColumnarStorage: &destinationGcsParquetColumnarStorage,
		Type:                                 typ,
	}
}

func (u *DestinationGcsOutputFormat) UnmarshalJSON(data []byte) error {

	var destinationGcsAvroApacheAvro DestinationGcsAvroApacheAvro = DestinationGcsAvroApacheAvro{}
	if err := utils.UnmarshalJSON(data, &destinationGcsAvroApacheAvro, "", true, true); err == nil {
		u.DestinationGcsAvroApacheAvro = &destinationGcsAvroApacheAvro
		u.Type = DestinationGcsOutputFormatTypeDestinationGcsAvroApacheAvro
		return nil
	}

	var destinationGcsJSONLinesNewlineDelimitedJSON DestinationGcsJSONLinesNewlineDelimitedJSON = DestinationGcsJSONLinesNewlineDelimitedJSON{}
	if err := utils.UnmarshalJSON(data, &destinationGcsJSONLinesNewlineDelimitedJSON, "", true, true); err == nil {
		u.DestinationGcsJSONLinesNewlineDelimitedJSON = &destinationGcsJSONLinesNewlineDelimitedJSON
		u.Type = DestinationGcsOutputFormatTypeDestinationGcsJSONLinesNewlineDelimitedJSON
		return nil
	}

	var destinationGcsCSVCommaSeparatedValues DestinationGcsCSVCommaSeparatedValues = DestinationGcsCSVCommaSeparatedValues{}
	if err := utils.UnmarshalJSON(data, &destinationGcsCSVCommaSeparatedValues, "", true, true); err == nil {
		u.DestinationGcsCSVCommaSeparatedValues = &destinationGcsCSVCommaSeparatedValues
		u.Type = DestinationGcsOutputFormatTypeDestinationGcsCSVCommaSeparatedValues
		return nil
	}

	var destinationGcsParquetColumnarStorage DestinationGcsParquetColumnarStorage = DestinationGcsParquetColumnarStorage{}
	if err := utils.UnmarshalJSON(data, &destinationGcsParquetColumnarStorage, "", true, true); err == nil {
		u.DestinationGcsParquetColumnarStorage = &destinationGcsParquetColumnarStorage
		u.Type = DestinationGcsOutputFormatTypeDestinationGcsParquetColumnarStorage
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u DestinationGcsOutputFormat) MarshalJSON() ([]byte, error) {
	if u.DestinationGcsAvroApacheAvro != nil {
		return utils.MarshalJSON(u.DestinationGcsAvroApacheAvro, "", true)
	}

	if u.DestinationGcsCSVCommaSeparatedValues != nil {
		return utils.MarshalJSON(u.DestinationGcsCSVCommaSeparatedValues, "", true)
	}

	if u.DestinationGcsJSONLinesNewlineDelimitedJSON != nil {
		return utils.MarshalJSON(u.DestinationGcsJSONLinesNewlineDelimitedJSON, "", true)
	}

	if u.DestinationGcsParquetColumnarStorage != nil {
		return utils.MarshalJSON(u.DestinationGcsParquetColumnarStorage, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

// DestinationGCSGCSBucketRegion - Select a Region of the GCS Bucket. Read more <a href="https://cloud.google.com/storage/docs/locations">here</a>.
type DestinationGCSGCSBucketRegion string

const (
	DestinationGCSGCSBucketRegionNorthamericaNortheast1 DestinationGCSGCSBucketRegion = "northamerica-northeast1"
	DestinationGCSGCSBucketRegionNorthamericaNortheast2 DestinationGCSGCSBucketRegion = "northamerica-northeast2"
	DestinationGCSGCSBucketRegionUsCentral1             DestinationGCSGCSBucketRegion = "us-central1"
	DestinationGCSGCSBucketRegionUsEast1                DestinationGCSGCSBucketRegion = "us-east1"
	DestinationGCSGCSBucketRegionUsEast4                DestinationGCSGCSBucketRegion = "us-east4"
	DestinationGCSGCSBucketRegionUsWest1                DestinationGCSGCSBucketRegion = "us-west1"
	DestinationGCSGCSBucketRegionUsWest2                DestinationGCSGCSBucketRegion = "us-west2"
	DestinationGCSGCSBucketRegionUsWest3                DestinationGCSGCSBucketRegion = "us-west3"
	DestinationGCSGCSBucketRegionUsWest4                DestinationGCSGCSBucketRegion = "us-west4"
	DestinationGCSGCSBucketRegionSouthamericaEast1      DestinationGCSGCSBucketRegion = "southamerica-east1"
	DestinationGCSGCSBucketRegionSouthamericaWest1      DestinationGCSGCSBucketRegion = "southamerica-west1"
	DestinationGCSGCSBucketRegionEuropeCentral2         DestinationGCSGCSBucketRegion = "europe-central2"
	DestinationGCSGCSBucketRegionEuropeNorth1           DestinationGCSGCSBucketRegion = "europe-north1"
	DestinationGCSGCSBucketRegionEuropeWest1            DestinationGCSGCSBucketRegion = "europe-west1"
	DestinationGCSGCSBucketRegionEuropeWest2            DestinationGCSGCSBucketRegion = "europe-west2"
	DestinationGCSGCSBucketRegionEuropeWest3            DestinationGCSGCSBucketRegion = "europe-west3"
	DestinationGCSGCSBucketRegionEuropeWest4            DestinationGCSGCSBucketRegion = "europe-west4"
	DestinationGCSGCSBucketRegionEuropeWest6            DestinationGCSGCSBucketRegion = "europe-west6"
	DestinationGCSGCSBucketRegionAsiaEast1              DestinationGCSGCSBucketRegion = "asia-east1"
	DestinationGCSGCSBucketRegionAsiaEast2              DestinationGCSGCSBucketRegion = "asia-east2"
	DestinationGCSGCSBucketRegionAsiaNortheast1         DestinationGCSGCSBucketRegion = "asia-northeast1"
	DestinationGCSGCSBucketRegionAsiaNortheast2         DestinationGCSGCSBucketRegion = "asia-northeast2"
	DestinationGCSGCSBucketRegionAsiaNortheast3         DestinationGCSGCSBucketRegion = "asia-northeast3"
	DestinationGCSGCSBucketRegionAsiaSouth1             DestinationGCSGCSBucketRegion = "asia-south1"
	DestinationGCSGCSBucketRegionAsiaSouth2             DestinationGCSGCSBucketRegion = "asia-south2"
	DestinationGCSGCSBucketRegionAsiaSoutheast1         DestinationGCSGCSBucketRegion = "asia-southeast1"
	DestinationGCSGCSBucketRegionAsiaSoutheast2         DestinationGCSGCSBucketRegion = "asia-southeast2"
	DestinationGCSGCSBucketRegionAustraliaSoutheast1    DestinationGCSGCSBucketRegion = "australia-southeast1"
	DestinationGCSGCSBucketRegionAustraliaSoutheast2    DestinationGCSGCSBucketRegion = "australia-southeast2"
	DestinationGCSGCSBucketRegionAsia                   DestinationGCSGCSBucketRegion = "asia"
	DestinationGCSGCSBucketRegionEu                     DestinationGCSGCSBucketRegion = "eu"
	DestinationGCSGCSBucketRegionUs                     DestinationGCSGCSBucketRegion = "us"
	DestinationGCSGCSBucketRegionAsia1                  DestinationGCSGCSBucketRegion = "asia1"
	DestinationGCSGCSBucketRegionEur4                   DestinationGCSGCSBucketRegion = "eur4"
	DestinationGCSGCSBucketRegionNam4                   DestinationGCSGCSBucketRegion = "nam4"
)

func (e DestinationGCSGCSBucketRegion) ToPointer() *DestinationGCSGCSBucketRegion {
	return &e
}

func (e *DestinationGCSGCSBucketRegion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "northamerica-northeast1":
		fallthrough
	case "northamerica-northeast2":
		fallthrough
	case "us-central1":
		fallthrough
	case "us-east1":
		fallthrough
	case "us-east4":
		fallthrough
	case "us-west1":
		fallthrough
	case "us-west2":
		fallthrough
	case "us-west3":
		fallthrough
	case "us-west4":
		fallthrough
	case "southamerica-east1":
		fallthrough
	case "southamerica-west1":
		fallthrough
	case "europe-central2":
		fallthrough
	case "europe-north1":
		fallthrough
	case "europe-west1":
		fallthrough
	case "europe-west2":
		fallthrough
	case "europe-west3":
		fallthrough
	case "europe-west4":
		fallthrough
	case "europe-west6":
		fallthrough
	case "asia-east1":
		fallthrough
	case "asia-east2":
		fallthrough
	case "asia-northeast1":
		fallthrough
	case "asia-northeast2":
		fallthrough
	case "asia-northeast3":
		fallthrough
	case "asia-south1":
		fallthrough
	case "asia-south2":
		fallthrough
	case "asia-southeast1":
		fallthrough
	case "asia-southeast2":
		fallthrough
	case "australia-southeast1":
		fallthrough
	case "australia-southeast2":
		fallthrough
	case "asia":
		fallthrough
	case "eu":
		fallthrough
	case "us":
		fallthrough
	case "asia1":
		fallthrough
	case "eur4":
		fallthrough
	case "nam4":
		*e = DestinationGCSGCSBucketRegion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGCSGCSBucketRegion: %v", v)
	}
}

type DestinationGcs struct {
	// An HMAC key is a type of credential and can be associated with a service account or a user account in Cloud Storage. Read more <a href="https://cloud.google.com/storage/docs/authentication/hmackeys">here</a>.
	Credential      DestinationGcsAuthentication `json:"credential"`
	destinationType Gcs                          `const:"gcs" json:"destinationType"`
	// Output data format. One of the following formats must be selected - <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-avro#advantages_of_avro">AVRO</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-parquet#parquet_schemas">PARQUET</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-csv#loading_csv_data_into_a_table">CSV</a> format, or <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-json#loading_json_data_into_a_new_table">JSONL</a> format.
	Format DestinationGcsOutputFormat `json:"format"`
	// You can find the bucket name in the App Engine Admin console Application Settings page, under the label Google Cloud Storage Bucket. Read more <a href="https://cloud.google.com/storage/docs/naming-buckets">here</a>.
	GcsBucketName string `json:"gcs_bucket_name"`
	// GCS Bucket Path string Subdirectory under the above bucket to sync the data into.
	GcsBucketPath string `json:"gcs_bucket_path"`
	// Select a Region of the GCS Bucket. Read more <a href="https://cloud.google.com/storage/docs/locations">here</a>.
	GcsBucketRegion *DestinationGCSGCSBucketRegion `default:"us" json:"gcs_bucket_region"`
}

func (d DestinationGcs) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcs) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *DestinationGcs) GetCredential() DestinationGcsAuthentication {
	if o == nil {
		return DestinationGcsAuthentication{}
	}
	return o.Credential
}

func (o *DestinationGcs) GetDestinationType() Gcs {
	return GcsGcs
}

func (o *DestinationGcs) GetFormat() DestinationGcsOutputFormat {
	if o == nil {
		return DestinationGcsOutputFormat{}
	}
	return o.Format
}

func (o *DestinationGcs) GetGcsBucketName() string {
	if o == nil {
		return ""
	}
	return o.GcsBucketName
}

func (o *DestinationGcs) GetGcsBucketPath() string {
	if o == nil {
		return ""
	}
	return o.GcsBucketPath
}

func (o *DestinationGcs) GetGcsBucketRegion() *DestinationGCSGCSBucketRegion {
	if o == nil {
		return nil
	}
	return o.GcsBucketRegion
}
