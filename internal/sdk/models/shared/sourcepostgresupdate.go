// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

type SourcePostgresUpdateSchemasReplicationMethodMethod string

const (
	SourcePostgresUpdateSchemasReplicationMethodMethodStandard SourcePostgresUpdateSchemasReplicationMethodMethod = "Standard"
)

func (e SourcePostgresUpdateSchemasReplicationMethodMethod) ToPointer() *SourcePostgresUpdateSchemasReplicationMethodMethod {
	return &e
}
func (e *SourcePostgresUpdateSchemasReplicationMethodMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Standard":
		*e = SourcePostgresUpdateSchemasReplicationMethodMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresUpdateSchemasReplicationMethodMethod: %v", v)
	}
}

// SourcePostgresUpdateScanChangesWithUserDefinedCursor - Incrementally detects new inserts and updates using the <a href="https://docs.airbyte.com/understanding-airbyte/connections/incremental-append/#user-defined-cursor">cursor column</a> chosen when configuring a connection (e.g. created_at, updated_at).
type SourcePostgresUpdateScanChangesWithUserDefinedCursor struct {
	method SourcePostgresUpdateSchemasReplicationMethodMethod `const:"Standard" json:"method"`
}

func (s SourcePostgresUpdateScanChangesWithUserDefinedCursor) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresUpdateScanChangesWithUserDefinedCursor) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresUpdateScanChangesWithUserDefinedCursor) GetMethod() SourcePostgresUpdateSchemasReplicationMethodMethod {
	return SourcePostgresUpdateSchemasReplicationMethodMethodStandard
}

type SourcePostgresUpdateSchemasMethod string

const (
	SourcePostgresUpdateSchemasMethodXmin SourcePostgresUpdateSchemasMethod = "Xmin"
)

func (e SourcePostgresUpdateSchemasMethod) ToPointer() *SourcePostgresUpdateSchemasMethod {
	return &e
}
func (e *SourcePostgresUpdateSchemasMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Xmin":
		*e = SourcePostgresUpdateSchemasMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresUpdateSchemasMethod: %v", v)
	}
}

// DetectChangesWithXminSystemColumn - <i>Recommended</i> - Incrementally reads new inserts and updates via Postgres <a href="https://docs.airbyte.com/integrations/sources/postgres/#xmin">Xmin system column</a>. Suitable for databases that have low transaction pressure.
type DetectChangesWithXminSystemColumn struct {
	method SourcePostgresUpdateSchemasMethod `const:"Xmin" json:"method"`
}

func (d DetectChangesWithXminSystemColumn) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DetectChangesWithXminSystemColumn) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *DetectChangesWithXminSystemColumn) GetMethod() SourcePostgresUpdateSchemasMethod {
	return SourcePostgresUpdateSchemasMethodXmin
}

// SourcePostgresUpdateInvalidCDCPositionBehaviorAdvanced - Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value into the WAL. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss.
type SourcePostgresUpdateInvalidCDCPositionBehaviorAdvanced string

const (
	SourcePostgresUpdateInvalidCDCPositionBehaviorAdvancedFailSync   SourcePostgresUpdateInvalidCDCPositionBehaviorAdvanced = "Fail sync"
	SourcePostgresUpdateInvalidCDCPositionBehaviorAdvancedReSyncData SourcePostgresUpdateInvalidCDCPositionBehaviorAdvanced = "Re-sync data"
)

func (e SourcePostgresUpdateInvalidCDCPositionBehaviorAdvanced) ToPointer() *SourcePostgresUpdateInvalidCDCPositionBehaviorAdvanced {
	return &e
}
func (e *SourcePostgresUpdateInvalidCDCPositionBehaviorAdvanced) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Fail sync":
		fallthrough
	case "Re-sync data":
		*e = SourcePostgresUpdateInvalidCDCPositionBehaviorAdvanced(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresUpdateInvalidCDCPositionBehaviorAdvanced: %v", v)
	}
}

// LSNCommitBehaviour - Determines when Airbyte should flush the LSN of processed WAL logs in the source database. `After loading Data in the destination` is default. If `While reading Data` is selected, in case of a downstream failure (while loading data into the destination), next sync would result in a full sync.
type LSNCommitBehaviour string

const (
	LSNCommitBehaviourWhileReadingData                 LSNCommitBehaviour = "While reading Data"
	LSNCommitBehaviourAfterLoadingDataInTheDestination LSNCommitBehaviour = "After loading Data in the destination"
)

func (e LSNCommitBehaviour) ToPointer() *LSNCommitBehaviour {
	return &e
}
func (e *LSNCommitBehaviour) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "While reading Data":
		fallthrough
	case "After loading Data in the destination":
		*e = LSNCommitBehaviour(v)
		return nil
	default:
		return fmt.Errorf("invalid value for LSNCommitBehaviour: %v", v)
	}
}

type SourcePostgresUpdateSchemasReplicationMethodUpdateMethodMethod string

const (
	SourcePostgresUpdateSchemasReplicationMethodUpdateMethodMethodCdc SourcePostgresUpdateSchemasReplicationMethodUpdateMethodMethod = "CDC"
)

func (e SourcePostgresUpdateSchemasReplicationMethodUpdateMethodMethod) ToPointer() *SourcePostgresUpdateSchemasReplicationMethodUpdateMethodMethod {
	return &e
}
func (e *SourcePostgresUpdateSchemasReplicationMethodUpdateMethodMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CDC":
		*e = SourcePostgresUpdateSchemasReplicationMethodUpdateMethodMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresUpdateSchemasReplicationMethodUpdateMethodMethod: %v", v)
	}
}

// Plugin - A logical decoding plugin installed on the PostgreSQL server.
type Plugin string

const (
	PluginPgoutput Plugin = "pgoutput"
)

func (e Plugin) ToPointer() *Plugin {
	return &e
}
func (e *Plugin) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "pgoutput":
		*e = Plugin(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Plugin: %v", v)
	}
}

// ReadChangesUsingWriteAheadLogCDC - <i>Recommended</i> - Incrementally reads new inserts, updates, and deletes using the Postgres <a href="https://docs.airbyte.com/integrations/sources/postgres/#cdc">write-ahead log (WAL)</a>. This needs to be configured on the source database itself. Recommended for tables of any size.
type ReadChangesUsingWriteAheadLogCDC struct {
	AdditionalProperties any `additionalProperties:"true" json:"-"`
	// Specifies a query that the connector executes on the source database when the connector sends a heartbeat message. Please see the <a href="https://docs.airbyte.com/integrations/sources/postgres/postgres-troubleshooting#advanced-wal-disk-consumption-and-heartbeat-action-query">setup guide</a> for how and when to configure this setting.
	HeartbeatActionQuery *string `default:"" json:"heartbeat_action_query"`
	// The amount of time an initial load is allowed to continue for before catching up on CDC logs.
	InitialLoadTimeoutHours *int64 `default:"8" json:"initial_load_timeout_hours"`
	// The amount of time the connector will wait when it launches to determine if there is new data to sync or not. Defaults to 1200 seconds. Valid range: 120 seconds to 2400 seconds. Read about <a href="https://docs.airbyte.com/integrations/sources/postgres/postgres-troubleshooting#advanced-setting-up-initial-cdc-waiting-time">initial waiting time</a>.
	InitialWaitingSeconds *int64 `default:"1200" json:"initial_waiting_seconds"`
	// Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value into the WAL. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss.
	InvalidCdcCursorPositionBehavior *SourcePostgresUpdateInvalidCDCPositionBehaviorAdvanced `default:"Fail sync" json:"invalid_cdc_cursor_position_behavior"`
	// Determines when Airbyte should flush the LSN of processed WAL logs in the source database. `After loading Data in the destination` is default. If `While reading Data` is selected, in case of a downstream failure (while loading data into the destination), next sync would result in a full sync.
	LsnCommitBehaviour *LSNCommitBehaviour                                            `default:"After loading Data in the destination" json:"lsn_commit_behaviour"`
	method             SourcePostgresUpdateSchemasReplicationMethodUpdateMethodMethod `const:"CDC" json:"method"`
	// A logical decoding plugin installed on the PostgreSQL server.
	Plugin *Plugin `default:"pgoutput" json:"plugin"`
	// A Postgres publication used for consuming changes. Read about <a href="https://docs.airbyte.com/integrations/sources/postgres#step-4-create-publications-and-replication-identities-for-tables">publications and replication identities</a>.
	Publication string `json:"publication"`
	// The size of the internal queue. This may interfere with memory consumption and efficiency of the connector, please be careful.
	QueueSize *int64 `default:"10000" json:"queue_size"`
	// A plugin logical replication slot. Read about <a href="https://docs.airbyte.com/integrations/sources/postgres#step-3-create-replication-slot">replication slots</a>.
	ReplicationSlot string `json:"replication_slot"`
}

func (r ReadChangesUsingWriteAheadLogCDC) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(r, "", false)
}

func (r *ReadChangesUsingWriteAheadLogCDC) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &r, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *ReadChangesUsingWriteAheadLogCDC) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *ReadChangesUsingWriteAheadLogCDC) GetHeartbeatActionQuery() *string {
	if o == nil {
		return nil
	}
	return o.HeartbeatActionQuery
}

func (o *ReadChangesUsingWriteAheadLogCDC) GetInitialLoadTimeoutHours() *int64 {
	if o == nil {
		return nil
	}
	return o.InitialLoadTimeoutHours
}

func (o *ReadChangesUsingWriteAheadLogCDC) GetInitialWaitingSeconds() *int64 {
	if o == nil {
		return nil
	}
	return o.InitialWaitingSeconds
}

func (o *ReadChangesUsingWriteAheadLogCDC) GetInvalidCdcCursorPositionBehavior() *SourcePostgresUpdateInvalidCDCPositionBehaviorAdvanced {
	if o == nil {
		return nil
	}
	return o.InvalidCdcCursorPositionBehavior
}

func (o *ReadChangesUsingWriteAheadLogCDC) GetLsnCommitBehaviour() *LSNCommitBehaviour {
	if o == nil {
		return nil
	}
	return o.LsnCommitBehaviour
}

func (o *ReadChangesUsingWriteAheadLogCDC) GetMethod() SourcePostgresUpdateSchemasReplicationMethodUpdateMethodMethod {
	return SourcePostgresUpdateSchemasReplicationMethodUpdateMethodMethodCdc
}

func (o *ReadChangesUsingWriteAheadLogCDC) GetPlugin() *Plugin {
	if o == nil {
		return nil
	}
	return o.Plugin
}

func (o *ReadChangesUsingWriteAheadLogCDC) GetPublication() string {
	if o == nil {
		return ""
	}
	return o.Publication
}

func (o *ReadChangesUsingWriteAheadLogCDC) GetQueueSize() *int64 {
	if o == nil {
		return nil
	}
	return o.QueueSize
}

func (o *ReadChangesUsingWriteAheadLogCDC) GetReplicationSlot() string {
	if o == nil {
		return ""
	}
	return o.ReplicationSlot
}

type SourcePostgresUpdateUpdateMethodType string

const (
	SourcePostgresUpdateUpdateMethodTypeReadChangesUsingWriteAheadLogCDC                     SourcePostgresUpdateUpdateMethodType = "Read Changes using Write-Ahead Log (CDC)"
	SourcePostgresUpdateUpdateMethodTypeDetectChangesWithXminSystemColumn                    SourcePostgresUpdateUpdateMethodType = "Detect Changes with Xmin System Column"
	SourcePostgresUpdateUpdateMethodTypeSourcePostgresUpdateScanChangesWithUserDefinedCursor SourcePostgresUpdateUpdateMethodType = "source-postgres-update_Scan Changes with User Defined Cursor"
)

// SourcePostgresUpdateUpdateMethod - Configures how data is extracted from the database.
type SourcePostgresUpdateUpdateMethod struct {
	ReadChangesUsingWriteAheadLogCDC                     *ReadChangesUsingWriteAheadLogCDC
	DetectChangesWithXminSystemColumn                    *DetectChangesWithXminSystemColumn
	SourcePostgresUpdateScanChangesWithUserDefinedCursor *SourcePostgresUpdateScanChangesWithUserDefinedCursor

	Type SourcePostgresUpdateUpdateMethodType
}

func CreateSourcePostgresUpdateUpdateMethodReadChangesUsingWriteAheadLogCDC(readChangesUsingWriteAheadLogCDC ReadChangesUsingWriteAheadLogCDC) SourcePostgresUpdateUpdateMethod {
	typ := SourcePostgresUpdateUpdateMethodTypeReadChangesUsingWriteAheadLogCDC

	return SourcePostgresUpdateUpdateMethod{
		ReadChangesUsingWriteAheadLogCDC: &readChangesUsingWriteAheadLogCDC,
		Type:                             typ,
	}
}

func CreateSourcePostgresUpdateUpdateMethodDetectChangesWithXminSystemColumn(detectChangesWithXminSystemColumn DetectChangesWithXminSystemColumn) SourcePostgresUpdateUpdateMethod {
	typ := SourcePostgresUpdateUpdateMethodTypeDetectChangesWithXminSystemColumn

	return SourcePostgresUpdateUpdateMethod{
		DetectChangesWithXminSystemColumn: &detectChangesWithXminSystemColumn,
		Type:                              typ,
	}
}

func CreateSourcePostgresUpdateUpdateMethodSourcePostgresUpdateScanChangesWithUserDefinedCursor(sourcePostgresUpdateScanChangesWithUserDefinedCursor SourcePostgresUpdateScanChangesWithUserDefinedCursor) SourcePostgresUpdateUpdateMethod {
	typ := SourcePostgresUpdateUpdateMethodTypeSourcePostgresUpdateScanChangesWithUserDefinedCursor

	return SourcePostgresUpdateUpdateMethod{
		SourcePostgresUpdateScanChangesWithUserDefinedCursor: &sourcePostgresUpdateScanChangesWithUserDefinedCursor,
		Type: typ,
	}
}

func (u *SourcePostgresUpdateUpdateMethod) UnmarshalJSON(data []byte) error {

	var detectChangesWithXminSystemColumn DetectChangesWithXminSystemColumn = DetectChangesWithXminSystemColumn{}
	if err := utils.UnmarshalJSON(data, &detectChangesWithXminSystemColumn, "", true, true); err == nil {
		u.DetectChangesWithXminSystemColumn = &detectChangesWithXminSystemColumn
		u.Type = SourcePostgresUpdateUpdateMethodTypeDetectChangesWithXminSystemColumn
		return nil
	}

	var sourcePostgresUpdateScanChangesWithUserDefinedCursor SourcePostgresUpdateScanChangesWithUserDefinedCursor = SourcePostgresUpdateScanChangesWithUserDefinedCursor{}
	if err := utils.UnmarshalJSON(data, &sourcePostgresUpdateScanChangesWithUserDefinedCursor, "", true, true); err == nil {
		u.SourcePostgresUpdateScanChangesWithUserDefinedCursor = &sourcePostgresUpdateScanChangesWithUserDefinedCursor
		u.Type = SourcePostgresUpdateUpdateMethodTypeSourcePostgresUpdateScanChangesWithUserDefinedCursor
		return nil
	}

	var readChangesUsingWriteAheadLogCDC ReadChangesUsingWriteAheadLogCDC = ReadChangesUsingWriteAheadLogCDC{}
	if err := utils.UnmarshalJSON(data, &readChangesUsingWriteAheadLogCDC, "", true, true); err == nil {
		u.ReadChangesUsingWriteAheadLogCDC = &readChangesUsingWriteAheadLogCDC
		u.Type = SourcePostgresUpdateUpdateMethodTypeReadChangesUsingWriteAheadLogCDC
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourcePostgresUpdateUpdateMethod", string(data))
}

func (u SourcePostgresUpdateUpdateMethod) MarshalJSON() ([]byte, error) {
	if u.ReadChangesUsingWriteAheadLogCDC != nil {
		return utils.MarshalJSON(u.ReadChangesUsingWriteAheadLogCDC, "", true)
	}

	if u.DetectChangesWithXminSystemColumn != nil {
		return utils.MarshalJSON(u.DetectChangesWithXminSystemColumn, "", true)
	}

	if u.SourcePostgresUpdateScanChangesWithUserDefinedCursor != nil {
		return utils.MarshalJSON(u.SourcePostgresUpdateScanChangesWithUserDefinedCursor, "", true)
	}

	return nil, errors.New("could not marshal union type SourcePostgresUpdateUpdateMethod: all fields are null")
}

type SourcePostgresUpdateSchemasSSLModeSSLModes6Mode string

const (
	SourcePostgresUpdateSchemasSSLModeSSLModes6ModeVerifyFull SourcePostgresUpdateSchemasSSLModeSSLModes6Mode = "verify-full"
)

func (e SourcePostgresUpdateSchemasSSLModeSSLModes6Mode) ToPointer() *SourcePostgresUpdateSchemasSSLModeSSLModes6Mode {
	return &e
}
func (e *SourcePostgresUpdateSchemasSSLModeSSLModes6Mode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "verify-full":
		*e = SourcePostgresUpdateSchemasSSLModeSSLModes6Mode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresUpdateSchemasSSLModeSSLModes6Mode: %v", v)
	}
}

// SourcePostgresUpdateVerifyFull - This is the most secure mode. Always require encryption and verifies the identity of the source database server.
type SourcePostgresUpdateVerifyFull struct {
	AdditionalProperties any `additionalProperties:"true" json:"-"`
	// CA certificate
	CaCertificate string `json:"ca_certificate"`
	// Client certificate
	ClientCertificate *string `json:"client_certificate,omitempty"`
	// Client key
	ClientKey *string `json:"client_key,omitempty"`
	// Password for keystorage. If you do not add it - the password will be generated automatically.
	ClientKeyPassword *string                                         `json:"client_key_password,omitempty"`
	mode              SourcePostgresUpdateSchemasSSLModeSSLModes6Mode `const:"verify-full" json:"mode"`
}

func (s SourcePostgresUpdateVerifyFull) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresUpdateVerifyFull) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresUpdateVerifyFull) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *SourcePostgresUpdateVerifyFull) GetCaCertificate() string {
	if o == nil {
		return ""
	}
	return o.CaCertificate
}

func (o *SourcePostgresUpdateVerifyFull) GetClientCertificate() *string {
	if o == nil {
		return nil
	}
	return o.ClientCertificate
}

func (o *SourcePostgresUpdateVerifyFull) GetClientKey() *string {
	if o == nil {
		return nil
	}
	return o.ClientKey
}

func (o *SourcePostgresUpdateVerifyFull) GetClientKeyPassword() *string {
	if o == nil {
		return nil
	}
	return o.ClientKeyPassword
}

func (o *SourcePostgresUpdateVerifyFull) GetMode() SourcePostgresUpdateSchemasSSLModeSSLModes6Mode {
	return SourcePostgresUpdateSchemasSSLModeSSLModes6ModeVerifyFull
}

type SourcePostgresUpdateSchemasSSLModeSSLModes5Mode string

const (
	SourcePostgresUpdateSchemasSSLModeSSLModes5ModeVerifyCa SourcePostgresUpdateSchemasSSLModeSSLModes5Mode = "verify-ca"
)

func (e SourcePostgresUpdateSchemasSSLModeSSLModes5Mode) ToPointer() *SourcePostgresUpdateSchemasSSLModeSSLModes5Mode {
	return &e
}
func (e *SourcePostgresUpdateSchemasSSLModeSSLModes5Mode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "verify-ca":
		*e = SourcePostgresUpdateSchemasSSLModeSSLModes5Mode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresUpdateSchemasSSLModeSSLModes5Mode: %v", v)
	}
}

// SourcePostgresUpdateVerifyCa - Always require encryption and verifies that the source database server has a valid SSL certificate.
type SourcePostgresUpdateVerifyCa struct {
	AdditionalProperties any `additionalProperties:"true" json:"-"`
	// CA certificate
	CaCertificate string `json:"ca_certificate"`
	// Client certificate
	ClientCertificate *string `json:"client_certificate,omitempty"`
	// Client key
	ClientKey *string `json:"client_key,omitempty"`
	// Password for keystorage. If you do not add it - the password will be generated automatically.
	ClientKeyPassword *string                                         `json:"client_key_password,omitempty"`
	mode              SourcePostgresUpdateSchemasSSLModeSSLModes5Mode `const:"verify-ca" json:"mode"`
}

func (s SourcePostgresUpdateVerifyCa) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresUpdateVerifyCa) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresUpdateVerifyCa) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *SourcePostgresUpdateVerifyCa) GetCaCertificate() string {
	if o == nil {
		return ""
	}
	return o.CaCertificate
}

func (o *SourcePostgresUpdateVerifyCa) GetClientCertificate() *string {
	if o == nil {
		return nil
	}
	return o.ClientCertificate
}

func (o *SourcePostgresUpdateVerifyCa) GetClientKey() *string {
	if o == nil {
		return nil
	}
	return o.ClientKey
}

func (o *SourcePostgresUpdateVerifyCa) GetClientKeyPassword() *string {
	if o == nil {
		return nil
	}
	return o.ClientKeyPassword
}

func (o *SourcePostgresUpdateVerifyCa) GetMode() SourcePostgresUpdateSchemasSSLModeSSLModes5Mode {
	return SourcePostgresUpdateSchemasSSLModeSSLModes5ModeVerifyCa
}

type SourcePostgresUpdateSchemasSSLModeSSLModesMode string

const (
	SourcePostgresUpdateSchemasSSLModeSSLModesModeRequire SourcePostgresUpdateSchemasSSLModeSSLModesMode = "require"
)

func (e SourcePostgresUpdateSchemasSSLModeSSLModesMode) ToPointer() *SourcePostgresUpdateSchemasSSLModeSSLModesMode {
	return &e
}
func (e *SourcePostgresUpdateSchemasSSLModeSSLModesMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "require":
		*e = SourcePostgresUpdateSchemasSSLModeSSLModesMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresUpdateSchemasSSLModeSSLModesMode: %v", v)
	}
}

// SourcePostgresUpdateRequire - Always require encryption. If the source database server does not support encryption, connection will fail.
type SourcePostgresUpdateRequire struct {
	AdditionalProperties any                                            `additionalProperties:"true" json:"-"`
	mode                 SourcePostgresUpdateSchemasSSLModeSSLModesMode `const:"require" json:"mode"`
}

func (s SourcePostgresUpdateRequire) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresUpdateRequire) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresUpdateRequire) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *SourcePostgresUpdateRequire) GetMode() SourcePostgresUpdateSchemasSSLModeSSLModesMode {
	return SourcePostgresUpdateSchemasSSLModeSSLModesModeRequire
}

type SourcePostgresUpdateSchemasSslModeMode string

const (
	SourcePostgresUpdateSchemasSslModeModePrefer SourcePostgresUpdateSchemasSslModeMode = "prefer"
)

func (e SourcePostgresUpdateSchemasSslModeMode) ToPointer() *SourcePostgresUpdateSchemasSslModeMode {
	return &e
}
func (e *SourcePostgresUpdateSchemasSslModeMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "prefer":
		*e = SourcePostgresUpdateSchemasSslModeMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresUpdateSchemasSslModeMode: %v", v)
	}
}

// SourcePostgresUpdatePrefer - Allows unencrypted connection only if the source database does not support encryption.
type SourcePostgresUpdatePrefer struct {
	AdditionalProperties any                                    `additionalProperties:"true" json:"-"`
	mode                 SourcePostgresUpdateSchemasSslModeMode `const:"prefer" json:"mode"`
}

func (s SourcePostgresUpdatePrefer) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresUpdatePrefer) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresUpdatePrefer) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *SourcePostgresUpdatePrefer) GetMode() SourcePostgresUpdateSchemasSslModeMode {
	return SourcePostgresUpdateSchemasSslModeModePrefer
}

type SourcePostgresUpdateSchemasMode string

const (
	SourcePostgresUpdateSchemasModeAllow SourcePostgresUpdateSchemasMode = "allow"
)

func (e SourcePostgresUpdateSchemasMode) ToPointer() *SourcePostgresUpdateSchemasMode {
	return &e
}
func (e *SourcePostgresUpdateSchemasMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "allow":
		*e = SourcePostgresUpdateSchemasMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresUpdateSchemasMode: %v", v)
	}
}

// SourcePostgresUpdateAllow - Enables encryption only when required by the source database.
type SourcePostgresUpdateAllow struct {
	AdditionalProperties any                             `additionalProperties:"true" json:"-"`
	mode                 SourcePostgresUpdateSchemasMode `const:"allow" json:"mode"`
}

func (s SourcePostgresUpdateAllow) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresUpdateAllow) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresUpdateAllow) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *SourcePostgresUpdateAllow) GetMode() SourcePostgresUpdateSchemasMode {
	return SourcePostgresUpdateSchemasModeAllow
}

type SourcePostgresUpdateMode string

const (
	SourcePostgresUpdateModeDisable SourcePostgresUpdateMode = "disable"
)

func (e SourcePostgresUpdateMode) ToPointer() *SourcePostgresUpdateMode {
	return &e
}
func (e *SourcePostgresUpdateMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "disable":
		*e = SourcePostgresUpdateMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresUpdateMode: %v", v)
	}
}

// SourcePostgresUpdateDisable - Disables encryption of communication between Airbyte and source database.
type SourcePostgresUpdateDisable struct {
	AdditionalProperties any                      `additionalProperties:"true" json:"-"`
	mode                 SourcePostgresUpdateMode `const:"disable" json:"mode"`
}

func (s SourcePostgresUpdateDisable) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresUpdateDisable) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresUpdateDisable) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *SourcePostgresUpdateDisable) GetMode() SourcePostgresUpdateMode {
	return SourcePostgresUpdateModeDisable
}

type SourcePostgresUpdateSSLModesType string

const (
	SourcePostgresUpdateSSLModesTypeSourcePostgresUpdateDisable    SourcePostgresUpdateSSLModesType = "source-postgres-update_disable"
	SourcePostgresUpdateSSLModesTypeSourcePostgresUpdateAllow      SourcePostgresUpdateSSLModesType = "source-postgres-update_allow"
	SourcePostgresUpdateSSLModesTypeSourcePostgresUpdatePrefer     SourcePostgresUpdateSSLModesType = "source-postgres-update_prefer"
	SourcePostgresUpdateSSLModesTypeSourcePostgresUpdateRequire    SourcePostgresUpdateSSLModesType = "source-postgres-update_require"
	SourcePostgresUpdateSSLModesTypeSourcePostgresUpdateVerifyCa   SourcePostgresUpdateSSLModesType = "source-postgres-update_verify-ca"
	SourcePostgresUpdateSSLModesTypeSourcePostgresUpdateVerifyFull SourcePostgresUpdateSSLModesType = "source-postgres-update_verify-full"
)

// SourcePostgresUpdateSSLModes - SSL connection modes.
//
//	Read more <a href="https://jdbc.postgresql.org/documentation/head/ssl-client.html"> in the docs</a>.
type SourcePostgresUpdateSSLModes struct {
	SourcePostgresUpdateDisable    *SourcePostgresUpdateDisable
	SourcePostgresUpdateAllow      *SourcePostgresUpdateAllow
	SourcePostgresUpdatePrefer     *SourcePostgresUpdatePrefer
	SourcePostgresUpdateRequire    *SourcePostgresUpdateRequire
	SourcePostgresUpdateVerifyCa   *SourcePostgresUpdateVerifyCa
	SourcePostgresUpdateVerifyFull *SourcePostgresUpdateVerifyFull

	Type SourcePostgresUpdateSSLModesType
}

func CreateSourcePostgresUpdateSSLModesSourcePostgresUpdateDisable(sourcePostgresUpdateDisable SourcePostgresUpdateDisable) SourcePostgresUpdateSSLModes {
	typ := SourcePostgresUpdateSSLModesTypeSourcePostgresUpdateDisable

	return SourcePostgresUpdateSSLModes{
		SourcePostgresUpdateDisable: &sourcePostgresUpdateDisable,
		Type:                        typ,
	}
}

func CreateSourcePostgresUpdateSSLModesSourcePostgresUpdateAllow(sourcePostgresUpdateAllow SourcePostgresUpdateAllow) SourcePostgresUpdateSSLModes {
	typ := SourcePostgresUpdateSSLModesTypeSourcePostgresUpdateAllow

	return SourcePostgresUpdateSSLModes{
		SourcePostgresUpdateAllow: &sourcePostgresUpdateAllow,
		Type:                      typ,
	}
}

func CreateSourcePostgresUpdateSSLModesSourcePostgresUpdatePrefer(sourcePostgresUpdatePrefer SourcePostgresUpdatePrefer) SourcePostgresUpdateSSLModes {
	typ := SourcePostgresUpdateSSLModesTypeSourcePostgresUpdatePrefer

	return SourcePostgresUpdateSSLModes{
		SourcePostgresUpdatePrefer: &sourcePostgresUpdatePrefer,
		Type:                       typ,
	}
}

func CreateSourcePostgresUpdateSSLModesSourcePostgresUpdateRequire(sourcePostgresUpdateRequire SourcePostgresUpdateRequire) SourcePostgresUpdateSSLModes {
	typ := SourcePostgresUpdateSSLModesTypeSourcePostgresUpdateRequire

	return SourcePostgresUpdateSSLModes{
		SourcePostgresUpdateRequire: &sourcePostgresUpdateRequire,
		Type:                        typ,
	}
}

func CreateSourcePostgresUpdateSSLModesSourcePostgresUpdateVerifyCa(sourcePostgresUpdateVerifyCa SourcePostgresUpdateVerifyCa) SourcePostgresUpdateSSLModes {
	typ := SourcePostgresUpdateSSLModesTypeSourcePostgresUpdateVerifyCa

	return SourcePostgresUpdateSSLModes{
		SourcePostgresUpdateVerifyCa: &sourcePostgresUpdateVerifyCa,
		Type:                         typ,
	}
}

func CreateSourcePostgresUpdateSSLModesSourcePostgresUpdateVerifyFull(sourcePostgresUpdateVerifyFull SourcePostgresUpdateVerifyFull) SourcePostgresUpdateSSLModes {
	typ := SourcePostgresUpdateSSLModesTypeSourcePostgresUpdateVerifyFull

	return SourcePostgresUpdateSSLModes{
		SourcePostgresUpdateVerifyFull: &sourcePostgresUpdateVerifyFull,
		Type:                           typ,
	}
}

func (u *SourcePostgresUpdateSSLModes) UnmarshalJSON(data []byte) error {

	var sourcePostgresUpdateDisable SourcePostgresUpdateDisable = SourcePostgresUpdateDisable{}
	if err := utils.UnmarshalJSON(data, &sourcePostgresUpdateDisable, "", true, true); err == nil {
		u.SourcePostgresUpdateDisable = &sourcePostgresUpdateDisable
		u.Type = SourcePostgresUpdateSSLModesTypeSourcePostgresUpdateDisable
		return nil
	}

	var sourcePostgresUpdateAllow SourcePostgresUpdateAllow = SourcePostgresUpdateAllow{}
	if err := utils.UnmarshalJSON(data, &sourcePostgresUpdateAllow, "", true, true); err == nil {
		u.SourcePostgresUpdateAllow = &sourcePostgresUpdateAllow
		u.Type = SourcePostgresUpdateSSLModesTypeSourcePostgresUpdateAllow
		return nil
	}

	var sourcePostgresUpdatePrefer SourcePostgresUpdatePrefer = SourcePostgresUpdatePrefer{}
	if err := utils.UnmarshalJSON(data, &sourcePostgresUpdatePrefer, "", true, true); err == nil {
		u.SourcePostgresUpdatePrefer = &sourcePostgresUpdatePrefer
		u.Type = SourcePostgresUpdateSSLModesTypeSourcePostgresUpdatePrefer
		return nil
	}

	var sourcePostgresUpdateRequire SourcePostgresUpdateRequire = SourcePostgresUpdateRequire{}
	if err := utils.UnmarshalJSON(data, &sourcePostgresUpdateRequire, "", true, true); err == nil {
		u.SourcePostgresUpdateRequire = &sourcePostgresUpdateRequire
		u.Type = SourcePostgresUpdateSSLModesTypeSourcePostgresUpdateRequire
		return nil
	}

	var sourcePostgresUpdateVerifyCa SourcePostgresUpdateVerifyCa = SourcePostgresUpdateVerifyCa{}
	if err := utils.UnmarshalJSON(data, &sourcePostgresUpdateVerifyCa, "", true, true); err == nil {
		u.SourcePostgresUpdateVerifyCa = &sourcePostgresUpdateVerifyCa
		u.Type = SourcePostgresUpdateSSLModesTypeSourcePostgresUpdateVerifyCa
		return nil
	}

	var sourcePostgresUpdateVerifyFull SourcePostgresUpdateVerifyFull = SourcePostgresUpdateVerifyFull{}
	if err := utils.UnmarshalJSON(data, &sourcePostgresUpdateVerifyFull, "", true, true); err == nil {
		u.SourcePostgresUpdateVerifyFull = &sourcePostgresUpdateVerifyFull
		u.Type = SourcePostgresUpdateSSLModesTypeSourcePostgresUpdateVerifyFull
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourcePostgresUpdateSSLModes", string(data))
}

func (u SourcePostgresUpdateSSLModes) MarshalJSON() ([]byte, error) {
	if u.SourcePostgresUpdateDisable != nil {
		return utils.MarshalJSON(u.SourcePostgresUpdateDisable, "", true)
	}

	if u.SourcePostgresUpdateAllow != nil {
		return utils.MarshalJSON(u.SourcePostgresUpdateAllow, "", true)
	}

	if u.SourcePostgresUpdatePrefer != nil {
		return utils.MarshalJSON(u.SourcePostgresUpdatePrefer, "", true)
	}

	if u.SourcePostgresUpdateRequire != nil {
		return utils.MarshalJSON(u.SourcePostgresUpdateRequire, "", true)
	}

	if u.SourcePostgresUpdateVerifyCa != nil {
		return utils.MarshalJSON(u.SourcePostgresUpdateVerifyCa, "", true)
	}

	if u.SourcePostgresUpdateVerifyFull != nil {
		return utils.MarshalJSON(u.SourcePostgresUpdateVerifyFull, "", true)
	}

	return nil, errors.New("could not marshal union type SourcePostgresUpdateSSLModes: all fields are null")
}

// SourcePostgresUpdateSchemasTunnelMethodTunnelMethod - Connect through a jump server tunnel host using username and password authentication
type SourcePostgresUpdateSchemasTunnelMethodTunnelMethod string

const (
	SourcePostgresUpdateSchemasTunnelMethodTunnelMethodSSHPasswordAuth SourcePostgresUpdateSchemasTunnelMethodTunnelMethod = "SSH_PASSWORD_AUTH"
)

func (e SourcePostgresUpdateSchemasTunnelMethodTunnelMethod) ToPointer() *SourcePostgresUpdateSchemasTunnelMethodTunnelMethod {
	return &e
}
func (e *SourcePostgresUpdateSchemasTunnelMethodTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_PASSWORD_AUTH":
		*e = SourcePostgresUpdateSchemasTunnelMethodTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresUpdateSchemasTunnelMethodTunnelMethod: %v", v)
	}
}

type SourcePostgresUpdatePasswordAuthentication struct {
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and password authentication
	tunnelMethod SourcePostgresUpdateSchemasTunnelMethodTunnelMethod `const:"SSH_PASSWORD_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser string `json:"tunnel_user"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword string `json:"tunnel_user_password"`
}

func (s SourcePostgresUpdatePasswordAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresUpdatePasswordAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresUpdatePasswordAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *SourcePostgresUpdatePasswordAuthentication) GetTunnelMethod() SourcePostgresUpdateSchemasTunnelMethodTunnelMethod {
	return SourcePostgresUpdateSchemasTunnelMethodTunnelMethodSSHPasswordAuth
}

func (o *SourcePostgresUpdatePasswordAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *SourcePostgresUpdatePasswordAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

func (o *SourcePostgresUpdatePasswordAuthentication) GetTunnelUserPassword() string {
	if o == nil {
		return ""
	}
	return o.TunnelUserPassword
}

// SourcePostgresUpdateSchemasTunnelMethod - Connect through a jump server tunnel host using username and ssh key
type SourcePostgresUpdateSchemasTunnelMethod string

const (
	SourcePostgresUpdateSchemasTunnelMethodSSHKeyAuth SourcePostgresUpdateSchemasTunnelMethod = "SSH_KEY_AUTH"
)

func (e SourcePostgresUpdateSchemasTunnelMethod) ToPointer() *SourcePostgresUpdateSchemasTunnelMethod {
	return &e
}
func (e *SourcePostgresUpdateSchemasTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SSH_KEY_AUTH":
		*e = SourcePostgresUpdateSchemasTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresUpdateSchemasTunnelMethod: %v", v)
	}
}

type SourcePostgresUpdateSSHKeyAuthentication struct {
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey string `json:"ssh_key"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost string `json:"tunnel_host"`
	// Connect through a jump server tunnel host using username and ssh key
	tunnelMethod SourcePostgresUpdateSchemasTunnelMethod `const:"SSH_KEY_AUTH" json:"tunnel_method"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host.
	TunnelUser string `json:"tunnel_user"`
}

func (s SourcePostgresUpdateSSHKeyAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresUpdateSSHKeyAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresUpdateSSHKeyAuthentication) GetSSHKey() string {
	if o == nil {
		return ""
	}
	return o.SSHKey
}

func (o *SourcePostgresUpdateSSHKeyAuthentication) GetTunnelHost() string {
	if o == nil {
		return ""
	}
	return o.TunnelHost
}

func (o *SourcePostgresUpdateSSHKeyAuthentication) GetTunnelMethod() SourcePostgresUpdateSchemasTunnelMethod {
	return SourcePostgresUpdateSchemasTunnelMethodSSHKeyAuth
}

func (o *SourcePostgresUpdateSSHKeyAuthentication) GetTunnelPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TunnelPort
}

func (o *SourcePostgresUpdateSSHKeyAuthentication) GetTunnelUser() string {
	if o == nil {
		return ""
	}
	return o.TunnelUser
}

// SourcePostgresUpdateTunnelMethod - No ssh tunnel needed to connect to database
type SourcePostgresUpdateTunnelMethod string

const (
	SourcePostgresUpdateTunnelMethodNoTunnel SourcePostgresUpdateTunnelMethod = "NO_TUNNEL"
)

func (e SourcePostgresUpdateTunnelMethod) ToPointer() *SourcePostgresUpdateTunnelMethod {
	return &e
}
func (e *SourcePostgresUpdateTunnelMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NO_TUNNEL":
		*e = SourcePostgresUpdateTunnelMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourcePostgresUpdateTunnelMethod: %v", v)
	}
}

type SourcePostgresUpdateNoTunnel struct {
	// No ssh tunnel needed to connect to database
	tunnelMethod SourcePostgresUpdateTunnelMethod `const:"NO_TUNNEL" json:"tunnel_method"`
}

func (s SourcePostgresUpdateNoTunnel) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresUpdateNoTunnel) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresUpdateNoTunnel) GetTunnelMethod() SourcePostgresUpdateTunnelMethod {
	return SourcePostgresUpdateTunnelMethodNoTunnel
}

type SourcePostgresUpdateSSHTunnelMethodType string

const (
	SourcePostgresUpdateSSHTunnelMethodTypeSourcePostgresUpdateNoTunnel               SourcePostgresUpdateSSHTunnelMethodType = "source-postgres-update_No Tunnel"
	SourcePostgresUpdateSSHTunnelMethodTypeSourcePostgresUpdateSSHKeyAuthentication   SourcePostgresUpdateSSHTunnelMethodType = "source-postgres-update_SSH Key Authentication"
	SourcePostgresUpdateSSHTunnelMethodTypeSourcePostgresUpdatePasswordAuthentication SourcePostgresUpdateSSHTunnelMethodType = "source-postgres-update_Password Authentication"
)

// SourcePostgresUpdateSSHTunnelMethod - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type SourcePostgresUpdateSSHTunnelMethod struct {
	SourcePostgresUpdateNoTunnel               *SourcePostgresUpdateNoTunnel
	SourcePostgresUpdateSSHKeyAuthentication   *SourcePostgresUpdateSSHKeyAuthentication
	SourcePostgresUpdatePasswordAuthentication *SourcePostgresUpdatePasswordAuthentication

	Type SourcePostgresUpdateSSHTunnelMethodType
}

func CreateSourcePostgresUpdateSSHTunnelMethodSourcePostgresUpdateNoTunnel(sourcePostgresUpdateNoTunnel SourcePostgresUpdateNoTunnel) SourcePostgresUpdateSSHTunnelMethod {
	typ := SourcePostgresUpdateSSHTunnelMethodTypeSourcePostgresUpdateNoTunnel

	return SourcePostgresUpdateSSHTunnelMethod{
		SourcePostgresUpdateNoTunnel: &sourcePostgresUpdateNoTunnel,
		Type:                         typ,
	}
}

func CreateSourcePostgresUpdateSSHTunnelMethodSourcePostgresUpdateSSHKeyAuthentication(sourcePostgresUpdateSSHKeyAuthentication SourcePostgresUpdateSSHKeyAuthentication) SourcePostgresUpdateSSHTunnelMethod {
	typ := SourcePostgresUpdateSSHTunnelMethodTypeSourcePostgresUpdateSSHKeyAuthentication

	return SourcePostgresUpdateSSHTunnelMethod{
		SourcePostgresUpdateSSHKeyAuthentication: &sourcePostgresUpdateSSHKeyAuthentication,
		Type:                                     typ,
	}
}

func CreateSourcePostgresUpdateSSHTunnelMethodSourcePostgresUpdatePasswordAuthentication(sourcePostgresUpdatePasswordAuthentication SourcePostgresUpdatePasswordAuthentication) SourcePostgresUpdateSSHTunnelMethod {
	typ := SourcePostgresUpdateSSHTunnelMethodTypeSourcePostgresUpdatePasswordAuthentication

	return SourcePostgresUpdateSSHTunnelMethod{
		SourcePostgresUpdatePasswordAuthentication: &sourcePostgresUpdatePasswordAuthentication,
		Type: typ,
	}
}

func (u *SourcePostgresUpdateSSHTunnelMethod) UnmarshalJSON(data []byte) error {

	var sourcePostgresUpdateNoTunnel SourcePostgresUpdateNoTunnel = SourcePostgresUpdateNoTunnel{}
	if err := utils.UnmarshalJSON(data, &sourcePostgresUpdateNoTunnel, "", true, true); err == nil {
		u.SourcePostgresUpdateNoTunnel = &sourcePostgresUpdateNoTunnel
		u.Type = SourcePostgresUpdateSSHTunnelMethodTypeSourcePostgresUpdateNoTunnel
		return nil
	}

	var sourcePostgresUpdateSSHKeyAuthentication SourcePostgresUpdateSSHKeyAuthentication = SourcePostgresUpdateSSHKeyAuthentication{}
	if err := utils.UnmarshalJSON(data, &sourcePostgresUpdateSSHKeyAuthentication, "", true, true); err == nil {
		u.SourcePostgresUpdateSSHKeyAuthentication = &sourcePostgresUpdateSSHKeyAuthentication
		u.Type = SourcePostgresUpdateSSHTunnelMethodTypeSourcePostgresUpdateSSHKeyAuthentication
		return nil
	}

	var sourcePostgresUpdatePasswordAuthentication SourcePostgresUpdatePasswordAuthentication = SourcePostgresUpdatePasswordAuthentication{}
	if err := utils.UnmarshalJSON(data, &sourcePostgresUpdatePasswordAuthentication, "", true, true); err == nil {
		u.SourcePostgresUpdatePasswordAuthentication = &sourcePostgresUpdatePasswordAuthentication
		u.Type = SourcePostgresUpdateSSHTunnelMethodTypeSourcePostgresUpdatePasswordAuthentication
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourcePostgresUpdateSSHTunnelMethod", string(data))
}

func (u SourcePostgresUpdateSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.SourcePostgresUpdateNoTunnel != nil {
		return utils.MarshalJSON(u.SourcePostgresUpdateNoTunnel, "", true)
	}

	if u.SourcePostgresUpdateSSHKeyAuthentication != nil {
		return utils.MarshalJSON(u.SourcePostgresUpdateSSHKeyAuthentication, "", true)
	}

	if u.SourcePostgresUpdatePasswordAuthentication != nil {
		return utils.MarshalJSON(u.SourcePostgresUpdatePasswordAuthentication, "", true)
	}

	return nil, errors.New("could not marshal union type SourcePostgresUpdateSSHTunnelMethod: all fields are null")
}

type SourcePostgresUpdate struct {
	// Name of the database.
	Database string `json:"database"`
	// Hostname of the database.
	Host string `json:"host"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (Eg. key1=value1&key2=value2&key3=value3). For more information read about <a href="https://jdbc.postgresql.org/documentation/head/connect.html">JDBC URL parameters</a>.
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// Password associated with the username.
	Password *string `json:"password,omitempty"`
	// Port of the database.
	Port *int64 `default:"5432" json:"port"`
	// Configures how data is extracted from the database.
	ReplicationMethod *SourcePostgresUpdateUpdateMethod `json:"replication_method,omitempty"`
	// The list of schemas (case sensitive) to sync from. Defaults to public.
	Schemas []string `json:"schemas,omitempty"`
	// SSL connection modes.
	//   Read more <a href="https://jdbc.postgresql.org/documentation/head/ssl-client.html"> in the docs</a>.
	SslMode *SourcePostgresUpdateSSLModes `json:"ssl_mode,omitempty"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod *SourcePostgresUpdateSSHTunnelMethod `json:"tunnel_method,omitempty"`
	// Username to access the database.
	Username string `json:"username"`
}

func (s SourcePostgresUpdate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourcePostgresUpdate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *SourcePostgresUpdate) GetDatabase() string {
	if o == nil {
		return ""
	}
	return o.Database
}

func (o *SourcePostgresUpdate) GetHost() string {
	if o == nil {
		return ""
	}
	return o.Host
}

func (o *SourcePostgresUpdate) GetJdbcURLParams() *string {
	if o == nil {
		return nil
	}
	return o.JdbcURLParams
}

func (o *SourcePostgresUpdate) GetPassword() *string {
	if o == nil {
		return nil
	}
	return o.Password
}

func (o *SourcePostgresUpdate) GetPort() *int64 {
	if o == nil {
		return nil
	}
	return o.Port
}

func (o *SourcePostgresUpdate) GetReplicationMethod() *SourcePostgresUpdateUpdateMethod {
	if o == nil {
		return nil
	}
	return o.ReplicationMethod
}

func (o *SourcePostgresUpdate) GetSchemas() []string {
	if o == nil {
		return nil
	}
	return o.Schemas
}

func (o *SourcePostgresUpdate) GetSslMode() *SourcePostgresUpdateSSLModes {
	if o == nil {
		return nil
	}
	return o.SslMode
}

func (o *SourcePostgresUpdate) GetTunnelMethod() *SourcePostgresUpdateSSHTunnelMethod {
	if o == nil {
		return nil
	}
	return o.TunnelMethod
}

func (o *SourcePostgresUpdate) GetUsername() string {
	if o == nil {
		return ""
	}
	return o.Username
}
