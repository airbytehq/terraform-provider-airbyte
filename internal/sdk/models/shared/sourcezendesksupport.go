// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/types"
	"time"
)

type SourceZendeskSupportOAuth20Legacy struct {
	// The OAuth access token. See the <a href="https://developer.zendesk.com/documentation/ticketing/working-with-oauth/creating-and-using-oauth-tokens-with-the-api/">Zendesk docs</a> for more information on generating this token.
	AccessToken string `json:"access_token"`
	// The OAuth client's ID. See <a href="https://docs.searchunify.com/Content/Content-Sources/Zendesk-Authentication-OAuth-Client-ID-Secret.htm#:~:text=Get%20Client%20ID%20and%20Client%20Secret&text=Go%20to%20OAuth%20Clients%20and,will%20be%20displayed%20only%20once.">this guide</a> for more information.
	ClientID *string `json:"client_id,omitempty"`
	// The OAuth client secret. See <a href="https://docs.searchunify.com/Content/Content-Sources/Zendesk-Authentication-OAuth-Client-ID-Secret.htm#:~:text=Get%20Client%20ID%20and%20Client%20Secret&text=Go%20to%20OAuth%20Clients%20and,will%20be%20displayed%20only%20once.">this guide</a> for more information.
	ClientSecret         *string `json:"client_secret,omitempty"`
	credentials          *string `const:"oauth2.0" json:"credentials,omitempty"`
	AdditionalProperties any     `additionalProperties:"true" json:"-"`
}

func (s SourceZendeskSupportOAuth20Legacy) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceZendeskSupportOAuth20Legacy) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceZendeskSupportOAuth20Legacy) GetAccessToken() string {
	if s == nil {
		return ""
	}
	return s.AccessToken
}

func (s *SourceZendeskSupportOAuth20Legacy) GetClientID() *string {
	if s == nil {
		return nil
	}
	return s.ClientID
}

func (s *SourceZendeskSupportOAuth20Legacy) GetClientSecret() *string {
	if s == nil {
		return nil
	}
	return s.ClientSecret
}

func (s *SourceZendeskSupportOAuth20Legacy) GetCredentials() *string {
	return types.Pointer("oauth2.0")
}

func (s *SourceZendeskSupportOAuth20Legacy) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceZendeskSupportAPIToken struct {
	// The value of the API token generated. See our <a href="https://docs.airbyte.com/integrations/sources/zendesk-support#setup-guide">full documentation</a> for more information on generating this token.
	APIToken    string  `json:"api_token"`
	credentials *string `const:"api_token" json:"credentials,omitempty"`
	// The user email for your Zendesk account.
	Email                string `json:"email"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (s SourceZendeskSupportAPIToken) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceZendeskSupportAPIToken) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceZendeskSupportAPIToken) GetAPIToken() string {
	if s == nil {
		return ""
	}
	return s.APIToken
}

func (s *SourceZendeskSupportAPIToken) GetCredentials() *string {
	return types.Pointer("api_token")
}

func (s *SourceZendeskSupportAPIToken) GetEmail() string {
	if s == nil {
		return ""
	}
	return s.Email
}

func (s *SourceZendeskSupportAPIToken) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type OAuth20WithRefreshToken struct {
	// Access Token for making authenticated requests.
	AccessToken *string `json:"access_token,omitempty"`
	// The OAuth client's ID. See <a href="https://developer.zendesk.com/api-reference/ticketing/oauth/grant_type_tokens/">Zendesk OAuth grant-type tokens documentation</a> for more information.
	ClientID string `json:"client_id"`
	// The OAuth client secret. See <a href="https://developer.zendesk.com/api-reference/ticketing/oauth/grant_type_tokens/">Zendesk OAuth grant-type tokens documentation</a> for more information.
	ClientSecret string  `json:"client_secret"`
	credentials  *string `const:"oauth2_refresh" json:"credentials,omitempty"`
	// The refresh token used to obtain new access tokens. Note that Zendesk uses rotating refresh tokens - each refresh will return a new refresh token and invalidate the previous one.
	RefreshToken string `json:"refresh_token"`
	// The date-time when the access token should be refreshed.
	TokenExpiryDate      *time.Time `json:"token_expiry_date,omitempty"`
	AdditionalProperties any        `additionalProperties:"true" json:"-"`
}

func (o OAuth20WithRefreshToken) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(o, "", false)
}

func (o *OAuth20WithRefreshToken) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &o, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *OAuth20WithRefreshToken) GetAccessToken() *string {
	if o == nil {
		return nil
	}
	return o.AccessToken
}

func (o *OAuth20WithRefreshToken) GetClientID() string {
	if o == nil {
		return ""
	}
	return o.ClientID
}

func (o *OAuth20WithRefreshToken) GetClientSecret() string {
	if o == nil {
		return ""
	}
	return o.ClientSecret
}

func (o *OAuth20WithRefreshToken) GetCredentials() *string {
	return types.Pointer("oauth2_refresh")
}

func (o *OAuth20WithRefreshToken) GetRefreshToken() string {
	if o == nil {
		return ""
	}
	return o.RefreshToken
}

func (o *OAuth20WithRefreshToken) GetTokenExpiryDate() *time.Time {
	if o == nil {
		return nil
	}
	return o.TokenExpiryDate
}

func (o *OAuth20WithRefreshToken) GetAdditionalProperties() any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

type SourceZendeskSupportAuthenticationType string

const (
	SourceZendeskSupportAuthenticationTypeOAuth20WithRefreshToken           SourceZendeskSupportAuthenticationType = "OAuth2.0 with Refresh Token"
	SourceZendeskSupportAuthenticationTypeSourceZendeskSupportAPIToken      SourceZendeskSupportAuthenticationType = "source-zendesk-support_API Token"
	SourceZendeskSupportAuthenticationTypeSourceZendeskSupportOAuth20Legacy SourceZendeskSupportAuthenticationType = "source-zendesk-support_OAuth2.0 (Legacy)"
)

// SourceZendeskSupportAuthentication - Zendesk allows three authentication methods. We recommend using `OAuth2.0 with Refresh Token` for Airbyte Cloud users (recommended), `OAuth2.0 (Legacy)` for existing OAuth connections, and `API token` for Airbyte Open Source users.
type SourceZendeskSupportAuthentication struct {
	OAuth20WithRefreshToken           *OAuth20WithRefreshToken           `queryParam:"inline" union:"member"`
	SourceZendeskSupportAPIToken      *SourceZendeskSupportAPIToken      `queryParam:"inline" union:"member"`
	SourceZendeskSupportOAuth20Legacy *SourceZendeskSupportOAuth20Legacy `queryParam:"inline" union:"member"`

	Type SourceZendeskSupportAuthenticationType
}

func CreateSourceZendeskSupportAuthenticationOAuth20WithRefreshToken(oAuth20WithRefreshToken OAuth20WithRefreshToken) SourceZendeskSupportAuthentication {
	typ := SourceZendeskSupportAuthenticationTypeOAuth20WithRefreshToken

	return SourceZendeskSupportAuthentication{
		OAuth20WithRefreshToken: &oAuth20WithRefreshToken,
		Type:                    typ,
	}
}

func CreateSourceZendeskSupportAuthenticationSourceZendeskSupportAPIToken(sourceZendeskSupportAPIToken SourceZendeskSupportAPIToken) SourceZendeskSupportAuthentication {
	typ := SourceZendeskSupportAuthenticationTypeSourceZendeskSupportAPIToken

	return SourceZendeskSupportAuthentication{
		SourceZendeskSupportAPIToken: &sourceZendeskSupportAPIToken,
		Type:                         typ,
	}
}

func CreateSourceZendeskSupportAuthenticationSourceZendeskSupportOAuth20Legacy(sourceZendeskSupportOAuth20Legacy SourceZendeskSupportOAuth20Legacy) SourceZendeskSupportAuthentication {
	typ := SourceZendeskSupportAuthenticationTypeSourceZendeskSupportOAuth20Legacy

	return SourceZendeskSupportAuthentication{
		SourceZendeskSupportOAuth20Legacy: &sourceZendeskSupportOAuth20Legacy,
		Type:                              typ,
	}
}

func (u *SourceZendeskSupportAuthentication) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var oAuth20WithRefreshToken OAuth20WithRefreshToken = OAuth20WithRefreshToken{}
	if err := utils.UnmarshalJSON(data, &oAuth20WithRefreshToken, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceZendeskSupportAuthenticationTypeOAuth20WithRefreshToken,
			Value: &oAuth20WithRefreshToken,
		})
	}

	var sourceZendeskSupportAPIToken SourceZendeskSupportAPIToken = SourceZendeskSupportAPIToken{}
	if err := utils.UnmarshalJSON(data, &sourceZendeskSupportAPIToken, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceZendeskSupportAuthenticationTypeSourceZendeskSupportAPIToken,
			Value: &sourceZendeskSupportAPIToken,
		})
	}

	var sourceZendeskSupportOAuth20Legacy SourceZendeskSupportOAuth20Legacy = SourceZendeskSupportOAuth20Legacy{}
	if err := utils.UnmarshalJSON(data, &sourceZendeskSupportOAuth20Legacy, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceZendeskSupportAuthenticationTypeSourceZendeskSupportOAuth20Legacy,
			Value: &sourceZendeskSupportOAuth20Legacy,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceZendeskSupportAuthentication", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceZendeskSupportAuthentication", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceZendeskSupportAuthenticationType)
	switch best.Type {
	case SourceZendeskSupportAuthenticationTypeOAuth20WithRefreshToken:
		u.OAuth20WithRefreshToken = best.Value.(*OAuth20WithRefreshToken)
		return nil
	case SourceZendeskSupportAuthenticationTypeSourceZendeskSupportAPIToken:
		u.SourceZendeskSupportAPIToken = best.Value.(*SourceZendeskSupportAPIToken)
		return nil
	case SourceZendeskSupportAuthenticationTypeSourceZendeskSupportOAuth20Legacy:
		u.SourceZendeskSupportOAuth20Legacy = best.Value.(*SourceZendeskSupportOAuth20Legacy)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceZendeskSupportAuthentication", string(data))
}

func (u SourceZendeskSupportAuthentication) MarshalJSON() ([]byte, error) {
	if u.OAuth20WithRefreshToken != nil {
		return utils.MarshalJSON(u.OAuth20WithRefreshToken, "", true)
	}

	if u.SourceZendeskSupportAPIToken != nil {
		return utils.MarshalJSON(u.SourceZendeskSupportAPIToken, "", true)
	}

	if u.SourceZendeskSupportOAuth20Legacy != nil {
		return utils.MarshalJSON(u.SourceZendeskSupportOAuth20Legacy, "", true)
	}

	return nil, errors.New("could not marshal union type SourceZendeskSupportAuthentication: all fields are null")
}

type SourceZendeskSupportSourceType string

const (
	SourceZendeskSupportSourceTypeZendeskSupport SourceZendeskSupportSourceType = "zendesk-support"
)

func (e SourceZendeskSupportSourceType) ToPointer() *SourceZendeskSupportSourceType {
	return &e
}
func (e *SourceZendeskSupportSourceType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "zendesk-support":
		*e = SourceZendeskSupportSourceType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceZendeskSupportSourceType: %v", v)
	}
}

type SourceZendeskSupport struct {
	// Zendesk allows three authentication methods. We recommend using `OAuth2.0 with Refresh Token` for Airbyte Cloud users (recommended), `OAuth2.0 (Legacy)` for existing OAuth connections, and `API token` for Airbyte Open Source users.
	Credentials *SourceZendeskSupportAuthentication `json:"credentials,omitempty"`
	// [Deprecated] Makes each stream read a single page of data.
	IgnorePagination *bool `json:"ignore_pagination,omitempty"`
	// The number of worker threads to use for the sync. The performance upper boundary is based on the limit of your Zendesk Support plan. More info about the rate limit plan tiers can be found on Zendesk's API <a href="https://developer.zendesk.com/api-reference/introduction/rate-limits/#zendesk-support-plan-limits">docs</a>.
	NumWorkers *int64 `default:"3" json:"num_workers"`
	// The number of records per page for the ticket_comments stream API requests. Lower values may help prevent timeouts on large datasets. The maximum value is 1000.
	PageSize *int64 `default:"100" json:"page_size"`
	// The UTC date and time from which you'd like to replicate data, in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated.
	StartDate *time.Time `json:"start_date,omitempty"`
	// This is your unique Zendesk subdomain that can be found in your account URL. For example, in https://MY_SUBDOMAIN.zendesk.com/, MY_SUBDOMAIN is the value of your subdomain.
	Subdomain            string                          `json:"subdomain"`
	sourceType           *SourceZendeskSupportSourceType `const:"zendesk-support" json:"sourceType"`
	AdditionalProperties any                             `additionalProperties:"true" json:"-"`
}

func (s SourceZendeskSupport) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceZendeskSupport) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceZendeskSupport) GetCredentials() *SourceZendeskSupportAuthentication {
	if s == nil {
		return nil
	}
	return s.Credentials
}

func (s *SourceZendeskSupport) GetIgnorePagination() *bool {
	if s == nil {
		return nil
	}
	return s.IgnorePagination
}

func (s *SourceZendeskSupport) GetNumWorkers() *int64 {
	if s == nil {
		return nil
	}
	return s.NumWorkers
}

func (s *SourceZendeskSupport) GetPageSize() *int64 {
	if s == nil {
		return nil
	}
	return s.PageSize
}

func (s *SourceZendeskSupport) GetStartDate() *time.Time {
	if s == nil {
		return nil
	}
	return s.StartDate
}

func (s *SourceZendeskSupport) GetSubdomain() string {
	if s == nil {
		return ""
	}
	return s.Subdomain
}

func (s *SourceZendeskSupport) GetSourceType() *SourceZendeskSupportSourceType {
	return SourceZendeskSupportSourceTypeZendeskSupport.ToPointer()
}

func (s *SourceZendeskSupport) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}
