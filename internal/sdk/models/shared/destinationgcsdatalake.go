// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

type DestinationGcsDataLakeCatalogType string

const (
	DestinationGcsDataLakeCatalogTypePolaris DestinationGcsDataLakeCatalogType = "POLARIS"
)

func (e DestinationGcsDataLakeCatalogType) ToPointer() *DestinationGcsDataLakeCatalogType {
	return &e
}
func (e *DestinationGcsDataLakeCatalogType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "POLARIS":
		*e = DestinationGcsDataLakeCatalogType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsDataLakeCatalogType: %v", v)
	}
}

// PolarisCatalog - Configuration for Apache Polaris Iceberg catalog.
type PolarisCatalog struct {
	// The name of the catalog in Polaris. This corresponds to the catalog name created via the Polaris Management API.
	CatalogName string                             `json:"catalog_name"`
	CatalogType *DestinationGcsDataLakeCatalogType `default:"POLARIS" json:"catalog_type"`
	// The OAuth Client ID for authenticating with the Polaris server.
	ClientID string `json:"client_id"`
	// The OAuth Client Secret for authenticating with the Polaris server.
	ClientSecret string `json:"client_secret"`
	// The base URL of the Polaris server. For example: http://localhost:8181/api/catalog
	ServerURI            string `json:"server_uri"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (p PolarisCatalog) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *PolarisCatalog) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (p *PolarisCatalog) GetCatalogName() string {
	if p == nil {
		return ""
	}
	return p.CatalogName
}

func (p *PolarisCatalog) GetCatalogType() *DestinationGcsDataLakeCatalogType {
	if p == nil {
		return nil
	}
	return p.CatalogType
}

func (p *PolarisCatalog) GetClientID() string {
	if p == nil {
		return ""
	}
	return p.ClientID
}

func (p *PolarisCatalog) GetClientSecret() string {
	if p == nil {
		return ""
	}
	return p.ClientSecret
}

func (p *PolarisCatalog) GetServerURI() string {
	if p == nil {
		return ""
	}
	return p.ServerURI
}

func (p *PolarisCatalog) GetAdditionalProperties() any {
	if p == nil {
		return nil
	}
	return p.AdditionalProperties
}

type DestinationGcsDataLakeSchemasCatalogType string

const (
	DestinationGcsDataLakeSchemasCatalogTypeBiglake DestinationGcsDataLakeSchemasCatalogType = "BIGLAKE"
)

func (e DestinationGcsDataLakeSchemasCatalogType) ToPointer() *DestinationGcsDataLakeSchemasCatalogType {
	return &e
}
func (e *DestinationGcsDataLakeSchemasCatalogType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "BIGLAKE":
		*e = DestinationGcsDataLakeSchemasCatalogType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsDataLakeSchemasCatalogType: %v", v)
	}
}

// BigLakeCatalog - Configuration for Google Cloud BigLake Iceberg catalog.
type BigLakeCatalog struct {
	// The name of the BigLake catalog. This should match the catalog you created in BigLake metastore.
	CatalogName          string                                    `json:"catalog_name"`
	CatalogType          *DestinationGcsDataLakeSchemasCatalogType `default:"BIGLAKE" json:"catalog_type"`
	AdditionalProperties any                                       `additionalProperties:"true" json:"-"`
}

func (b BigLakeCatalog) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(b, "", false)
}

func (b *BigLakeCatalog) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &b, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (b *BigLakeCatalog) GetCatalogName() string {
	if b == nil {
		return ""
	}
	return b.CatalogName
}

func (b *BigLakeCatalog) GetCatalogType() *DestinationGcsDataLakeSchemasCatalogType {
	if b == nil {
		return nil
	}
	return b.CatalogType
}

func (b *BigLakeCatalog) GetAdditionalProperties() any {
	if b == nil {
		return nil
	}
	return b.AdditionalProperties
}

type CatalogTypeType string

const (
	CatalogTypeTypeBigLakeCatalog CatalogTypeType = "BigLake Catalog"
	CatalogTypeTypePolarisCatalog CatalogTypeType = "Polaris Catalog"
)

// CatalogType - Specifies the type of Iceberg catalog (BigLake or Polaris).
type CatalogType struct {
	BigLakeCatalog *BigLakeCatalog `queryParam:"inline" union:"member"`
	PolarisCatalog *PolarisCatalog `queryParam:"inline" union:"member"`

	Type CatalogTypeType
}

func CreateCatalogTypeBigLakeCatalog(bigLakeCatalog BigLakeCatalog) CatalogType {
	typ := CatalogTypeTypeBigLakeCatalog

	return CatalogType{
		BigLakeCatalog: &bigLakeCatalog,
		Type:           typ,
	}
}

func CreateCatalogTypePolarisCatalog(polarisCatalog PolarisCatalog) CatalogType {
	typ := CatalogTypeTypePolarisCatalog

	return CatalogType{
		PolarisCatalog: &polarisCatalog,
		Type:           typ,
	}
}

func (u *CatalogType) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var bigLakeCatalog BigLakeCatalog = BigLakeCatalog{}
	if err := utils.UnmarshalJSON(data, &bigLakeCatalog, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  CatalogTypeTypeBigLakeCatalog,
			Value: &bigLakeCatalog,
		})
	}

	var polarisCatalog PolarisCatalog = PolarisCatalog{}
	if err := utils.UnmarshalJSON(data, &polarisCatalog, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  CatalogTypeTypePolarisCatalog,
			Value: &polarisCatalog,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for CatalogType", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for CatalogType", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(CatalogTypeType)
	switch best.Type {
	case CatalogTypeTypeBigLakeCatalog:
		u.BigLakeCatalog = best.Value.(*BigLakeCatalog)
		return nil
	case CatalogTypeTypePolarisCatalog:
		u.PolarisCatalog = best.Value.(*PolarisCatalog)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for CatalogType", string(data))
}

func (u CatalogType) MarshalJSON() ([]byte, error) {
	if u.BigLakeCatalog != nil {
		return utils.MarshalJSON(u.BigLakeCatalog, "", true)
	}

	if u.PolarisCatalog != nil {
		return utils.MarshalJSON(u.PolarisCatalog, "", true)
	}

	return nil, errors.New("could not marshal union type CatalogType: all fields are null")
}

type DestinationGcsDataLakeDestinationType string

const (
	DestinationGcsDataLakeDestinationTypeGcsDataLake DestinationGcsDataLakeDestinationType = "gcs-data-lake"
)

func (e DestinationGcsDataLakeDestinationType) ToPointer() *DestinationGcsDataLakeDestinationType {
	return &e
}
func (e *DestinationGcsDataLakeDestinationType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "gcs-data-lake":
		*e = DestinationGcsDataLakeDestinationType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationGcsDataLakeDestinationType: %v", v)
	}
}

// DestinationGcsDataLake - Configuration for GCS Data Lake destination using Apache Iceberg format
type DestinationGcsDataLake struct {
	// Specifies the type of Iceberg catalog (BigLake or Polaris).
	CatalogType CatalogType `json:"catalog_type"`
	// The GCP location (region) for BigLake metastore resources. For example: "us-central1" or "us". See <a href="https://cloud.google.com/biglake/docs/locations">BigLake locations</a> for available regions.
	GcpLocation string `json:"gcp_location"`
	// The GCP project ID where resources are located. If not specified, it will be extracted from the service account credentials.
	GcpProjectID *string `json:"gcp_project_id,omitempty"`
	// The name of the GCS bucket that will host the Iceberg data.
	GcsBucketName string `json:"gcs_bucket_name"`
	// Optional custom GCS endpoint URL. Use this for testing with local GCS emulators.
	GcsEndpoint *string `json:"gcs_endpoint,omitempty"`
	// The primary or default branch name in the catalog. Most query engines will use "main" by default. See <a href="https://iceberg.apache.org/docs/latest/branching/">Iceberg documentation</a> for more information.
	MainBranchName string `json:"main_branch_name"`
	// The default namespace to use for tables. This will ONLY be used if the `Destination Namespace` setting is set to `Destination-defined` or `Source-defined`
	Namespace string `json:"namespace"`
	// The contents of the JSON service account key file. See the <a href="https://cloud.google.com/iam/docs/creating-managing-service-account-keys">Google Cloud documentation</a> for more information on how to obtain this.
	ServiceAccountJSON string `json:"service_account_json"`
	// The root location of the data warehouse used by the Iceberg catalog. Must include the storage protocol "gs://" for Google Cloud Storage. For example: "gs://your-bucket/path/to/warehouse/
	WarehouseLocation    string                                 `json:"warehouse_location"`
	destinationType      *DestinationGcsDataLakeDestinationType `const:"gcs-data-lake" json:"destinationType"`
	AdditionalProperties any                                    `additionalProperties:"true" json:"-"`
}

func (d DestinationGcsDataLake) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationGcsDataLake) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationGcsDataLake) GetCatalogType() CatalogType {
	if d == nil {
		return CatalogType{}
	}
	return d.CatalogType
}

func (d *DestinationGcsDataLake) GetGcpLocation() string {
	if d == nil {
		return ""
	}
	return d.GcpLocation
}

func (d *DestinationGcsDataLake) GetGcpProjectID() *string {
	if d == nil {
		return nil
	}
	return d.GcpProjectID
}

func (d *DestinationGcsDataLake) GetGcsBucketName() string {
	if d == nil {
		return ""
	}
	return d.GcsBucketName
}

func (d *DestinationGcsDataLake) GetGcsEndpoint() *string {
	if d == nil {
		return nil
	}
	return d.GcsEndpoint
}

func (d *DestinationGcsDataLake) GetMainBranchName() string {
	if d == nil {
		return ""
	}
	return d.MainBranchName
}

func (d *DestinationGcsDataLake) GetNamespace() string {
	if d == nil {
		return ""
	}
	return d.Namespace
}

func (d *DestinationGcsDataLake) GetServiceAccountJSON() string {
	if d == nil {
		return ""
	}
	return d.ServiceAccountJSON
}

func (d *DestinationGcsDataLake) GetWarehouseLocation() string {
	if d == nil {
		return ""
	}
	return d.WarehouseLocation
}

func (d *DestinationGcsDataLake) GetDestinationType() *DestinationGcsDataLakeDestinationType {
	return DestinationGcsDataLakeDestinationTypeGcsDataLake.ToPointer()
}

func (d *DestinationGcsDataLake) GetAdditionalProperties() any {
	if d == nil {
		return nil
	}
	return d.AdditionalProperties
}
