// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

// SourceTeradataReplicationMethod - Replication method to use for extracting data from the database. STANDARD replication requires no setup on the DB side but will not be able to represent deletions incrementally. CDC uses the Binlog to detect inserts, updates, and deletes. This needs to be configured on the source database itself.
type SourceTeradataReplicationMethod string

const (
	SourceTeradataReplicationMethodStandard SourceTeradataReplicationMethod = "STANDARD"
	SourceTeradataReplicationMethodCdc      SourceTeradataReplicationMethod = "CDC"
)

func (e SourceTeradataReplicationMethod) ToPointer() *SourceTeradataReplicationMethod {
	return &e
}
func (e *SourceTeradataReplicationMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "STANDARD":
		fallthrough
	case "CDC":
		*e = SourceTeradataReplicationMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceTeradataReplicationMethod: %v", v)
	}
}

// SourceTeradataVerifyFull - Verify-full SSL mode.
type SourceTeradataVerifyFull struct {
	mode string `const:"verify-full" json:"mode"`
	// Specifies the file name of a PEM file that contains Certificate Authority (CA) certificates for use with SSLMODE=verify-full.
	//  See more information - <a href="https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/jdbcug_chapter_2.html#URL_SSLCA"> in the docs</a>.
	SslCaCertificate     string `json:"ssl_ca_certificate"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (s SourceTeradataVerifyFull) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceTeradataVerifyFull) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceTeradataVerifyFull) GetMode() string {
	return "verify-full"
}

func (s *SourceTeradataVerifyFull) GetSslCaCertificate() string {
	if s == nil {
		return ""
	}
	return s.SslCaCertificate
}

func (s *SourceTeradataVerifyFull) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

// SourceTeradataVerifyCa - Verify-ca SSL mode.
type SourceTeradataVerifyCa struct {
	mode string `const:"verify-ca" json:"mode"`
	// Specifies the file name of a PEM file that contains Certificate Authority (CA) certificates for use with SSLMODE=verify-ca.
	//  See more information - <a href="https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/jdbcug_chapter_2.html#URL_SSLCA"> in the docs</a>.
	SslCaCertificate     string `json:"ssl_ca_certificate"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (s SourceTeradataVerifyCa) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceTeradataVerifyCa) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceTeradataVerifyCa) GetMode() string {
	return "verify-ca"
}

func (s *SourceTeradataVerifyCa) GetSslCaCertificate() string {
	if s == nil {
		return ""
	}
	return s.SslCaCertificate
}

func (s *SourceTeradataVerifyCa) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

// SourceTeradataRequire - Require SSL mode.
type SourceTeradataRequire struct {
	mode                 string `const:"require" json:"mode"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (s SourceTeradataRequire) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceTeradataRequire) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceTeradataRequire) GetMode() string {
	return "require"
}

func (s *SourceTeradataRequire) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

// SourceTeradataPrefer - Prefer SSL mode.
type SourceTeradataPrefer struct {
	mode                 string `const:"prefer" json:"mode"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (s SourceTeradataPrefer) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceTeradataPrefer) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceTeradataPrefer) GetMode() string {
	return "prefer"
}

func (s *SourceTeradataPrefer) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

// SourceTeradataAllow - Allow SSL mode.
type SourceTeradataAllow struct {
	mode                 string `const:"allow" json:"mode"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (s SourceTeradataAllow) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceTeradataAllow) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceTeradataAllow) GetMode() string {
	return "allow"
}

func (s *SourceTeradataAllow) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

// SourceTeradataDisable - Disable SSL.
type SourceTeradataDisable struct {
	mode                 string `const:"disable" json:"mode"`
	AdditionalProperties any    `additionalProperties:"true" json:"-"`
}

func (s SourceTeradataDisable) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceTeradataDisable) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceTeradataDisable) GetMode() string {
	return "disable"
}

func (s *SourceTeradataDisable) GetAdditionalProperties() any {
	if s == nil {
		return nil
	}
	return s.AdditionalProperties
}

type SourceTeradataSSLModesType string

const (
	SourceTeradataSSLModesTypeSourceTeradataDisable    SourceTeradataSSLModesType = "source-teradata_disable"
	SourceTeradataSSLModesTypeSourceTeradataAllow      SourceTeradataSSLModesType = "source-teradata_allow"
	SourceTeradataSSLModesTypeSourceTeradataPrefer     SourceTeradataSSLModesType = "source-teradata_prefer"
	SourceTeradataSSLModesTypeSourceTeradataRequire    SourceTeradataSSLModesType = "source-teradata_require"
	SourceTeradataSSLModesTypeSourceTeradataVerifyCa   SourceTeradataSSLModesType = "source-teradata_verify-ca"
	SourceTeradataSSLModesTypeSourceTeradataVerifyFull SourceTeradataSSLModesType = "source-teradata_verify-full"
)

// SourceTeradataSSLModes - SSL connection modes.
//
//	<b>disable</b> - Chose this mode to disable encryption of communication between Airbyte and destination database
//	<b>allow</b> - Chose this mode to enable encryption only when required by the destination database
//	<b>prefer</b> - Chose this mode to allow unencrypted connection only if the destination database does not support encryption
//	<b>require</b> - Chose this mode to always require encryption. If the destination database server does not support encryption, connection will fail
//	 <b>verify-ca</b> - Chose this mode to always require encryption and to verify that the destination database server has a valid SSL certificate
//	 <b>verify-full</b> - This is the most secure mode. Chose this mode to always require encryption and to verify the identity of the destination database server
//	See more information - <a href="https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/jdbcug_chapter_2.html#URL_SSLMODE"> in the docs</a>.
type SourceTeradataSSLModes struct {
	SourceTeradataDisable    *SourceTeradataDisable    `queryParam:"inline" union:"member"`
	SourceTeradataAllow      *SourceTeradataAllow      `queryParam:"inline" union:"member"`
	SourceTeradataPrefer     *SourceTeradataPrefer     `queryParam:"inline" union:"member"`
	SourceTeradataRequire    *SourceTeradataRequire    `queryParam:"inline" union:"member"`
	SourceTeradataVerifyCa   *SourceTeradataVerifyCa   `queryParam:"inline" union:"member"`
	SourceTeradataVerifyFull *SourceTeradataVerifyFull `queryParam:"inline" union:"member"`

	Type SourceTeradataSSLModesType
}

func CreateSourceTeradataSSLModesSourceTeradataDisable(sourceTeradataDisable SourceTeradataDisable) SourceTeradataSSLModes {
	typ := SourceTeradataSSLModesTypeSourceTeradataDisable

	return SourceTeradataSSLModes{
		SourceTeradataDisable: &sourceTeradataDisable,
		Type:                  typ,
	}
}

func CreateSourceTeradataSSLModesSourceTeradataAllow(sourceTeradataAllow SourceTeradataAllow) SourceTeradataSSLModes {
	typ := SourceTeradataSSLModesTypeSourceTeradataAllow

	return SourceTeradataSSLModes{
		SourceTeradataAllow: &sourceTeradataAllow,
		Type:                typ,
	}
}

func CreateSourceTeradataSSLModesSourceTeradataPrefer(sourceTeradataPrefer SourceTeradataPrefer) SourceTeradataSSLModes {
	typ := SourceTeradataSSLModesTypeSourceTeradataPrefer

	return SourceTeradataSSLModes{
		SourceTeradataPrefer: &sourceTeradataPrefer,
		Type:                 typ,
	}
}

func CreateSourceTeradataSSLModesSourceTeradataRequire(sourceTeradataRequire SourceTeradataRequire) SourceTeradataSSLModes {
	typ := SourceTeradataSSLModesTypeSourceTeradataRequire

	return SourceTeradataSSLModes{
		SourceTeradataRequire: &sourceTeradataRequire,
		Type:                  typ,
	}
}

func CreateSourceTeradataSSLModesSourceTeradataVerifyCa(sourceTeradataVerifyCa SourceTeradataVerifyCa) SourceTeradataSSLModes {
	typ := SourceTeradataSSLModesTypeSourceTeradataVerifyCa

	return SourceTeradataSSLModes{
		SourceTeradataVerifyCa: &sourceTeradataVerifyCa,
		Type:                   typ,
	}
}

func CreateSourceTeradataSSLModesSourceTeradataVerifyFull(sourceTeradataVerifyFull SourceTeradataVerifyFull) SourceTeradataSSLModes {
	typ := SourceTeradataSSLModesTypeSourceTeradataVerifyFull

	return SourceTeradataSSLModes{
		SourceTeradataVerifyFull: &sourceTeradataVerifyFull,
		Type:                     typ,
	}
}

func (u *SourceTeradataSSLModes) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var sourceTeradataDisable SourceTeradataDisable = SourceTeradataDisable{}
	if err := utils.UnmarshalJSON(data, &sourceTeradataDisable, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceTeradataSSLModesTypeSourceTeradataDisable,
			Value: &sourceTeradataDisable,
		})
	}

	var sourceTeradataAllow SourceTeradataAllow = SourceTeradataAllow{}
	if err := utils.UnmarshalJSON(data, &sourceTeradataAllow, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceTeradataSSLModesTypeSourceTeradataAllow,
			Value: &sourceTeradataAllow,
		})
	}

	var sourceTeradataPrefer SourceTeradataPrefer = SourceTeradataPrefer{}
	if err := utils.UnmarshalJSON(data, &sourceTeradataPrefer, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceTeradataSSLModesTypeSourceTeradataPrefer,
			Value: &sourceTeradataPrefer,
		})
	}

	var sourceTeradataRequire SourceTeradataRequire = SourceTeradataRequire{}
	if err := utils.UnmarshalJSON(data, &sourceTeradataRequire, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceTeradataSSLModesTypeSourceTeradataRequire,
			Value: &sourceTeradataRequire,
		})
	}

	var sourceTeradataVerifyCa SourceTeradataVerifyCa = SourceTeradataVerifyCa{}
	if err := utils.UnmarshalJSON(data, &sourceTeradataVerifyCa, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceTeradataSSLModesTypeSourceTeradataVerifyCa,
			Value: &sourceTeradataVerifyCa,
		})
	}

	var sourceTeradataVerifyFull SourceTeradataVerifyFull = SourceTeradataVerifyFull{}
	if err := utils.UnmarshalJSON(data, &sourceTeradataVerifyFull, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceTeradataSSLModesTypeSourceTeradataVerifyFull,
			Value: &sourceTeradataVerifyFull,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceTeradataSSLModes", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceTeradataSSLModes", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceTeradataSSLModesType)
	switch best.Type {
	case SourceTeradataSSLModesTypeSourceTeradataDisable:
		u.SourceTeradataDisable = best.Value.(*SourceTeradataDisable)
		return nil
	case SourceTeradataSSLModesTypeSourceTeradataAllow:
		u.SourceTeradataAllow = best.Value.(*SourceTeradataAllow)
		return nil
	case SourceTeradataSSLModesTypeSourceTeradataPrefer:
		u.SourceTeradataPrefer = best.Value.(*SourceTeradataPrefer)
		return nil
	case SourceTeradataSSLModesTypeSourceTeradataRequire:
		u.SourceTeradataRequire = best.Value.(*SourceTeradataRequire)
		return nil
	case SourceTeradataSSLModesTypeSourceTeradataVerifyCa:
		u.SourceTeradataVerifyCa = best.Value.(*SourceTeradataVerifyCa)
		return nil
	case SourceTeradataSSLModesTypeSourceTeradataVerifyFull:
		u.SourceTeradataVerifyFull = best.Value.(*SourceTeradataVerifyFull)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceTeradataSSLModes", string(data))
}

func (u SourceTeradataSSLModes) MarshalJSON() ([]byte, error) {
	if u.SourceTeradataDisable != nil {
		return utils.MarshalJSON(u.SourceTeradataDisable, "", true)
	}

	if u.SourceTeradataAllow != nil {
		return utils.MarshalJSON(u.SourceTeradataAllow, "", true)
	}

	if u.SourceTeradataPrefer != nil {
		return utils.MarshalJSON(u.SourceTeradataPrefer, "", true)
	}

	if u.SourceTeradataRequire != nil {
		return utils.MarshalJSON(u.SourceTeradataRequire, "", true)
	}

	if u.SourceTeradataVerifyCa != nil {
		return utils.MarshalJSON(u.SourceTeradataVerifyCa, "", true)
	}

	if u.SourceTeradataVerifyFull != nil {
		return utils.MarshalJSON(u.SourceTeradataVerifyFull, "", true)
	}

	return nil, errors.New("could not marshal union type SourceTeradataSSLModes: all fields are null")
}

type SourceTeradataSourceType string

const (
	SourceTeradataSourceTypeTeradata SourceTeradataSourceType = "teradata"
)

func (e SourceTeradataSourceType) ToPointer() *SourceTeradataSourceType {
	return &e
}
func (e *SourceTeradataSourceType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "teradata":
		*e = SourceTeradataSourceType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceTeradataSourceType: %v", v)
	}
}

type SourceTeradata struct {
	// Name of the database.
	Database string `json:"database"`
	// Hostname of the database.
	Host string `json:"host"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3)
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// Password associated with the username.
	Password *string `json:"password,omitempty"`
	// Port of the database.
	Port *int64 `default:"1025" json:"port"`
	// Replication method to use for extracting data from the database. STANDARD replication requires no setup on the DB side but will not be able to represent deletions incrementally. CDC uses the Binlog to detect inserts, updates, and deletes. This needs to be configured on the source database itself.
	ReplicationMethod *SourceTeradataReplicationMethod `default:"STANDARD" json:"replication_method"`
	// Encrypt data using SSL. When activating SSL, please select one of the connection modes.
	Ssl *bool `default:"false" json:"ssl"`
	// SSL connection modes.
	//  <b>disable</b> - Chose this mode to disable encryption of communication between Airbyte and destination database
	//  <b>allow</b> - Chose this mode to enable encryption only when required by the destination database
	//  <b>prefer</b> - Chose this mode to allow unencrypted connection only if the destination database does not support encryption
	//  <b>require</b> - Chose this mode to always require encryption. If the destination database server does not support encryption, connection will fail
	//   <b>verify-ca</b> - Chose this mode to always require encryption and to verify that the destination database server has a valid SSL certificate
	//   <b>verify-full</b> - This is the most secure mode. Chose this mode to always require encryption and to verify the identity of the destination database server
	//  See more information - <a href="https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/jdbcug_chapter_2.html#URL_SSLMODE"> in the docs</a>.
	SslMode *SourceTeradataSSLModes `json:"ssl_mode,omitempty"`
	// Username to use to access the database.
	Username   string                    `json:"username"`
	sourceType *SourceTeradataSourceType `const:"teradata" json:"sourceType"`
}

func (s SourceTeradata) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceTeradata) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceTeradata) GetDatabase() string {
	if s == nil {
		return ""
	}
	return s.Database
}

func (s *SourceTeradata) GetHost() string {
	if s == nil {
		return ""
	}
	return s.Host
}

func (s *SourceTeradata) GetJdbcURLParams() *string {
	if s == nil {
		return nil
	}
	return s.JdbcURLParams
}

func (s *SourceTeradata) GetPassword() *string {
	if s == nil {
		return nil
	}
	return s.Password
}

func (s *SourceTeradata) GetPort() *int64 {
	if s == nil {
		return nil
	}
	return s.Port
}

func (s *SourceTeradata) GetReplicationMethod() *SourceTeradataReplicationMethod {
	if s == nil {
		return nil
	}
	return s.ReplicationMethod
}

func (s *SourceTeradata) GetSsl() *bool {
	if s == nil {
		return nil
	}
	return s.Ssl
}

func (s *SourceTeradata) GetSslMode() *SourceTeradataSSLModes {
	if s == nil {
		return nil
	}
	return s.SslMode
}

func (s *SourceTeradata) GetUsername() string {
	if s == nil {
		return ""
	}
	return s.Username
}

func (s *SourceTeradata) GetSourceType() *SourceTeradataSourceType {
	return SourceTeradataSourceTypeTeradata.ToPointer()
}
