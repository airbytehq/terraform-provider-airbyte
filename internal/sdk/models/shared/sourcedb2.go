// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
)

// TLSEncryptedVerifyCertificate - Verify and use the cert provided by the server.
type TLSEncryptedVerifyCertificate struct {
	encryptionMethod string `const:"encrypted_verify_certificate" json:"encryption_method"`
	// Key Store Password
	KeyStorePassword *string `json:"key_store_password,omitempty"`
	// Privacy Enhanced Mail (PEM) files are concatenated certificate containers frequently used in certificate installations
	SslCertificate string `json:"ssl_certificate"`
}

func (t TLSEncryptedVerifyCertificate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(t, "", false)
}

func (t *TLSEncryptedVerifyCertificate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &t, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (t *TLSEncryptedVerifyCertificate) GetEncryptionMethod() string {
	return "encrypted_verify_certificate"
}

func (t *TLSEncryptedVerifyCertificate) GetKeyStorePassword() *string {
	if t == nil {
		return nil
	}
	return t.KeyStorePassword
}

func (t *TLSEncryptedVerifyCertificate) GetSslCertificate() string {
	if t == nil {
		return ""
	}
	return t.SslCertificate
}

// Unencrypted - Data transfer will not be encrypted.
type Unencrypted struct {
	encryptionMethod string `const:"unencrypted" json:"encryption_method"`
}

func (u Unencrypted) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(u, "", false)
}

func (u *Unencrypted) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &u, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (u *Unencrypted) GetEncryptionMethod() string {
	return "unencrypted"
}

type SourceDb2EncryptionType string

const (
	SourceDb2EncryptionTypeUnencrypted                   SourceDb2EncryptionType = "Unencrypted"
	SourceDb2EncryptionTypeTLSEncryptedVerifyCertificate SourceDb2EncryptionType = "TLS Encrypted (verify certificate)"
)

// SourceDb2Encryption - Encryption method to use when communicating with the database
type SourceDb2Encryption struct {
	Unencrypted                   *Unencrypted                   `queryParam:"inline" union:"member"`
	TLSEncryptedVerifyCertificate *TLSEncryptedVerifyCertificate `queryParam:"inline" union:"member"`

	Type SourceDb2EncryptionType
}

func CreateSourceDb2EncryptionUnencrypted(unencrypted Unencrypted) SourceDb2Encryption {
	typ := SourceDb2EncryptionTypeUnencrypted

	return SourceDb2Encryption{
		Unencrypted: &unencrypted,
		Type:        typ,
	}
}

func CreateSourceDb2EncryptionTLSEncryptedVerifyCertificate(tlsEncryptedVerifyCertificate TLSEncryptedVerifyCertificate) SourceDb2Encryption {
	typ := SourceDb2EncryptionTypeTLSEncryptedVerifyCertificate

	return SourceDb2Encryption{
		TLSEncryptedVerifyCertificate: &tlsEncryptedVerifyCertificate,
		Type:                          typ,
	}
}

func (u *SourceDb2Encryption) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var unencrypted Unencrypted = Unencrypted{}
	if err := utils.UnmarshalJSON(data, &unencrypted, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceDb2EncryptionTypeUnencrypted,
			Value: &unencrypted,
		})
	}

	var tlsEncryptedVerifyCertificate TLSEncryptedVerifyCertificate = TLSEncryptedVerifyCertificate{}
	if err := utils.UnmarshalJSON(data, &tlsEncryptedVerifyCertificate, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  SourceDb2EncryptionTypeTLSEncryptedVerifyCertificate,
			Value: &tlsEncryptedVerifyCertificate,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceDb2Encryption", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceDb2Encryption", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(SourceDb2EncryptionType)
	switch best.Type {
	case SourceDb2EncryptionTypeUnencrypted:
		u.Unencrypted = best.Value.(*Unencrypted)
		return nil
	case SourceDb2EncryptionTypeTLSEncryptedVerifyCertificate:
		u.TLSEncryptedVerifyCertificate = best.Value.(*TLSEncryptedVerifyCertificate)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SourceDb2Encryption", string(data))
}

func (u SourceDb2Encryption) MarshalJSON() ([]byte, error) {
	if u.Unencrypted != nil {
		return utils.MarshalJSON(u.Unencrypted, "", true)
	}

	if u.TLSEncryptedVerifyCertificate != nil {
		return utils.MarshalJSON(u.TLSEncryptedVerifyCertificate, "", true)
	}

	return nil, errors.New("could not marshal union type SourceDb2Encryption: all fields are null")
}

type SourceDb2SourceType string

const (
	SourceDb2SourceTypeDb2 SourceDb2SourceType = "db2"
)

func (e SourceDb2SourceType) ToPointer() *SourceDb2SourceType {
	return &e
}
func (e *SourceDb2SourceType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "db2":
		*e = SourceDb2SourceType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceDb2SourceType: %v", v)
	}
}

type SourceDb2 struct {
	// Name of the database.
	Db string `json:"db"`
	// Encryption method to use when communicating with the database
	Encryption SourceDb2Encryption `json:"encryption"`
	// Host of the Db2.
	Host string `json:"host"`
	// Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
	JdbcURLParams *string `json:"jdbc_url_params,omitempty"`
	// Password associated with the username.
	Password string `json:"password"`
	// Port of the database.
	Port *int64 `default:"8123" json:"port"`
	// Username to use to access the database.
	Username   string               `json:"username"`
	sourceType *SourceDb2SourceType `const:"db2" json:"sourceType"`
}

func (s SourceDb2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SourceDb2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (s *SourceDb2) GetDb() string {
	if s == nil {
		return ""
	}
	return s.Db
}

func (s *SourceDb2) GetEncryption() SourceDb2Encryption {
	if s == nil {
		return SourceDb2Encryption{}
	}
	return s.Encryption
}

func (s *SourceDb2) GetHost() string {
	if s == nil {
		return ""
	}
	return s.Host
}

func (s *SourceDb2) GetJdbcURLParams() *string {
	if s == nil {
		return nil
	}
	return s.JdbcURLParams
}

func (s *SourceDb2) GetPassword() string {
	if s == nil {
		return ""
	}
	return s.Password
}

func (s *SourceDb2) GetPort() *int64 {
	if s == nil {
		return nil
	}
	return s.Port
}

func (s *SourceDb2) GetUsername() string {
	if s == nil {
		return ""
	}
	return s.Username
}

func (s *SourceDb2) GetSourceType() *SourceDb2SourceType {
	return SourceDb2SourceTypeDb2.ToPointer()
}
