// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/internal/utils"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/types"
)

// DestinationMongodbUpdateLoginPassword - Login/Password.
type DestinationMongodbUpdateLoginPassword struct {
	authorization *string `const:"login/password" json:"authorization,omitempty"`
	// Password associated with the username.
	Password *string `json:"password,omitempty"`
	// Username to use to access the database.
	Username *string `json:"username,omitempty"`
}

func (d DestinationMongodbUpdateLoginPassword) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationMongodbUpdateLoginPassword) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationMongodbUpdateLoginPassword) GetAuthorization() *string {
	return types.Pointer("login/password")
}

func (d *DestinationMongodbUpdateLoginPassword) GetPassword() *string {
	if d == nil {
		return nil
	}
	return d.Password
}

func (d *DestinationMongodbUpdateLoginPassword) GetUsername() *string {
	if d == nil {
		return nil
	}
	return d.Username
}

// DestinationMongodbUpdateNone - None.
type DestinationMongodbUpdateNone struct {
	authorization *string `const:"none" json:"authorization,omitempty"`
}

func (d DestinationMongodbUpdateNone) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationMongodbUpdateNone) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationMongodbUpdateNone) GetAuthorization() *string {
	return types.Pointer("none")
}

type DestinationMongodbUpdateAuthorizationTypeType string

const (
	DestinationMongodbUpdateAuthorizationTypeTypeDestinationMongodbUpdateNone          DestinationMongodbUpdateAuthorizationTypeType = "destination-mongodb-update_None"
	DestinationMongodbUpdateAuthorizationTypeTypeDestinationMongodbUpdateLoginPassword DestinationMongodbUpdateAuthorizationTypeType = "destination-mongodb-update_Login/Password"
)

// DestinationMongodbUpdateAuthorizationType - Authorization type.
type DestinationMongodbUpdateAuthorizationType struct {
	DestinationMongodbUpdateNone          *DestinationMongodbUpdateNone          `queryParam:"inline" union:"member"`
	DestinationMongodbUpdateLoginPassword *DestinationMongodbUpdateLoginPassword `queryParam:"inline" union:"member"`

	Type DestinationMongodbUpdateAuthorizationTypeType
}

func CreateDestinationMongodbUpdateAuthorizationTypeDestinationMongodbUpdateNone(destinationMongodbUpdateNone DestinationMongodbUpdateNone) DestinationMongodbUpdateAuthorizationType {
	typ := DestinationMongodbUpdateAuthorizationTypeTypeDestinationMongodbUpdateNone

	return DestinationMongodbUpdateAuthorizationType{
		DestinationMongodbUpdateNone: &destinationMongodbUpdateNone,
		Type:                         typ,
	}
}

func CreateDestinationMongodbUpdateAuthorizationTypeDestinationMongodbUpdateLoginPassword(destinationMongodbUpdateLoginPassword DestinationMongodbUpdateLoginPassword) DestinationMongodbUpdateAuthorizationType {
	typ := DestinationMongodbUpdateAuthorizationTypeTypeDestinationMongodbUpdateLoginPassword

	return DestinationMongodbUpdateAuthorizationType{
		DestinationMongodbUpdateLoginPassword: &destinationMongodbUpdateLoginPassword,
		Type:                                  typ,
	}
}

func (u *DestinationMongodbUpdateAuthorizationType) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var destinationMongodbUpdateNone DestinationMongodbUpdateNone = DestinationMongodbUpdateNone{}
	if err := utils.UnmarshalJSON(data, &destinationMongodbUpdateNone, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationMongodbUpdateAuthorizationTypeTypeDestinationMongodbUpdateNone,
			Value: &destinationMongodbUpdateNone,
		})
	}

	var destinationMongodbUpdateLoginPassword DestinationMongodbUpdateLoginPassword = DestinationMongodbUpdateLoginPassword{}
	if err := utils.UnmarshalJSON(data, &destinationMongodbUpdateLoginPassword, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationMongodbUpdateAuthorizationTypeTypeDestinationMongodbUpdateLoginPassword,
			Value: &destinationMongodbUpdateLoginPassword,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationMongodbUpdateAuthorizationType", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationMongodbUpdateAuthorizationType", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(DestinationMongodbUpdateAuthorizationTypeType)
	switch best.Type {
	case DestinationMongodbUpdateAuthorizationTypeTypeDestinationMongodbUpdateNone:
		u.DestinationMongodbUpdateNone = best.Value.(*DestinationMongodbUpdateNone)
		return nil
	case DestinationMongodbUpdateAuthorizationTypeTypeDestinationMongodbUpdateLoginPassword:
		u.DestinationMongodbUpdateLoginPassword = best.Value.(*DestinationMongodbUpdateLoginPassword)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationMongodbUpdateAuthorizationType", string(data))
}

func (u DestinationMongodbUpdateAuthorizationType) MarshalJSON() ([]byte, error) {
	if u.DestinationMongodbUpdateNone != nil {
		return utils.MarshalJSON(u.DestinationMongodbUpdateNone, "", true)
	}

	if u.DestinationMongodbUpdateLoginPassword != nil {
		return utils.MarshalJSON(u.DestinationMongodbUpdateLoginPassword, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationMongodbUpdateAuthorizationType: all fields are null")
}

type DestinationMongodbUpdateSchemasInstanceTypeInstance string

const (
	DestinationMongodbUpdateSchemasInstanceTypeInstanceAtlas DestinationMongodbUpdateSchemasInstanceTypeInstance = "atlas"
)

func (e DestinationMongodbUpdateSchemasInstanceTypeInstance) ToPointer() *DestinationMongodbUpdateSchemasInstanceTypeInstance {
	return &e
}
func (e *DestinationMongodbUpdateSchemasInstanceTypeInstance) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "atlas":
		*e = DestinationMongodbUpdateSchemasInstanceTypeInstance(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationMongodbUpdateSchemasInstanceTypeInstance: %v", v)
	}
}

type DestinationMongodbUpdateMongoDBAtlas struct {
	// URL of a cluster to connect to.
	ClusterURL *string                                              `json:"cluster_url,omitempty"`
	Instance   *DestinationMongodbUpdateSchemasInstanceTypeInstance `default:"atlas" json:"instance"`
}

func (d DestinationMongodbUpdateMongoDBAtlas) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationMongodbUpdateMongoDBAtlas) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationMongodbUpdateMongoDBAtlas) GetClusterURL() *string {
	if d == nil {
		return nil
	}
	return d.ClusterURL
}

func (d *DestinationMongodbUpdateMongoDBAtlas) GetInstance() *DestinationMongodbUpdateSchemasInstanceTypeInstance {
	if d == nil {
		return nil
	}
	return d.Instance
}

type DestinationMongodbUpdateSchemasInstance string

const (
	DestinationMongodbUpdateSchemasInstanceReplica DestinationMongodbUpdateSchemasInstance = "replica"
)

func (e DestinationMongodbUpdateSchemasInstance) ToPointer() *DestinationMongodbUpdateSchemasInstance {
	return &e
}
func (e *DestinationMongodbUpdateSchemasInstance) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "replica":
		*e = DestinationMongodbUpdateSchemasInstance(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationMongodbUpdateSchemasInstance: %v", v)
	}
}

type DestinationMongodbUpdateReplicaSet struct {
	Instance *DestinationMongodbUpdateSchemasInstance `default:"replica" json:"instance"`
	// A replica set name.
	ReplicaSet *string `json:"replica_set,omitempty"`
	// The members of a replica set. Please specify `host`:`port` of each member seperated by comma.
	ServerAddresses *string `json:"server_addresses,omitempty"`
}

func (d DestinationMongodbUpdateReplicaSet) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationMongodbUpdateReplicaSet) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationMongodbUpdateReplicaSet) GetInstance() *DestinationMongodbUpdateSchemasInstance {
	if d == nil {
		return nil
	}
	return d.Instance
}

func (d *DestinationMongodbUpdateReplicaSet) GetReplicaSet() *string {
	if d == nil {
		return nil
	}
	return d.ReplicaSet
}

func (d *DestinationMongodbUpdateReplicaSet) GetServerAddresses() *string {
	if d == nil {
		return nil
	}
	return d.ServerAddresses
}

type DestinationMongodbUpdateInstance string

const (
	DestinationMongodbUpdateInstanceStandalone DestinationMongodbUpdateInstance = "standalone"
)

func (e DestinationMongodbUpdateInstance) ToPointer() *DestinationMongodbUpdateInstance {
	return &e
}
func (e *DestinationMongodbUpdateInstance) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "standalone":
		*e = DestinationMongodbUpdateInstance(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationMongodbUpdateInstance: %v", v)
	}
}

type DestinationMongodbUpdateStandaloneMongoDbInstance struct {
	// The Host of a Mongo database to be replicated.
	Host     *string                           `json:"host,omitempty"`
	Instance *DestinationMongodbUpdateInstance `default:"standalone" json:"instance"`
	// The Port of a Mongo database to be replicated.
	Port *int64 `default:"27017" json:"port"`
}

func (d DestinationMongodbUpdateStandaloneMongoDbInstance) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationMongodbUpdateStandaloneMongoDbInstance) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationMongodbUpdateStandaloneMongoDbInstance) GetHost() *string {
	if d == nil {
		return nil
	}
	return d.Host
}

func (d *DestinationMongodbUpdateStandaloneMongoDbInstance) GetInstance() *DestinationMongodbUpdateInstance {
	if d == nil {
		return nil
	}
	return d.Instance
}

func (d *DestinationMongodbUpdateStandaloneMongoDbInstance) GetPort() *int64 {
	if d == nil {
		return nil
	}
	return d.Port
}

type DestinationMongodbUpdateMongoDbInstanceTypeType string

const (
	DestinationMongodbUpdateMongoDbInstanceTypeTypeDestinationMongodbUpdateStandaloneMongoDbInstance DestinationMongodbUpdateMongoDbInstanceTypeType = "destination-mongodb-update_Standalone MongoDb Instance"
	DestinationMongodbUpdateMongoDbInstanceTypeTypeDestinationMongodbUpdateReplicaSet                DestinationMongodbUpdateMongoDbInstanceTypeType = "destination-mongodb-update_Replica Set"
	DestinationMongodbUpdateMongoDbInstanceTypeTypeDestinationMongodbUpdateMongoDBAtlas              DestinationMongodbUpdateMongoDbInstanceTypeType = "destination-mongodb-update_MongoDB Atlas"
)

// DestinationMongodbUpdateMongoDbInstanceType - MongoDb instance to connect to. For MongoDB Atlas and Replica Set TLS connection is used by default.
type DestinationMongodbUpdateMongoDbInstanceType struct {
	DestinationMongodbUpdateStandaloneMongoDbInstance *DestinationMongodbUpdateStandaloneMongoDbInstance `queryParam:"inline" union:"member"`
	DestinationMongodbUpdateReplicaSet                *DestinationMongodbUpdateReplicaSet                `queryParam:"inline" union:"member"`
	DestinationMongodbUpdateMongoDBAtlas              *DestinationMongodbUpdateMongoDBAtlas              `queryParam:"inline" union:"member"`

	Type DestinationMongodbUpdateMongoDbInstanceTypeType
}

func CreateDestinationMongodbUpdateMongoDbInstanceTypeDestinationMongodbUpdateStandaloneMongoDbInstance(destinationMongodbUpdateStandaloneMongoDbInstance DestinationMongodbUpdateStandaloneMongoDbInstance) DestinationMongodbUpdateMongoDbInstanceType {
	typ := DestinationMongodbUpdateMongoDbInstanceTypeTypeDestinationMongodbUpdateStandaloneMongoDbInstance

	return DestinationMongodbUpdateMongoDbInstanceType{
		DestinationMongodbUpdateStandaloneMongoDbInstance: &destinationMongodbUpdateStandaloneMongoDbInstance,
		Type: typ,
	}
}

func CreateDestinationMongodbUpdateMongoDbInstanceTypeDestinationMongodbUpdateReplicaSet(destinationMongodbUpdateReplicaSet DestinationMongodbUpdateReplicaSet) DestinationMongodbUpdateMongoDbInstanceType {
	typ := DestinationMongodbUpdateMongoDbInstanceTypeTypeDestinationMongodbUpdateReplicaSet

	return DestinationMongodbUpdateMongoDbInstanceType{
		DestinationMongodbUpdateReplicaSet: &destinationMongodbUpdateReplicaSet,
		Type:                               typ,
	}
}

func CreateDestinationMongodbUpdateMongoDbInstanceTypeDestinationMongodbUpdateMongoDBAtlas(destinationMongodbUpdateMongoDBAtlas DestinationMongodbUpdateMongoDBAtlas) DestinationMongodbUpdateMongoDbInstanceType {
	typ := DestinationMongodbUpdateMongoDbInstanceTypeTypeDestinationMongodbUpdateMongoDBAtlas

	return DestinationMongodbUpdateMongoDbInstanceType{
		DestinationMongodbUpdateMongoDBAtlas: &destinationMongodbUpdateMongoDBAtlas,
		Type:                                 typ,
	}
}

func (u *DestinationMongodbUpdateMongoDbInstanceType) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var destinationMongodbUpdateStandaloneMongoDbInstance DestinationMongodbUpdateStandaloneMongoDbInstance = DestinationMongodbUpdateStandaloneMongoDbInstance{}
	if err := utils.UnmarshalJSON(data, &destinationMongodbUpdateStandaloneMongoDbInstance, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationMongodbUpdateMongoDbInstanceTypeTypeDestinationMongodbUpdateStandaloneMongoDbInstance,
			Value: &destinationMongodbUpdateStandaloneMongoDbInstance,
		})
	}

	var destinationMongodbUpdateReplicaSet DestinationMongodbUpdateReplicaSet = DestinationMongodbUpdateReplicaSet{}
	if err := utils.UnmarshalJSON(data, &destinationMongodbUpdateReplicaSet, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationMongodbUpdateMongoDbInstanceTypeTypeDestinationMongodbUpdateReplicaSet,
			Value: &destinationMongodbUpdateReplicaSet,
		})
	}

	var destinationMongodbUpdateMongoDBAtlas DestinationMongodbUpdateMongoDBAtlas = DestinationMongodbUpdateMongoDBAtlas{}
	if err := utils.UnmarshalJSON(data, &destinationMongodbUpdateMongoDBAtlas, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationMongodbUpdateMongoDbInstanceTypeTypeDestinationMongodbUpdateMongoDBAtlas,
			Value: &destinationMongodbUpdateMongoDBAtlas,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationMongodbUpdateMongoDbInstanceType", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationMongodbUpdateMongoDbInstanceType", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(DestinationMongodbUpdateMongoDbInstanceTypeType)
	switch best.Type {
	case DestinationMongodbUpdateMongoDbInstanceTypeTypeDestinationMongodbUpdateStandaloneMongoDbInstance:
		u.DestinationMongodbUpdateStandaloneMongoDbInstance = best.Value.(*DestinationMongodbUpdateStandaloneMongoDbInstance)
		return nil
	case DestinationMongodbUpdateMongoDbInstanceTypeTypeDestinationMongodbUpdateReplicaSet:
		u.DestinationMongodbUpdateReplicaSet = best.Value.(*DestinationMongodbUpdateReplicaSet)
		return nil
	case DestinationMongodbUpdateMongoDbInstanceTypeTypeDestinationMongodbUpdateMongoDBAtlas:
		u.DestinationMongodbUpdateMongoDBAtlas = best.Value.(*DestinationMongodbUpdateMongoDBAtlas)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationMongodbUpdateMongoDbInstanceType", string(data))
}

func (u DestinationMongodbUpdateMongoDbInstanceType) MarshalJSON() ([]byte, error) {
	if u.DestinationMongodbUpdateStandaloneMongoDbInstance != nil {
		return utils.MarshalJSON(u.DestinationMongodbUpdateStandaloneMongoDbInstance, "", true)
	}

	if u.DestinationMongodbUpdateReplicaSet != nil {
		return utils.MarshalJSON(u.DestinationMongodbUpdateReplicaSet, "", true)
	}

	if u.DestinationMongodbUpdateMongoDBAtlas != nil {
		return utils.MarshalJSON(u.DestinationMongodbUpdateMongoDBAtlas, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationMongodbUpdateMongoDbInstanceType: all fields are null")
}

type DestinationMongodbUpdatePasswordAuthentication struct {
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost *string `json:"tunnel_host,omitempty"`
	// Connect through a jump server tunnel host using username and password authentication
	tunnelMethod *string `const:"SSH_PASSWORD_AUTH" json:"tunnel_method,omitempty"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host
	TunnelUser *string `json:"tunnel_user,omitempty"`
	// OS-level password for logging into the jump server host
	TunnelUserPassword *string `json:"tunnel_user_password,omitempty"`
}

func (d DestinationMongodbUpdatePasswordAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationMongodbUpdatePasswordAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationMongodbUpdatePasswordAuthentication) GetTunnelHost() *string {
	if d == nil {
		return nil
	}
	return d.TunnelHost
}

func (d *DestinationMongodbUpdatePasswordAuthentication) GetTunnelMethod() *string {
	return types.Pointer("SSH_PASSWORD_AUTH")
}

func (d *DestinationMongodbUpdatePasswordAuthentication) GetTunnelPort() *int64 {
	if d == nil {
		return nil
	}
	return d.TunnelPort
}

func (d *DestinationMongodbUpdatePasswordAuthentication) GetTunnelUser() *string {
	if d == nil {
		return nil
	}
	return d.TunnelUser
}

func (d *DestinationMongodbUpdatePasswordAuthentication) GetTunnelUserPassword() *string {
	if d == nil {
		return nil
	}
	return d.TunnelUserPassword
}

type DestinationMongodbUpdateSSHKeyAuthentication struct {
	// OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
	SSHKey *string `json:"ssh_key,omitempty"`
	// Hostname of the jump server host that allows inbound ssh tunnel.
	TunnelHost *string `json:"tunnel_host,omitempty"`
	// Connect through a jump server tunnel host using username and ssh key
	tunnelMethod *string `const:"SSH_KEY_AUTH" json:"tunnel_method,omitempty"`
	// Port on the proxy/jump server that accepts inbound ssh connections.
	TunnelPort *int64 `default:"22" json:"tunnel_port"`
	// OS-level username for logging into the jump server host.
	TunnelUser *string `json:"tunnel_user,omitempty"`
}

func (d DestinationMongodbUpdateSSHKeyAuthentication) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationMongodbUpdateSSHKeyAuthentication) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationMongodbUpdateSSHKeyAuthentication) GetSSHKey() *string {
	if d == nil {
		return nil
	}
	return d.SSHKey
}

func (d *DestinationMongodbUpdateSSHKeyAuthentication) GetTunnelHost() *string {
	if d == nil {
		return nil
	}
	return d.TunnelHost
}

func (d *DestinationMongodbUpdateSSHKeyAuthentication) GetTunnelMethod() *string {
	return types.Pointer("SSH_KEY_AUTH")
}

func (d *DestinationMongodbUpdateSSHKeyAuthentication) GetTunnelPort() *int64 {
	if d == nil {
		return nil
	}
	return d.TunnelPort
}

func (d *DestinationMongodbUpdateSSHKeyAuthentication) GetTunnelUser() *string {
	if d == nil {
		return nil
	}
	return d.TunnelUser
}

type DestinationMongodbUpdateNoTunnel struct {
	// No ssh tunnel needed to connect to database
	tunnelMethod *string `const:"NO_TUNNEL" json:"tunnel_method,omitempty"`
}

func (d DestinationMongodbUpdateNoTunnel) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationMongodbUpdateNoTunnel) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationMongodbUpdateNoTunnel) GetTunnelMethod() *string {
	return types.Pointer("NO_TUNNEL")
}

type DestinationMongodbUpdateSSHTunnelMethodType string

const (
	DestinationMongodbUpdateSSHTunnelMethodTypeDestinationMongodbUpdateNoTunnel               DestinationMongodbUpdateSSHTunnelMethodType = "destination-mongodb-update_No Tunnel"
	DestinationMongodbUpdateSSHTunnelMethodTypeDestinationMongodbUpdateSSHKeyAuthentication   DestinationMongodbUpdateSSHTunnelMethodType = "destination-mongodb-update_SSH Key Authentication"
	DestinationMongodbUpdateSSHTunnelMethodTypeDestinationMongodbUpdatePasswordAuthentication DestinationMongodbUpdateSSHTunnelMethodType = "destination-mongodb-update_Password Authentication"
)

// DestinationMongodbUpdateSSHTunnelMethod - Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
type DestinationMongodbUpdateSSHTunnelMethod struct {
	DestinationMongodbUpdateNoTunnel               *DestinationMongodbUpdateNoTunnel               `queryParam:"inline" union:"member"`
	DestinationMongodbUpdateSSHKeyAuthentication   *DestinationMongodbUpdateSSHKeyAuthentication   `queryParam:"inline" union:"member"`
	DestinationMongodbUpdatePasswordAuthentication *DestinationMongodbUpdatePasswordAuthentication `queryParam:"inline" union:"member"`

	Type DestinationMongodbUpdateSSHTunnelMethodType
}

func CreateDestinationMongodbUpdateSSHTunnelMethodDestinationMongodbUpdateNoTunnel(destinationMongodbUpdateNoTunnel DestinationMongodbUpdateNoTunnel) DestinationMongodbUpdateSSHTunnelMethod {
	typ := DestinationMongodbUpdateSSHTunnelMethodTypeDestinationMongodbUpdateNoTunnel

	return DestinationMongodbUpdateSSHTunnelMethod{
		DestinationMongodbUpdateNoTunnel: &destinationMongodbUpdateNoTunnel,
		Type:                             typ,
	}
}

func CreateDestinationMongodbUpdateSSHTunnelMethodDestinationMongodbUpdateSSHKeyAuthentication(destinationMongodbUpdateSSHKeyAuthentication DestinationMongodbUpdateSSHKeyAuthentication) DestinationMongodbUpdateSSHTunnelMethod {
	typ := DestinationMongodbUpdateSSHTunnelMethodTypeDestinationMongodbUpdateSSHKeyAuthentication

	return DestinationMongodbUpdateSSHTunnelMethod{
		DestinationMongodbUpdateSSHKeyAuthentication: &destinationMongodbUpdateSSHKeyAuthentication,
		Type: typ,
	}
}

func CreateDestinationMongodbUpdateSSHTunnelMethodDestinationMongodbUpdatePasswordAuthentication(destinationMongodbUpdatePasswordAuthentication DestinationMongodbUpdatePasswordAuthentication) DestinationMongodbUpdateSSHTunnelMethod {
	typ := DestinationMongodbUpdateSSHTunnelMethodTypeDestinationMongodbUpdatePasswordAuthentication

	return DestinationMongodbUpdateSSHTunnelMethod{
		DestinationMongodbUpdatePasswordAuthentication: &destinationMongodbUpdatePasswordAuthentication,
		Type: typ,
	}
}

func (u *DestinationMongodbUpdateSSHTunnelMethod) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var destinationMongodbUpdateNoTunnel DestinationMongodbUpdateNoTunnel = DestinationMongodbUpdateNoTunnel{}
	if err := utils.UnmarshalJSON(data, &destinationMongodbUpdateNoTunnel, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationMongodbUpdateSSHTunnelMethodTypeDestinationMongodbUpdateNoTunnel,
			Value: &destinationMongodbUpdateNoTunnel,
		})
	}

	var destinationMongodbUpdateSSHKeyAuthentication DestinationMongodbUpdateSSHKeyAuthentication = DestinationMongodbUpdateSSHKeyAuthentication{}
	if err := utils.UnmarshalJSON(data, &destinationMongodbUpdateSSHKeyAuthentication, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationMongodbUpdateSSHTunnelMethodTypeDestinationMongodbUpdateSSHKeyAuthentication,
			Value: &destinationMongodbUpdateSSHKeyAuthentication,
		})
	}

	var destinationMongodbUpdatePasswordAuthentication DestinationMongodbUpdatePasswordAuthentication = DestinationMongodbUpdatePasswordAuthentication{}
	if err := utils.UnmarshalJSON(data, &destinationMongodbUpdatePasswordAuthentication, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DestinationMongodbUpdateSSHTunnelMethodTypeDestinationMongodbUpdatePasswordAuthentication,
			Value: &destinationMongodbUpdatePasswordAuthentication,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationMongodbUpdateSSHTunnelMethod", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationMongodbUpdateSSHTunnelMethod", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(DestinationMongodbUpdateSSHTunnelMethodType)
	switch best.Type {
	case DestinationMongodbUpdateSSHTunnelMethodTypeDestinationMongodbUpdateNoTunnel:
		u.DestinationMongodbUpdateNoTunnel = best.Value.(*DestinationMongodbUpdateNoTunnel)
		return nil
	case DestinationMongodbUpdateSSHTunnelMethodTypeDestinationMongodbUpdateSSHKeyAuthentication:
		u.DestinationMongodbUpdateSSHKeyAuthentication = best.Value.(*DestinationMongodbUpdateSSHKeyAuthentication)
		return nil
	case DestinationMongodbUpdateSSHTunnelMethodTypeDestinationMongodbUpdatePasswordAuthentication:
		u.DestinationMongodbUpdatePasswordAuthentication = best.Value.(*DestinationMongodbUpdatePasswordAuthentication)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DestinationMongodbUpdateSSHTunnelMethod", string(data))
}

func (u DestinationMongodbUpdateSSHTunnelMethod) MarshalJSON() ([]byte, error) {
	if u.DestinationMongodbUpdateNoTunnel != nil {
		return utils.MarshalJSON(u.DestinationMongodbUpdateNoTunnel, "", true)
	}

	if u.DestinationMongodbUpdateSSHKeyAuthentication != nil {
		return utils.MarshalJSON(u.DestinationMongodbUpdateSSHKeyAuthentication, "", true)
	}

	if u.DestinationMongodbUpdatePasswordAuthentication != nil {
		return utils.MarshalJSON(u.DestinationMongodbUpdatePasswordAuthentication, "", true)
	}

	return nil, errors.New("could not marshal union type DestinationMongodbUpdateSSHTunnelMethod: all fields are null")
}

type DestinationMongodbUpdateDestinationType string

const (
	DestinationMongodbUpdateDestinationTypeMongodb DestinationMongodbUpdateDestinationType = "mongodb"
)

func (e DestinationMongodbUpdateDestinationType) ToPointer() *DestinationMongodbUpdateDestinationType {
	return &e
}
func (e *DestinationMongodbUpdateDestinationType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "mongodb":
		*e = DestinationMongodbUpdateDestinationType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DestinationMongodbUpdateDestinationType: %v", v)
	}
}

type DestinationMongodbUpdate struct {
	// Authorization type.
	AuthType *DestinationMongodbUpdateAuthorizationType `json:"auth_type,omitempty"`
	// Name of the database.
	Database *string `json:"database,omitempty"`
	// MongoDb instance to connect to. For MongoDB Atlas and Replica Set TLS connection is used by default.
	InstanceType *DestinationMongodbUpdateMongoDbInstanceType `json:"instance_type,omitempty"`
	// Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
	TunnelMethod    *DestinationMongodbUpdateSSHTunnelMethod `json:"tunnel_method,omitempty"`
	destinationType *DestinationMongodbUpdateDestinationType `const:"mongodb" json:"destinationType"`
}

func (d DestinationMongodbUpdate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DestinationMongodbUpdate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DestinationMongodbUpdate) GetAuthType() *DestinationMongodbUpdateAuthorizationType {
	if d == nil {
		return nil
	}
	return d.AuthType
}

func (d *DestinationMongodbUpdate) GetDatabase() *string {
	if d == nil {
		return nil
	}
	return d.Database
}

func (d *DestinationMongodbUpdate) GetInstanceType() *DestinationMongodbUpdateMongoDbInstanceType {
	if d == nil {
		return nil
	}
	return d.InstanceType
}

func (d *DestinationMongodbUpdate) GetTunnelMethod() *DestinationMongodbUpdateSSHTunnelMethod {
	if d == nil {
		return nil
	}
	return d.TunnelMethod
}

func (d *DestinationMongodbUpdate) GetDestinationType() *DestinationMongodbUpdateDestinationType {
	return DestinationMongodbUpdateDestinationTypeMongodb.ToPointer()
}
