// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"context"
	"fmt"
	speakeasy_int64planmodifier "github.com/airbytehq/terraform-provider-airbyte/internal/planmodifiers/int64planmodifier"
	speakeasy_listplanmodifier "github.com/airbytehq/terraform-provider-airbyte/internal/planmodifiers/listplanmodifier"
	speakeasy_objectplanmodifier "github.com/airbytehq/terraform-provider-airbyte/internal/planmodifiers/objectplanmodifier"
	speakeasy_setplanmodifier "github.com/airbytehq/terraform-provider-airbyte/internal/planmodifiers/setplanmodifier"
	speakeasy_stringplanmodifier "github.com/airbytehq/terraform-provider-airbyte/internal/planmodifiers/stringplanmodifier"
	tfTypes "github.com/airbytehq/terraform-provider-airbyte/internal/provider/types"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/models/operations"
	"github.com/airbytehq/terraform-provider-airbyte/internal/validators"
	speakeasy_objectvalidators "github.com/airbytehq/terraform-provider-airbyte/internal/validators/objectvalidators"
	speakeasy_stringvalidators "github.com/airbytehq/terraform-provider-airbyte/internal/validators/stringvalidators"
	"github.com/hashicorp/terraform-plugin-framework-validators/objectvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &ConnectionResource{}
var _ resource.ResourceWithImportState = &ConnectionResource{}

func NewConnectionResource() resource.Resource {
	return &ConnectionResource{}
}

// ConnectionResource defines the resource implementation.
type ConnectionResource struct {
	client *sdk.SDK
}

// ConnectionResourceModel describes the resource data model.
type ConnectionResourceModel struct {
	Configurations                   *tfTypes.StreamConfigurations         `tfsdk:"configurations"`
	ConnectionID                     types.String                          `tfsdk:"connection_id"`
	CreatedAt                        types.Int64                           `tfsdk:"created_at"`
	DataResidency                    types.String                          `tfsdk:"data_residency"`
	DestinationID                    types.String                          `tfsdk:"destination_id"`
	Name                             types.String                          `tfsdk:"name"`
	NamespaceDefinition              types.String                          `tfsdk:"namespace_definition"`
	NamespaceFormat                  types.String                          `tfsdk:"namespace_format"`
	NonBreakingSchemaUpdatesBehavior types.String                          `tfsdk:"non_breaking_schema_updates_behavior"`
	Prefix                           types.String                          `tfsdk:"prefix"`
	Schedule                         *tfTypes.AirbyteAPIConnectionSchedule `tfsdk:"schedule"`
	SourceID                         types.String                          `tfsdk:"source_id"`
	Status                           types.String                          `tfsdk:"status"`
	Tags                             []tfTypes.Tag                         `tfsdk:"tags"`
	WorkspaceID                      types.String                          `tfsdk:"workspace_id"`
}

func (r *ConnectionResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_connection"
}

func (r *ConnectionResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "Connection Resource",
		Attributes: map[string]schema.Attribute{
			"configurations": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"streams": schema.SetNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Set{
							speakeasy_setplanmodifier.SuppressDiff(speakeasy_setplanmodifier.ExplicitSuppress),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							PlanModifiers: []planmodifier.Object{
								speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
							},
							Attributes: map[string]schema.Attribute{
								"cursor_field": schema.ListAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.List{
										speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
									},
									ElementType: types.StringType,
									Description: `Path to the field that will be used to determine if a record is new or modified since the last sync. This field is REQUIRED if ` + "`" + `sync_mode` + "`" + ` is ` + "`" + `incremental` + "`" + ` unless there is a default.`,
								},
								"mappers": schema.ListNestedAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.List{
										speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
									},
									NestedObject: schema.NestedAttributeObject{
										Validators: []validator.Object{
											speakeasy_objectvalidators.NotNull(),
										},
										PlanModifiers: []planmodifier.Object{
											speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
										},
										Attributes: map[string]schema.Attribute{
											"id": schema.StringAttribute{
												Computed: true,
												Optional: true,
												PlanModifiers: []planmodifier.String{
													speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
												},
											},
											"mapper_configuration": schema.SingleNestedAttribute{
												Computed: true,
												Optional: true,
												PlanModifiers: []planmodifier.Object{
													speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
												},
												Attributes: map[string]schema.Attribute{
													"encryption": schema.SingleNestedAttribute{
														Computed: true,
														Optional: true,
														PlanModifiers: []planmodifier.Object{
															speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
														},
														Attributes: map[string]schema.Attribute{
															"aes": schema.SingleNestedAttribute{
																Computed: true,
																Optional: true,
																PlanModifiers: []planmodifier.Object{
																	speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
																},
																Attributes: map[string]schema.Attribute{
																	"algorithm": schema.StringAttribute{
																		Computed: true,
																		Optional: true,
																		PlanModifiers: []planmodifier.String{
																			speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
																		},
																		Description: `Not Null; must be one of ["RSA", "AES"]`,
																		Validators: []validator.String{
																			speakeasy_stringvalidators.NotNull(),
																			stringvalidator.OneOf(
																				"RSA",
																				"AES",
																			),
																		},
																	},
																	"field_name_suffix": schema.StringAttribute{
																		Computed: true,
																		Optional: true,
																		PlanModifiers: []planmodifier.String{
																			speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
																		},
																		Description: `Not Null`,
																		Validators: []validator.String{
																			speakeasy_stringvalidators.NotNull(),
																		},
																	},
																	"key": schema.StringAttribute{
																		Computed:  true,
																		Optional:  true,
																		Sensitive: true,
																		PlanModifiers: []planmodifier.String{
																			speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
																		},
																		Description: `Not Null`,
																		Validators: []validator.String{
																			speakeasy_stringvalidators.NotNull(),
																		},
																	},
																	"mode": schema.StringAttribute{
																		Computed: true,
																		Optional: true,
																		PlanModifiers: []planmodifier.String{
																			speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
																		},
																		Description: `Not Null; must be one of ["CBC", "CFB", "OFB", "CTR", "GCM", "ECB"]`,
																		Validators: []validator.String{
																			speakeasy_stringvalidators.NotNull(),
																			stringvalidator.OneOf(
																				"CBC",
																				"CFB",
																				"OFB",
																				"CTR",
																				"GCM",
																				"ECB",
																			),
																		},
																	},
																	"padding": schema.StringAttribute{
																		Computed: true,
																		Optional: true,
																		PlanModifiers: []planmodifier.String{
																			speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
																		},
																		Description: `Not Null; must be one of ["NoPadding", "PKCS5Padding"]`,
																		Validators: []validator.String{
																			speakeasy_stringvalidators.NotNull(),
																			stringvalidator.OneOf(
																				"NoPadding",
																				"PKCS5Padding",
																			),
																		},
																	},
																	"target_field": schema.StringAttribute{
																		Computed: true,
																		Optional: true,
																		PlanModifiers: []planmodifier.String{
																			speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
																		},
																		Description: `Not Null`,
																		Validators: []validator.String{
																			speakeasy_stringvalidators.NotNull(),
																		},
																	},
																},
																Validators: []validator.Object{
																	objectvalidator.ConflictsWith(path.Expressions{
																		path.MatchRelative().AtParent().AtName("rsa"),
																	}...),
																},
															},
															"rsa": schema.SingleNestedAttribute{
																Computed: true,
																Optional: true,
																PlanModifiers: []planmodifier.Object{
																	speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
																},
																Attributes: map[string]schema.Attribute{
																	"algorithm": schema.StringAttribute{
																		Computed: true,
																		Optional: true,
																		PlanModifiers: []planmodifier.String{
																			speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
																		},
																		Description: `Not Null; must be one of ["RSA", "AES"]`,
																		Validators: []validator.String{
																			speakeasy_stringvalidators.NotNull(),
																			stringvalidator.OneOf(
																				"RSA",
																				"AES",
																			),
																		},
																	},
																	"field_name_suffix": schema.StringAttribute{
																		Computed: true,
																		Optional: true,
																		PlanModifiers: []planmodifier.String{
																			speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
																		},
																		Description: `Not Null`,
																		Validators: []validator.String{
																			speakeasy_stringvalidators.NotNull(),
																		},
																	},
																	"public_key": schema.StringAttribute{
																		Computed: true,
																		Optional: true,
																		PlanModifiers: []planmodifier.String{
																			speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
																		},
																		Description: `Not Null`,
																		Validators: []validator.String{
																			speakeasy_stringvalidators.NotNull(),
																		},
																	},
																	"target_field": schema.StringAttribute{
																		Computed: true,
																		Optional: true,
																		PlanModifiers: []planmodifier.String{
																			speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
																		},
																		Description: `Not Null`,
																		Validators: []validator.String{
																			speakeasy_stringvalidators.NotNull(),
																		},
																	},
																},
																Validators: []validator.Object{
																	objectvalidator.ConflictsWith(path.Expressions{
																		path.MatchRelative().AtParent().AtName("aes"),
																	}...),
																},
															},
														},
														Validators: []validator.Object{
															objectvalidator.ConflictsWith(path.Expressions{
																path.MatchRelative().AtParent().AtName("field_renaming"),
																path.MatchRelative().AtParent().AtName("hashing"),
																path.MatchRelative().AtParent().AtName("row_filtering"),
															}...),
														},
													},
													"field_renaming": schema.SingleNestedAttribute{
														Computed: true,
														Optional: true,
														PlanModifiers: []planmodifier.Object{
															speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
														},
														Attributes: map[string]schema.Attribute{
															"new_field_name": schema.StringAttribute{
																Computed: true,
																Optional: true,
																PlanModifiers: []planmodifier.String{
																	speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
																},
																Description: `The new name for the field after renaming. Not Null`,
																Validators: []validator.String{
																	speakeasy_stringvalidators.NotNull(),
																},
															},
															"original_field_name": schema.StringAttribute{
																Computed: true,
																Optional: true,
																PlanModifiers: []planmodifier.String{
																	speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
																},
																Description: `The current name of the field to rename. Not Null`,
																Validators: []validator.String{
																	speakeasy_stringvalidators.NotNull(),
																},
															},
														},
														Validators: []validator.Object{
															objectvalidator.ConflictsWith(path.Expressions{
																path.MatchRelative().AtParent().AtName("encryption"),
																path.MatchRelative().AtParent().AtName("hashing"),
																path.MatchRelative().AtParent().AtName("row_filtering"),
															}...),
														},
													},
													"hashing": schema.SingleNestedAttribute{
														Computed: true,
														Optional: true,
														PlanModifiers: []planmodifier.Object{
															speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
														},
														Attributes: map[string]schema.Attribute{
															"field_name_suffix": schema.StringAttribute{
																Computed: true,
																Optional: true,
																PlanModifiers: []planmodifier.String{
																	speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
																},
																Description: `The suffix to append to the field name after hashing. Not Null`,
																Validators: []validator.String{
																	speakeasy_stringvalidators.NotNull(),
																},
															},
															"method": schema.StringAttribute{
																Computed: true,
																Optional: true,
																PlanModifiers: []planmodifier.String{
																	speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
																},
																Description: `The hashing algorithm to use. Not Null; must be one of ["MD2", "MD5", "SHA-1", "SHA-224", "SHA-256", "SHA-384", "SHA-512"]`,
																Validators: []validator.String{
																	speakeasy_stringvalidators.NotNull(),
																	stringvalidator.OneOf(
																		"MD2",
																		"MD5",
																		"SHA-1",
																		"SHA-224",
																		"SHA-256",
																		"SHA-384",
																		"SHA-512",
																	),
																},
															},
															"target_field": schema.StringAttribute{
																Computed: true,
																Optional: true,
																PlanModifiers: []planmodifier.String{
																	speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
																},
																Description: `The name of the field to be hashed. Not Null`,
																Validators: []validator.String{
																	speakeasy_stringvalidators.NotNull(),
																},
															},
														},
														Validators: []validator.Object{
															objectvalidator.ConflictsWith(path.Expressions{
																path.MatchRelative().AtParent().AtName("encryption"),
																path.MatchRelative().AtParent().AtName("field_renaming"),
																path.MatchRelative().AtParent().AtName("row_filtering"),
															}...),
														},
													},
													"row_filtering": schema.SingleNestedAttribute{
														Computed: true,
														Optional: true,
														PlanModifiers: []planmodifier.Object{
															speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
														},
														Attributes: map[string]schema.Attribute{
															"conditions": schema.StringAttribute{
																Computed: true,
																Optional: true,
																PlanModifiers: []planmodifier.String{
																	speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
																},
																Description: `Not Null; Parsed as JSON.`,
																Validators: []validator.String{
																	speakeasy_stringvalidators.NotNull(),
																	validators.IsValidJSON(),
																},
															},
														},
														Validators: []validator.Object{
															objectvalidator.ConflictsWith(path.Expressions{
																path.MatchRelative().AtParent().AtName("encryption"),
																path.MatchRelative().AtParent().AtName("field_renaming"),
																path.MatchRelative().AtParent().AtName("hashing"),
															}...),
														},
													},
												},
												Description: `The values required to configure the mapper. Not Null`,
												Validators: []validator.Object{
													speakeasy_objectvalidators.NotNull(),
												},
											},
											"type": schema.StringAttribute{
												Computed: true,
												Optional: true,
												PlanModifiers: []planmodifier.String{
													speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
												},
												Description: `Not Null; must be one of ["hashing", "field-renaming", "row-filtering", "encryption"]`,
												Validators: []validator.String{
													speakeasy_stringvalidators.NotNull(),
													stringvalidator.OneOf(
														"hashing",
														"field-renaming",
														"row-filtering",
														"encryption",
													),
												},
											},
										},
									},
									Description: `Mappers that should be applied to the stream before writing to the destination.`,
								},
								"name": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `Not Null`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
								"primary_key": schema.ListAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.List{
										speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
									},
									ElementType: types.ListType{
										ElemType: types.StringType,
									},
									Description: `Paths to the fields that will be used as primary key. This field is REQUIRED if ` + "`" + `destination_sync_mode` + "`" + ` is ` + "`" + `*_dedup` + "`" + ` unless it is already supplied by the source schema.`,
								},
								"selected_fields": schema.ListNestedAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.List{
										speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
									},
									NestedObject: schema.NestedAttributeObject{
										Validators: []validator.Object{
											speakeasy_objectvalidators.NotNull(),
										},
										PlanModifiers: []planmodifier.Object{
											speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
										},
										Attributes: map[string]schema.Attribute{
											"field_path": schema.ListAttribute{
												Computed: true,
												Optional: true,
												PlanModifiers: []planmodifier.List{
													speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
												},
												ElementType: types.StringType,
											},
										},
									},
									Description: `Paths to the fields that will be included in the configured catalog.`,
								},
								"sync_mode": schema.StringAttribute{
									Computed: true,
									Optional: true,
									PlanModifiers: []planmodifier.String{
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `must be one of ["full_refresh_overwrite", "full_refresh_overwrite_deduped", "full_refresh_append", "incremental_append", "incremental_deduped_history"]`,
									Validators: []validator.String{
										stringvalidator.OneOf(
											"full_refresh_overwrite",
											"full_refresh_overwrite_deduped",
											"full_refresh_append",
											"incremental_append",
											"incremental_deduped_history",
										),
									},
								},
							},
						},
					},
				},
				Description: `A list of configured stream options for a connection.`,
			},
			"connection_id": schema.StringAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.String{
					speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
				},
			},
			"created_at": schema.Int64Attribute{
				Computed: true,
				PlanModifiers: []planmodifier.Int64{
					speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
				},
			},
			"data_residency": schema.StringAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.String{
					speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
				},
				DeprecationMessage: `We no longer support modifying dataResidency on Community and Enterprise connections. This will be supported on Cloud until May 31, at which time all connections will use the dataResidency of their associated workspace.`,
			},
			"destination_id": schema.StringAttribute{
				Required: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
				},
				Description: `Requires replacement if changed.`,
			},
			"name": schema.StringAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.String{
					speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
				},
				Description: `Optional name of the connection`,
			},
			"namespace_definition": schema.StringAttribute{
				Computed: true,
				Optional: true,
				Default:  stringdefault.StaticString(`destination`),
				PlanModifiers: []planmodifier.String{
					speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
				},
				Description: `Define the location where the data will be stored in the destination. Default: "destination"; must be one of ["source", "destination", "custom_format"]`,
				Validators: []validator.String{
					stringvalidator.OneOf(
						"source",
						"destination",
						"custom_format",
					),
				},
			},
			"namespace_format": schema.StringAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.String{
					speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
				},
				Description: `Used when namespaceDefinition is 'custom_format'. If blank then behaves like namespaceDefinition = 'destination'. If "${SOURCE_NAMESPACE}" then behaves like namespaceDefinition = 'source'.`,
			},
			"non_breaking_schema_updates_behavior": schema.StringAttribute{
				Computed: true,
				Optional: true,
				Default:  stringdefault.StaticString(`ignore`),
				PlanModifiers: []planmodifier.String{
					speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
				},
				Description: `Set how Airbyte handles syncs when it detects a non-breaking schema change in the source. Default: "ignore"; must be one of ["ignore", "disable_connection", "propagate_columns", "propagate_fully"]`,
				Validators: []validator.String{
					stringvalidator.OneOf(
						"ignore",
						"disable_connection",
						"propagate_columns",
						"propagate_fully",
					),
				},
			},
			"prefix": schema.StringAttribute{
				Computed: true,
				Optional: true,
				Default:  stringdefault.StaticString(``),
				PlanModifiers: []planmodifier.String{
					speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
				},
				Description: `Prefix that will be prepended to the name of each stream when it is written to the destination (ex. “airbyte_” causes “projects” => “airbyte_projects”). Default: ""`,
			},
			"schedule": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"basic_timing": schema.StringAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.String{
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
					},
					"cron_expression": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
					},
					"schedule_type": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Not Null; must be one of ["manual", "cron"]`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
							stringvalidator.OneOf(
								"manual",
								"cron",
							),
						},
					},
				},
				Description: `schedule for when the the connection should run, per the schedule type`,
			},
			"source_id": schema.StringAttribute{
				Required: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
				},
				Description: `Requires replacement if changed.`,
			},
			"status": schema.StringAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.String{
					speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
				},
				Description: `must be one of ["active", "inactive", "deprecated"]`,
				Validators: []validator.String{
					stringvalidator.OneOf(
						"active",
						"inactive",
						"deprecated",
					),
				},
			},
			"tags": schema.ListNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.List{
					speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
				},
				NestedObject: schema.NestedAttributeObject{
					Validators: []validator.Object{
						speakeasy_objectvalidators.NotNull(),
					},
					PlanModifiers: []planmodifier.Object{
						speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
					},
					Attributes: map[string]schema.Attribute{
						"color": schema.StringAttribute{
							Computed: true,
							Optional: true,
							PlanModifiers: []planmodifier.String{
								speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
							},
							Description: `Not Null`,
							Validators: []validator.String{
								speakeasy_stringvalidators.NotNull(),
							},
						},
						"name": schema.StringAttribute{
							Computed: true,
							Optional: true,
							PlanModifiers: []planmodifier.String{
								speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
							},
							Description: `Not Null`,
							Validators: []validator.String{
								speakeasy_stringvalidators.NotNull(),
							},
						},
						"tag_id": schema.StringAttribute{
							Computed: true,
							Optional: true,
							PlanModifiers: []planmodifier.String{
								speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
							},
							Description: `Not Null`,
							Validators: []validator.String{
								speakeasy_stringvalidators.NotNull(),
							},
						},
						"workspace_id": schema.StringAttribute{
							Computed: true,
							Optional: true,
							PlanModifiers: []planmodifier.String{
								speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
							},
							Description: `Not Null`,
							Validators: []validator.String{
								speakeasy_stringvalidators.NotNull(),
							},
						},
					},
				},
			},
			"workspace_id": schema.StringAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.String{
					speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
				},
			},
		},
	}
}

func (r *ConnectionResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*sdk.SDK)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *sdk.SDK, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	r.client = client
}

func (r *ConnectionResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data *ConnectionResourceModel
	var plan types.Object

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(plan.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	request := *data.ToSharedConnectionCreateRequest()
	res, err := r.client.Connections.CreateConnection(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.ConnectionResponse != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	data.RefreshFromSharedConnectionResponse(res.ConnectionResponse)
	refreshPlan(ctx, plan, &data, resp.Diagnostics)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *ConnectionResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data *ConnectionResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.State.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	var connectionID string
	connectionID = data.ConnectionID.ValueString()

	request := operations.GetConnectionRequest{
		ConnectionID: connectionID,
	}
	res, err := r.client.Connections.GetConnection(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode == 404 {
		resp.State.RemoveResource(ctx)
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.ConnectionResponse != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	data.RefreshFromSharedConnectionResponse(res.ConnectionResponse)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *ConnectionResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data *ConnectionResourceModel
	var plan types.Object

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	merge(ctx, req, resp, &data)
	if resp.Diagnostics.HasError() {
		return
	}

	var connectionID string
	connectionID = data.ConnectionID.ValueString()

	connectionPatchRequest := *data.ToSharedConnectionPatchRequest()
	request := operations.PatchConnectionRequest{
		ConnectionID:           connectionID,
		ConnectionPatchRequest: connectionPatchRequest,
	}
	res, err := r.client.Connections.PatchConnection(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.ConnectionResponse != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	data.RefreshFromSharedConnectionResponse(res.ConnectionResponse)
	refreshPlan(ctx, plan, &data, resp.Diagnostics)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *ConnectionResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data *ConnectionResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.State.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	var connectionID string
	connectionID = data.ConnectionID.ValueString()

	request := operations.DeleteConnectionRequest{
		ConnectionID: connectionID,
	}
	res, err := r.client.Connections.DeleteConnection(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if fmt.Sprintf("%v", res.StatusCode)[0] != '2' {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}

}

func (r *ConnectionResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("connection_id"), req.ID)...)
}
