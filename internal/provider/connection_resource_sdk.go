// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"context"
	"encoding/json"
	tfTypes "github.com/airbytehq/terraform-provider-airbyte/internal/provider/types"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/models/operations"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/models/shared"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

func (r *ConnectionResourceModel) ToSharedConnectionCreateRequest(ctx context.Context) (*shared.ConnectionCreateRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	name := new(string)
	if !r.Name.IsUnknown() && !r.Name.IsNull() {
		*name = r.Name.ValueString()
	} else {
		name = nil
	}
	var sourceID string
	sourceID = r.SourceID.ValueString()

	var destinationID string
	destinationID = r.DestinationID.ValueString()

	var configurations *shared.StreamConfigurations
	if r.Configurations != nil {
		var streams []shared.StreamConfiguration = []shared.StreamConfiguration{}
		for _, streamsItem := range r.Configurations.Streams {
			var name1 string
			name1 = streamsItem.Name.ValueString()

			namespace := new(string)
			if !streamsItem.Namespace.IsUnknown() && !streamsItem.Namespace.IsNull() {
				*namespace = streamsItem.Namespace.ValueString()
			} else {
				namespace = nil
			}
			syncMode := new(shared.ConnectionSyncModeEnum)
			if !streamsItem.SyncMode.IsUnknown() && !streamsItem.SyncMode.IsNull() {
				*syncMode = shared.ConnectionSyncModeEnum(streamsItem.SyncMode.ValueString())
			} else {
				syncMode = nil
			}
			var cursorField []string = []string{}
			for _, cursorFieldItem := range streamsItem.CursorField {
				cursorField = append(cursorField, cursorFieldItem.ValueString())
			}
			var primaryKey [][]string = [][]string{}
			for _, primaryKeyItem := range streamsItem.PrimaryKey {
				var primaryKeyTmp []string = []string{}
				for _, item := range primaryKeyItem {
					primaryKeyTmp = append(primaryKeyTmp, item.ValueString())
				}
				primaryKey = append(primaryKey, primaryKeyTmp)
			}
			includeFiles := new(bool)
			if !streamsItem.IncludeFiles.IsUnknown() && !streamsItem.IncludeFiles.IsNull() {
				*includeFiles = streamsItem.IncludeFiles.ValueBool()
			} else {
				includeFiles = nil
			}
			var selectedFields []shared.SelectedFieldInfo = []shared.SelectedFieldInfo{}
			for _, selectedFieldsItem := range streamsItem.SelectedFields {
				var fieldPath []string = []string{}
				for _, fieldPathItem := range selectedFieldsItem.FieldPath {
					fieldPath = append(fieldPath, fieldPathItem.ValueString())
				}
				selectedFields = append(selectedFields, shared.SelectedFieldInfo{
					FieldPath: fieldPath,
				})
			}
			var mappers []shared.ConfiguredStreamMapper = []shared.ConfiguredStreamMapper{}
			for _, mappersItem := range streamsItem.Mappers {
				id := new(string)
				if !mappersItem.ID.IsUnknown() && !mappersItem.ID.IsNull() {
					*id = mappersItem.ID.ValueString()
				} else {
					id = nil
				}
				typeVar := shared.StreamMapperType(mappersItem.Type.ValueString())
				var mapperConfiguration shared.MapperConfiguration
				var hashing *shared.Hashing
				if mappersItem.MapperConfiguration.Hashing != nil {
					var fieldNameSuffix string
					fieldNameSuffix = mappersItem.MapperConfiguration.Hashing.FieldNameSuffix.ValueString()

					method := shared.HashingMethod(mappersItem.MapperConfiguration.Hashing.Method.ValueString())
					var targetField string
					targetField = mappersItem.MapperConfiguration.Hashing.TargetField.ValueString()

					hashing = &shared.Hashing{
						FieldNameSuffix: fieldNameSuffix,
						Method:          method,
						TargetField:     targetField,
					}
				}
				if hashing != nil {
					mapperConfiguration = shared.MapperConfiguration{
						Hashing: hashing,
					}
				}
				var fieldRenaming *shared.FieldRenaming
				if mappersItem.MapperConfiguration.FieldRenaming != nil {
					var newFieldName string
					newFieldName = mappersItem.MapperConfiguration.FieldRenaming.NewFieldName.ValueString()

					var originalFieldName string
					originalFieldName = mappersItem.MapperConfiguration.FieldRenaming.OriginalFieldName.ValueString()

					fieldRenaming = &shared.FieldRenaming{
						NewFieldName:      newFieldName,
						OriginalFieldName: originalFieldName,
					}
				}
				if fieldRenaming != nil {
					mapperConfiguration = shared.MapperConfiguration{
						FieldRenaming: fieldRenaming,
					}
				}
				var rowFiltering *shared.RowFiltering
				if mappersItem.MapperConfiguration.RowFiltering != nil {
					var conditions interface{}
					_ = json.Unmarshal([]byte(mappersItem.MapperConfiguration.RowFiltering.Conditions.ValueString()), &conditions)
					rowFiltering = &shared.RowFiltering{
						Conditions: conditions,
					}
				}
				if rowFiltering != nil {
					mapperConfiguration = shared.MapperConfiguration{
						RowFiltering: rowFiltering,
					}
				}
				var encryption *shared.Encryption
				if mappersItem.MapperConfiguration.Encryption != nil {
					var encryptionRSA *shared.EncryptionRSA
					if mappersItem.MapperConfiguration.Encryption.Rsa != nil {
						algorithm := shared.EncryptionMapperAlgorithm(mappersItem.MapperConfiguration.Encryption.Rsa.Algorithm.ValueString())
						var fieldNameSuffix1 string
						fieldNameSuffix1 = mappersItem.MapperConfiguration.Encryption.Rsa.FieldNameSuffix.ValueString()

						var publicKey string
						publicKey = mappersItem.MapperConfiguration.Encryption.Rsa.PublicKey.ValueString()

						var targetField1 string
						targetField1 = mappersItem.MapperConfiguration.Encryption.Rsa.TargetField.ValueString()

						encryptionRSA = &shared.EncryptionRSA{
							Algorithm:       algorithm,
							FieldNameSuffix: fieldNameSuffix1,
							PublicKey:       publicKey,
							TargetField:     targetField1,
						}
					}
					if encryptionRSA != nil {
						encryption = &shared.Encryption{
							EncryptionRSA: encryptionRSA,
						}
					}
					var encryptionAES *shared.EncryptionAES
					if mappersItem.MapperConfiguration.Encryption.Aes != nil {
						algorithm1 := shared.EncryptionMapperAlgorithm(mappersItem.MapperConfiguration.Encryption.Aes.Algorithm.ValueString())
						var fieldNameSuffix2 string
						fieldNameSuffix2 = mappersItem.MapperConfiguration.Encryption.Aes.FieldNameSuffix.ValueString()

						var key string
						key = mappersItem.MapperConfiguration.Encryption.Aes.Key.ValueString()

						mode := shared.Mode(mappersItem.MapperConfiguration.Encryption.Aes.Mode.ValueString())
						padding := shared.Padding(mappersItem.MapperConfiguration.Encryption.Aes.Padding.ValueString())
						var targetField2 string
						targetField2 = mappersItem.MapperConfiguration.Encryption.Aes.TargetField.ValueString()

						encryptionAES = &shared.EncryptionAES{
							Algorithm:       algorithm1,
							FieldNameSuffix: fieldNameSuffix2,
							Key:             key,
							Mode:            mode,
							Padding:         padding,
							TargetField:     targetField2,
						}
					}
					if encryptionAES != nil {
						encryption = &shared.Encryption{
							EncryptionAES: encryptionAES,
						}
					}
				}
				if encryption != nil {
					mapperConfiguration = shared.MapperConfiguration{
						Encryption: encryption,
					}
				}
				mappers = append(mappers, shared.ConfiguredStreamMapper{
					ID:                  id,
					Type:                typeVar,
					MapperConfiguration: mapperConfiguration,
				})
			}
			streams = append(streams, shared.StreamConfiguration{
				Name:           name1,
				Namespace:      namespace,
				SyncMode:       syncMode,
				CursorField:    cursorField,
				PrimaryKey:     primaryKey,
				IncludeFiles:   includeFiles,
				SelectedFields: selectedFields,
				Mappers:        mappers,
			})
		}
		configurations = &shared.StreamConfigurations{
			Streams: streams,
		}
	}
	var schedule *shared.AirbyteAPIConnectionSchedule
	if r.Schedule != nil {
		scheduleType := shared.ScheduleTypeEnum(r.Schedule.ScheduleType.ValueString())
		cronExpression := new(string)
		if !r.Schedule.CronExpression.IsUnknown() && !r.Schedule.CronExpression.IsNull() {
			*cronExpression = r.Schedule.CronExpression.ValueString()
		} else {
			cronExpression = nil
		}
		schedule = &shared.AirbyteAPIConnectionSchedule{
			ScheduleType:   scheduleType,
			CronExpression: cronExpression,
		}
	}
	dataResidency := new(string)
	if !r.DataResidency.IsUnknown() && !r.DataResidency.IsNull() {
		*dataResidency = r.DataResidency.ValueString()
	} else {
		dataResidency = nil
	}
	namespaceDefinition := new(shared.NamespaceDefinitionEnum)
	if !r.NamespaceDefinition.IsUnknown() && !r.NamespaceDefinition.IsNull() {
		*namespaceDefinition = shared.NamespaceDefinitionEnum(r.NamespaceDefinition.ValueString())
	} else {
		namespaceDefinition = nil
	}
	namespaceFormat := new(string)
	if !r.NamespaceFormat.IsUnknown() && !r.NamespaceFormat.IsNull() {
		*namespaceFormat = r.NamespaceFormat.ValueString()
	} else {
		namespaceFormat = nil
	}
	prefix := new(string)
	if !r.Prefix.IsUnknown() && !r.Prefix.IsNull() {
		*prefix = r.Prefix.ValueString()
	} else {
		prefix = nil
	}
	nonBreakingSchemaUpdatesBehavior := new(shared.NonBreakingSchemaUpdatesBehaviorEnum)
	if !r.NonBreakingSchemaUpdatesBehavior.IsUnknown() && !r.NonBreakingSchemaUpdatesBehavior.IsNull() {
		*nonBreakingSchemaUpdatesBehavior = shared.NonBreakingSchemaUpdatesBehaviorEnum(r.NonBreakingSchemaUpdatesBehavior.ValueString())
	} else {
		nonBreakingSchemaUpdatesBehavior = nil
	}
	status := new(shared.ConnectionStatusEnum)
	if !r.Status.IsUnknown() && !r.Status.IsNull() {
		*status = shared.ConnectionStatusEnum(r.Status.ValueString())
	} else {
		status = nil
	}
	var tags []shared.Tag = []shared.Tag{}
	for _, tagsItem := range r.Tags {
		var tagID string
		tagID = tagsItem.TagID.ValueString()

		var workspaceID string
		workspaceID = tagsItem.WorkspaceID.ValueString()

		var name2 string
		name2 = tagsItem.Name.ValueString()

		var color string
		color = tagsItem.Color.ValueString()

		tags = append(tags, shared.Tag{
			TagID:       tagID,
			WorkspaceID: workspaceID,
			Name:        name2,
			Color:       color,
		})
	}
	out := shared.ConnectionCreateRequest{
		Name:                             name,
		SourceID:                         sourceID,
		DestinationID:                    destinationID,
		Configurations:                   configurations,
		Schedule:                         schedule,
		DataResidency:                    dataResidency,
		NamespaceDefinition:              namespaceDefinition,
		NamespaceFormat:                  namespaceFormat,
		Prefix:                           prefix,
		NonBreakingSchemaUpdatesBehavior: nonBreakingSchemaUpdatesBehavior,
		Status:                           status,
		Tags:                             tags,
	}

	return &out, diags
}

func (r *ConnectionResourceModel) ToSharedConnectionPatchRequest(ctx context.Context) (*shared.ConnectionPatchRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	name := new(string)
	if !r.Name.IsUnknown() && !r.Name.IsNull() {
		*name = r.Name.ValueString()
	} else {
		name = nil
	}
	var configurations *shared.StreamConfigurations
	if r.Configurations != nil {
		var streams []shared.StreamConfiguration = []shared.StreamConfiguration{}
		for _, streamsItem := range r.Configurations.Streams {
			var name1 string
			name1 = streamsItem.Name.ValueString()

			namespace := new(string)
			if !streamsItem.Namespace.IsUnknown() && !streamsItem.Namespace.IsNull() {
				*namespace = streamsItem.Namespace.ValueString()
			} else {
				namespace = nil
			}
			syncMode := new(shared.ConnectionSyncModeEnum)
			if !streamsItem.SyncMode.IsUnknown() && !streamsItem.SyncMode.IsNull() {
				*syncMode = shared.ConnectionSyncModeEnum(streamsItem.SyncMode.ValueString())
			} else {
				syncMode = nil
			}
			var cursorField []string = []string{}
			for _, cursorFieldItem := range streamsItem.CursorField {
				cursorField = append(cursorField, cursorFieldItem.ValueString())
			}
			var primaryKey [][]string = [][]string{}
			for _, primaryKeyItem := range streamsItem.PrimaryKey {
				var primaryKeyTmp []string = []string{}
				for _, item := range primaryKeyItem {
					primaryKeyTmp = append(primaryKeyTmp, item.ValueString())
				}
				primaryKey = append(primaryKey, primaryKeyTmp)
			}
			includeFiles := new(bool)
			if !streamsItem.IncludeFiles.IsUnknown() && !streamsItem.IncludeFiles.IsNull() {
				*includeFiles = streamsItem.IncludeFiles.ValueBool()
			} else {
				includeFiles = nil
			}
			var selectedFields []shared.SelectedFieldInfo = []shared.SelectedFieldInfo{}
			for _, selectedFieldsItem := range streamsItem.SelectedFields {
				var fieldPath []string = []string{}
				for _, fieldPathItem := range selectedFieldsItem.FieldPath {
					fieldPath = append(fieldPath, fieldPathItem.ValueString())
				}
				selectedFields = append(selectedFields, shared.SelectedFieldInfo{
					FieldPath: fieldPath,
				})
			}
			var mappers []shared.ConfiguredStreamMapper = []shared.ConfiguredStreamMapper{}
			for _, mappersItem := range streamsItem.Mappers {
				id := new(string)
				if !mappersItem.ID.IsUnknown() && !mappersItem.ID.IsNull() {
					*id = mappersItem.ID.ValueString()
				} else {
					id = nil
				}
				typeVar := shared.StreamMapperType(mappersItem.Type.ValueString())
				var mapperConfiguration shared.MapperConfiguration
				var hashing *shared.Hashing
				if mappersItem.MapperConfiguration.Hashing != nil {
					var fieldNameSuffix string
					fieldNameSuffix = mappersItem.MapperConfiguration.Hashing.FieldNameSuffix.ValueString()

					method := shared.HashingMethod(mappersItem.MapperConfiguration.Hashing.Method.ValueString())
					var targetField string
					targetField = mappersItem.MapperConfiguration.Hashing.TargetField.ValueString()

					hashing = &shared.Hashing{
						FieldNameSuffix: fieldNameSuffix,
						Method:          method,
						TargetField:     targetField,
					}
				}
				if hashing != nil {
					mapperConfiguration = shared.MapperConfiguration{
						Hashing: hashing,
					}
				}
				var fieldRenaming *shared.FieldRenaming
				if mappersItem.MapperConfiguration.FieldRenaming != nil {
					var newFieldName string
					newFieldName = mappersItem.MapperConfiguration.FieldRenaming.NewFieldName.ValueString()

					var originalFieldName string
					originalFieldName = mappersItem.MapperConfiguration.FieldRenaming.OriginalFieldName.ValueString()

					fieldRenaming = &shared.FieldRenaming{
						NewFieldName:      newFieldName,
						OriginalFieldName: originalFieldName,
					}
				}
				if fieldRenaming != nil {
					mapperConfiguration = shared.MapperConfiguration{
						FieldRenaming: fieldRenaming,
					}
				}
				var rowFiltering *shared.RowFiltering
				if mappersItem.MapperConfiguration.RowFiltering != nil {
					var conditions interface{}
					_ = json.Unmarshal([]byte(mappersItem.MapperConfiguration.RowFiltering.Conditions.ValueString()), &conditions)
					rowFiltering = &shared.RowFiltering{
						Conditions: conditions,
					}
				}
				if rowFiltering != nil {
					mapperConfiguration = shared.MapperConfiguration{
						RowFiltering: rowFiltering,
					}
				}
				var encryption *shared.Encryption
				if mappersItem.MapperConfiguration.Encryption != nil {
					var encryptionRSA *shared.EncryptionRSA
					if mappersItem.MapperConfiguration.Encryption.Rsa != nil {
						algorithm := shared.EncryptionMapperAlgorithm(mappersItem.MapperConfiguration.Encryption.Rsa.Algorithm.ValueString())
						var fieldNameSuffix1 string
						fieldNameSuffix1 = mappersItem.MapperConfiguration.Encryption.Rsa.FieldNameSuffix.ValueString()

						var publicKey string
						publicKey = mappersItem.MapperConfiguration.Encryption.Rsa.PublicKey.ValueString()

						var targetField1 string
						targetField1 = mappersItem.MapperConfiguration.Encryption.Rsa.TargetField.ValueString()

						encryptionRSA = &shared.EncryptionRSA{
							Algorithm:       algorithm,
							FieldNameSuffix: fieldNameSuffix1,
							PublicKey:       publicKey,
							TargetField:     targetField1,
						}
					}
					if encryptionRSA != nil {
						encryption = &shared.Encryption{
							EncryptionRSA: encryptionRSA,
						}
					}
					var encryptionAES *shared.EncryptionAES
					if mappersItem.MapperConfiguration.Encryption.Aes != nil {
						algorithm1 := shared.EncryptionMapperAlgorithm(mappersItem.MapperConfiguration.Encryption.Aes.Algorithm.ValueString())
						var fieldNameSuffix2 string
						fieldNameSuffix2 = mappersItem.MapperConfiguration.Encryption.Aes.FieldNameSuffix.ValueString()

						var key string
						key = mappersItem.MapperConfiguration.Encryption.Aes.Key.ValueString()

						mode := shared.Mode(mappersItem.MapperConfiguration.Encryption.Aes.Mode.ValueString())
						padding := shared.Padding(mappersItem.MapperConfiguration.Encryption.Aes.Padding.ValueString())
						var targetField2 string
						targetField2 = mappersItem.MapperConfiguration.Encryption.Aes.TargetField.ValueString()

						encryptionAES = &shared.EncryptionAES{
							Algorithm:       algorithm1,
							FieldNameSuffix: fieldNameSuffix2,
							Key:             key,
							Mode:            mode,
							Padding:         padding,
							TargetField:     targetField2,
						}
					}
					if encryptionAES != nil {
						encryption = &shared.Encryption{
							EncryptionAES: encryptionAES,
						}
					}
				}
				if encryption != nil {
					mapperConfiguration = shared.MapperConfiguration{
						Encryption: encryption,
					}
				}
				mappers = append(mappers, shared.ConfiguredStreamMapper{
					ID:                  id,
					Type:                typeVar,
					MapperConfiguration: mapperConfiguration,
				})
			}
			streams = append(streams, shared.StreamConfiguration{
				Name:           name1,
				Namespace:      namespace,
				SyncMode:       syncMode,
				CursorField:    cursorField,
				PrimaryKey:     primaryKey,
				IncludeFiles:   includeFiles,
				SelectedFields: selectedFields,
				Mappers:        mappers,
			})
		}
		configurations = &shared.StreamConfigurations{
			Streams: streams,
		}
	}
	var schedule *shared.AirbyteAPIConnectionSchedule
	if r.Schedule != nil {
		scheduleType := shared.ScheduleTypeEnum(r.Schedule.ScheduleType.ValueString())
		cronExpression := new(string)
		if !r.Schedule.CronExpression.IsUnknown() && !r.Schedule.CronExpression.IsNull() {
			*cronExpression = r.Schedule.CronExpression.ValueString()
		} else {
			cronExpression = nil
		}
		schedule = &shared.AirbyteAPIConnectionSchedule{
			ScheduleType:   scheduleType,
			CronExpression: cronExpression,
		}
	}
	dataResidency := new(string)
	if !r.DataResidency.IsUnknown() && !r.DataResidency.IsNull() {
		*dataResidency = r.DataResidency.ValueString()
	} else {
		dataResidency = nil
	}
	namespaceDefinition := new(shared.NamespaceDefinitionEnumNoDefault)
	if !r.NamespaceDefinition.IsUnknown() && !r.NamespaceDefinition.IsNull() {
		*namespaceDefinition = shared.NamespaceDefinitionEnumNoDefault(r.NamespaceDefinition.ValueString())
	} else {
		namespaceDefinition = nil
	}
	namespaceFormat := new(string)
	if !r.NamespaceFormat.IsUnknown() && !r.NamespaceFormat.IsNull() {
		*namespaceFormat = r.NamespaceFormat.ValueString()
	} else {
		namespaceFormat = nil
	}
	prefix := new(string)
	if !r.Prefix.IsUnknown() && !r.Prefix.IsNull() {
		*prefix = r.Prefix.ValueString()
	} else {
		prefix = nil
	}
	nonBreakingSchemaUpdatesBehavior := new(shared.NonBreakingSchemaUpdatesBehaviorEnumNoDefault)
	if !r.NonBreakingSchemaUpdatesBehavior.IsUnknown() && !r.NonBreakingSchemaUpdatesBehavior.IsNull() {
		*nonBreakingSchemaUpdatesBehavior = shared.NonBreakingSchemaUpdatesBehaviorEnumNoDefault(r.NonBreakingSchemaUpdatesBehavior.ValueString())
	} else {
		nonBreakingSchemaUpdatesBehavior = nil
	}
	status := new(shared.ConnectionStatusEnum)
	if !r.Status.IsUnknown() && !r.Status.IsNull() {
		*status = shared.ConnectionStatusEnum(r.Status.ValueString())
	} else {
		status = nil
	}
	var tags []shared.Tag = []shared.Tag{}
	for _, tagsItem := range r.Tags {
		var tagID string
		tagID = tagsItem.TagID.ValueString()

		var workspaceID string
		workspaceID = tagsItem.WorkspaceID.ValueString()

		var name2 string
		name2 = tagsItem.Name.ValueString()

		var color string
		color = tagsItem.Color.ValueString()

		tags = append(tags, shared.Tag{
			TagID:       tagID,
			WorkspaceID: workspaceID,
			Name:        name2,
			Color:       color,
		})
	}
	out := shared.ConnectionPatchRequest{
		Name:                             name,
		Configurations:                   configurations,
		Schedule:                         schedule,
		DataResidency:                    dataResidency,
		NamespaceDefinition:              namespaceDefinition,
		NamespaceFormat:                  namespaceFormat,
		Prefix:                           prefix,
		NonBreakingSchemaUpdatesBehavior: nonBreakingSchemaUpdatesBehavior,
		Status:                           status,
		Tags:                             tags,
	}

	return &out, diags
}

func (r *ConnectionResourceModel) ToOperationsPatchConnectionRequest(ctx context.Context) (*operations.PatchConnectionRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var connectionID string
	connectionID = r.ConnectionID.ValueString()

	connectionPatchRequest, connectionPatchRequestDiags := r.ToSharedConnectionPatchRequest(ctx)
	diags.Append(connectionPatchRequestDiags...)

	if diags.HasError() {
		return nil, diags
	}

	out := operations.PatchConnectionRequest{
		ConnectionID:           connectionID,
		ConnectionPatchRequest: *connectionPatchRequest,
	}

	return &out, diags
}

func (r *ConnectionResourceModel) ToOperationsGetConnectionRequest(ctx context.Context) (*operations.GetConnectionRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var connectionID string
	connectionID = r.ConnectionID.ValueString()

	out := operations.GetConnectionRequest{
		ConnectionID: connectionID,
	}

	return &out, diags
}

func (r *ConnectionResourceModel) ToOperationsDeleteConnectionRequest(ctx context.Context) (*operations.DeleteConnectionRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var connectionID string
	connectionID = r.ConnectionID.ValueString()

	out := operations.DeleteConnectionRequest{
		ConnectionID: connectionID,
	}

	return &out, diags
}

func (r *ConnectionResourceModel) RefreshFromSharedConnectionResponse(ctx context.Context, resp *shared.ConnectionResponse) diag.Diagnostics {
	var diags diag.Diagnostics

	if resp != nil {
		if r.Configurations == nil {
			r.Configurations = &tfTypes.StreamConfigurations{}
		}
		r.Configurations.Streams = []tfTypes.StreamConfiguration{}
		if len(r.Configurations.Streams) > len(resp.Configurations.Streams) {
			r.Configurations.Streams = r.Configurations.Streams[:len(resp.Configurations.Streams)]
		}
		for streamsCount, streamsItem := range resp.Configurations.Streams {
			var streams tfTypes.StreamConfiguration
			streams.CursorField = make([]types.String, 0, len(streamsItem.CursorField))
			for _, v := range streamsItem.CursorField {
				streams.CursorField = append(streams.CursorField, types.StringValue(v))
			}
			streams.IncludeFiles = types.BoolPointerValue(streamsItem.IncludeFiles)
			streams.Mappers = []tfTypes.ConfiguredStreamMapper{}
			for mappersCount, mappersItem := range streamsItem.Mappers {
				var mappers tfTypes.ConfiguredStreamMapper
				mappers.ID = types.StringPointerValue(mappersItem.ID)
				if mappersItem.MapperConfiguration.Encryption != nil {
					mappers.MapperConfiguration.Encryption = &tfTypes.Encryption{}
					if mappersItem.MapperConfiguration.Encryption.EncryptionAES != nil {
						mappers.MapperConfiguration.Encryption.Aes = &tfTypes.EncryptionAES{}
						mappers.MapperConfiguration.Encryption.Aes.Algorithm = types.StringValue(string(mappersItem.MapperConfiguration.Encryption.EncryptionAES.Algorithm))
						mappers.MapperConfiguration.Encryption.Aes.FieldNameSuffix = types.StringValue(mappersItem.MapperConfiguration.Encryption.EncryptionAES.FieldNameSuffix)
						mappers.MapperConfiguration.Encryption.Aes.Key = types.StringValue(mappersItem.MapperConfiguration.Encryption.EncryptionAES.Key)
						mappers.MapperConfiguration.Encryption.Aes.Mode = types.StringValue(string(mappersItem.MapperConfiguration.Encryption.EncryptionAES.Mode))
						mappers.MapperConfiguration.Encryption.Aes.Padding = types.StringValue(string(mappersItem.MapperConfiguration.Encryption.EncryptionAES.Padding))
						mappers.MapperConfiguration.Encryption.Aes.TargetField = types.StringValue(mappersItem.MapperConfiguration.Encryption.EncryptionAES.TargetField)
					}
					if mappersItem.MapperConfiguration.Encryption.EncryptionRSA != nil {
						mappers.MapperConfiguration.Encryption.Rsa = &tfTypes.EncryptionRSA{}
						mappers.MapperConfiguration.Encryption.Rsa.Algorithm = types.StringValue(string(mappersItem.MapperConfiguration.Encryption.EncryptionRSA.Algorithm))
						mappers.MapperConfiguration.Encryption.Rsa.FieldNameSuffix = types.StringValue(mappersItem.MapperConfiguration.Encryption.EncryptionRSA.FieldNameSuffix)
						mappers.MapperConfiguration.Encryption.Rsa.PublicKey = types.StringValue(mappersItem.MapperConfiguration.Encryption.EncryptionRSA.PublicKey)
						mappers.MapperConfiguration.Encryption.Rsa.TargetField = types.StringValue(mappersItem.MapperConfiguration.Encryption.EncryptionRSA.TargetField)
					}
				}
				if mappersItem.MapperConfiguration.FieldRenaming != nil {
					mappers.MapperConfiguration.FieldRenaming = &tfTypes.FieldRenaming{}
					mappers.MapperConfiguration.FieldRenaming.NewFieldName = types.StringValue(mappersItem.MapperConfiguration.FieldRenaming.NewFieldName)
					mappers.MapperConfiguration.FieldRenaming.OriginalFieldName = types.StringValue(mappersItem.MapperConfiguration.FieldRenaming.OriginalFieldName)
				}
				if mappersItem.MapperConfiguration.Hashing != nil {
					mappers.MapperConfiguration.Hashing = &tfTypes.Hashing{}
					mappers.MapperConfiguration.Hashing.FieldNameSuffix = types.StringValue(mappersItem.MapperConfiguration.Hashing.FieldNameSuffix)
					mappers.MapperConfiguration.Hashing.Method = types.StringValue(string(mappersItem.MapperConfiguration.Hashing.Method))
					mappers.MapperConfiguration.Hashing.TargetField = types.StringValue(mappersItem.MapperConfiguration.Hashing.TargetField)
				}
				if mappersItem.MapperConfiguration.RowFiltering != nil {
					mappers.MapperConfiguration.RowFiltering = &tfTypes.RowFiltering{}
					conditionsResult, _ := json.Marshal(mappersItem.MapperConfiguration.RowFiltering.Conditions)
					mappers.MapperConfiguration.RowFiltering.Conditions = types.StringValue(string(conditionsResult))
				}
				mappers.Type = types.StringValue(string(mappersItem.Type))
				if mappersCount+1 > len(streams.Mappers) {
					streams.Mappers = append(streams.Mappers, mappers)
				} else {
					streams.Mappers[mappersCount].ID = mappers.ID
					streams.Mappers[mappersCount].MapperConfiguration = mappers.MapperConfiguration
					streams.Mappers[mappersCount].Type = mappers.Type
				}
			}
			streams.Name = types.StringValue(streamsItem.Name)
			streams.Namespace = types.StringPointerValue(streamsItem.Namespace)
			streams.PrimaryKey = nil
			for _, primaryKeyItem := range streamsItem.PrimaryKey {
				var primaryKey []types.String
				primaryKey = make([]types.String, 0, len(primaryKeyItem))
				for _, v := range primaryKeyItem {
					primaryKey = append(primaryKey, types.StringValue(v))
				}
				streams.PrimaryKey = append(streams.PrimaryKey, primaryKey)
			}
			streams.SelectedFields = []tfTypes.SelectedFieldInfo{}
			for selectedFieldsCount, selectedFieldsItem := range streamsItem.SelectedFields {
				var selectedFields tfTypes.SelectedFieldInfo
				selectedFields.FieldPath = make([]types.String, 0, len(selectedFieldsItem.FieldPath))
				for _, v := range selectedFieldsItem.FieldPath {
					selectedFields.FieldPath = append(selectedFields.FieldPath, types.StringValue(v))
				}
				if selectedFieldsCount+1 > len(streams.SelectedFields) {
					streams.SelectedFields = append(streams.SelectedFields, selectedFields)
				} else {
					streams.SelectedFields[selectedFieldsCount].FieldPath = selectedFields.FieldPath
				}
			}
			if streamsItem.SyncMode != nil {
				streams.SyncMode = types.StringValue(string(*streamsItem.SyncMode))
			} else {
				streams.SyncMode = types.StringNull()
			}
			if streamsCount+1 > len(r.Configurations.Streams) {
				r.Configurations.Streams = append(r.Configurations.Streams, streams)
			} else {
				r.Configurations.Streams[streamsCount].CursorField = streams.CursorField
				r.Configurations.Streams[streamsCount].IncludeFiles = streams.IncludeFiles
				r.Configurations.Streams[streamsCount].Mappers = streams.Mappers
				r.Configurations.Streams[streamsCount].Name = streams.Name
				r.Configurations.Streams[streamsCount].Namespace = streams.Namespace
				r.Configurations.Streams[streamsCount].PrimaryKey = streams.PrimaryKey
				r.Configurations.Streams[streamsCount].SelectedFields = streams.SelectedFields
				r.Configurations.Streams[streamsCount].SyncMode = streams.SyncMode
			}
		}
		r.ConnectionID = types.StringValue(resp.ConnectionID)
		r.CreatedAt = types.Int64Value(resp.CreatedAt)
		r.DataResidency = types.StringValue(resp.DataResidency)
		r.DestinationID = types.StringValue(resp.DestinationID)
		r.Name = types.StringValue(resp.Name)
		if resp.NamespaceDefinition != nil {
			r.NamespaceDefinition = types.StringValue(string(*resp.NamespaceDefinition))
		} else {
			r.NamespaceDefinition = types.StringNull()
		}
		r.NamespaceFormat = types.StringPointerValue(resp.NamespaceFormat)
		if resp.NonBreakingSchemaUpdatesBehavior != nil {
			r.NonBreakingSchemaUpdatesBehavior = types.StringValue(string(*resp.NonBreakingSchemaUpdatesBehavior))
		} else {
			r.NonBreakingSchemaUpdatesBehavior = types.StringNull()
		}
		r.Prefix = types.StringPointerValue(resp.Prefix)
		if r.Schedule == nil {
			r.Schedule = &tfTypes.AirbyteAPIConnectionSchedule{}
		}
		r.Schedule.BasicTiming = types.StringPointerValue(resp.Schedule.BasicTiming)
		r.Schedule.CronExpression = types.StringPointerValue(resp.Schedule.CronExpression)
		r.Schedule.ScheduleType = types.StringValue(string(resp.Schedule.ScheduleType))
		r.SourceID = types.StringValue(resp.SourceID)
		r.Status = types.StringValue(string(resp.Status))
		r.Tags = []tfTypes.Tag{}
		if len(r.Tags) > len(resp.Tags) {
			r.Tags = r.Tags[:len(resp.Tags)]
		}
		for tagsCount, tagsItem := range resp.Tags {
			var tags tfTypes.Tag
			tags.Color = types.StringValue(tagsItem.Color)
			tags.Name = types.StringValue(tagsItem.Name)
			tags.TagID = types.StringValue(tagsItem.TagID)
			tags.WorkspaceID = types.StringValue(tagsItem.WorkspaceID)
			if tagsCount+1 > len(r.Tags) {
				r.Tags = append(r.Tags, tags)
			} else {
				r.Tags[tagsCount].Color = tags.Color
				r.Tags[tagsCount].Name = tags.Name
				r.Tags[tagsCount].TagID = tags.TagID
				r.Tags[tagsCount].WorkspaceID = tags.WorkspaceID
			}
		}
		r.WorkspaceID = types.StringValue(resp.WorkspaceID)
	}

	return diags
}
