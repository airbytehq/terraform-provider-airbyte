// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"context"
	tfTypes "github.com/airbytehq/terraform-provider-airbyte/internal/provider/types"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/models/operations"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/models/shared"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"time"
)

func (r *SourceS3ResourceModel) ToSharedSourceS3CreateRequest(ctx context.Context) (*shared.SourceS3CreateRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var name string
	name = r.Name.ValueString()

	definitionID := new(string)
	if !r.DefinitionID.IsUnknown() && !r.DefinitionID.IsNull() {
		*definitionID = r.DefinitionID.ValueString()
	} else {
		definitionID = nil
	}
	var workspaceID string
	workspaceID = r.WorkspaceID.ValueString()

	startDate := new(time.Time)
	if !r.Configuration.StartDate.IsUnknown() && !r.Configuration.StartDate.IsNull() {
		*startDate, _ = time.Parse(time.RFC3339Nano, r.Configuration.StartDate.ValueString())
	} else {
		startDate = nil
	}
	var streams []shared.SourceS3FileBasedStreamConfig = []shared.SourceS3FileBasedStreamConfig{}
	for _, streamsItem := range r.Configuration.Streams {
		var name1 string
		name1 = streamsItem.Name.ValueString()

		var globs []string = []string{}
		for _, globsItem := range streamsItem.Globs {
			globs = append(globs, globsItem.ValueString())
		}
		validationPolicy := new(shared.SourceS3ValidationPolicy)
		if !streamsItem.ValidationPolicy.IsUnknown() && !streamsItem.ValidationPolicy.IsNull() {
			*validationPolicy = shared.SourceS3ValidationPolicy(streamsItem.ValidationPolicy.ValueString())
		} else {
			validationPolicy = nil
		}
		inputSchema := new(string)
		if !streamsItem.InputSchema.IsUnknown() && !streamsItem.InputSchema.IsNull() {
			*inputSchema = streamsItem.InputSchema.ValueString()
		} else {
			inputSchema = nil
		}
		daysToSyncIfHistoryIsFull := new(int64)
		if !streamsItem.DaysToSyncIfHistoryIsFull.IsUnknown() && !streamsItem.DaysToSyncIfHistoryIsFull.IsNull() {
			*daysToSyncIfHistoryIsFull = streamsItem.DaysToSyncIfHistoryIsFull.ValueInt64()
		} else {
			daysToSyncIfHistoryIsFull = nil
		}
		var format shared.SourceS3Format
		var sourceS3AvroFormat *shared.SourceS3AvroFormat
		if streamsItem.Format.AvroFormat != nil {
			doubleAsString := new(bool)
			if !streamsItem.Format.AvroFormat.DoubleAsString.IsUnknown() && !streamsItem.Format.AvroFormat.DoubleAsString.IsNull() {
				*doubleAsString = streamsItem.Format.AvroFormat.DoubleAsString.ValueBool()
			} else {
				doubleAsString = nil
			}
			sourceS3AvroFormat = &shared.SourceS3AvroFormat{
				DoubleAsString: doubleAsString,
			}
		}
		if sourceS3AvroFormat != nil {
			format = shared.SourceS3Format{
				SourceS3AvroFormat: sourceS3AvroFormat,
			}
		}
		var sourceS3CSVFormat *shared.SourceS3CSVFormat
		if streamsItem.Format.CSVFormat != nil {
			delimiter := new(string)
			if !streamsItem.Format.CSVFormat.Delimiter.IsUnknown() && !streamsItem.Format.CSVFormat.Delimiter.IsNull() {
				*delimiter = streamsItem.Format.CSVFormat.Delimiter.ValueString()
			} else {
				delimiter = nil
			}
			quoteChar := new(string)
			if !streamsItem.Format.CSVFormat.QuoteChar.IsUnknown() && !streamsItem.Format.CSVFormat.QuoteChar.IsNull() {
				*quoteChar = streamsItem.Format.CSVFormat.QuoteChar.ValueString()
			} else {
				quoteChar = nil
			}
			escapeChar := new(string)
			if !streamsItem.Format.CSVFormat.EscapeChar.IsUnknown() && !streamsItem.Format.CSVFormat.EscapeChar.IsNull() {
				*escapeChar = streamsItem.Format.CSVFormat.EscapeChar.ValueString()
			} else {
				escapeChar = nil
			}
			encoding := new(string)
			if !streamsItem.Format.CSVFormat.Encoding.IsUnknown() && !streamsItem.Format.CSVFormat.Encoding.IsNull() {
				*encoding = streamsItem.Format.CSVFormat.Encoding.ValueString()
			} else {
				encoding = nil
			}
			doubleQuote := new(bool)
			if !streamsItem.Format.CSVFormat.DoubleQuote.IsUnknown() && !streamsItem.Format.CSVFormat.DoubleQuote.IsNull() {
				*doubleQuote = streamsItem.Format.CSVFormat.DoubleQuote.ValueBool()
			} else {
				doubleQuote = nil
			}
			var nullValues []string = []string{}
			for _, nullValuesItem := range streamsItem.Format.CSVFormat.NullValues {
				nullValues = append(nullValues, nullValuesItem.ValueString())
			}
			stringsCanBeNull := new(bool)
			if !streamsItem.Format.CSVFormat.StringsCanBeNull.IsUnknown() && !streamsItem.Format.CSVFormat.StringsCanBeNull.IsNull() {
				*stringsCanBeNull = streamsItem.Format.CSVFormat.StringsCanBeNull.ValueBool()
			} else {
				stringsCanBeNull = nil
			}
			skipRowsBeforeHeader := new(int64)
			if !streamsItem.Format.CSVFormat.SkipRowsBeforeHeader.IsUnknown() && !streamsItem.Format.CSVFormat.SkipRowsBeforeHeader.IsNull() {
				*skipRowsBeforeHeader = streamsItem.Format.CSVFormat.SkipRowsBeforeHeader.ValueInt64()
			} else {
				skipRowsBeforeHeader = nil
			}
			skipRowsAfterHeader := new(int64)
			if !streamsItem.Format.CSVFormat.SkipRowsAfterHeader.IsUnknown() && !streamsItem.Format.CSVFormat.SkipRowsAfterHeader.IsNull() {
				*skipRowsAfterHeader = streamsItem.Format.CSVFormat.SkipRowsAfterHeader.ValueInt64()
			} else {
				skipRowsAfterHeader = nil
			}
			var headerDefinition *shared.SourceS3CSVHeaderDefinition
			if streamsItem.Format.CSVFormat.HeaderDefinition != nil {
				var sourceS3FromCSV *shared.SourceS3FromCSV
				if streamsItem.Format.CSVFormat.HeaderDefinition.FromCSV != nil {
					sourceS3FromCSV = &shared.SourceS3FromCSV{}
				}
				if sourceS3FromCSV != nil {
					headerDefinition = &shared.SourceS3CSVHeaderDefinition{
						SourceS3FromCSV: sourceS3FromCSV,
					}
				}
				var sourceS3Autogenerated *shared.SourceS3Autogenerated
				if streamsItem.Format.CSVFormat.HeaderDefinition.Autogenerated != nil {
					sourceS3Autogenerated = &shared.SourceS3Autogenerated{}
				}
				if sourceS3Autogenerated != nil {
					headerDefinition = &shared.SourceS3CSVHeaderDefinition{
						SourceS3Autogenerated: sourceS3Autogenerated,
					}
				}
				var sourceS3UserProvided *shared.SourceS3UserProvided
				if streamsItem.Format.CSVFormat.HeaderDefinition.UserProvided != nil {
					var columnNames []string = []string{}
					for _, columnNamesItem := range streamsItem.Format.CSVFormat.HeaderDefinition.UserProvided.ColumnNames {
						columnNames = append(columnNames, columnNamesItem.ValueString())
					}
					sourceS3UserProvided = &shared.SourceS3UserProvided{
						ColumnNames: columnNames,
					}
				}
				if sourceS3UserProvided != nil {
					headerDefinition = &shared.SourceS3CSVHeaderDefinition{
						SourceS3UserProvided: sourceS3UserProvided,
					}
				}
			}
			var trueValues []string = []string{}
			for _, trueValuesItem := range streamsItem.Format.CSVFormat.TrueValues {
				trueValues = append(trueValues, trueValuesItem.ValueString())
			}
			var falseValues []string = []string{}
			for _, falseValuesItem := range streamsItem.Format.CSVFormat.FalseValues {
				falseValues = append(falseValues, falseValuesItem.ValueString())
			}
			ignoreErrorsOnFieldsMismatch := new(bool)
			if !streamsItem.Format.CSVFormat.IgnoreErrorsOnFieldsMismatch.IsUnknown() && !streamsItem.Format.CSVFormat.IgnoreErrorsOnFieldsMismatch.IsNull() {
				*ignoreErrorsOnFieldsMismatch = streamsItem.Format.CSVFormat.IgnoreErrorsOnFieldsMismatch.ValueBool()
			} else {
				ignoreErrorsOnFieldsMismatch = nil
			}
			sourceS3CSVFormat = &shared.SourceS3CSVFormat{
				Delimiter:                    delimiter,
				QuoteChar:                    quoteChar,
				EscapeChar:                   escapeChar,
				Encoding:                     encoding,
				DoubleQuote:                  doubleQuote,
				NullValues:                   nullValues,
				StringsCanBeNull:             stringsCanBeNull,
				SkipRowsBeforeHeader:         skipRowsBeforeHeader,
				SkipRowsAfterHeader:          skipRowsAfterHeader,
				HeaderDefinition:             headerDefinition,
				TrueValues:                   trueValues,
				FalseValues:                  falseValues,
				IgnoreErrorsOnFieldsMismatch: ignoreErrorsOnFieldsMismatch,
			}
		}
		if sourceS3CSVFormat != nil {
			format = shared.SourceS3Format{
				SourceS3CSVFormat: sourceS3CSVFormat,
			}
		}
		var sourceS3JsonlFormat *shared.SourceS3JsonlFormat
		if streamsItem.Format.JsonlFormat != nil {
			sourceS3JsonlFormat = &shared.SourceS3JsonlFormat{}
		}
		if sourceS3JsonlFormat != nil {
			format = shared.SourceS3Format{
				SourceS3JsonlFormat: sourceS3JsonlFormat,
			}
		}
		var sourceS3ParquetFormat *shared.SourceS3ParquetFormat
		if streamsItem.Format.ParquetFormat != nil {
			decimalAsFloat := new(bool)
			if !streamsItem.Format.ParquetFormat.DecimalAsFloat.IsUnknown() && !streamsItem.Format.ParquetFormat.DecimalAsFloat.IsNull() {
				*decimalAsFloat = streamsItem.Format.ParquetFormat.DecimalAsFloat.ValueBool()
			} else {
				decimalAsFloat = nil
			}
			sourceS3ParquetFormat = &shared.SourceS3ParquetFormat{
				DecimalAsFloat: decimalAsFloat,
			}
		}
		if sourceS3ParquetFormat != nil {
			format = shared.SourceS3Format{
				SourceS3ParquetFormat: sourceS3ParquetFormat,
			}
		}
		var sourceS3UnstructuredDocumentFormat *shared.SourceS3UnstructuredDocumentFormat
		if streamsItem.Format.UnstructuredDocumentFormat != nil {
			skipUnprocessableFiles := new(bool)
			if !streamsItem.Format.UnstructuredDocumentFormat.SkipUnprocessableFiles.IsUnknown() && !streamsItem.Format.UnstructuredDocumentFormat.SkipUnprocessableFiles.IsNull() {
				*skipUnprocessableFiles = streamsItem.Format.UnstructuredDocumentFormat.SkipUnprocessableFiles.ValueBool()
			} else {
				skipUnprocessableFiles = nil
			}
			strategy := new(shared.SourceS3ParsingStrategy)
			if !streamsItem.Format.UnstructuredDocumentFormat.Strategy.IsUnknown() && !streamsItem.Format.UnstructuredDocumentFormat.Strategy.IsNull() {
				*strategy = shared.SourceS3ParsingStrategy(streamsItem.Format.UnstructuredDocumentFormat.Strategy.ValueString())
			} else {
				strategy = nil
			}
			var processing *shared.SourceS3Processing
			if streamsItem.Format.UnstructuredDocumentFormat.Processing != nil {
				var sourceS3Local *shared.SourceS3Local
				if streamsItem.Format.UnstructuredDocumentFormat.Processing.Local != nil {
					sourceS3Local = &shared.SourceS3Local{}
				}
				if sourceS3Local != nil {
					processing = &shared.SourceS3Processing{
						SourceS3Local: sourceS3Local,
					}
				}
			}
			sourceS3UnstructuredDocumentFormat = &shared.SourceS3UnstructuredDocumentFormat{
				SkipUnprocessableFiles: skipUnprocessableFiles,
				Strategy:               strategy,
				Processing:             processing,
			}
		}
		if sourceS3UnstructuredDocumentFormat != nil {
			format = shared.SourceS3Format{
				SourceS3UnstructuredDocumentFormat: sourceS3UnstructuredDocumentFormat,
			}
		}
		var sourceS3ExcelFormat *shared.SourceS3ExcelFormat
		if streamsItem.Format.ExcelFormat != nil {
			sourceS3ExcelFormat = &shared.SourceS3ExcelFormat{}
		}
		if sourceS3ExcelFormat != nil {
			format = shared.SourceS3Format{
				SourceS3ExcelFormat: sourceS3ExcelFormat,
			}
		}
		schemaless := new(bool)
		if !streamsItem.Schemaless.IsUnknown() && !streamsItem.Schemaless.IsNull() {
			*schemaless = streamsItem.Schemaless.ValueBool()
		} else {
			schemaless = nil
		}
		recentNFilesToReadForSchemaDiscovery := new(int64)
		if !streamsItem.RecentNFilesToReadForSchemaDiscovery.IsUnknown() && !streamsItem.RecentNFilesToReadForSchemaDiscovery.IsNull() {
			*recentNFilesToReadForSchemaDiscovery = streamsItem.RecentNFilesToReadForSchemaDiscovery.ValueInt64()
		} else {
			recentNFilesToReadForSchemaDiscovery = nil
		}
		streams = append(streams, shared.SourceS3FileBasedStreamConfig{
			Name:                                 name1,
			Globs:                                globs,
			ValidationPolicy:                     validationPolicy,
			InputSchema:                          inputSchema,
			DaysToSyncIfHistoryIsFull:            daysToSyncIfHistoryIsFull,
			Format:                               format,
			Schemaless:                           schemaless,
			RecentNFilesToReadForSchemaDiscovery: recentNFilesToReadForSchemaDiscovery,
		})
	}
	var deliveryMethod *shared.SourceS3DeliveryMethod
	if r.Configuration.DeliveryMethod != nil {
		var sourceS3ReplicateRecords *shared.SourceS3ReplicateRecords
		if r.Configuration.DeliveryMethod.ReplicateRecords != nil {
			sourceS3ReplicateRecords = &shared.SourceS3ReplicateRecords{}
		}
		if sourceS3ReplicateRecords != nil {
			deliveryMethod = &shared.SourceS3DeliveryMethod{
				SourceS3ReplicateRecords: sourceS3ReplicateRecords,
			}
		}
		var sourceS3CopyRawFiles *shared.SourceS3CopyRawFiles
		if r.Configuration.DeliveryMethod.CopyRawFiles != nil {
			preserveDirectoryStructure := new(bool)
			if !r.Configuration.DeliveryMethod.CopyRawFiles.PreserveDirectoryStructure.IsUnknown() && !r.Configuration.DeliveryMethod.CopyRawFiles.PreserveDirectoryStructure.IsNull() {
				*preserveDirectoryStructure = r.Configuration.DeliveryMethod.CopyRawFiles.PreserveDirectoryStructure.ValueBool()
			} else {
				preserveDirectoryStructure = nil
			}
			sourceS3CopyRawFiles = &shared.SourceS3CopyRawFiles{
				PreserveDirectoryStructure: preserveDirectoryStructure,
			}
		}
		if sourceS3CopyRawFiles != nil {
			deliveryMethod = &shared.SourceS3DeliveryMethod{
				SourceS3CopyRawFiles: sourceS3CopyRawFiles,
			}
		}
	}
	var bucket string
	bucket = r.Configuration.Bucket.ValueString()

	awsAccessKeyID := new(string)
	if !r.Configuration.AwsAccessKeyID.IsUnknown() && !r.Configuration.AwsAccessKeyID.IsNull() {
		*awsAccessKeyID = r.Configuration.AwsAccessKeyID.ValueString()
	} else {
		awsAccessKeyID = nil
	}
	roleArn := new(string)
	if !r.Configuration.RoleArn.IsUnknown() && !r.Configuration.RoleArn.IsNull() {
		*roleArn = r.Configuration.RoleArn.ValueString()
	} else {
		roleArn = nil
	}
	awsSecretAccessKey := new(string)
	if !r.Configuration.AwsSecretAccessKey.IsUnknown() && !r.Configuration.AwsSecretAccessKey.IsNull() {
		*awsSecretAccessKey = r.Configuration.AwsSecretAccessKey.ValueString()
	} else {
		awsSecretAccessKey = nil
	}
	endpoint := new(string)
	if !r.Configuration.Endpoint.IsUnknown() && !r.Configuration.Endpoint.IsNull() {
		*endpoint = r.Configuration.Endpoint.ValueString()
	} else {
		endpoint = nil
	}
	regionName := new(string)
	if !r.Configuration.RegionName.IsUnknown() && !r.Configuration.RegionName.IsNull() {
		*regionName = r.Configuration.RegionName.ValueString()
	} else {
		regionName = nil
	}
	configuration := shared.SourceS3{
		StartDate:          startDate,
		Streams:            streams,
		DeliveryMethod:     deliveryMethod,
		Bucket:             bucket,
		AwsAccessKeyID:     awsAccessKeyID,
		RoleArn:            roleArn,
		AwsSecretAccessKey: awsSecretAccessKey,
		Endpoint:           endpoint,
		RegionName:         regionName,
	}
	secretID := new(string)
	if !r.SecretID.IsUnknown() && !r.SecretID.IsNull() {
		*secretID = r.SecretID.ValueString()
	} else {
		secretID = nil
	}
	out := shared.SourceS3CreateRequest{
		Name:          name,
		DefinitionID:  definitionID,
		WorkspaceID:   workspaceID,
		Configuration: configuration,
		SecretID:      secretID,
	}

	return &out, diags
}

func (r *SourceS3ResourceModel) ToSharedSourceS3PutRequest(ctx context.Context) (*shared.SourceS3PutRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var name string
	name = r.Name.ValueString()

	var workspaceID string
	workspaceID = r.WorkspaceID.ValueString()

	startDate := new(time.Time)
	if !r.Configuration.StartDate.IsUnknown() && !r.Configuration.StartDate.IsNull() {
		*startDate, _ = time.Parse(time.RFC3339Nano, r.Configuration.StartDate.ValueString())
	} else {
		startDate = nil
	}
	var streams []shared.SourceS3UpdateFileBasedStreamConfig = []shared.SourceS3UpdateFileBasedStreamConfig{}
	for _, streamsItem := range r.Configuration.Streams {
		var name1 string
		name1 = streamsItem.Name.ValueString()

		var globs []string = []string{}
		for _, globsItem := range streamsItem.Globs {
			globs = append(globs, globsItem.ValueString())
		}
		validationPolicy := new(shared.SourceS3UpdateValidationPolicy)
		if !streamsItem.ValidationPolicy.IsUnknown() && !streamsItem.ValidationPolicy.IsNull() {
			*validationPolicy = shared.SourceS3UpdateValidationPolicy(streamsItem.ValidationPolicy.ValueString())
		} else {
			validationPolicy = nil
		}
		inputSchema := new(string)
		if !streamsItem.InputSchema.IsUnknown() && !streamsItem.InputSchema.IsNull() {
			*inputSchema = streamsItem.InputSchema.ValueString()
		} else {
			inputSchema = nil
		}
		daysToSyncIfHistoryIsFull := new(int64)
		if !streamsItem.DaysToSyncIfHistoryIsFull.IsUnknown() && !streamsItem.DaysToSyncIfHistoryIsFull.IsNull() {
			*daysToSyncIfHistoryIsFull = streamsItem.DaysToSyncIfHistoryIsFull.ValueInt64()
		} else {
			daysToSyncIfHistoryIsFull = nil
		}
		var format shared.SourceS3UpdateFormat
		var sourceS3UpdateAvroFormat *shared.SourceS3UpdateAvroFormat
		if streamsItem.Format.AvroFormat != nil {
			doubleAsString := new(bool)
			if !streamsItem.Format.AvroFormat.DoubleAsString.IsUnknown() && !streamsItem.Format.AvroFormat.DoubleAsString.IsNull() {
				*doubleAsString = streamsItem.Format.AvroFormat.DoubleAsString.ValueBool()
			} else {
				doubleAsString = nil
			}
			sourceS3UpdateAvroFormat = &shared.SourceS3UpdateAvroFormat{
				DoubleAsString: doubleAsString,
			}
		}
		if sourceS3UpdateAvroFormat != nil {
			format = shared.SourceS3UpdateFormat{
				SourceS3UpdateAvroFormat: sourceS3UpdateAvroFormat,
			}
		}
		var sourceS3UpdateCSVFormat *shared.SourceS3UpdateCSVFormat
		if streamsItem.Format.CSVFormat != nil {
			delimiter := new(string)
			if !streamsItem.Format.CSVFormat.Delimiter.IsUnknown() && !streamsItem.Format.CSVFormat.Delimiter.IsNull() {
				*delimiter = streamsItem.Format.CSVFormat.Delimiter.ValueString()
			} else {
				delimiter = nil
			}
			quoteChar := new(string)
			if !streamsItem.Format.CSVFormat.QuoteChar.IsUnknown() && !streamsItem.Format.CSVFormat.QuoteChar.IsNull() {
				*quoteChar = streamsItem.Format.CSVFormat.QuoteChar.ValueString()
			} else {
				quoteChar = nil
			}
			escapeChar := new(string)
			if !streamsItem.Format.CSVFormat.EscapeChar.IsUnknown() && !streamsItem.Format.CSVFormat.EscapeChar.IsNull() {
				*escapeChar = streamsItem.Format.CSVFormat.EscapeChar.ValueString()
			} else {
				escapeChar = nil
			}
			encoding := new(string)
			if !streamsItem.Format.CSVFormat.Encoding.IsUnknown() && !streamsItem.Format.CSVFormat.Encoding.IsNull() {
				*encoding = streamsItem.Format.CSVFormat.Encoding.ValueString()
			} else {
				encoding = nil
			}
			doubleQuote := new(bool)
			if !streamsItem.Format.CSVFormat.DoubleQuote.IsUnknown() && !streamsItem.Format.CSVFormat.DoubleQuote.IsNull() {
				*doubleQuote = streamsItem.Format.CSVFormat.DoubleQuote.ValueBool()
			} else {
				doubleQuote = nil
			}
			var nullValues []string = []string{}
			for _, nullValuesItem := range streamsItem.Format.CSVFormat.NullValues {
				nullValues = append(nullValues, nullValuesItem.ValueString())
			}
			stringsCanBeNull := new(bool)
			if !streamsItem.Format.CSVFormat.StringsCanBeNull.IsUnknown() && !streamsItem.Format.CSVFormat.StringsCanBeNull.IsNull() {
				*stringsCanBeNull = streamsItem.Format.CSVFormat.StringsCanBeNull.ValueBool()
			} else {
				stringsCanBeNull = nil
			}
			skipRowsBeforeHeader := new(int64)
			if !streamsItem.Format.CSVFormat.SkipRowsBeforeHeader.IsUnknown() && !streamsItem.Format.CSVFormat.SkipRowsBeforeHeader.IsNull() {
				*skipRowsBeforeHeader = streamsItem.Format.CSVFormat.SkipRowsBeforeHeader.ValueInt64()
			} else {
				skipRowsBeforeHeader = nil
			}
			skipRowsAfterHeader := new(int64)
			if !streamsItem.Format.CSVFormat.SkipRowsAfterHeader.IsUnknown() && !streamsItem.Format.CSVFormat.SkipRowsAfterHeader.IsNull() {
				*skipRowsAfterHeader = streamsItem.Format.CSVFormat.SkipRowsAfterHeader.ValueInt64()
			} else {
				skipRowsAfterHeader = nil
			}
			var headerDefinition *shared.SourceS3UpdateCSVHeaderDefinition
			if streamsItem.Format.CSVFormat.HeaderDefinition != nil {
				var sourceS3UpdateFromCSV *shared.SourceS3UpdateFromCSV
				if streamsItem.Format.CSVFormat.HeaderDefinition.FromCSV != nil {
					sourceS3UpdateFromCSV = &shared.SourceS3UpdateFromCSV{}
				}
				if sourceS3UpdateFromCSV != nil {
					headerDefinition = &shared.SourceS3UpdateCSVHeaderDefinition{
						SourceS3UpdateFromCSV: sourceS3UpdateFromCSV,
					}
				}
				var sourceS3UpdateAutogenerated *shared.SourceS3UpdateAutogenerated
				if streamsItem.Format.CSVFormat.HeaderDefinition.Autogenerated != nil {
					sourceS3UpdateAutogenerated = &shared.SourceS3UpdateAutogenerated{}
				}
				if sourceS3UpdateAutogenerated != nil {
					headerDefinition = &shared.SourceS3UpdateCSVHeaderDefinition{
						SourceS3UpdateAutogenerated: sourceS3UpdateAutogenerated,
					}
				}
				var sourceS3UpdateUserProvided *shared.SourceS3UpdateUserProvided
				if streamsItem.Format.CSVFormat.HeaderDefinition.UserProvided != nil {
					var columnNames []string = []string{}
					for _, columnNamesItem := range streamsItem.Format.CSVFormat.HeaderDefinition.UserProvided.ColumnNames {
						columnNames = append(columnNames, columnNamesItem.ValueString())
					}
					sourceS3UpdateUserProvided = &shared.SourceS3UpdateUserProvided{
						ColumnNames: columnNames,
					}
				}
				if sourceS3UpdateUserProvided != nil {
					headerDefinition = &shared.SourceS3UpdateCSVHeaderDefinition{
						SourceS3UpdateUserProvided: sourceS3UpdateUserProvided,
					}
				}
			}
			var trueValues []string = []string{}
			for _, trueValuesItem := range streamsItem.Format.CSVFormat.TrueValues {
				trueValues = append(trueValues, trueValuesItem.ValueString())
			}
			var falseValues []string = []string{}
			for _, falseValuesItem := range streamsItem.Format.CSVFormat.FalseValues {
				falseValues = append(falseValues, falseValuesItem.ValueString())
			}
			ignoreErrorsOnFieldsMismatch := new(bool)
			if !streamsItem.Format.CSVFormat.IgnoreErrorsOnFieldsMismatch.IsUnknown() && !streamsItem.Format.CSVFormat.IgnoreErrorsOnFieldsMismatch.IsNull() {
				*ignoreErrorsOnFieldsMismatch = streamsItem.Format.CSVFormat.IgnoreErrorsOnFieldsMismatch.ValueBool()
			} else {
				ignoreErrorsOnFieldsMismatch = nil
			}
			sourceS3UpdateCSVFormat = &shared.SourceS3UpdateCSVFormat{
				Delimiter:                    delimiter,
				QuoteChar:                    quoteChar,
				EscapeChar:                   escapeChar,
				Encoding:                     encoding,
				DoubleQuote:                  doubleQuote,
				NullValues:                   nullValues,
				StringsCanBeNull:             stringsCanBeNull,
				SkipRowsBeforeHeader:         skipRowsBeforeHeader,
				SkipRowsAfterHeader:          skipRowsAfterHeader,
				HeaderDefinition:             headerDefinition,
				TrueValues:                   trueValues,
				FalseValues:                  falseValues,
				IgnoreErrorsOnFieldsMismatch: ignoreErrorsOnFieldsMismatch,
			}
		}
		if sourceS3UpdateCSVFormat != nil {
			format = shared.SourceS3UpdateFormat{
				SourceS3UpdateCSVFormat: sourceS3UpdateCSVFormat,
			}
		}
		var sourceS3UpdateJsonlFormat *shared.SourceS3UpdateJsonlFormat
		if streamsItem.Format.JsonlFormat != nil {
			sourceS3UpdateJsonlFormat = &shared.SourceS3UpdateJsonlFormat{}
		}
		if sourceS3UpdateJsonlFormat != nil {
			format = shared.SourceS3UpdateFormat{
				SourceS3UpdateJsonlFormat: sourceS3UpdateJsonlFormat,
			}
		}
		var sourceS3UpdateParquetFormat *shared.SourceS3UpdateParquetFormat
		if streamsItem.Format.ParquetFormat != nil {
			decimalAsFloat := new(bool)
			if !streamsItem.Format.ParquetFormat.DecimalAsFloat.IsUnknown() && !streamsItem.Format.ParquetFormat.DecimalAsFloat.IsNull() {
				*decimalAsFloat = streamsItem.Format.ParquetFormat.DecimalAsFloat.ValueBool()
			} else {
				decimalAsFloat = nil
			}
			sourceS3UpdateParquetFormat = &shared.SourceS3UpdateParquetFormat{
				DecimalAsFloat: decimalAsFloat,
			}
		}
		if sourceS3UpdateParquetFormat != nil {
			format = shared.SourceS3UpdateFormat{
				SourceS3UpdateParquetFormat: sourceS3UpdateParquetFormat,
			}
		}
		var sourceS3UpdateUnstructuredDocumentFormat *shared.SourceS3UpdateUnstructuredDocumentFormat
		if streamsItem.Format.UnstructuredDocumentFormat != nil {
			skipUnprocessableFiles := new(bool)
			if !streamsItem.Format.UnstructuredDocumentFormat.SkipUnprocessableFiles.IsUnknown() && !streamsItem.Format.UnstructuredDocumentFormat.SkipUnprocessableFiles.IsNull() {
				*skipUnprocessableFiles = streamsItem.Format.UnstructuredDocumentFormat.SkipUnprocessableFiles.ValueBool()
			} else {
				skipUnprocessableFiles = nil
			}
			strategy := new(shared.SourceS3UpdateParsingStrategy)
			if !streamsItem.Format.UnstructuredDocumentFormat.Strategy.IsUnknown() && !streamsItem.Format.UnstructuredDocumentFormat.Strategy.IsNull() {
				*strategy = shared.SourceS3UpdateParsingStrategy(streamsItem.Format.UnstructuredDocumentFormat.Strategy.ValueString())
			} else {
				strategy = nil
			}
			var processing *shared.SourceS3UpdateProcessing
			if streamsItem.Format.UnstructuredDocumentFormat.Processing != nil {
				var sourceS3UpdateLocal *shared.SourceS3UpdateLocal
				if streamsItem.Format.UnstructuredDocumentFormat.Processing.Local != nil {
					sourceS3UpdateLocal = &shared.SourceS3UpdateLocal{}
				}
				if sourceS3UpdateLocal != nil {
					processing = &shared.SourceS3UpdateProcessing{
						SourceS3UpdateLocal: sourceS3UpdateLocal,
					}
				}
			}
			sourceS3UpdateUnstructuredDocumentFormat = &shared.SourceS3UpdateUnstructuredDocumentFormat{
				SkipUnprocessableFiles: skipUnprocessableFiles,
				Strategy:               strategy,
				Processing:             processing,
			}
		}
		if sourceS3UpdateUnstructuredDocumentFormat != nil {
			format = shared.SourceS3UpdateFormat{
				SourceS3UpdateUnstructuredDocumentFormat: sourceS3UpdateUnstructuredDocumentFormat,
			}
		}
		var sourceS3UpdateExcelFormat *shared.SourceS3UpdateExcelFormat
		if streamsItem.Format.ExcelFormat != nil {
			sourceS3UpdateExcelFormat = &shared.SourceS3UpdateExcelFormat{}
		}
		if sourceS3UpdateExcelFormat != nil {
			format = shared.SourceS3UpdateFormat{
				SourceS3UpdateExcelFormat: sourceS3UpdateExcelFormat,
			}
		}
		schemaless := new(bool)
		if !streamsItem.Schemaless.IsUnknown() && !streamsItem.Schemaless.IsNull() {
			*schemaless = streamsItem.Schemaless.ValueBool()
		} else {
			schemaless = nil
		}
		recentNFilesToReadForSchemaDiscovery := new(int64)
		if !streamsItem.RecentNFilesToReadForSchemaDiscovery.IsUnknown() && !streamsItem.RecentNFilesToReadForSchemaDiscovery.IsNull() {
			*recentNFilesToReadForSchemaDiscovery = streamsItem.RecentNFilesToReadForSchemaDiscovery.ValueInt64()
		} else {
			recentNFilesToReadForSchemaDiscovery = nil
		}
		streams = append(streams, shared.SourceS3UpdateFileBasedStreamConfig{
			Name:                                 name1,
			Globs:                                globs,
			ValidationPolicy:                     validationPolicy,
			InputSchema:                          inputSchema,
			DaysToSyncIfHistoryIsFull:            daysToSyncIfHistoryIsFull,
			Format:                               format,
			Schemaless:                           schemaless,
			RecentNFilesToReadForSchemaDiscovery: recentNFilesToReadForSchemaDiscovery,
		})
	}
	var deliveryMethod *shared.SourceS3UpdateDeliveryMethod
	if r.Configuration.DeliveryMethod != nil {
		var sourceS3UpdateReplicateRecords *shared.SourceS3UpdateReplicateRecords
		if r.Configuration.DeliveryMethod.ReplicateRecords != nil {
			sourceS3UpdateReplicateRecords = &shared.SourceS3UpdateReplicateRecords{}
		}
		if sourceS3UpdateReplicateRecords != nil {
			deliveryMethod = &shared.SourceS3UpdateDeliveryMethod{
				SourceS3UpdateReplicateRecords: sourceS3UpdateReplicateRecords,
			}
		}
		var sourceS3UpdateCopyRawFiles *shared.SourceS3UpdateCopyRawFiles
		if r.Configuration.DeliveryMethod.CopyRawFiles != nil {
			preserveDirectoryStructure := new(bool)
			if !r.Configuration.DeliveryMethod.CopyRawFiles.PreserveDirectoryStructure.IsUnknown() && !r.Configuration.DeliveryMethod.CopyRawFiles.PreserveDirectoryStructure.IsNull() {
				*preserveDirectoryStructure = r.Configuration.DeliveryMethod.CopyRawFiles.PreserveDirectoryStructure.ValueBool()
			} else {
				preserveDirectoryStructure = nil
			}
			sourceS3UpdateCopyRawFiles = &shared.SourceS3UpdateCopyRawFiles{
				PreserveDirectoryStructure: preserveDirectoryStructure,
			}
		}
		if sourceS3UpdateCopyRawFiles != nil {
			deliveryMethod = &shared.SourceS3UpdateDeliveryMethod{
				SourceS3UpdateCopyRawFiles: sourceS3UpdateCopyRawFiles,
			}
		}
	}
	var bucket string
	bucket = r.Configuration.Bucket.ValueString()

	awsAccessKeyID := new(string)
	if !r.Configuration.AwsAccessKeyID.IsUnknown() && !r.Configuration.AwsAccessKeyID.IsNull() {
		*awsAccessKeyID = r.Configuration.AwsAccessKeyID.ValueString()
	} else {
		awsAccessKeyID = nil
	}
	roleArn := new(string)
	if !r.Configuration.RoleArn.IsUnknown() && !r.Configuration.RoleArn.IsNull() {
		*roleArn = r.Configuration.RoleArn.ValueString()
	} else {
		roleArn = nil
	}
	awsSecretAccessKey := new(string)
	if !r.Configuration.AwsSecretAccessKey.IsUnknown() && !r.Configuration.AwsSecretAccessKey.IsNull() {
		*awsSecretAccessKey = r.Configuration.AwsSecretAccessKey.ValueString()
	} else {
		awsSecretAccessKey = nil
	}
	endpoint := new(string)
	if !r.Configuration.Endpoint.IsUnknown() && !r.Configuration.Endpoint.IsNull() {
		*endpoint = r.Configuration.Endpoint.ValueString()
	} else {
		endpoint = nil
	}
	regionName := new(string)
	if !r.Configuration.RegionName.IsUnknown() && !r.Configuration.RegionName.IsNull() {
		*regionName = r.Configuration.RegionName.ValueString()
	} else {
		regionName = nil
	}
	configuration := shared.SourceS3Update{
		StartDate:          startDate,
		Streams:            streams,
		DeliveryMethod:     deliveryMethod,
		Bucket:             bucket,
		AwsAccessKeyID:     awsAccessKeyID,
		RoleArn:            roleArn,
		AwsSecretAccessKey: awsSecretAccessKey,
		Endpoint:           endpoint,
		RegionName:         regionName,
	}
	out := shared.SourceS3PutRequest{
		Name:          name,
		WorkspaceID:   workspaceID,
		Configuration: configuration,
	}

	return &out, diags
}

func (r *SourceS3ResourceModel) ToOperationsPutSourceS3Request(ctx context.Context) (*operations.PutSourceS3Request, diag.Diagnostics) {
	var diags diag.Diagnostics

	var sourceID string
	sourceID = r.SourceID.ValueString()

	sourceS3PutRequest, sourceS3PutRequestDiags := r.ToSharedSourceS3PutRequest(ctx)
	diags.Append(sourceS3PutRequestDiags...)

	if diags.HasError() {
		return nil, diags
	}

	out := operations.PutSourceS3Request{
		SourceID:           sourceID,
		SourceS3PutRequest: sourceS3PutRequest,
	}

	return &out, diags
}

func (r *SourceS3ResourceModel) ToOperationsGetSourceS3Request(ctx context.Context) (*operations.GetSourceS3Request, diag.Diagnostics) {
	var diags diag.Diagnostics

	var sourceID string
	sourceID = r.SourceID.ValueString()

	out := operations.GetSourceS3Request{
		SourceID: sourceID,
	}

	return &out, diags
}

func (r *SourceS3ResourceModel) ToOperationsDeleteSourceS3Request(ctx context.Context) (*operations.DeleteSourceS3Request, diag.Diagnostics) {
	var diags diag.Diagnostics

	var sourceID string
	sourceID = r.SourceID.ValueString()

	out := operations.DeleteSourceS3Request{
		SourceID: sourceID,
	}

	return &out, diags
}

func (r *SourceS3ResourceModel) RefreshFromSharedSourceResponse(ctx context.Context, resp *shared.SourceResponse) diag.Diagnostics {
	var diags diag.Diagnostics

	if resp != nil {
		r.CreatedAt = types.Int64Value(resp.CreatedAt)
		r.DefinitionID = types.StringValue(resp.DefinitionID)
		r.Name = types.StringValue(resp.Name)
		if resp.ResourceAllocation == nil {
			r.ResourceAllocation = nil
		} else {
			r.ResourceAllocation = &tfTypes.ScopedResourceRequirements{}
			if resp.ResourceAllocation.Default == nil {
				r.ResourceAllocation.Default = nil
			} else {
				r.ResourceAllocation.Default = &tfTypes.ResourceRequirements{}
				r.ResourceAllocation.Default.CPULimit = types.StringPointerValue(resp.ResourceAllocation.Default.CPULimit)
				r.ResourceAllocation.Default.CPURequest = types.StringPointerValue(resp.ResourceAllocation.Default.CPURequest)
				r.ResourceAllocation.Default.EphemeralStorageLimit = types.StringPointerValue(resp.ResourceAllocation.Default.EphemeralStorageLimit)
				r.ResourceAllocation.Default.EphemeralStorageRequest = types.StringPointerValue(resp.ResourceAllocation.Default.EphemeralStorageRequest)
				r.ResourceAllocation.Default.MemoryLimit = types.StringPointerValue(resp.ResourceAllocation.Default.MemoryLimit)
				r.ResourceAllocation.Default.MemoryRequest = types.StringPointerValue(resp.ResourceAllocation.Default.MemoryRequest)
			}
			r.ResourceAllocation.JobSpecific = []tfTypes.JobTypeResourceLimit{}
			if len(r.ResourceAllocation.JobSpecific) > len(resp.ResourceAllocation.JobSpecific) {
				r.ResourceAllocation.JobSpecific = r.ResourceAllocation.JobSpecific[:len(resp.ResourceAllocation.JobSpecific)]
			}
			for jobSpecificCount, jobSpecificItem := range resp.ResourceAllocation.JobSpecific {
				var jobSpecific tfTypes.JobTypeResourceLimit
				jobSpecific.JobType = types.StringValue(string(jobSpecificItem.JobType))
				jobSpecific.ResourceRequirements.CPULimit = types.StringPointerValue(jobSpecificItem.ResourceRequirements.CPULimit)
				jobSpecific.ResourceRequirements.CPURequest = types.StringPointerValue(jobSpecificItem.ResourceRequirements.CPURequest)
				jobSpecific.ResourceRequirements.EphemeralStorageLimit = types.StringPointerValue(jobSpecificItem.ResourceRequirements.EphemeralStorageLimit)
				jobSpecific.ResourceRequirements.EphemeralStorageRequest = types.StringPointerValue(jobSpecificItem.ResourceRequirements.EphemeralStorageRequest)
				jobSpecific.ResourceRequirements.MemoryLimit = types.StringPointerValue(jobSpecificItem.ResourceRequirements.MemoryLimit)
				jobSpecific.ResourceRequirements.MemoryRequest = types.StringPointerValue(jobSpecificItem.ResourceRequirements.MemoryRequest)
				if jobSpecificCount+1 > len(r.ResourceAllocation.JobSpecific) {
					r.ResourceAllocation.JobSpecific = append(r.ResourceAllocation.JobSpecific, jobSpecific)
				} else {
					r.ResourceAllocation.JobSpecific[jobSpecificCount].JobType = jobSpecific.JobType
					r.ResourceAllocation.JobSpecific[jobSpecificCount].ResourceRequirements = jobSpecific.ResourceRequirements
				}
			}
		}
		r.SourceID = types.StringValue(resp.SourceID)
		r.SourceType = types.StringValue(resp.SourceType)
		r.WorkspaceID = types.StringValue(resp.WorkspaceID)
	}

	return diags
}
