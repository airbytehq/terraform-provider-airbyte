// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package provider

import (
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/pkg/models/shared"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

func (r *DestinationLangchainResourceModel) ToCreateSDKType() *shared.DestinationLangchainCreateRequest {
	var embedding shared.DestinationLangchainEmbedding
	var destinationLangchainOpenAI *shared.DestinationLangchainOpenAI
	if r.Configuration.Embedding.OpenAI != nil {
		openaiKey := r.Configuration.Embedding.OpenAI.OpenaiKey.ValueString()
		destinationLangchainOpenAI = &shared.DestinationLangchainOpenAI{
			OpenaiKey: openaiKey,
		}
	}
	if destinationLangchainOpenAI != nil {
		embedding = shared.DestinationLangchainEmbedding{
			DestinationLangchainOpenAI: destinationLangchainOpenAI,
		}
	}
	var destinationLangchainFake *shared.DestinationLangchainFake
	if r.Configuration.Embedding.Fake != nil {
		destinationLangchainFake = &shared.DestinationLangchainFake{}
	}
	if destinationLangchainFake != nil {
		embedding = shared.DestinationLangchainEmbedding{
			DestinationLangchainFake: destinationLangchainFake,
		}
	}
	var indexing shared.DestinationLangchainIndexing
	var destinationLangchainPinecone *shared.DestinationLangchainPinecone
	if r.Configuration.Indexing.Pinecone != nil {
		index := r.Configuration.Indexing.Pinecone.Index.ValueString()
		pineconeEnvironment := r.Configuration.Indexing.Pinecone.PineconeEnvironment.ValueString()
		pineconeKey := r.Configuration.Indexing.Pinecone.PineconeKey.ValueString()
		destinationLangchainPinecone = &shared.DestinationLangchainPinecone{
			Index:               index,
			PineconeEnvironment: pineconeEnvironment,
			PineconeKey:         pineconeKey,
		}
	}
	if destinationLangchainPinecone != nil {
		indexing = shared.DestinationLangchainIndexing{
			DestinationLangchainPinecone: destinationLangchainPinecone,
		}
	}
	var destinationLangchainDocArrayHnswSearch *shared.DestinationLangchainDocArrayHnswSearch
	if r.Configuration.Indexing.DocArrayHnswSearch != nil {
		destinationPath := r.Configuration.Indexing.DocArrayHnswSearch.DestinationPath.ValueString()
		destinationLangchainDocArrayHnswSearch = &shared.DestinationLangchainDocArrayHnswSearch{
			DestinationPath: destinationPath,
		}
	}
	if destinationLangchainDocArrayHnswSearch != nil {
		indexing = shared.DestinationLangchainIndexing{
			DestinationLangchainDocArrayHnswSearch: destinationLangchainDocArrayHnswSearch,
		}
	}
	var destinationLangchainChromaLocalPersistance *shared.DestinationLangchainChromaLocalPersistance
	if r.Configuration.Indexing.ChromaLocalPersistance != nil {
		collectionName := new(string)
		if !r.Configuration.Indexing.ChromaLocalPersistance.CollectionName.IsUnknown() && !r.Configuration.Indexing.ChromaLocalPersistance.CollectionName.IsNull() {
			*collectionName = r.Configuration.Indexing.ChromaLocalPersistance.CollectionName.ValueString()
		} else {
			collectionName = nil
		}
		destinationPath1 := r.Configuration.Indexing.ChromaLocalPersistance.DestinationPath.ValueString()
		destinationLangchainChromaLocalPersistance = &shared.DestinationLangchainChromaLocalPersistance{
			CollectionName:  collectionName,
			DestinationPath: destinationPath1,
		}
	}
	if destinationLangchainChromaLocalPersistance != nil {
		indexing = shared.DestinationLangchainIndexing{
			DestinationLangchainChromaLocalPersistance: destinationLangchainChromaLocalPersistance,
		}
	}
	chunkOverlap := new(int64)
	if !r.Configuration.Processing.ChunkOverlap.IsUnknown() && !r.Configuration.Processing.ChunkOverlap.IsNull() {
		*chunkOverlap = r.Configuration.Processing.ChunkOverlap.ValueInt64()
	} else {
		chunkOverlap = nil
	}
	chunkSize := r.Configuration.Processing.ChunkSize.ValueInt64()
	var textFields []string = nil
	for _, textFieldsItem := range r.Configuration.Processing.TextFields {
		textFields = append(textFields, textFieldsItem.ValueString())
	}
	processing := shared.DestinationLangchainProcessingConfigModel{
		ChunkOverlap: chunkOverlap,
		ChunkSize:    chunkSize,
		TextFields:   textFields,
	}
	configuration := shared.DestinationLangchain{
		Embedding:  embedding,
		Indexing:   indexing,
		Processing: processing,
	}
	definitionID := new(string)
	if !r.DefinitionID.IsUnknown() && !r.DefinitionID.IsNull() {
		*definitionID = r.DefinitionID.ValueString()
	} else {
		definitionID = nil
	}
	name := r.Name.ValueString()
	workspaceID := r.WorkspaceID.ValueString()
	out := shared.DestinationLangchainCreateRequest{
		Configuration: configuration,
		DefinitionID:  definitionID,
		Name:          name,
		WorkspaceID:   workspaceID,
	}
	return &out
}

func (r *DestinationLangchainResourceModel) ToGetSDKType() *shared.DestinationLangchainCreateRequest {
	out := r.ToCreateSDKType()
	return out
}

func (r *DestinationLangchainResourceModel) ToUpdateSDKType() *shared.DestinationLangchainPutRequest {
	var embedding shared.Embedding
	var openAI *shared.OpenAI
	if r.Configuration.Embedding.OpenAI != nil {
		openaiKey := r.Configuration.Embedding.OpenAI.OpenaiKey.ValueString()
		openAI = &shared.OpenAI{
			OpenaiKey: openaiKey,
		}
	}
	if openAI != nil {
		embedding = shared.Embedding{
			OpenAI: openAI,
		}
	}
	var fake *shared.Fake
	if r.Configuration.Embedding.Fake != nil {
		fake = &shared.Fake{}
	}
	if fake != nil {
		embedding = shared.Embedding{
			Fake: fake,
		}
	}
	var indexing shared.Indexing
	var destinationLangchainUpdatePinecone *shared.DestinationLangchainUpdatePinecone
	if r.Configuration.Indexing.Pinecone != nil {
		index := r.Configuration.Indexing.Pinecone.Index.ValueString()
		pineconeEnvironment := r.Configuration.Indexing.Pinecone.PineconeEnvironment.ValueString()
		pineconeKey := r.Configuration.Indexing.Pinecone.PineconeKey.ValueString()
		destinationLangchainUpdatePinecone = &shared.DestinationLangchainUpdatePinecone{
			Index:               index,
			PineconeEnvironment: pineconeEnvironment,
			PineconeKey:         pineconeKey,
		}
	}
	if destinationLangchainUpdatePinecone != nil {
		indexing = shared.Indexing{
			DestinationLangchainUpdatePinecone: destinationLangchainUpdatePinecone,
		}
	}
	var docArrayHnswSearch *shared.DocArrayHnswSearch
	if r.Configuration.Indexing.DocArrayHnswSearch != nil {
		destinationPath := r.Configuration.Indexing.DocArrayHnswSearch.DestinationPath.ValueString()
		docArrayHnswSearch = &shared.DocArrayHnswSearch{
			DestinationPath: destinationPath,
		}
	}
	if docArrayHnswSearch != nil {
		indexing = shared.Indexing{
			DocArrayHnswSearch: docArrayHnswSearch,
		}
	}
	var chromaLocalPersistance *shared.ChromaLocalPersistance
	if r.Configuration.Indexing.ChromaLocalPersistance != nil {
		collectionName := new(string)
		if !r.Configuration.Indexing.ChromaLocalPersistance.CollectionName.IsUnknown() && !r.Configuration.Indexing.ChromaLocalPersistance.CollectionName.IsNull() {
			*collectionName = r.Configuration.Indexing.ChromaLocalPersistance.CollectionName.ValueString()
		} else {
			collectionName = nil
		}
		destinationPath1 := r.Configuration.Indexing.ChromaLocalPersistance.DestinationPath.ValueString()
		chromaLocalPersistance = &shared.ChromaLocalPersistance{
			CollectionName:  collectionName,
			DestinationPath: destinationPath1,
		}
	}
	if chromaLocalPersistance != nil {
		indexing = shared.Indexing{
			ChromaLocalPersistance: chromaLocalPersistance,
		}
	}
	chunkOverlap := new(int64)
	if !r.Configuration.Processing.ChunkOverlap.IsUnknown() && !r.Configuration.Processing.ChunkOverlap.IsNull() {
		*chunkOverlap = r.Configuration.Processing.ChunkOverlap.ValueInt64()
	} else {
		chunkOverlap = nil
	}
	chunkSize := r.Configuration.Processing.ChunkSize.ValueInt64()
	var textFields []string = nil
	for _, textFieldsItem := range r.Configuration.Processing.TextFields {
		textFields = append(textFields, textFieldsItem.ValueString())
	}
	processing := shared.ProcessingConfigModel{
		ChunkOverlap: chunkOverlap,
		ChunkSize:    chunkSize,
		TextFields:   textFields,
	}
	configuration := shared.DestinationLangchainUpdate{
		Embedding:  embedding,
		Indexing:   indexing,
		Processing: processing,
	}
	name := r.Name.ValueString()
	workspaceID := r.WorkspaceID.ValueString()
	out := shared.DestinationLangchainPutRequest{
		Configuration: configuration,
		Name:          name,
		WorkspaceID:   workspaceID,
	}
	return &out
}

func (r *DestinationLangchainResourceModel) ToDeleteSDKType() *shared.DestinationLangchainCreateRequest {
	out := r.ToCreateSDKType()
	return out
}

func (r *DestinationLangchainResourceModel) RefreshFromGetResponse(resp *shared.DestinationResponse) {
	r.DestinationID = types.StringValue(resp.DestinationID)
	r.DestinationType = types.StringValue(resp.DestinationType)
	r.Name = types.StringValue(resp.Name)
	r.WorkspaceID = types.StringValue(resp.WorkspaceID)
}

func (r *DestinationLangchainResourceModel) RefreshFromCreateResponse(resp *shared.DestinationResponse) {
	r.RefreshFromGetResponse(resp)
}
