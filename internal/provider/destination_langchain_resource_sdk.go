// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package provider

import (
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/models/shared"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

func (r *DestinationLangchainResourceModel) ToSharedDestinationLangchainCreateRequest() *shared.DestinationLangchainCreateRequest {
	var embedding shared.DestinationLangchainEmbedding
	var destinationLangchainOpenAI *shared.DestinationLangchainOpenAI
	if r.Configuration.Embedding.OpenAI != nil {
		openaiKey := r.Configuration.Embedding.OpenAI.OpenaiKey.ValueString()
		destinationLangchainOpenAI = &shared.DestinationLangchainOpenAI{
			OpenaiKey: openaiKey,
		}
	}
	if destinationLangchainOpenAI != nil {
		embedding = shared.DestinationLangchainEmbedding{
			DestinationLangchainOpenAI: destinationLangchainOpenAI,
		}
	}
	var destinationLangchainFake *shared.DestinationLangchainFake
	if r.Configuration.Embedding.Fake != nil {
		destinationLangchainFake = &shared.DestinationLangchainFake{}
	}
	if destinationLangchainFake != nil {
		embedding = shared.DestinationLangchainEmbedding{
			DestinationLangchainFake: destinationLangchainFake,
		}
	}
	var indexing shared.DestinationLangchainIndexing
	var destinationLangchainPinecone *shared.DestinationLangchainPinecone
	if r.Configuration.Indexing.Pinecone != nil {
		index := r.Configuration.Indexing.Pinecone.Index.ValueString()
		pineconeEnvironment := r.Configuration.Indexing.Pinecone.PineconeEnvironment.ValueString()
		pineconeKey := r.Configuration.Indexing.Pinecone.PineconeKey.ValueString()
		destinationLangchainPinecone = &shared.DestinationLangchainPinecone{
			Index:               index,
			PineconeEnvironment: pineconeEnvironment,
			PineconeKey:         pineconeKey,
		}
	}
	if destinationLangchainPinecone != nil {
		indexing = shared.DestinationLangchainIndexing{
			DestinationLangchainPinecone: destinationLangchainPinecone,
		}
	}
	var destinationLangchainDocArrayHnswSearch *shared.DestinationLangchainDocArrayHnswSearch
	if r.Configuration.Indexing.DocArrayHnswSearch != nil {
		destinationPath := r.Configuration.Indexing.DocArrayHnswSearch.DestinationPath.ValueString()
		destinationLangchainDocArrayHnswSearch = &shared.DestinationLangchainDocArrayHnswSearch{
			DestinationPath: destinationPath,
		}
	}
	if destinationLangchainDocArrayHnswSearch != nil {
		indexing = shared.DestinationLangchainIndexing{
			DestinationLangchainDocArrayHnswSearch: destinationLangchainDocArrayHnswSearch,
		}
	}
	var destinationLangchainChromaLocalPersistance *shared.DestinationLangchainChromaLocalPersistance
	if r.Configuration.Indexing.ChromaLocalPersistance != nil {
		collectionName := new(string)
		if !r.Configuration.Indexing.ChromaLocalPersistance.CollectionName.IsUnknown() && !r.Configuration.Indexing.ChromaLocalPersistance.CollectionName.IsNull() {
			*collectionName = r.Configuration.Indexing.ChromaLocalPersistance.CollectionName.ValueString()
		} else {
			collectionName = nil
		}
		destinationPath1 := r.Configuration.Indexing.ChromaLocalPersistance.DestinationPath.ValueString()
		destinationLangchainChromaLocalPersistance = &shared.DestinationLangchainChromaLocalPersistance{
			CollectionName:  collectionName,
			DestinationPath: destinationPath1,
		}
	}
	if destinationLangchainChromaLocalPersistance != nil {
		indexing = shared.DestinationLangchainIndexing{
			DestinationLangchainChromaLocalPersistance: destinationLangchainChromaLocalPersistance,
		}
	}
	chunkOverlap := new(int64)
	if !r.Configuration.Processing.ChunkOverlap.IsUnknown() && !r.Configuration.Processing.ChunkOverlap.IsNull() {
		*chunkOverlap = r.Configuration.Processing.ChunkOverlap.ValueInt64()
	} else {
		chunkOverlap = nil
	}
	chunkSize := r.Configuration.Processing.ChunkSize.ValueInt64()
	var textFields []string = []string{}
	for _, textFieldsItem := range r.Configuration.Processing.TextFields {
		textFields = append(textFields, textFieldsItem.ValueString())
	}
	processing := shared.DestinationLangchainProcessingConfigModel{
		ChunkOverlap: chunkOverlap,
		ChunkSize:    chunkSize,
		TextFields:   textFields,
	}
	configuration := shared.DestinationLangchain{
		Embedding:  embedding,
		Indexing:   indexing,
		Processing: processing,
	}
	definitionID := new(string)
	if !r.DefinitionID.IsUnknown() && !r.DefinitionID.IsNull() {
		*definitionID = r.DefinitionID.ValueString()
	} else {
		definitionID = nil
	}
	name := r.Name.ValueString()
	workspaceID := r.WorkspaceID.ValueString()
	out := shared.DestinationLangchainCreateRequest{
		Configuration: configuration,
		DefinitionID:  definitionID,
		Name:          name,
		WorkspaceID:   workspaceID,
	}
	return &out
}

func (r *DestinationLangchainResourceModel) RefreshFromSharedDestinationResponse(resp *shared.DestinationResponse) {
	if resp != nil {
		r.DestinationID = types.StringValue(resp.DestinationID)
		r.DestinationType = types.StringValue(resp.DestinationType)
		r.Name = types.StringValue(resp.Name)
		r.WorkspaceID = types.StringValue(resp.WorkspaceID)
	}
}

func (r *DestinationLangchainResourceModel) ToSharedDestinationLangchainPutRequest() *shared.DestinationLangchainPutRequest {
	var embedding shared.DestinationLangchainUpdateEmbedding
	var destinationLangchainUpdateOpenAI *shared.DestinationLangchainUpdateOpenAI
	if r.Configuration.Embedding.OpenAI != nil {
		openaiKey := r.Configuration.Embedding.OpenAI.OpenaiKey.ValueString()
		destinationLangchainUpdateOpenAI = &shared.DestinationLangchainUpdateOpenAI{
			OpenaiKey: openaiKey,
		}
	}
	if destinationLangchainUpdateOpenAI != nil {
		embedding = shared.DestinationLangchainUpdateEmbedding{
			DestinationLangchainUpdateOpenAI: destinationLangchainUpdateOpenAI,
		}
	}
	var destinationLangchainUpdateFake *shared.DestinationLangchainUpdateFake
	if r.Configuration.Embedding.Fake != nil {
		destinationLangchainUpdateFake = &shared.DestinationLangchainUpdateFake{}
	}
	if destinationLangchainUpdateFake != nil {
		embedding = shared.DestinationLangchainUpdateEmbedding{
			DestinationLangchainUpdateFake: destinationLangchainUpdateFake,
		}
	}
	var indexing shared.DestinationLangchainUpdateIndexing
	var destinationLangchainUpdatePinecone *shared.DestinationLangchainUpdatePinecone
	if r.Configuration.Indexing.Pinecone != nil {
		index := r.Configuration.Indexing.Pinecone.Index.ValueString()
		pineconeEnvironment := r.Configuration.Indexing.Pinecone.PineconeEnvironment.ValueString()
		pineconeKey := r.Configuration.Indexing.Pinecone.PineconeKey.ValueString()
		destinationLangchainUpdatePinecone = &shared.DestinationLangchainUpdatePinecone{
			Index:               index,
			PineconeEnvironment: pineconeEnvironment,
			PineconeKey:         pineconeKey,
		}
	}
	if destinationLangchainUpdatePinecone != nil {
		indexing = shared.DestinationLangchainUpdateIndexing{
			DestinationLangchainUpdatePinecone: destinationLangchainUpdatePinecone,
		}
	}
	var docArrayHnswSearch *shared.DocArrayHnswSearch
	if r.Configuration.Indexing.DocArrayHnswSearch != nil {
		destinationPath := r.Configuration.Indexing.DocArrayHnswSearch.DestinationPath.ValueString()
		docArrayHnswSearch = &shared.DocArrayHnswSearch{
			DestinationPath: destinationPath,
		}
	}
	if docArrayHnswSearch != nil {
		indexing = shared.DestinationLangchainUpdateIndexing{
			DocArrayHnswSearch: docArrayHnswSearch,
		}
	}
	var chromaLocalPersistance *shared.ChromaLocalPersistance
	if r.Configuration.Indexing.ChromaLocalPersistance != nil {
		collectionName := new(string)
		if !r.Configuration.Indexing.ChromaLocalPersistance.CollectionName.IsUnknown() && !r.Configuration.Indexing.ChromaLocalPersistance.CollectionName.IsNull() {
			*collectionName = r.Configuration.Indexing.ChromaLocalPersistance.CollectionName.ValueString()
		} else {
			collectionName = nil
		}
		destinationPath1 := r.Configuration.Indexing.ChromaLocalPersistance.DestinationPath.ValueString()
		chromaLocalPersistance = &shared.ChromaLocalPersistance{
			CollectionName:  collectionName,
			DestinationPath: destinationPath1,
		}
	}
	if chromaLocalPersistance != nil {
		indexing = shared.DestinationLangchainUpdateIndexing{
			ChromaLocalPersistance: chromaLocalPersistance,
		}
	}
	chunkOverlap := new(int64)
	if !r.Configuration.Processing.ChunkOverlap.IsUnknown() && !r.Configuration.Processing.ChunkOverlap.IsNull() {
		*chunkOverlap = r.Configuration.Processing.ChunkOverlap.ValueInt64()
	} else {
		chunkOverlap = nil
	}
	chunkSize := r.Configuration.Processing.ChunkSize.ValueInt64()
	var textFields []string = []string{}
	for _, textFieldsItem := range r.Configuration.Processing.TextFields {
		textFields = append(textFields, textFieldsItem.ValueString())
	}
	processing := shared.DestinationLangchainUpdateProcessingConfigModel{
		ChunkOverlap: chunkOverlap,
		ChunkSize:    chunkSize,
		TextFields:   textFields,
	}
	configuration := shared.DestinationLangchainUpdate{
		Embedding:  embedding,
		Indexing:   indexing,
		Processing: processing,
	}
	name := r.Name.ValueString()
	workspaceID := r.WorkspaceID.ValueString()
	out := shared.DestinationLangchainPutRequest{
		Configuration: configuration,
		Name:          name,
		WorkspaceID:   workspaceID,
	}
	return &out
}
