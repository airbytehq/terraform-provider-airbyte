// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"context"
	"encoding/json"
	tfTypes "github.com/airbytehq/terraform-provider-airbyte/internal/provider/types"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/models/operations"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/models/shared"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

func (r *DestinationKafkaResourceModel) RefreshFromSharedDestinationResponse(ctx context.Context, resp *shared.DestinationResponse) diag.Diagnostics {
	var diags diag.Diagnostics

	if resp != nil {
		configurationPriorData := r.Configuration
		r.Configuration.Acks = configurationPriorData.Acks
		r.Configuration.AdditionalProperties = configurationPriorData.AdditionalProperties
		r.Configuration.BatchSize = configurationPriorData.BatchSize
		r.Configuration.BootstrapServers = configurationPriorData.BootstrapServers
		r.Configuration.BufferMemory = configurationPriorData.BufferMemory
		r.Configuration.ClientDNSLookup = configurationPriorData.ClientDNSLookup
		r.Configuration.ClientID = configurationPriorData.ClientID
		r.Configuration.CompressionType = configurationPriorData.CompressionType
		r.Configuration.DeliveryTimeoutMs = configurationPriorData.DeliveryTimeoutMs
		r.Configuration.EnableIdempotence = configurationPriorData.EnableIdempotence
		r.Configuration.LingerMs = configurationPriorData.LingerMs
		r.Configuration.MaxBlockMs = configurationPriorData.MaxBlockMs
		r.Configuration.MaxInFlightRequestsPerConnection = configurationPriorData.MaxInFlightRequestsPerConnection
		r.Configuration.MaxRequestSize = configurationPriorData.MaxRequestSize
		r.Configuration.Protocol = configurationPriorData.Protocol
		r.Configuration.ReceiveBufferBytes = configurationPriorData.ReceiveBufferBytes
		r.Configuration.RequestTimeoutMs = configurationPriorData.RequestTimeoutMs
		r.Configuration.Retries = configurationPriorData.Retries
		r.Configuration.SendBufferBytes = configurationPriorData.SendBufferBytes
		r.Configuration.SocketConnectionSetupTimeoutMaxMs = configurationPriorData.SocketConnectionSetupTimeoutMaxMs
		r.Configuration.SocketConnectionSetupTimeoutMs = configurationPriorData.SocketConnectionSetupTimeoutMs
		r.Configuration.SyncProducer = configurationPriorData.SyncProducer
		r.Configuration.TestTopic = configurationPriorData.TestTopic
		r.Configuration.TopicPattern = configurationPriorData.TopicPattern
		r.CreatedAt = types.Int64Value(resp.CreatedAt)
		r.DefinitionID = types.StringValue(resp.DefinitionID)
		r.DestinationID = types.StringValue(resp.DestinationID)
		r.DestinationType = types.StringValue(resp.DestinationType)
		r.Name = types.StringValue(resp.Name)
		if resp.ResourceAllocation == nil {
			r.ResourceAllocation = nil
		} else {
			r.ResourceAllocation = &tfTypes.ScopedResourceRequirements{}
			if resp.ResourceAllocation.Default == nil {
				r.ResourceAllocation.Default = nil
			} else {
				r.ResourceAllocation.Default = &tfTypes.ResourceRequirements{}
				r.ResourceAllocation.Default.CPULimit = types.StringPointerValue(resp.ResourceAllocation.Default.CPULimit)
				r.ResourceAllocation.Default.CPURequest = types.StringPointerValue(resp.ResourceAllocation.Default.CPURequest)
				r.ResourceAllocation.Default.EphemeralStorageLimit = types.StringPointerValue(resp.ResourceAllocation.Default.EphemeralStorageLimit)
				r.ResourceAllocation.Default.EphemeralStorageRequest = types.StringPointerValue(resp.ResourceAllocation.Default.EphemeralStorageRequest)
				r.ResourceAllocation.Default.MemoryLimit = types.StringPointerValue(resp.ResourceAllocation.Default.MemoryLimit)
				r.ResourceAllocation.Default.MemoryRequest = types.StringPointerValue(resp.ResourceAllocation.Default.MemoryRequest)
			}
			r.ResourceAllocation.JobSpecific = []tfTypes.JobTypeResourceLimit{}

			for _, jobSpecificItem := range resp.ResourceAllocation.JobSpecific {
				var jobSpecific tfTypes.JobTypeResourceLimit

				jobSpecific.JobType = types.StringValue(string(jobSpecificItem.JobType))
				jobSpecific.ResourceRequirements.CPULimit = types.StringPointerValue(jobSpecificItem.ResourceRequirements.CPULimit)
				jobSpecific.ResourceRequirements.CPURequest = types.StringPointerValue(jobSpecificItem.ResourceRequirements.CPURequest)
				jobSpecific.ResourceRequirements.EphemeralStorageLimit = types.StringPointerValue(jobSpecificItem.ResourceRequirements.EphemeralStorageLimit)
				jobSpecific.ResourceRequirements.EphemeralStorageRequest = types.StringPointerValue(jobSpecificItem.ResourceRequirements.EphemeralStorageRequest)
				jobSpecific.ResourceRequirements.MemoryLimit = types.StringPointerValue(jobSpecificItem.ResourceRequirements.MemoryLimit)
				jobSpecific.ResourceRequirements.MemoryRequest = types.StringPointerValue(jobSpecificItem.ResourceRequirements.MemoryRequest)

				r.ResourceAllocation.JobSpecific = append(r.ResourceAllocation.JobSpecific, jobSpecific)
			}
		}
		r.WorkspaceID = types.StringValue(resp.WorkspaceID)
	}

	return diags
}

func (r *DestinationKafkaResourceModel) ToOperationsDeleteDestinationKafkaRequest(ctx context.Context) (*operations.DeleteDestinationKafkaRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var destinationID string
	destinationID = r.DestinationID.ValueString()

	out := operations.DeleteDestinationKafkaRequest{
		DestinationID: destinationID,
	}

	return &out, diags
}

func (r *DestinationKafkaResourceModel) ToOperationsGetDestinationKafkaRequest(ctx context.Context) (*operations.GetDestinationKafkaRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var destinationID string
	destinationID = r.DestinationID.ValueString()

	out := operations.GetDestinationKafkaRequest{
		DestinationID: destinationID,
	}

	return &out, diags
}

func (r *DestinationKafkaResourceModel) ToOperationsPutDestinationKafkaRequest(ctx context.Context) (*operations.PutDestinationKafkaRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var destinationID string
	destinationID = r.DestinationID.ValueString()

	destinationKafkaPutRequest, destinationKafkaPutRequestDiags := r.ToSharedDestinationKafkaPutRequest(ctx)
	diags.Append(destinationKafkaPutRequestDiags...)

	if diags.HasError() {
		return nil, diags
	}

	out := operations.PutDestinationKafkaRequest{
		DestinationID:              destinationID,
		DestinationKafkaPutRequest: *destinationKafkaPutRequest,
	}

	return &out, diags
}

func (r *DestinationKafkaResourceModel) ToSharedDestinationKafkaCreateRequest(ctx context.Context) (*shared.DestinationKafkaCreateRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var name string
	name = r.Name.ValueString()

	definitionID := new(string)
	if !r.DefinitionID.IsUnknown() && !r.DefinitionID.IsNull() {
		*definitionID = r.DefinitionID.ValueString()
	} else {
		definitionID = nil
	}
	var workspaceID string
	workspaceID = r.WorkspaceID.ValueString()

	acks := new(shared.ACKs)
	if !r.Configuration.Acks.IsUnknown() && !r.Configuration.Acks.IsNull() {
		*acks = shared.ACKs(r.Configuration.Acks.ValueString())
	} else {
		acks = nil
	}
	var batchSize int64
	batchSize = r.Configuration.BatchSize.ValueInt64()

	var bootstrapServers string
	bootstrapServers = r.Configuration.BootstrapServers.ValueString()

	var bufferMemory string
	bufferMemory = r.Configuration.BufferMemory.ValueString()

	clientDNSLookup := new(shared.DestinationKafkaClientDNSLookup)
	if !r.Configuration.ClientDNSLookup.IsUnknown() && !r.Configuration.ClientDNSLookup.IsNull() {
		*clientDNSLookup = shared.DestinationKafkaClientDNSLookup(r.Configuration.ClientDNSLookup.ValueString())
	} else {
		clientDNSLookup = nil
	}
	clientID := new(string)
	if !r.Configuration.ClientID.IsUnknown() && !r.Configuration.ClientID.IsNull() {
		*clientID = r.Configuration.ClientID.ValueString()
	} else {
		clientID = nil
	}
	compressionType := new(shared.CompressionType)
	if !r.Configuration.CompressionType.IsUnknown() && !r.Configuration.CompressionType.IsNull() {
		*compressionType = shared.CompressionType(r.Configuration.CompressionType.ValueString())
	} else {
		compressionType = nil
	}
	var deliveryTimeoutMs int64
	deliveryTimeoutMs = r.Configuration.DeliveryTimeoutMs.ValueInt64()

	enableIdempotence := new(bool)
	if !r.Configuration.EnableIdempotence.IsUnknown() && !r.Configuration.EnableIdempotence.IsNull() {
		*enableIdempotence = r.Configuration.EnableIdempotence.ValueBool()
	} else {
		enableIdempotence = nil
	}
	var lingerMs string
	lingerMs = r.Configuration.LingerMs.ValueString()

	var maxBlockMs string
	maxBlockMs = r.Configuration.MaxBlockMs.ValueString()

	var maxInFlightRequestsPerConnection int64
	maxInFlightRequestsPerConnection = r.Configuration.MaxInFlightRequestsPerConnection.ValueInt64()

	var maxRequestSize int64
	maxRequestSize = r.Configuration.MaxRequestSize.ValueInt64()

	var protocol shared.DestinationKafkaProtocol
	var destinationKafkaPLAINTEXT *shared.DestinationKafkaPLAINTEXT
	if r.Configuration.Protocol.Plaintext != nil {
		securityProtocol := new(shared.SecurityProtocol)
		if !r.Configuration.Protocol.Plaintext.SecurityProtocol.IsUnknown() && !r.Configuration.Protocol.Plaintext.SecurityProtocol.IsNull() {
			*securityProtocol = shared.SecurityProtocol(r.Configuration.Protocol.Plaintext.SecurityProtocol.ValueString())
		} else {
			securityProtocol = nil
		}
		destinationKafkaPLAINTEXT = &shared.DestinationKafkaPLAINTEXT{
			SecurityProtocol: securityProtocol,
		}
	}
	if destinationKafkaPLAINTEXT != nil {
		protocol = shared.DestinationKafkaProtocol{
			DestinationKafkaPLAINTEXT: destinationKafkaPLAINTEXT,
		}
	}
	var destinationKafkaSASLPLAINTEXT *shared.DestinationKafkaSASLPLAINTEXT
	if r.Configuration.Protocol.SaslPlaintext != nil {
		saslJaasConfig := new(string)
		if !r.Configuration.Protocol.SaslPlaintext.SaslJaasConfig.IsUnknown() && !r.Configuration.Protocol.SaslPlaintext.SaslJaasConfig.IsNull() {
			*saslJaasConfig = r.Configuration.Protocol.SaslPlaintext.SaslJaasConfig.ValueString()
		} else {
			saslJaasConfig = nil
		}
		saslMechanism := new(shared.DestinationKafkaSASLMechanism)
		if !r.Configuration.Protocol.SaslPlaintext.SaslMechanism.IsUnknown() && !r.Configuration.Protocol.SaslPlaintext.SaslMechanism.IsNull() {
			*saslMechanism = shared.DestinationKafkaSASLMechanism(r.Configuration.Protocol.SaslPlaintext.SaslMechanism.ValueString())
		} else {
			saslMechanism = nil
		}
		securityProtocol1 := new(shared.DestinationKafkaSecurityProtocol)
		if !r.Configuration.Protocol.SaslPlaintext.SecurityProtocol.IsUnknown() && !r.Configuration.Protocol.SaslPlaintext.SecurityProtocol.IsNull() {
			*securityProtocol1 = shared.DestinationKafkaSecurityProtocol(r.Configuration.Protocol.SaslPlaintext.SecurityProtocol.ValueString())
		} else {
			securityProtocol1 = nil
		}
		destinationKafkaSASLPLAINTEXT = &shared.DestinationKafkaSASLPLAINTEXT{
			SaslJaasConfig:   saslJaasConfig,
			SaslMechanism:    saslMechanism,
			SecurityProtocol: securityProtocol1,
		}
	}
	if destinationKafkaSASLPLAINTEXT != nil {
		protocol = shared.DestinationKafkaProtocol{
			DestinationKafkaSASLPLAINTEXT: destinationKafkaSASLPLAINTEXT,
		}
	}
	var destinationKafkaSASLSSL *shared.DestinationKafkaSASLSSL
	if r.Configuration.Protocol.SaslSsl != nil {
		saslJaasConfig1 := new(string)
		if !r.Configuration.Protocol.SaslSsl.SaslJaasConfig.IsUnknown() && !r.Configuration.Protocol.SaslSsl.SaslJaasConfig.IsNull() {
			*saslJaasConfig1 = r.Configuration.Protocol.SaslSsl.SaslJaasConfig.ValueString()
		} else {
			saslJaasConfig1 = nil
		}
		saslMechanism1 := new(shared.DestinationKafkaSchemasSASLMechanism)
		if !r.Configuration.Protocol.SaslSsl.SaslMechanism.IsUnknown() && !r.Configuration.Protocol.SaslSsl.SaslMechanism.IsNull() {
			*saslMechanism1 = shared.DestinationKafkaSchemasSASLMechanism(r.Configuration.Protocol.SaslSsl.SaslMechanism.ValueString())
		} else {
			saslMechanism1 = nil
		}
		securityProtocol2 := new(shared.DestinationKafkaSchemasSecurityProtocol)
		if !r.Configuration.Protocol.SaslSsl.SecurityProtocol.IsUnknown() && !r.Configuration.Protocol.SaslSsl.SecurityProtocol.IsNull() {
			*securityProtocol2 = shared.DestinationKafkaSchemasSecurityProtocol(r.Configuration.Protocol.SaslSsl.SecurityProtocol.ValueString())
		} else {
			securityProtocol2 = nil
		}
		destinationKafkaSASLSSL = &shared.DestinationKafkaSASLSSL{
			SaslJaasConfig:   saslJaasConfig1,
			SaslMechanism:    saslMechanism1,
			SecurityProtocol: securityProtocol2,
		}
	}
	if destinationKafkaSASLSSL != nil {
		protocol = shared.DestinationKafkaProtocol{
			DestinationKafkaSASLSSL: destinationKafkaSASLSSL,
		}
	}
	var receiveBufferBytes int64
	receiveBufferBytes = r.Configuration.ReceiveBufferBytes.ValueInt64()

	var requestTimeoutMs int64
	requestTimeoutMs = r.Configuration.RequestTimeoutMs.ValueInt64()

	var retries int64
	retries = r.Configuration.Retries.ValueInt64()

	var sendBufferBytes int64
	sendBufferBytes = r.Configuration.SendBufferBytes.ValueInt64()

	var socketConnectionSetupTimeoutMaxMs string
	socketConnectionSetupTimeoutMaxMs = r.Configuration.SocketConnectionSetupTimeoutMaxMs.ValueString()

	var socketConnectionSetupTimeoutMs string
	socketConnectionSetupTimeoutMs = r.Configuration.SocketConnectionSetupTimeoutMs.ValueString()

	syncProducer := new(bool)
	if !r.Configuration.SyncProducer.IsUnknown() && !r.Configuration.SyncProducer.IsNull() {
		*syncProducer = r.Configuration.SyncProducer.ValueBool()
	} else {
		syncProducer = nil
	}
	testTopic := new(string)
	if !r.Configuration.TestTopic.IsUnknown() && !r.Configuration.TestTopic.IsNull() {
		*testTopic = r.Configuration.TestTopic.ValueString()
	} else {
		testTopic = nil
	}
	var topicPattern string
	topicPattern = r.Configuration.TopicPattern.ValueString()

	var additionalProperties map[string]any
	if !r.Configuration.AdditionalProperties.IsUnknown() && !r.Configuration.AdditionalProperties.IsNull() {
		_ = json.Unmarshal([]byte(r.Configuration.AdditionalProperties.ValueString()), &additionalProperties)
	}
	configuration := shared.DestinationKafka{
		Acks:                              acks,
		BatchSize:                         batchSize,
		BootstrapServers:                  bootstrapServers,
		BufferMemory:                      bufferMemory,
		ClientDNSLookup:                   clientDNSLookup,
		ClientID:                          clientID,
		CompressionType:                   compressionType,
		DeliveryTimeoutMs:                 deliveryTimeoutMs,
		EnableIdempotence:                 enableIdempotence,
		LingerMs:                          lingerMs,
		MaxBlockMs:                        maxBlockMs,
		MaxInFlightRequestsPerConnection:  maxInFlightRequestsPerConnection,
		MaxRequestSize:                    maxRequestSize,
		Protocol:                          protocol,
		ReceiveBufferBytes:                receiveBufferBytes,
		RequestTimeoutMs:                  requestTimeoutMs,
		Retries:                           retries,
		SendBufferBytes:                   sendBufferBytes,
		SocketConnectionSetupTimeoutMaxMs: socketConnectionSetupTimeoutMaxMs,
		SocketConnectionSetupTimeoutMs:    socketConnectionSetupTimeoutMs,
		SyncProducer:                      syncProducer,
		TestTopic:                         testTopic,
		TopicPattern:                      topicPattern,
		AdditionalProperties:              additionalProperties,
	}
	out := shared.DestinationKafkaCreateRequest{
		Name:          name,
		DefinitionID:  definitionID,
		WorkspaceID:   workspaceID,
		Configuration: configuration,
	}

	return &out, diags
}

func (r *DestinationKafkaResourceModel) ToSharedDestinationKafkaPutRequest(ctx context.Context) (*shared.DestinationKafkaPutRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var name string
	name = r.Name.ValueString()

	var workspaceID string
	workspaceID = r.WorkspaceID.ValueString()

	acks := new(shared.DestinationKafkaUpdateACKs)
	if !r.Configuration.Acks.IsUnknown() && !r.Configuration.Acks.IsNull() {
		*acks = shared.DestinationKafkaUpdateACKs(r.Configuration.Acks.ValueString())
	} else {
		acks = nil
	}
	batchSize := new(int64)
	if !r.Configuration.BatchSize.IsUnknown() && !r.Configuration.BatchSize.IsNull() {
		*batchSize = r.Configuration.BatchSize.ValueInt64()
	} else {
		batchSize = nil
	}
	bootstrapServers := new(string)
	if !r.Configuration.BootstrapServers.IsUnknown() && !r.Configuration.BootstrapServers.IsNull() {
		*bootstrapServers = r.Configuration.BootstrapServers.ValueString()
	} else {
		bootstrapServers = nil
	}
	bufferMemory := new(string)
	if !r.Configuration.BufferMemory.IsUnknown() && !r.Configuration.BufferMemory.IsNull() {
		*bufferMemory = r.Configuration.BufferMemory.ValueString()
	} else {
		bufferMemory = nil
	}
	clientDNSLookup := new(shared.DestinationKafkaUpdateClientDNSLookup)
	if !r.Configuration.ClientDNSLookup.IsUnknown() && !r.Configuration.ClientDNSLookup.IsNull() {
		*clientDNSLookup = shared.DestinationKafkaUpdateClientDNSLookup(r.Configuration.ClientDNSLookup.ValueString())
	} else {
		clientDNSLookup = nil
	}
	clientID := new(string)
	if !r.Configuration.ClientID.IsUnknown() && !r.Configuration.ClientID.IsNull() {
		*clientID = r.Configuration.ClientID.ValueString()
	} else {
		clientID = nil
	}
	compressionType := new(shared.DestinationKafkaUpdateCompressionType)
	if !r.Configuration.CompressionType.IsUnknown() && !r.Configuration.CompressionType.IsNull() {
		*compressionType = shared.DestinationKafkaUpdateCompressionType(r.Configuration.CompressionType.ValueString())
	} else {
		compressionType = nil
	}
	deliveryTimeoutMs := new(int64)
	if !r.Configuration.DeliveryTimeoutMs.IsUnknown() && !r.Configuration.DeliveryTimeoutMs.IsNull() {
		*deliveryTimeoutMs = r.Configuration.DeliveryTimeoutMs.ValueInt64()
	} else {
		deliveryTimeoutMs = nil
	}
	enableIdempotence := new(bool)
	if !r.Configuration.EnableIdempotence.IsUnknown() && !r.Configuration.EnableIdempotence.IsNull() {
		*enableIdempotence = r.Configuration.EnableIdempotence.ValueBool()
	} else {
		enableIdempotence = nil
	}
	lingerMs := new(string)
	if !r.Configuration.LingerMs.IsUnknown() && !r.Configuration.LingerMs.IsNull() {
		*lingerMs = r.Configuration.LingerMs.ValueString()
	} else {
		lingerMs = nil
	}
	maxBlockMs := new(string)
	if !r.Configuration.MaxBlockMs.IsUnknown() && !r.Configuration.MaxBlockMs.IsNull() {
		*maxBlockMs = r.Configuration.MaxBlockMs.ValueString()
	} else {
		maxBlockMs = nil
	}
	maxInFlightRequestsPerConnection := new(int64)
	if !r.Configuration.MaxInFlightRequestsPerConnection.IsUnknown() && !r.Configuration.MaxInFlightRequestsPerConnection.IsNull() {
		*maxInFlightRequestsPerConnection = r.Configuration.MaxInFlightRequestsPerConnection.ValueInt64()
	} else {
		maxInFlightRequestsPerConnection = nil
	}
	maxRequestSize := new(int64)
	if !r.Configuration.MaxRequestSize.IsUnknown() && !r.Configuration.MaxRequestSize.IsNull() {
		*maxRequestSize = r.Configuration.MaxRequestSize.ValueInt64()
	} else {
		maxRequestSize = nil
	}
	var protocol *shared.DestinationKafkaUpdateProtocol
	var destinationKafkaUpdatePLAINTEXT *shared.DestinationKafkaUpdatePLAINTEXT
	if r.Configuration.Protocol.Plaintext != nil {
		securityProtocol := new(shared.DestinationKafkaUpdateSecurityProtocol)
		if !r.Configuration.Protocol.Plaintext.SecurityProtocol.IsUnknown() && !r.Configuration.Protocol.Plaintext.SecurityProtocol.IsNull() {
			*securityProtocol = shared.DestinationKafkaUpdateSecurityProtocol(r.Configuration.Protocol.Plaintext.SecurityProtocol.ValueString())
		} else {
			securityProtocol = nil
		}
		destinationKafkaUpdatePLAINTEXT = &shared.DestinationKafkaUpdatePLAINTEXT{
			SecurityProtocol: securityProtocol,
		}
	}
	if destinationKafkaUpdatePLAINTEXT != nil {
		protocol = &shared.DestinationKafkaUpdateProtocol{
			DestinationKafkaUpdatePLAINTEXT: destinationKafkaUpdatePLAINTEXT,
		}
	}
	var destinationKafkaUpdateSASLPLAINTEXT *shared.DestinationKafkaUpdateSASLPLAINTEXT
	if r.Configuration.Protocol.SaslPlaintext != nil {
		saslJaasConfig := new(string)
		if !r.Configuration.Protocol.SaslPlaintext.SaslJaasConfig.IsUnknown() && !r.Configuration.Protocol.SaslPlaintext.SaslJaasConfig.IsNull() {
			*saslJaasConfig = r.Configuration.Protocol.SaslPlaintext.SaslJaasConfig.ValueString()
		} else {
			saslJaasConfig = nil
		}
		saslMechanism := new(shared.DestinationKafkaUpdateSASLMechanism)
		if !r.Configuration.Protocol.SaslPlaintext.SaslMechanism.IsUnknown() && !r.Configuration.Protocol.SaslPlaintext.SaslMechanism.IsNull() {
			*saslMechanism = shared.DestinationKafkaUpdateSASLMechanism(r.Configuration.Protocol.SaslPlaintext.SaslMechanism.ValueString())
		} else {
			saslMechanism = nil
		}
		securityProtocol1 := new(shared.DestinationKafkaUpdateSchemasSecurityProtocol)
		if !r.Configuration.Protocol.SaslPlaintext.SecurityProtocol.IsUnknown() && !r.Configuration.Protocol.SaslPlaintext.SecurityProtocol.IsNull() {
			*securityProtocol1 = shared.DestinationKafkaUpdateSchemasSecurityProtocol(r.Configuration.Protocol.SaslPlaintext.SecurityProtocol.ValueString())
		} else {
			securityProtocol1 = nil
		}
		destinationKafkaUpdateSASLPLAINTEXT = &shared.DestinationKafkaUpdateSASLPLAINTEXT{
			SaslJaasConfig:   saslJaasConfig,
			SaslMechanism:    saslMechanism,
			SecurityProtocol: securityProtocol1,
		}
	}
	if destinationKafkaUpdateSASLPLAINTEXT != nil {
		protocol = &shared.DestinationKafkaUpdateProtocol{
			DestinationKafkaUpdateSASLPLAINTEXT: destinationKafkaUpdateSASLPLAINTEXT,
		}
	}
	var destinationKafkaUpdateSASLSSL *shared.DestinationKafkaUpdateSASLSSL
	if r.Configuration.Protocol.SaslSsl != nil {
		saslJaasConfig1 := new(string)
		if !r.Configuration.Protocol.SaslSsl.SaslJaasConfig.IsUnknown() && !r.Configuration.Protocol.SaslSsl.SaslJaasConfig.IsNull() {
			*saslJaasConfig1 = r.Configuration.Protocol.SaslSsl.SaslJaasConfig.ValueString()
		} else {
			saslJaasConfig1 = nil
		}
		saslMechanism1 := new(shared.DestinationKafkaUpdateSchemasSASLMechanism)
		if !r.Configuration.Protocol.SaslSsl.SaslMechanism.IsUnknown() && !r.Configuration.Protocol.SaslSsl.SaslMechanism.IsNull() {
			*saslMechanism1 = shared.DestinationKafkaUpdateSchemasSASLMechanism(r.Configuration.Protocol.SaslSsl.SaslMechanism.ValueString())
		} else {
			saslMechanism1 = nil
		}
		securityProtocol2 := new(shared.DestinationKafkaUpdateSchemasProtocolSecurityProtocol)
		if !r.Configuration.Protocol.SaslSsl.SecurityProtocol.IsUnknown() && !r.Configuration.Protocol.SaslSsl.SecurityProtocol.IsNull() {
			*securityProtocol2 = shared.DestinationKafkaUpdateSchemasProtocolSecurityProtocol(r.Configuration.Protocol.SaslSsl.SecurityProtocol.ValueString())
		} else {
			securityProtocol2 = nil
		}
		destinationKafkaUpdateSASLSSL = &shared.DestinationKafkaUpdateSASLSSL{
			SaslJaasConfig:   saslJaasConfig1,
			SaslMechanism:    saslMechanism1,
			SecurityProtocol: securityProtocol2,
		}
	}
	if destinationKafkaUpdateSASLSSL != nil {
		protocol = &shared.DestinationKafkaUpdateProtocol{
			DestinationKafkaUpdateSASLSSL: destinationKafkaUpdateSASLSSL,
		}
	}
	receiveBufferBytes := new(int64)
	if !r.Configuration.ReceiveBufferBytes.IsUnknown() && !r.Configuration.ReceiveBufferBytes.IsNull() {
		*receiveBufferBytes = r.Configuration.ReceiveBufferBytes.ValueInt64()
	} else {
		receiveBufferBytes = nil
	}
	requestTimeoutMs := new(int64)
	if !r.Configuration.RequestTimeoutMs.IsUnknown() && !r.Configuration.RequestTimeoutMs.IsNull() {
		*requestTimeoutMs = r.Configuration.RequestTimeoutMs.ValueInt64()
	} else {
		requestTimeoutMs = nil
	}
	retries := new(int64)
	if !r.Configuration.Retries.IsUnknown() && !r.Configuration.Retries.IsNull() {
		*retries = r.Configuration.Retries.ValueInt64()
	} else {
		retries = nil
	}
	sendBufferBytes := new(int64)
	if !r.Configuration.SendBufferBytes.IsUnknown() && !r.Configuration.SendBufferBytes.IsNull() {
		*sendBufferBytes = r.Configuration.SendBufferBytes.ValueInt64()
	} else {
		sendBufferBytes = nil
	}
	socketConnectionSetupTimeoutMaxMs := new(string)
	if !r.Configuration.SocketConnectionSetupTimeoutMaxMs.IsUnknown() && !r.Configuration.SocketConnectionSetupTimeoutMaxMs.IsNull() {
		*socketConnectionSetupTimeoutMaxMs = r.Configuration.SocketConnectionSetupTimeoutMaxMs.ValueString()
	} else {
		socketConnectionSetupTimeoutMaxMs = nil
	}
	socketConnectionSetupTimeoutMs := new(string)
	if !r.Configuration.SocketConnectionSetupTimeoutMs.IsUnknown() && !r.Configuration.SocketConnectionSetupTimeoutMs.IsNull() {
		*socketConnectionSetupTimeoutMs = r.Configuration.SocketConnectionSetupTimeoutMs.ValueString()
	} else {
		socketConnectionSetupTimeoutMs = nil
	}
	syncProducer := new(bool)
	if !r.Configuration.SyncProducer.IsUnknown() && !r.Configuration.SyncProducer.IsNull() {
		*syncProducer = r.Configuration.SyncProducer.ValueBool()
	} else {
		syncProducer = nil
	}
	testTopic := new(string)
	if !r.Configuration.TestTopic.IsUnknown() && !r.Configuration.TestTopic.IsNull() {
		*testTopic = r.Configuration.TestTopic.ValueString()
	} else {
		testTopic = nil
	}
	topicPattern := new(string)
	if !r.Configuration.TopicPattern.IsUnknown() && !r.Configuration.TopicPattern.IsNull() {
		*topicPattern = r.Configuration.TopicPattern.ValueString()
	} else {
		topicPattern = nil
	}
	var additionalProperties map[string]any
	if !r.Configuration.AdditionalProperties.IsUnknown() && !r.Configuration.AdditionalProperties.IsNull() {
		_ = json.Unmarshal([]byte(r.Configuration.AdditionalProperties.ValueString()), &additionalProperties)
	}
	configuration := shared.DestinationKafkaUpdate{
		Acks:                              acks,
		BatchSize:                         batchSize,
		BootstrapServers:                  bootstrapServers,
		BufferMemory:                      bufferMemory,
		ClientDNSLookup:                   clientDNSLookup,
		ClientID:                          clientID,
		CompressionType:                   compressionType,
		DeliveryTimeoutMs:                 deliveryTimeoutMs,
		EnableIdempotence:                 enableIdempotence,
		LingerMs:                          lingerMs,
		MaxBlockMs:                        maxBlockMs,
		MaxInFlightRequestsPerConnection:  maxInFlightRequestsPerConnection,
		MaxRequestSize:                    maxRequestSize,
		Protocol:                          protocol,
		ReceiveBufferBytes:                receiveBufferBytes,
		RequestTimeoutMs:                  requestTimeoutMs,
		Retries:                           retries,
		SendBufferBytes:                   sendBufferBytes,
		SocketConnectionSetupTimeoutMaxMs: socketConnectionSetupTimeoutMaxMs,
		SocketConnectionSetupTimeoutMs:    socketConnectionSetupTimeoutMs,
		SyncProducer:                      syncProducer,
		TestTopic:                         testTopic,
		TopicPattern:                      topicPattern,
		AdditionalProperties:              additionalProperties,
	}
	out := shared.DestinationKafkaPutRequest{
		Name:          name,
		WorkspaceID:   workspaceID,
		Configuration: configuration,
	}

	return &out, diags
}
