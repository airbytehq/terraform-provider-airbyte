// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"context"
	"encoding/json"
	tfTypes "github.com/airbytehq/terraform-provider-airbyte/internal/provider/types"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/models/operations"
	"github.com/airbytehq/terraform-provider-airbyte/internal/sdk/models/shared"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

func (r *SourceKafkaResourceModel) RefreshFromSharedSourceResponse(ctx context.Context, resp *shared.SourceResponse) diag.Diagnostics {
	var diags diag.Diagnostics

	if resp != nil {
		configurationPriorData := r.Configuration
		r.Configuration = &tfTypes.SourceKafka{}
		r.Configuration.AdditionalProperties = configurationPriorData.AdditionalProperties
		r.Configuration.AutoCommitIntervalMs = configurationPriorData.AutoCommitIntervalMs
		r.Configuration.AutoOffsetReset = configurationPriorData.AutoOffsetReset
		r.Configuration.BootstrapServers = configurationPriorData.BootstrapServers
		r.Configuration.ClientDNSLookup = configurationPriorData.ClientDNSLookup
		r.Configuration.ClientID = configurationPriorData.ClientID
		r.Configuration.EnableAutoCommit = configurationPriorData.EnableAutoCommit
		r.Configuration.GroupID = configurationPriorData.GroupID
		r.Configuration.MaxPollRecords = configurationPriorData.MaxPollRecords
		r.Configuration.MaxRecordsProcess = configurationPriorData.MaxRecordsProcess
		r.Configuration.MessageFormat = configurationPriorData.MessageFormat
		r.Configuration.PollingTime = configurationPriorData.PollingTime
		r.Configuration.Protocol = configurationPriorData.Protocol
		r.Configuration.ReceiveBufferBytes = configurationPriorData.ReceiveBufferBytes
		r.Configuration.RepeatedCalls = configurationPriorData.RepeatedCalls
		r.Configuration.RequestTimeoutMs = configurationPriorData.RequestTimeoutMs
		r.Configuration.RetryBackoffMs = configurationPriorData.RetryBackoffMs
		r.Configuration.Subscription = configurationPriorData.Subscription
		r.Configuration.TestTopic = configurationPriorData.TestTopic
		r.CreatedAt = types.Int64Value(resp.CreatedAt)
		r.DefinitionID = types.StringValue(resp.DefinitionID)
		r.Name = types.StringValue(resp.Name)
		if resp.ResourceAllocation == nil {
			r.ResourceAllocation = nil
		} else {
			r.ResourceAllocation = &tfTypes.ScopedResourceRequirements{}
			if resp.ResourceAllocation.Default == nil {
				r.ResourceAllocation.Default = nil
			} else {
				r.ResourceAllocation.Default = &tfTypes.ResourceRequirements{}
				r.ResourceAllocation.Default.CPULimit = types.StringPointerValue(resp.ResourceAllocation.Default.CPULimit)
				r.ResourceAllocation.Default.CPURequest = types.StringPointerValue(resp.ResourceAllocation.Default.CPURequest)
				r.ResourceAllocation.Default.EphemeralStorageLimit = types.StringPointerValue(resp.ResourceAllocation.Default.EphemeralStorageLimit)
				r.ResourceAllocation.Default.EphemeralStorageRequest = types.StringPointerValue(resp.ResourceAllocation.Default.EphemeralStorageRequest)
				r.ResourceAllocation.Default.MemoryLimit = types.StringPointerValue(resp.ResourceAllocation.Default.MemoryLimit)
				r.ResourceAllocation.Default.MemoryRequest = types.StringPointerValue(resp.ResourceAllocation.Default.MemoryRequest)
			}
			r.ResourceAllocation.JobSpecific = []tfTypes.JobTypeResourceLimit{}

			for _, jobSpecificItem := range resp.ResourceAllocation.JobSpecific {
				var jobSpecific tfTypes.JobTypeResourceLimit

				jobSpecific.JobType = types.StringValue(string(jobSpecificItem.JobType))
				jobSpecific.ResourceRequirements = &tfTypes.ResourceRequirements{}
				jobSpecific.ResourceRequirements.CPULimit = types.StringPointerValue(jobSpecificItem.ResourceRequirements.CPULimit)
				jobSpecific.ResourceRequirements.CPURequest = types.StringPointerValue(jobSpecificItem.ResourceRequirements.CPURequest)
				jobSpecific.ResourceRequirements.EphemeralStorageLimit = types.StringPointerValue(jobSpecificItem.ResourceRequirements.EphemeralStorageLimit)
				jobSpecific.ResourceRequirements.EphemeralStorageRequest = types.StringPointerValue(jobSpecificItem.ResourceRequirements.EphemeralStorageRequest)
				jobSpecific.ResourceRequirements.MemoryLimit = types.StringPointerValue(jobSpecificItem.ResourceRequirements.MemoryLimit)
				jobSpecific.ResourceRequirements.MemoryRequest = types.StringPointerValue(jobSpecificItem.ResourceRequirements.MemoryRequest)

				r.ResourceAllocation.JobSpecific = append(r.ResourceAllocation.JobSpecific, jobSpecific)
			}
		}
		r.SourceID = types.StringValue(resp.SourceID)
		r.SourceType = types.StringValue(resp.SourceType)
		r.WorkspaceID = types.StringValue(resp.WorkspaceID)
	}

	return diags
}

func (r *SourceKafkaResourceModel) ToOperationsDeleteSourceKafkaRequest(ctx context.Context) (*operations.DeleteSourceKafkaRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var sourceID string
	sourceID = r.SourceID.ValueString()

	out := operations.DeleteSourceKafkaRequest{
		SourceID: sourceID,
	}

	return &out, diags
}

func (r *SourceKafkaResourceModel) ToOperationsGetSourceKafkaRequest(ctx context.Context) (*operations.GetSourceKafkaRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var sourceID string
	sourceID = r.SourceID.ValueString()

	out := operations.GetSourceKafkaRequest{
		SourceID: sourceID,
	}

	return &out, diags
}

func (r *SourceKafkaResourceModel) ToOperationsPutSourceKafkaRequest(ctx context.Context) (*operations.PutSourceKafkaRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var sourceID string
	sourceID = r.SourceID.ValueString()

	sourceKafkaPutRequest, sourceKafkaPutRequestDiags := r.ToSharedSourceKafkaPutRequest(ctx)
	diags.Append(sourceKafkaPutRequestDiags...)

	if diags.HasError() {
		return nil, diags
	}

	out := operations.PutSourceKafkaRequest{
		SourceID:              sourceID,
		SourceKafkaPutRequest: *sourceKafkaPutRequest,
	}

	return &out, diags
}

func (r *SourceKafkaResourceModel) ToSharedSourceKafkaCreateRequest(ctx context.Context) (*shared.SourceKafkaCreateRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var name string
	name = r.Name.ValueString()

	definitionID := new(string)
	if !r.DefinitionID.IsUnknown() && !r.DefinitionID.IsNull() {
		*definitionID = r.DefinitionID.ValueString()
	} else {
		definitionID = nil
	}
	var workspaceID string
	workspaceID = r.WorkspaceID.ValueString()

	var messageFormat *shared.MessageFormat
	if r.Configuration.MessageFormat != nil {
		var jsonVar *shared.JSON
		if r.Configuration.MessageFormat.JSON != nil {
			jsonVar = &shared.JSON{}
		}
		if jsonVar != nil {
			messageFormat = &shared.MessageFormat{
				JSON: jsonVar,
			}
		}
		var avro *shared.Avro
		if r.Configuration.MessageFormat.Avro != nil {
			deserializationStrategy := new(shared.DeserializationStrategy)
			if !r.Configuration.MessageFormat.Avro.DeserializationStrategy.IsUnknown() && !r.Configuration.MessageFormat.Avro.DeserializationStrategy.IsNull() {
				*deserializationStrategy = shared.DeserializationStrategy(r.Configuration.MessageFormat.Avro.DeserializationStrategy.ValueString())
			} else {
				deserializationStrategy = nil
			}
			schemaRegistryPassword := new(string)
			if !r.Configuration.MessageFormat.Avro.SchemaRegistryPassword.IsUnknown() && !r.Configuration.MessageFormat.Avro.SchemaRegistryPassword.IsNull() {
				*schemaRegistryPassword = r.Configuration.MessageFormat.Avro.SchemaRegistryPassword.ValueString()
			} else {
				schemaRegistryPassword = nil
			}
			schemaRegistryURL := new(string)
			if !r.Configuration.MessageFormat.Avro.SchemaRegistryURL.IsUnknown() && !r.Configuration.MessageFormat.Avro.SchemaRegistryURL.IsNull() {
				*schemaRegistryURL = r.Configuration.MessageFormat.Avro.SchemaRegistryURL.ValueString()
			} else {
				schemaRegistryURL = nil
			}
			schemaRegistryUsername := new(string)
			if !r.Configuration.MessageFormat.Avro.SchemaRegistryUsername.IsUnknown() && !r.Configuration.MessageFormat.Avro.SchemaRegistryUsername.IsNull() {
				*schemaRegistryUsername = r.Configuration.MessageFormat.Avro.SchemaRegistryUsername.ValueString()
			} else {
				schemaRegistryUsername = nil
			}
			avro = &shared.Avro{
				DeserializationStrategy: deserializationStrategy,
				SchemaRegistryPassword:  schemaRegistryPassword,
				SchemaRegistryURL:       schemaRegistryURL,
				SchemaRegistryUsername:  schemaRegistryUsername,
			}
		}
		if avro != nil {
			messageFormat = &shared.MessageFormat{
				Avro: avro,
			}
		}
	}
	autoCommitIntervalMs := new(int64)
	if !r.Configuration.AutoCommitIntervalMs.IsUnknown() && !r.Configuration.AutoCommitIntervalMs.IsNull() {
		*autoCommitIntervalMs = r.Configuration.AutoCommitIntervalMs.ValueInt64()
	} else {
		autoCommitIntervalMs = nil
	}
	autoOffsetReset := new(shared.AutoOffsetReset)
	if !r.Configuration.AutoOffsetReset.IsUnknown() && !r.Configuration.AutoOffsetReset.IsNull() {
		*autoOffsetReset = shared.AutoOffsetReset(r.Configuration.AutoOffsetReset.ValueString())
	} else {
		autoOffsetReset = nil
	}
	var bootstrapServers string
	bootstrapServers = r.Configuration.BootstrapServers.ValueString()

	clientDNSLookup := new(shared.ClientDNSLookup)
	if !r.Configuration.ClientDNSLookup.IsUnknown() && !r.Configuration.ClientDNSLookup.IsNull() {
		*clientDNSLookup = shared.ClientDNSLookup(r.Configuration.ClientDNSLookup.ValueString())
	} else {
		clientDNSLookup = nil
	}
	clientID := new(string)
	if !r.Configuration.ClientID.IsUnknown() && !r.Configuration.ClientID.IsNull() {
		*clientID = r.Configuration.ClientID.ValueString()
	} else {
		clientID = nil
	}
	enableAutoCommit := new(bool)
	if !r.Configuration.EnableAutoCommit.IsUnknown() && !r.Configuration.EnableAutoCommit.IsNull() {
		*enableAutoCommit = r.Configuration.EnableAutoCommit.ValueBool()
	} else {
		enableAutoCommit = nil
	}
	groupID := new(string)
	if !r.Configuration.GroupID.IsUnknown() && !r.Configuration.GroupID.IsNull() {
		*groupID = r.Configuration.GroupID.ValueString()
	} else {
		groupID = nil
	}
	maxPollRecords := new(int64)
	if !r.Configuration.MaxPollRecords.IsUnknown() && !r.Configuration.MaxPollRecords.IsNull() {
		*maxPollRecords = r.Configuration.MaxPollRecords.ValueInt64()
	} else {
		maxPollRecords = nil
	}
	maxRecordsProcess := new(int64)
	if !r.Configuration.MaxRecordsProcess.IsUnknown() && !r.Configuration.MaxRecordsProcess.IsNull() {
		*maxRecordsProcess = r.Configuration.MaxRecordsProcess.ValueInt64()
	} else {
		maxRecordsProcess = nil
	}
	pollingTime := new(int64)
	if !r.Configuration.PollingTime.IsUnknown() && !r.Configuration.PollingTime.IsNull() {
		*pollingTime = r.Configuration.PollingTime.ValueInt64()
	} else {
		pollingTime = nil
	}
	var protocol shared.Protocol
	var plaintext *shared.Plaintext
	if r.Configuration.Protocol.Plaintext != nil {
		plaintext = &shared.Plaintext{}
	}
	if plaintext != nil {
		protocol = shared.Protocol{
			Plaintext: plaintext,
		}
	}
	var saslPlaintext *shared.SaslPlaintext
	if r.Configuration.Protocol.SaslPlaintext != nil {
		saslJaasConfig := new(string)
		if !r.Configuration.Protocol.SaslPlaintext.SaslJaasConfig.IsUnknown() && !r.Configuration.Protocol.SaslPlaintext.SaslJaasConfig.IsNull() {
			*saslJaasConfig = r.Configuration.Protocol.SaslPlaintext.SaslJaasConfig.ValueString()
		} else {
			saslJaasConfig = nil
		}
		saslPlaintext = &shared.SaslPlaintext{
			SaslJaasConfig: saslJaasConfig,
		}
	}
	if saslPlaintext != nil {
		protocol = shared.Protocol{
			SaslPlaintext: saslPlaintext,
		}
	}
	var saslSsl *shared.SaslSsl
	if r.Configuration.Protocol.SaslSsl != nil {
		oauthbearerTokenEndpointURL := new(string)
		if !r.Configuration.Protocol.SaslSsl.OauthbearerTokenEndpointURL.IsUnknown() && !r.Configuration.Protocol.SaslSsl.OauthbearerTokenEndpointURL.IsNull() {
			*oauthbearerTokenEndpointURL = r.Configuration.Protocol.SaslSsl.OauthbearerTokenEndpointURL.ValueString()
		} else {
			oauthbearerTokenEndpointURL = nil
		}
		saslJaasConfig1 := new(string)
		if !r.Configuration.Protocol.SaslSsl.SaslJaasConfig.IsUnknown() && !r.Configuration.Protocol.SaslSsl.SaslJaasConfig.IsNull() {
			*saslJaasConfig1 = r.Configuration.Protocol.SaslSsl.SaslJaasConfig.ValueString()
		} else {
			saslJaasConfig1 = nil
		}
		saslMechanism := new(shared.SASLMechanism)
		if !r.Configuration.Protocol.SaslSsl.SaslMechanism.IsUnknown() && !r.Configuration.Protocol.SaslSsl.SaslMechanism.IsNull() {
			*saslMechanism = shared.SASLMechanism(r.Configuration.Protocol.SaslSsl.SaslMechanism.ValueString())
		} else {
			saslMechanism = nil
		}
		saslSsl = &shared.SaslSsl{
			OauthbearerTokenEndpointURL: oauthbearerTokenEndpointURL,
			SaslJaasConfig:              saslJaasConfig1,
			SaslMechanism:               saslMechanism,
		}
	}
	if saslSsl != nil {
		protocol = shared.Protocol{
			SaslSsl: saslSsl,
		}
	}
	receiveBufferBytes := new(int64)
	if !r.Configuration.ReceiveBufferBytes.IsUnknown() && !r.Configuration.ReceiveBufferBytes.IsNull() {
		*receiveBufferBytes = r.Configuration.ReceiveBufferBytes.ValueInt64()
	} else {
		receiveBufferBytes = nil
	}
	repeatedCalls := new(int64)
	if !r.Configuration.RepeatedCalls.IsUnknown() && !r.Configuration.RepeatedCalls.IsNull() {
		*repeatedCalls = r.Configuration.RepeatedCalls.ValueInt64()
	} else {
		repeatedCalls = nil
	}
	requestTimeoutMs := new(int64)
	if !r.Configuration.RequestTimeoutMs.IsUnknown() && !r.Configuration.RequestTimeoutMs.IsNull() {
		*requestTimeoutMs = r.Configuration.RequestTimeoutMs.ValueInt64()
	} else {
		requestTimeoutMs = nil
	}
	retryBackoffMs := new(int64)
	if !r.Configuration.RetryBackoffMs.IsUnknown() && !r.Configuration.RetryBackoffMs.IsNull() {
		*retryBackoffMs = r.Configuration.RetryBackoffMs.ValueInt64()
	} else {
		retryBackoffMs = nil
	}
	var subscription shared.SubscriptionMethod
	var manuallyAssignAListOfPartitions *shared.ManuallyAssignAListOfPartitions
	if r.Configuration.Subscription.ManuallyAssignAListOfPartitions != nil {
		var topicPartitions string
		topicPartitions = r.Configuration.Subscription.ManuallyAssignAListOfPartitions.TopicPartitions.ValueString()

		manuallyAssignAListOfPartitions = &shared.ManuallyAssignAListOfPartitions{
			TopicPartitions: topicPartitions,
		}
	}
	if manuallyAssignAListOfPartitions != nil {
		subscription = shared.SubscriptionMethod{
			ManuallyAssignAListOfPartitions: manuallyAssignAListOfPartitions,
		}
	}
	var subscribeToAllTopicsMatchingSpecifiedPattern *shared.SubscribeToAllTopicsMatchingSpecifiedPattern
	if r.Configuration.Subscription.SubscribeToAllTopicsMatchingSpecifiedPattern != nil {
		var topicPattern string
		topicPattern = r.Configuration.Subscription.SubscribeToAllTopicsMatchingSpecifiedPattern.TopicPattern.ValueString()

		subscribeToAllTopicsMatchingSpecifiedPattern = &shared.SubscribeToAllTopicsMatchingSpecifiedPattern{
			TopicPattern: topicPattern,
		}
	}
	if subscribeToAllTopicsMatchingSpecifiedPattern != nil {
		subscription = shared.SubscriptionMethod{
			SubscribeToAllTopicsMatchingSpecifiedPattern: subscribeToAllTopicsMatchingSpecifiedPattern,
		}
	}
	testTopic := new(string)
	if !r.Configuration.TestTopic.IsUnknown() && !r.Configuration.TestTopic.IsNull() {
		*testTopic = r.Configuration.TestTopic.ValueString()
	} else {
		testTopic = nil
	}
	var additionalProperties map[string]any
	if !r.Configuration.AdditionalProperties.IsUnknown() && !r.Configuration.AdditionalProperties.IsNull() {
		_ = json.Unmarshal([]byte(r.Configuration.AdditionalProperties.ValueString()), &additionalProperties)
	}
	configuration := shared.SourceKafka{
		MessageFormat:        messageFormat,
		AutoCommitIntervalMs: autoCommitIntervalMs,
		AutoOffsetReset:      autoOffsetReset,
		BootstrapServers:     bootstrapServers,
		ClientDNSLookup:      clientDNSLookup,
		ClientID:             clientID,
		EnableAutoCommit:     enableAutoCommit,
		GroupID:              groupID,
		MaxPollRecords:       maxPollRecords,
		MaxRecordsProcess:    maxRecordsProcess,
		PollingTime:          pollingTime,
		Protocol:             protocol,
		ReceiveBufferBytes:   receiveBufferBytes,
		RepeatedCalls:        repeatedCalls,
		RequestTimeoutMs:     requestTimeoutMs,
		RetryBackoffMs:       retryBackoffMs,
		Subscription:         subscription,
		TestTopic:            testTopic,
		AdditionalProperties: additionalProperties,
	}
	secretID := new(string)
	if !r.SecretID.IsUnknown() && !r.SecretID.IsNull() {
		*secretID = r.SecretID.ValueString()
	} else {
		secretID = nil
	}
	out := shared.SourceKafkaCreateRequest{
		Name:          name,
		DefinitionID:  definitionID,
		WorkspaceID:   workspaceID,
		Configuration: configuration,
		SecretID:      secretID,
	}

	return &out, diags
}

func (r *SourceKafkaResourceModel) ToSharedSourceKafkaPutRequest(ctx context.Context) (*shared.SourceKafkaPutRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var name string
	name = r.Name.ValueString()

	var workspaceID string
	workspaceID = r.WorkspaceID.ValueString()

	var messageFormat *shared.SourceKafkaUpdateMessageFormat
	if r.Configuration.MessageFormat != nil {
		var sourceKafkaUpdateJSON *shared.SourceKafkaUpdateJSON
		if r.Configuration.MessageFormat.JSON != nil {
			sourceKafkaUpdateJSON = &shared.SourceKafkaUpdateJSON{}
		}
		if sourceKafkaUpdateJSON != nil {
			messageFormat = &shared.SourceKafkaUpdateMessageFormat{
				SourceKafkaUpdateJSON: sourceKafkaUpdateJSON,
			}
		}
		var sourceKafkaUpdateAVRO *shared.SourceKafkaUpdateAVRO
		if r.Configuration.MessageFormat.Avro != nil {
			deserializationStrategy := new(shared.SourceKafkaUpdateDeserializationStrategy)
			if !r.Configuration.MessageFormat.Avro.DeserializationStrategy.IsUnknown() && !r.Configuration.MessageFormat.Avro.DeserializationStrategy.IsNull() {
				*deserializationStrategy = shared.SourceKafkaUpdateDeserializationStrategy(r.Configuration.MessageFormat.Avro.DeserializationStrategy.ValueString())
			} else {
				deserializationStrategy = nil
			}
			schemaRegistryPassword := new(string)
			if !r.Configuration.MessageFormat.Avro.SchemaRegistryPassword.IsUnknown() && !r.Configuration.MessageFormat.Avro.SchemaRegistryPassword.IsNull() {
				*schemaRegistryPassword = r.Configuration.MessageFormat.Avro.SchemaRegistryPassword.ValueString()
			} else {
				schemaRegistryPassword = nil
			}
			schemaRegistryURL := new(string)
			if !r.Configuration.MessageFormat.Avro.SchemaRegistryURL.IsUnknown() && !r.Configuration.MessageFormat.Avro.SchemaRegistryURL.IsNull() {
				*schemaRegistryURL = r.Configuration.MessageFormat.Avro.SchemaRegistryURL.ValueString()
			} else {
				schemaRegistryURL = nil
			}
			schemaRegistryUsername := new(string)
			if !r.Configuration.MessageFormat.Avro.SchemaRegistryUsername.IsUnknown() && !r.Configuration.MessageFormat.Avro.SchemaRegistryUsername.IsNull() {
				*schemaRegistryUsername = r.Configuration.MessageFormat.Avro.SchemaRegistryUsername.ValueString()
			} else {
				schemaRegistryUsername = nil
			}
			sourceKafkaUpdateAVRO = &shared.SourceKafkaUpdateAVRO{
				DeserializationStrategy: deserializationStrategy,
				SchemaRegistryPassword:  schemaRegistryPassword,
				SchemaRegistryURL:       schemaRegistryURL,
				SchemaRegistryUsername:  schemaRegistryUsername,
			}
		}
		if sourceKafkaUpdateAVRO != nil {
			messageFormat = &shared.SourceKafkaUpdateMessageFormat{
				SourceKafkaUpdateAVRO: sourceKafkaUpdateAVRO,
			}
		}
	}
	autoCommitIntervalMs := new(int64)
	if !r.Configuration.AutoCommitIntervalMs.IsUnknown() && !r.Configuration.AutoCommitIntervalMs.IsNull() {
		*autoCommitIntervalMs = r.Configuration.AutoCommitIntervalMs.ValueInt64()
	} else {
		autoCommitIntervalMs = nil
	}
	autoOffsetReset := new(shared.SourceKafkaUpdateAutoOffsetReset)
	if !r.Configuration.AutoOffsetReset.IsUnknown() && !r.Configuration.AutoOffsetReset.IsNull() {
		*autoOffsetReset = shared.SourceKafkaUpdateAutoOffsetReset(r.Configuration.AutoOffsetReset.ValueString())
	} else {
		autoOffsetReset = nil
	}
	bootstrapServers := new(string)
	if !r.Configuration.BootstrapServers.IsUnknown() && !r.Configuration.BootstrapServers.IsNull() {
		*bootstrapServers = r.Configuration.BootstrapServers.ValueString()
	} else {
		bootstrapServers = nil
	}
	clientDNSLookup := new(shared.SourceKafkaUpdateClientDNSLookup)
	if !r.Configuration.ClientDNSLookup.IsUnknown() && !r.Configuration.ClientDNSLookup.IsNull() {
		*clientDNSLookup = shared.SourceKafkaUpdateClientDNSLookup(r.Configuration.ClientDNSLookup.ValueString())
	} else {
		clientDNSLookup = nil
	}
	clientID := new(string)
	if !r.Configuration.ClientID.IsUnknown() && !r.Configuration.ClientID.IsNull() {
		*clientID = r.Configuration.ClientID.ValueString()
	} else {
		clientID = nil
	}
	enableAutoCommit := new(bool)
	if !r.Configuration.EnableAutoCommit.IsUnknown() && !r.Configuration.EnableAutoCommit.IsNull() {
		*enableAutoCommit = r.Configuration.EnableAutoCommit.ValueBool()
	} else {
		enableAutoCommit = nil
	}
	groupID := new(string)
	if !r.Configuration.GroupID.IsUnknown() && !r.Configuration.GroupID.IsNull() {
		*groupID = r.Configuration.GroupID.ValueString()
	} else {
		groupID = nil
	}
	maxPollRecords := new(int64)
	if !r.Configuration.MaxPollRecords.IsUnknown() && !r.Configuration.MaxPollRecords.IsNull() {
		*maxPollRecords = r.Configuration.MaxPollRecords.ValueInt64()
	} else {
		maxPollRecords = nil
	}
	maxRecordsProcess := new(int64)
	if !r.Configuration.MaxRecordsProcess.IsUnknown() && !r.Configuration.MaxRecordsProcess.IsNull() {
		*maxRecordsProcess = r.Configuration.MaxRecordsProcess.ValueInt64()
	} else {
		maxRecordsProcess = nil
	}
	pollingTime := new(int64)
	if !r.Configuration.PollingTime.IsUnknown() && !r.Configuration.PollingTime.IsNull() {
		*pollingTime = r.Configuration.PollingTime.ValueInt64()
	} else {
		pollingTime = nil
	}
	var protocol *shared.SourceKafkaUpdateProtocol
	var sourceKafkaUpdatePLAINTEXT *shared.SourceKafkaUpdatePLAINTEXT
	if r.Configuration.Protocol.Plaintext != nil {
		sourceKafkaUpdatePLAINTEXT = &shared.SourceKafkaUpdatePLAINTEXT{}
	}
	if sourceKafkaUpdatePLAINTEXT != nil {
		protocol = &shared.SourceKafkaUpdateProtocol{
			SourceKafkaUpdatePLAINTEXT: sourceKafkaUpdatePLAINTEXT,
		}
	}
	var sourceKafkaUpdateSASLPLAINTEXT *shared.SourceKafkaUpdateSASLPLAINTEXT
	if r.Configuration.Protocol.SaslPlaintext != nil {
		saslJaasConfig := new(string)
		if !r.Configuration.Protocol.SaslPlaintext.SaslJaasConfig.IsUnknown() && !r.Configuration.Protocol.SaslPlaintext.SaslJaasConfig.IsNull() {
			*saslJaasConfig = r.Configuration.Protocol.SaslPlaintext.SaslJaasConfig.ValueString()
		} else {
			saslJaasConfig = nil
		}
		sourceKafkaUpdateSASLPLAINTEXT = &shared.SourceKafkaUpdateSASLPLAINTEXT{
			SaslJaasConfig: saslJaasConfig,
		}
	}
	if sourceKafkaUpdateSASLPLAINTEXT != nil {
		protocol = &shared.SourceKafkaUpdateProtocol{
			SourceKafkaUpdateSASLPLAINTEXT: sourceKafkaUpdateSASLPLAINTEXT,
		}
	}
	var sourceKafkaUpdateSASLSSL *shared.SourceKafkaUpdateSASLSSL
	if r.Configuration.Protocol.SaslSsl != nil {
		oauthbearerTokenEndpointURL := new(string)
		if !r.Configuration.Protocol.SaslSsl.OauthbearerTokenEndpointURL.IsUnknown() && !r.Configuration.Protocol.SaslSsl.OauthbearerTokenEndpointURL.IsNull() {
			*oauthbearerTokenEndpointURL = r.Configuration.Protocol.SaslSsl.OauthbearerTokenEndpointURL.ValueString()
		} else {
			oauthbearerTokenEndpointURL = nil
		}
		saslJaasConfig1 := new(string)
		if !r.Configuration.Protocol.SaslSsl.SaslJaasConfig.IsUnknown() && !r.Configuration.Protocol.SaslSsl.SaslJaasConfig.IsNull() {
			*saslJaasConfig1 = r.Configuration.Protocol.SaslSsl.SaslJaasConfig.ValueString()
		} else {
			saslJaasConfig1 = nil
		}
		saslMechanism := new(shared.SourceKafkaUpdateSASLMechanism)
		if !r.Configuration.Protocol.SaslSsl.SaslMechanism.IsUnknown() && !r.Configuration.Protocol.SaslSsl.SaslMechanism.IsNull() {
			*saslMechanism = shared.SourceKafkaUpdateSASLMechanism(r.Configuration.Protocol.SaslSsl.SaslMechanism.ValueString())
		} else {
			saslMechanism = nil
		}
		sourceKafkaUpdateSASLSSL = &shared.SourceKafkaUpdateSASLSSL{
			OauthbearerTokenEndpointURL: oauthbearerTokenEndpointURL,
			SaslJaasConfig:              saslJaasConfig1,
			SaslMechanism:               saslMechanism,
		}
	}
	if sourceKafkaUpdateSASLSSL != nil {
		protocol = &shared.SourceKafkaUpdateProtocol{
			SourceKafkaUpdateSASLSSL: sourceKafkaUpdateSASLSSL,
		}
	}
	receiveBufferBytes := new(int64)
	if !r.Configuration.ReceiveBufferBytes.IsUnknown() && !r.Configuration.ReceiveBufferBytes.IsNull() {
		*receiveBufferBytes = r.Configuration.ReceiveBufferBytes.ValueInt64()
	} else {
		receiveBufferBytes = nil
	}
	repeatedCalls := new(int64)
	if !r.Configuration.RepeatedCalls.IsUnknown() && !r.Configuration.RepeatedCalls.IsNull() {
		*repeatedCalls = r.Configuration.RepeatedCalls.ValueInt64()
	} else {
		repeatedCalls = nil
	}
	requestTimeoutMs := new(int64)
	if !r.Configuration.RequestTimeoutMs.IsUnknown() && !r.Configuration.RequestTimeoutMs.IsNull() {
		*requestTimeoutMs = r.Configuration.RequestTimeoutMs.ValueInt64()
	} else {
		requestTimeoutMs = nil
	}
	retryBackoffMs := new(int64)
	if !r.Configuration.RetryBackoffMs.IsUnknown() && !r.Configuration.RetryBackoffMs.IsNull() {
		*retryBackoffMs = r.Configuration.RetryBackoffMs.ValueInt64()
	} else {
		retryBackoffMs = nil
	}
	var subscription *shared.SourceKafkaUpdateSubscriptionMethod
	var sourceKafkaUpdateManuallyAssignAListOfPartitions *shared.SourceKafkaUpdateManuallyAssignAListOfPartitions
	if r.Configuration.Subscription.ManuallyAssignAListOfPartitions != nil {
		topicPartitions := new(string)
		if !r.Configuration.Subscription.ManuallyAssignAListOfPartitions.TopicPartitions.IsUnknown() && !r.Configuration.Subscription.ManuallyAssignAListOfPartitions.TopicPartitions.IsNull() {
			*topicPartitions = r.Configuration.Subscription.ManuallyAssignAListOfPartitions.TopicPartitions.ValueString()
		} else {
			topicPartitions = nil
		}
		sourceKafkaUpdateManuallyAssignAListOfPartitions = &shared.SourceKafkaUpdateManuallyAssignAListOfPartitions{
			TopicPartitions: topicPartitions,
		}
	}
	if sourceKafkaUpdateManuallyAssignAListOfPartitions != nil {
		subscription = &shared.SourceKafkaUpdateSubscriptionMethod{
			SourceKafkaUpdateManuallyAssignAListOfPartitions: sourceKafkaUpdateManuallyAssignAListOfPartitions,
		}
	}
	var sourceKafkaUpdateSubscribeToAllTopicsMatchingSpecifiedPattern *shared.SourceKafkaUpdateSubscribeToAllTopicsMatchingSpecifiedPattern
	if r.Configuration.Subscription.SubscribeToAllTopicsMatchingSpecifiedPattern != nil {
		topicPattern := new(string)
		if !r.Configuration.Subscription.SubscribeToAllTopicsMatchingSpecifiedPattern.TopicPattern.IsUnknown() && !r.Configuration.Subscription.SubscribeToAllTopicsMatchingSpecifiedPattern.TopicPattern.IsNull() {
			*topicPattern = r.Configuration.Subscription.SubscribeToAllTopicsMatchingSpecifiedPattern.TopicPattern.ValueString()
		} else {
			topicPattern = nil
		}
		sourceKafkaUpdateSubscribeToAllTopicsMatchingSpecifiedPattern = &shared.SourceKafkaUpdateSubscribeToAllTopicsMatchingSpecifiedPattern{
			TopicPattern: topicPattern,
		}
	}
	if sourceKafkaUpdateSubscribeToAllTopicsMatchingSpecifiedPattern != nil {
		subscription = &shared.SourceKafkaUpdateSubscriptionMethod{
			SourceKafkaUpdateSubscribeToAllTopicsMatchingSpecifiedPattern: sourceKafkaUpdateSubscribeToAllTopicsMatchingSpecifiedPattern,
		}
	}
	testTopic := new(string)
	if !r.Configuration.TestTopic.IsUnknown() && !r.Configuration.TestTopic.IsNull() {
		*testTopic = r.Configuration.TestTopic.ValueString()
	} else {
		testTopic = nil
	}
	var additionalProperties map[string]any
	if !r.Configuration.AdditionalProperties.IsUnknown() && !r.Configuration.AdditionalProperties.IsNull() {
		_ = json.Unmarshal([]byte(r.Configuration.AdditionalProperties.ValueString()), &additionalProperties)
	}
	configuration := shared.SourceKafkaUpdate{
		MessageFormat:        messageFormat,
		AutoCommitIntervalMs: autoCommitIntervalMs,
		AutoOffsetReset:      autoOffsetReset,
		BootstrapServers:     bootstrapServers,
		ClientDNSLookup:      clientDNSLookup,
		ClientID:             clientID,
		EnableAutoCommit:     enableAutoCommit,
		GroupID:              groupID,
		MaxPollRecords:       maxPollRecords,
		MaxRecordsProcess:    maxRecordsProcess,
		PollingTime:          pollingTime,
		Protocol:             protocol,
		ReceiveBufferBytes:   receiveBufferBytes,
		RepeatedCalls:        repeatedCalls,
		RequestTimeoutMs:     requestTimeoutMs,
		RetryBackoffMs:       retryBackoffMs,
		Subscription:         subscription,
		TestTopic:            testTopic,
		AdditionalProperties: additionalProperties,
	}
	out := shared.SourceKafkaPutRequest{
		Name:          name,
		WorkspaceID:   workspaceID,
		Configuration: configuration,
	}

	return &out, diags
}
