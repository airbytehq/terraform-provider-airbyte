// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package utils

import (
	"context"

	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/tfsdk"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

// HoistedSource describes the path to a source field within a oneOf associated
// type that was hoisted to the parent level.
type HoistedSource struct {
	// AssociatedTypePath is the path to check if the associated type is active (not null)
	AssociatedTypePath path.Path
	// FieldPath is the path to the source field within the associated type
	FieldPath path.Path
}

// FindActiveHoistedValue searches through the hoisted sources to find an active
// associated type and returns a pointer to the field value. It prefers state values
// over plan values to preserve API-returned values for readonly computed fields.
// Returns nil if not found.
func FindActiveHoistedValue[T any](ctx context.Context, plan tfsdk.Plan, state tfsdk.State, sources []HoistedSource) *T {
	for _, source := range sources {
		// Check if the associated type is active in the plan (not null)
		var associatedTypeValue types.Object
		diags := plan.GetAttribute(ctx, source.AssociatedTypePath, &associatedTypeValue)
		if diags.HasError() {
			continue
		}

		if associatedTypeValue.IsNull() || associatedTypeValue.IsUnknown() {
			continue
		}

		// First, try to get the value from state (preserves API-returned values)
		// This is critical for readonly computed fields with defaults - the plan
		// would have the schema default, but state has the actual API value.
		var stateValue T
		diags = state.GetAttribute(ctx, source.FieldPath, &stateValue)
		if !diags.HasError() {
			if v, ok := any(stateValue).(interface{ IsUnknown() bool }); ok && !v.IsUnknown() {
				if vn, ok := any(stateValue).(interface{ IsNull() bool }); ok && !vn.IsNull() {
					return &stateValue
				}
			}
		}

		// Fall back to plan value if state value is not available
		var fieldValue T
		diags = plan.GetAttribute(ctx, source.FieldPath, &fieldValue)
		if diags.HasError() {
			continue
		}

		// Check if value is known using type assertion to attr.Value
		if v, ok := any(fieldValue).(interface{ IsUnknown() bool }); ok && !v.IsUnknown() {
			return &fieldValue
		}
	}
	return nil
}

// FindActiveAssociatedType searches through the hoisted sources to find an active
// associated type and returns a pointer to the field value from the plan.
// Deprecated: Use FindActiveHoistedValue instead, which prefers state values.
func FindActiveAssociatedType[T any](ctx context.Context, plan tfsdk.Plan, sources []HoistedSource) *T {
	for _, source := range sources {
		var associatedTypeValue types.Object
		diags := plan.GetAttribute(ctx, source.AssociatedTypePath, &associatedTypeValue)
		if diags.HasError() {
			continue
		}

		if associatedTypeValue.IsNull() || associatedTypeValue.IsUnknown() {
			continue
		}

		var fieldValue T
		diags = plan.GetAttribute(ctx, source.FieldPath, &fieldValue)
		if diags.HasError() {
			continue
		}

		// Check if value is known using type assertion to attr.Value
		if v, ok := any(fieldValue).(interface{ IsUnknown() bool }); ok && !v.IsUnknown() {
			return &fieldValue
		}
	}
	return nil
}
